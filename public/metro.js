
/*!
 ███╗   ███╗███████╗████████╗██████╗  ██████╗     ██╗   ██╗██╗
 ████╗ ████║██╔════╝╚══██╔══╝██╔══██╗██╔═══██╗    ██║   ██║██║
 ██╔████╔██║█████╗     ██║   ██████╔╝██║   ██║    ██║   ██║██║
 ██║╚██╔╝██║██╔══╝     ██║   ██╔══██╗██║   ██║    ██║   ██║██║
 ██║ ╚═╝ ██║███████╗   ██║   ██║  ██║╚██████╔╝    ╚██████╔╝██║
 ╚═╝     ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝ ╚═════╝      ╚═════╝ ╚═╝                                                             

 * Metro UI v5.1.18 Components Library  (https://metroui.org.ua)
 * Build: 29.08.2025, 10:45:22
 * Copyright 2012-2025 by Serhii Pimenov
 * Licensed under MIT
 */

"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };

  // ../metroui-lib/node_modules/@olton/datetime/dist/datetime.js
  var isNum = (v5) => !isNaN(v5);
  var DEFAULT_FORMAT = "YYYY-MM-DDTHH:mm:ss.sss";
  var INVALID_DATE = "Invalid date";
  var REGEX_FORMAT = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|m{1,2}|s{1,3}/g;
  var REGEX_FORMAT_STRFTIME = /(%[a-z])/gi;
  var DEFAULT_FORMAT_STRFTIME = "%Y-%m-%dT%H:%M:%S.%Q%t";
  var DEFAULT_LOCALE = {
    months: "January February March April May June July August September October November December".split(" "),
    monthsShort: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
    weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
    weekdaysShort: "Sun Mon Tue Wed Thu Fri Sat".split(" "),
    weekdaysMin: "Su Mo Tu We Th Fr Sa".split(" "),
    weekStart: 0
  };
  var M = {
    ms: "Milliseconds",
    s: "Seconds",
    m: "Minutes",
    h: "Hours",
    D: "Date",
    d: "Day",
    M: "Month",
    Y: "FullYear",
    y: "Year",
    t: "Time"
  };
  var C = {
    ms: "ms",
    s: "second",
    m: "minute",
    h: "hour",
    D: "day",
    W: "week",
    d: "weekDay",
    M: "month",
    Y: "year",
    Y2: "year2",
    t: "time",
    c: "century",
    q: "quarter"
  };
  var required = (m5 = "") => {
    throw new Error("This argument is required!");
  };
  var isset = (v5, nullable = true) => {
    try {
      return nullable ? typeof v5 !== "undefined" : typeof v5 !== "undefined" && v5 !== null;
    } catch (e2) {
      return false;
    }
  };
  var not = (v5) => typeof v5 === "undefined" || v5 === null;
  var lpad = function(str2, pad, length) {
    let _str = "" + str2;
    if (length && _str.length >= length) {
      return _str;
    }
    return Array(length + 1 - _str.length).join(pad) + _str;
  };
  var uk_default = {
    months: "\u0421\u0456\u0447\u0435\u043D\u044C_\u041B\u044E\u0442\u0438\u0439_\u0411\u0435\u0440\u0435\u0437\u0435\u043D\u044C_\u041A\u0432\u0456\u0442\u0435\u043D\u044C_\u0422\u0440\u0430\u0432\u0435\u043D\u044C_\u0427\u0435\u0440\u0432\u0435\u043D\u044C_\u041B\u0438\u043F\u0435\u043D\u044C_\u0421\u0435\u0440\u043F\u0435\u043D\u044C_\u0412\u0435\u0440\u0435\u0441\u0435\u043D\u044C_\u0416\u043E\u0432\u0442\u0435\u043D\u044C_\u041B\u0438\u0441\u0442\u043E\u043F\u0430\u0434_\u0413\u0440\u0443\u0434\u0435\u043D\u044C".split("_"),
    monthsParental: "\u0421\u0456\u0447\u043D\u044F_\u041B\u044E\u0442\u043E\u0433\u043E_\u0411\u0435\u0440\u0435\u0437\u0435\u043D\u044F_\u041A\u0432\u0456\u0442\u043D\u044F_\u0422\u0440\u0430\u0432\u043D\u044F_\u0427\u0435\u0440\u0432\u043D\u044F_\u041B\u0438\u043F\u043D\u044F_\u0421\u0435\u0440\u043F\u043D\u044F_\u0412\u0435\u0440\u0435\u0441\u043D\u044F_\u0416\u043E\u0432\u0442\u043D\u044F_\u041B\u0438\u0441\u0442\u043E\u043F\u0430\u0434\u0430_\u0413\u0440\u0443\u0434\u043D\u044F".split("_"),
    monthsShort: "\u0421\u0456\u0447_\u041B\u044E\u0442_\u0411\u0435\u0440_\u041A\u0432\u0456_\u0422\u0440\u0430_\u0427\u0435\u0440_\u041B\u0438\u043F_\u0421\u0435\u0440_\u0412\u0435\u0440_\u0416\u043E\u0432_\u041B\u0438\u0441_\u0413\u0440\u0443".split("_"),
    weekdays: "\u041D\u0435\u0434\u0456\u043B\u044F_\u041F\u043E\u043D\u0435\u0434\u0456\u043B\u043E\u043A_\u0412\u0456\u0432\u0442\u043E\u0440\u043E\u043A_\u0421\u0435\u0440\u0435\u0434\u0430_\u0427\u0435\u0442\u0432\u0435\u0440_\u041F'\u044F\u0442\u043D\u0438\u0446\u044F_\u0421\u0443\u0431\u043E\u0442\u0430".split("_"),
    weekdaysShort: "\u041D\u0435\u0434_\u041F\u043E\u043D_\u0412\u0456\u0432_\u0421\u0435\u0440_\u0427\u0435\u0442_\u041F\u0442\u043D_\u0421\u0443\u0431".split("_"),
    weekdaysMin: "\u041D\u0434_\u041F\u043D_\u0412\u0442_\u0421\u0440_\u0427\u0442_\u041F\u0442_\u0421\u0431".split("_"),
    weekStart: 1
  };
  var de_default = {
    months: "Januar_Februar_M\xE4rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
    monthsShort: "Jan_Feb_M\xE4r_Apr_Mai_Jun_Jul_Aug_Sep_Okt_Nov_Dez".split("_"),
    weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
    weekdaysShort: "Son_Mon_Die_Mit_Don_Fre_Sam".split("_"),
    weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
    weekStart: 1
  };
  var Datetime2 = class _Datetime {
    constructor() {
      const args = [].slice.call(arguments);
      this.value = new (Function.prototype.bind.apply(Date, [this].concat(args)))();
      this.locale = "en";
      this.weekStart = _Datetime.locales["en"].weekStart;
      this.utcMode = false;
      this.mutable = true;
      if (!isNum(this.value.getTime())) {
        throw new Error(INVALID_DATE);
      }
    }
    static locales = {
      en: DEFAULT_LOCALE,
      ua: uk_default,
      de: de_default
    };
    static isDatetime(val) {
      return val instanceof _Datetime;
    }
    static now(asDate = false) {
      return datetime2()[asDate ? "val" : "time"]();
    }
    static parse(str2 = required()) {
      return datetime2(Date.parse(str2));
    }
    static setLocale(name2 = required(), locale = required()) {
      _Datetime.locales[name2] = locale;
    }
    static getLocale(name2 = "en") {
      return isset(_Datetime.locales[name2], false) ? _Datetime.locales[name2] : _Datetime.locales["en"];
    }
    static align(date, align) {
      let _date = datetime2(date), result, temp;
      switch (align) {
        case C.s:
          result = _date.ms(0);
          break;
        //second
        case C.m:
          result = _Datetime.align(_date, C.s)[C.s](0);
          break;
        //minute
        case C.h:
          result = _Datetime.align(_date, C.m)[C.m](0);
          break;
        //hour
        case C.D:
          result = _Datetime.align(_date, C.h)[C.h](0);
          break;
        //day
        case C.M:
          result = _Datetime.align(_date, C.D)[C.D](1);
          break;
        //month
        case C.Y:
          result = _Datetime.align(_date, C.M)[C.M](0);
          break;
        //year
        case C.W: {
          temp = _date.weekDay();
          result = _Datetime.align(date, C.D).addDay(-temp);
          break;
        }
        default:
          result = _date;
      }
      return result;
    }
    static alignEnd(date, align) {
      let _date = datetime2(date), result, temp;
      switch (align) {
        case C.ms:
          result = _date.ms(999);
          break;
        //second
        case C.s:
          result = _Datetime.alignEnd(_date, C.ms);
          break;
        //second
        case C.m:
          result = _Datetime.alignEnd(_date, C.s)[C.s](59);
          break;
        //minute
        case C.h:
          result = _Datetime.alignEnd(_date, C.m)[C.m](59);
          break;
        //hour
        case C.D:
          result = _Datetime.alignEnd(_date, C.h)[C.h](23);
          break;
        //day
        case C.M:
          result = _Datetime.alignEnd(_date, C.D)[C.D](1).add(1, C.M).add(-1, C.D);
          break;
        //month
        case C.Y:
          result = _Datetime.alignEnd(_date, C.D)[C.M](11)[C.D](31);
          break;
        //year
        case C.W: {
          temp = _date.weekDay();
          result = _Datetime.alignEnd(_date, "day").addDay(6 - temp);
          break;
        }
        default:
          result = date;
      }
      return result;
    }
    immutable(v5) {
      this.mutable = !(not(v5) ? true : v5);
      return this;
    }
    utc() {
      this.utcMode = true;
      return this;
    }
    local() {
      this.utcMode = false;
      return this;
    }
    useLocale(val, override) {
      this.locale = override ? val : !isset(_Datetime.locales[val], false) ? "en" : val;
      this.weekStart = _Datetime.getLocale(this.locale).weekStart;
      return this;
    }
    clone() {
      const c5 = datetime2(this.value);
      c5.locale = this.locale;
      c5.weekStart = this.weekStart;
      c5.mutable = this.mutable;
      return c5;
    }
    align(to2) {
      if (this.mutable) {
        this.value = _Datetime.align(this, to2).val();
        return this;
      }
      return this.clone().immutable(false).align(to2).immutable(!this.mutable);
    }
    alignEnd(to2) {
      if (this.mutable) {
        this.value = _Datetime.alignEnd(this, to2).val();
        return this;
      }
      return this.clone().immutable(false).alignEnd(to2).immutable(!this.mutable);
    }
    val(val) {
      if (typeof val === "undefined" || val === null) {
        return this.value;
      }
      if (this.mutable) {
        this.value = typeof val === "string" ? Date.parse(val) : typeof val === "number" ? new Date(val) : val;
        return this;
      }
      return datetime2(val);
    }
    year2() {
      return +("" + this.year()).slice(-2);
    }
    /* Get + Set */
    _set(m5, v5) {
      const fn = "set" + (this.utcMode && m5 !== "t" ? "UTC" : "") + M[m5];
      if (this.mutable) {
        this.value[fn](v5);
        return this;
      }
      const clone = this.clone();
      clone.value[fn](v5);
      return clone;
    }
    _get(m5) {
      const fn = "get" + (this.utcMode && m5 !== "t" ? "UTC" : "") + M[m5];
      return this.value[fn]();
    }
    _work(part, val) {
      if (!arguments.length || (typeof val === "undefined" || val === null)) {
        return this._get(part);
      }
      return this._set(part, val);
    }
    ms(val) {
      return this._work("ms", val);
    }
    second(val) {
      return this._work("s", val);
    }
    minute(val) {
      return this._work("m", val);
    }
    hour(val) {
      return this._work("h", val);
    }
    day(val) {
      return this._work("D", val);
    }
    month(val) {
      return this._work("M", val);
    }
    year(val) {
      return this._work("Y", val);
    }
    time(val) {
      return this._work("t", val);
    }
    weekDay(val) {
      if (!arguments.length || not(val)) {
        return this.utcMode ? this.value.getUTCDay() : this.value.getDay();
      }
      const curr = this.weekDay();
      const diff = val - curr;
      this.day(this.day() + diff);
      return this;
    }
    get(unit) {
      return typeof this[unit] !== "function" ? this : this[unit]();
    }
    set(unit, val) {
      return typeof this[unit] !== "function" ? this : this[unit](val);
    }
    add(val, to2) {
      switch (to2) {
        case C.h:
          return this.time(this.time() + val * 60 * 60 * 1e3);
        case C.m:
          return this.time(this.time() + val * 60 * 1e3);
        case C.s:
          return this.time(this.time() + val * 1e3);
        case C.ms:
          return this.time(this.time() + val);
        case C.D:
          return this.day(this.day() + val);
        case C.W:
          return this.day(this.day() + val * 7);
        case C.M:
          return this.month(this.month() + val);
        case C.Y:
          return this.year(this.year() + val);
      }
    }
    addHour(v5) {
      return this.add(v5, C.h);
    }
    addMinute(v5) {
      return this.add(v5, C.m);
    }
    addSecond(v5) {
      return this.add(v5, C.s);
    }
    addMs(v5) {
      return this.add(v5, C.ms);
    }
    addDay(v5) {
      return this.add(v5, C.D);
    }
    addWeek(v5) {
      return this.add(v5, C.W);
    }
    addMonth(v5) {
      return this.add(v5, C.M);
    }
    addYear(v5) {
      return this.add(v5, C.Y);
    }
    format(fmt, locale) {
      const format = fmt || DEFAULT_FORMAT;
      const names = _Datetime.getLocale(locale || this.locale);
      const year = this.year(), year2 = this.year2(), month = this.month(), day = this.day(), weekDay = this.weekDay();
      const hour = this.hour(), minute = this.minute(), second = this.second(), ms = this.ms();
      const matches2 = {
        YY: year2,
        YYYY: year,
        M: month + 1,
        MM: lpad(month + 1, 0, 2),
        MMM: names.monthsShort[month],
        MMMM: names.months[month],
        D: day,
        DD: lpad(day, 0, 2),
        d: weekDay,
        dd: names.weekdaysMin[weekDay],
        ddd: names.weekdaysShort[weekDay],
        dddd: names.weekdays[weekDay],
        H: hour,
        HH: lpad(hour, 0, 2),
        m: minute,
        mm: lpad(minute, 0, 2),
        s: second,
        ss: lpad(second, 0, 2),
        sss: lpad(ms, 0, 3)
      };
      return format.replace(REGEX_FORMAT, (match, $1) => $1 || matches2[match]);
    }
    valueOf() {
      return this.value.valueOf();
    }
    toString() {
      return this.value.toString();
    }
  };
  var datetime2 = (...args) => args && args[0] instanceof Datetime2 ? args[0] : new Datetime2(...args);
  var fnFormat = Datetime2.prototype.format;
  var buddhistMixin = {
    buddhist() {
      return this.year() + 543;
    },
    format(format, locale) {
      format = format || DEFAULT_FORMAT;
      const matches2 = {
        BB: (this.buddhist() + "").slice(-2),
        BBBB: this.buddhist()
      };
      let result = format.replace(/(\[[^\]]+])|B{4}|B{2}/g, (match, $1) => $1 || matches2[match]);
      return fnFormat.bind(this)(result, locale);
    }
  };
  Object.assign(Datetime2.prototype, buddhistMixin);
  var createCalendar = (date, iso) => {
    let _date = date instanceof Datetime2 ? date.clone().align("month") : datetime2(date);
    let ws = iso === 0 || iso ? iso : date.weekStart;
    let wd = ws ? _date.isoWeekDay() : _date.weekDay();
    let names = Datetime2.getLocale(_date.locale);
    let now = datetime2(), i3;
    const getWeekDays = (wd2, ws2) => {
      if (ws2 === 0) {
        return wd2;
      }
      let su = wd2[0];
      return wd2.slice(1).concat([su]);
    };
    const result = {
      month: names.months[_date.month()],
      days: [],
      weekstart: iso ? 1 : 0,
      weekdays: getWeekDays(names.weekdaysMin, ws),
      today: now.format("YYYY-MM-DD"),
      weekends: [],
      week: []
    };
    _date.addDay(ws ? -wd + 1 : -wd);
    for (i3 = 0; i3 < 42; i3++) {
      result.days.push(_date.format("YYYY-MM-DD"));
      _date.add(1, "day");
    }
    result.weekends = result.days.filter(function(v5, i22) {
      const def = [0, 6, 7, 13, 14, 20, 21, 27, 28, 34, 35, 41];
      const iso2 = [5, 6, 12, 13, 19, 20, 26, 27, 33, 34, 40, 41];
      return ws === 0 ? def.includes(i22) : iso2.includes(i22);
    });
    _date = now.clone();
    wd = ws ? _date.isoWeekDay() : _date.weekDay();
    _date.addDay(ws ? -wd + 1 : -wd);
    for (i3 = 0; i3 < 7; i3++) {
      result.week.push(_date.format("YYYY-MM-DD"));
      _date.add(1, "day");
    }
    return result;
  };
  Object.assign(Datetime2.prototype, {
    // 1 - Monday, 0 - Sunday
    calendar(weekStart) {
      return createCalendar(this, weekStart);
    }
  });
  var fnFormat2 = Datetime2.prototype.format;
  Object.assign(Datetime2.prototype, {
    century() {
      return Math.ceil(this.year() / 100);
    },
    format(format, locale) {
      format = format || DEFAULT_FORMAT;
      const matches2 = {
        C: this.century()
      };
      let fmt = format.replace(/(\[[^\]]+])|C/g, (match, $1) => $1 || matches2[match]);
      return fnFormat2.bind(this)(fmt, locale);
    }
  });
  Object.assign(Datetime2.prototype, {
    same(d4) {
      return this.time() === datetime2(d4).time();
    },
    /*
    * align: year, month, day, hour, minute, second, ms = default
    * */
    compare(d4, align, operator = "=") {
      const date = datetime2(d4);
      const curr = datetime2(this.value);
      let t1, t2;
      operator = operator || "=";
      if (["<", ">", ">=", "<=", "=", "!="].includes(operator) === false) {
        operator = "=";
      }
      align = (align || "ms").toLowerCase();
      t1 = curr.align(align).time();
      t2 = date.align(align).time();
      switch (operator) {
        case "<":
          return t1 < t2;
        case ">":
          return t1 > t2;
        case "<=":
          return t1 <= t2;
        case ">=":
          return t1 >= t2;
        case "=":
          return t1 === t2;
        case "!=":
          return t1 !== t2;
      }
    },
    between(d1, d22) {
      return this.younger(d1) && this.older(d22);
    },
    older(date, align) {
      return this.compare(date, align, "<");
    },
    olderOrEqual(date, align) {
      return this.compare(date, align, "<=");
    },
    younger(date, align) {
      return this.compare(date, align, ">");
    },
    youngerOrEqual(date, align) {
      return this.compare(date, align, ">=");
    },
    equal(date, align) {
      return this.compare(date, align, "=");
    },
    notEqual(date, align) {
      return this.compare(date, align, "!=");
    },
    diff(d4) {
      const date = datetime2(d4);
      const diff = Math.abs(this.time() - date.time());
      const diffMonth = Math.abs(this.month() - date.month() + 12 * (this.year() - date.year()));
      return {
        "ms": diff,
        "second": Math.ceil(diff / 1e3),
        "minute": Math.ceil(diff / (1e3 * 60)),
        "hour": Math.ceil(diff / (1e3 * 60 * 60)),
        "day": Math.ceil(diff / (1e3 * 60 * 60 * 24)),
        "month": diffMonth,
        "year": Math.floor(diffMonth / 12)
      };
    },
    distance(d4, align) {
      return this.diff(d4)[align];
    }
  });
  Object.assign(Datetime2.prototype, {
    isLeapYear() {
      const year = this.year();
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
  });
  Object.assign(Datetime2.prototype, {
    dayOfYear() {
      const dayCount = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      const month = this.month();
      const day = this.day();
      return dayCount[month] + day + (month > 1 && this.isLeapYear() ? 1 : 0);
    }
  });
  Object.assign(Datetime2.prototype, {
    daysInMonth() {
      const curr = datetime2(this.value);
      return curr.add(1, "month").day(1).add(-1, "day").day();
    },
    daysInYear() {
      return this.isLeapYear() ? 366 : 365;
    },
    daysInYearMap() {
      const result = [];
      const curr = datetime2(this.value);
      curr.month(0).day(1);
      for (let i3 = 0; i3 < 12; i3++) {
        curr.add(1, "month").add(-1, "day");
        result.push(curr.day());
        curr.day(1).add(1, "month");
      }
      return result;
    },
    daysInYearObj(locale, shortName) {
      const map = this.daysInYearMap();
      const result = {};
      const names = Datetime2.getLocale(locale || this.locale);
      map.forEach((v5, i3) => result[names[shortName ? "monthsShort" : "months"][i3]] = v5);
      return result;
    }
  });
  Object.assign(Datetime2.prototype, {
    decade() {
      return Math.floor(this.year() / 10) * 10;
    },
    decadeStart() {
      const decade = this.decade();
      const result = this.mutable ? this : this.clone();
      return result.year(decade).month(0).day(1);
    },
    decadeEnd() {
      const decade = this.decade() + 9;
      const result = this.mutable ? this : this.clone();
      return result.year(decade).month(11).day(31);
    },
    decadeOfMonth() {
      const part = this.clone().add(1, "month").day(1).add(-1, "day").day() / 3;
      const day = this.day();
      if (day <= part) return 1;
      if (day <= part * 2) return 2;
      return 3;
    }
  });
  Object.assign(Datetime2, {
    from(str2, format, locale) {
      let norm, normFormat, fItems, dItems;
      let iMonth, iDay, iYear, iHour, iMinute, iSecond, iMs;
      let year, month, day, hour, minute, second, ms;
      let parsedMonth;
      const getIndex = function(where, what) {
        return where.map(function(el) {
          return el.toLowerCase();
        }).indexOf(what.toLowerCase());
      };
      const monthNameToNumber = function(month2) {
        let i3 = -1;
        const names = Datetime2.getLocale(locale || "en");
        if (not(month2)) return -1;
        i3 = getIndex(names.months, month2);
        if (i3 === -1 && typeof names["monthsParental"] !== "undefined") {
          i3 = getIndex(names["monthsParental"], month2);
        }
        if (i3 === -1) {
          month2 = month2.substr(0, 3);
          i3 = getIndex(names.monthsShort, month2);
        }
        return i3 === -1 ? -1 : i3 + 1;
      };
      const getPartIndex = function(part) {
        const parts = {
          "month": ["M", "mm", "%m"],
          "day": ["D", "dd", "%d"],
          "year": ["YY", "YYYY", "yy", "yyyy", "%y"],
          "hour": ["h", "hh", "%h"],
          "minute": ["m", "mi", "i", "ii", "%i"],
          "second": ["s", "ss", "%s"],
          "ms": ["sss"]
        };
        let result = -1, key, index;
        for (let i3 = 0; i3 < parts[part].length; i3++) {
          key = parts[part][i3];
          index = fItems.indexOf(key);
          if (index !== -1) {
            result = index;
            break;
          }
        }
        return result;
      };
      if (!format) {
        return datetime2();
      }
      norm = str2.replace(/[\/,.:\s]/g, "-");
      normFormat = format.toLowerCase().replace(/[^a-zA-Z0-9%]/g, "-");
      fItems = normFormat.split("-");
      dItems = norm.split("-");
      if (norm.replace(/-/g, "").trim() === "") {
        throw new Error(INVALID_DATE);
      }
      iMonth = getPartIndex("month");
      iDay = getPartIndex("day");
      iYear = getPartIndex("year");
      iHour = getPartIndex("hour");
      iMinute = getPartIndex("minute");
      iSecond = getPartIndex("second");
      iMs = getPartIndex("ms");
      if (iMonth > -1 && dItems[iMonth]) {
        if (isNaN(parseInt(dItems[iMonth]))) {
          dItems[iMonth] = monthNameToNumber(dItems[iMonth]);
          if (dItems[iMonth] === -1) {
            iMonth = -1;
          }
        } else {
          parsedMonth = parseInt(dItems[iMonth]);
          if (parsedMonth < 1 || parsedMonth > 12) {
            iMonth = -1;
          }
        }
      } else {
        iMonth = -1;
      }
      year = iYear > -1 && dItems[iYear] ? dItems[iYear] : 0;
      month = iMonth > -1 && dItems[iMonth] ? dItems[iMonth] : 1;
      day = iDay > -1 && dItems[iDay] ? dItems[iDay] : 1;
      hour = iHour > -1 && dItems[iHour] ? dItems[iHour] : 0;
      minute = iMinute > -1 && dItems[iMinute] ? dItems[iMinute] : 0;
      second = iSecond > -1 && dItems[iSecond] ? dItems[iSecond] : 0;
      ms = iMs > -1 && dItems[iMs] ? dItems[iMs] : 0;
      return datetime2(year, month - 1, day, hour, minute, second, ms);
    }
  });
  var fnFormat3 = Datetime2.prototype.format;
  Object.assign(Datetime2.prototype, {
    ampm(isLowerCase) {
      let val = this.hour() < 12 ? "AM" : "PM";
      return isLowerCase ? val.toLowerCase() : val;
    },
    hour12: function(h3, p5) {
      let hour = h3;
      if (arguments.length === 0) {
        return this.hour() % 12;
      }
      p5 = p5 || "am";
      if (p5.toLowerCase() === "pm") {
        hour += 12;
      }
      return this.hour(hour);
    },
    format: function(format, locale) {
      let matches2, result, h12 = this.hour12();
      format = format || DEFAULT_FORMAT;
      matches2 = {
        a: "[" + this.ampm(true) + "]",
        A: "[" + this.ampm(false) + "]",
        h: h12,
        hh: lpad(h12, 0, 2)
      };
      result = format.replace(/(\[[^\]]+])|a|A|h{1,2}/g, (match, $1) => $1 || matches2[match]);
      return fnFormat3.bind(this)(result, locale);
    }
  });
  var fnFormat4 = Datetime2.prototype.format;
  var fnAlign = Datetime2.align;
  var fnAlignEnd = Datetime2.alignEnd;
  Object.assign(Datetime2, {
    align(d4, align) {
      let date = datetime2(d4), result, temp;
      switch (align) {
        case "isoWeek":
          temp = date.isoWeekDay();
          result = fnAlign(date, "day").addDay(-temp + 1);
          break;
        // isoWeek
        default:
          result = fnAlign.apply(void 0, [date, align]);
      }
      return result;
    },
    alignEnd(d4, align) {
      let date = datetime2(d4), result, temp;
      switch (align) {
        case "isoWeek":
          temp = date.isoWeekDay();
          result = fnAlignEnd(date, "day").addDay(7 - temp);
          break;
        // isoWeek
        default:
          result = fnAlignEnd.apply(void 0, [date, align]);
      }
      return result;
    }
  });
  Object.assign(Datetime2.prototype, {
    isoWeekDay(val) {
      let wd = (this.weekDay() + 6) % 7 + 1;
      if (!arguments.length || not(val)) {
        return wd;
      }
      return this.addDay(val - wd);
    },
    format(format, locale) {
      format = format || DEFAULT_FORMAT;
      const matches2 = {
        I: this.isoWeekDay()
      };
      let result = format.replace(/(\[[^\]]+])|I{1,2}/g, (match, $1) => $1 || matches2[match]);
      return fnFormat4.bind(this)(result, locale);
    }
  });
  Object.assign(Datetime2, {
    max() {
      let arr = [].slice.call(arguments);
      return arr.map((el) => datetime2(el)).sort((a2, b5) => b5.time() - a2.time())[0];
    }
  });
  Object.assign(Datetime2.prototype, {
    max() {
      return Datetime2.max.apply(this, [this].concat([].slice.call(arguments)));
    }
  });
  Object.assign(Datetime2, {
    min() {
      let arr = [].slice.call(arguments);
      return arr.map((el) => datetime2(el)).sort((a2, b5) => a2.time() - b5.time())[0];
    }
  });
  Object.assign(Datetime2.prototype, {
    min() {
      return Datetime2.min.apply(this, [this].concat([].slice.call(arguments)));
    }
  });
  var fnAlign2 = Datetime2.align;
  var fnAlignEnd2 = Datetime2.alignEnd;
  var fnAdd = Datetime2.prototype.add;
  Object.assign(Datetime2, {
    align(d4, align) {
      let date = datetime2(d4), result;
      switch (align) {
        case "quarter":
          result = Datetime2.align(date, "day").day(1).month(date.quarter() * 3 - 3);
          break;
        //quarter
        default:
          result = fnAlign2.apply(this, [date, align]);
      }
      return result;
    },
    alignEnd(d4, align) {
      let date = datetime2(d4), result;
      switch (align) {
        case "quarter":
          result = Datetime2.align(date, "quarter").add(3, "month").add(-1, "ms");
          break;
        //quarter
        default:
          result = fnAlignEnd2.apply(this, [date, align]);
      }
      return result;
    }
  });
  Object.assign(Datetime2.prototype, {
    quarter() {
      const month = this.month();
      if (month <= 2) return 1;
      if (month <= 5) return 2;
      if (month <= 8) return 3;
      return 4;
    },
    add(val, to2) {
      if (to2 === "quarter") {
        return this.month(this.month() + val * 3);
      }
      return fnAdd.bind(this)(val, to2);
    },
    addQuarter(v5) {
      return this.add(v5, "quarter");
    }
  });
  Object.assign(Datetime2, {
    sort(arr, opt2) {
      let result, _arr;
      const o2 = {};
      if (typeof opt2 === "string" || typeof opt2 !== "object" || not(opt2)) {
        o2.format = DEFAULT_FORMAT;
        o2.dir = opt2 && opt2.toUpperCase() === "DESC" ? "DESC" : "ASC";
        o2.returnAs = "datetime";
      } else {
        o2.format = opt2.format || DEFAULT_FORMAT;
        o2.dir = (opt2.dir || "ASC").toUpperCase();
        o2.returnAs = opt2.format ? "string" : opt2.returnAs || "datetime";
      }
      _arr = arr.map((el) => datetime2(el)).sort((a2, b5) => a2.valueOf() - b5.valueOf());
      if (o2.dir === "DESC") {
        _arr.reverse();
      }
      switch (o2.returnAs) {
        case "string":
          result = _arr.map((el) => el.format(o2.format));
          break;
        case "date":
          result = _arr.map((el) => el.val());
          break;
        default:
          result = _arr;
      }
      return result;
    }
  });
  var fnFormat5 = Datetime2.prototype.format;
  Object.assign(Datetime2.prototype, {
    utcOffset() {
      return this.value.getTimezoneOffset();
    },
    timezone() {
      return this.toTimeString().replace(/.+GMT([+-])(\d{2})(\d{2}).+/, "$1$2:$3");
    },
    timezoneName() {
      return this.toTimeString().replace(/.+\((.+?)\)$/, "$1");
    },
    format(format, locale) {
      format = format || DEFAULT_FORMAT;
      const matches2 = {
        Z: this.utcMode ? "Z" : this.timezone(),
        ZZ: this.timezone().replace(":", ""),
        ZZZ: "[GMT]" + this.timezone(),
        z: this.timezoneName()
      };
      let result = format.replace(/(\[[^\]]+])|Z{1,3}|z/g, (match, $1) => $1 || matches2[match]);
      return fnFormat5.bind(this)(result, locale);
    }
  });
  var fnFormat6 = Datetime2.prototype.format;
  Object.assign(Datetime2.prototype, {
    // TODO Need optimisation
    weekNumber(weekStart = 0) {
      let nYear, nday, newYear, day, daynum, weeknum;
      newYear = datetime2(this.year(), 0, 1);
      day = newYear.weekDay() - weekStart;
      day = day >= 0 ? day : day + 7;
      daynum = Math.floor(
        (this.time() - newYear.time() - (this.utcOffset() - newYear.utcOffset()) * 6e4) / 864e5
      ) + 1;
      if (day < 4) {
        weeknum = Math.floor((daynum + day - 1) / 7) + 1;
        if (weeknum > 52) {
          nYear = datetime2(this.year() + 1, 0, 1);
          nday = nYear.weekDay() - weekStart;
          nday = nday >= 0 ? nday : nday + 7;
          weeknum = nday < 4 ? 1 : 53;
        }
      } else {
        weeknum = Math.floor((daynum + day - 1) / 7);
        if (weeknum === 0) {
          const lastDayPrevYear = datetime2(this.year() - 1, 11, 31);
          weeknum = lastDayPrevYear.weekNumber(weekStart);
          if (weekStart === 1 && daynum <= 7 - day) {
            weeknum = 1;
          }
        }
      }
      return weeknum;
    },
    isoWeekNumber() {
      const d4 = new Date(this.time());
      d4.setHours(0, 0, 0, 0);
      d4.setDate(d4.getDate() + 3 - (d4.getDay() + 6) % 7);
      const jan4 = new Date(d4.getFullYear(), 0, 4);
      jan4.setDate(jan4.getDate() + 3 - (jan4.getDay() + 6) % 7);
      return 1 + Math.round(((d4.getTime() - jan4.getTime()) / 864e5 - 3 + (jan4.getDay() + 6) % 7) / 7);
    },
    weeksInYear(weekStart = 0) {
      const curr = datetime2(this.value);
      const lastDay = curr.month(11).day(31);
      const weekNum = lastDay.weekNumber(weekStart);
      if (weekNum === 1 && lastDay.weekDay() === weekStart) {
        return lastDay.add(-1, "day").weekNumber(weekStart);
      }
      return weekNum;
    },
    // weeksInYear(weekStart){
    //     const curr = datetime(this.value);
    //     return curr.month(11).day(31).weekNumber(weekStart);
    // },
    format: function(format, locale) {
      let matches2, result, wn = this.weekNumber(), wni = this.isoWeekNumber();
      format = format || DEFAULT_FORMAT;
      matches2 = {
        W: wn,
        WW: lpad(wn, 0, 2),
        WWW: wni,
        WWWW: lpad(wni, 0, 2)
      };
      result = format.replace(/(\[[^\]]+])|W{1,4}/g, (match, $1) => $1 || matches2[match]);
      return fnFormat6.bind(this)(result, locale);
    }
  });
  Object.assign(Datetime2.prototype, {
    strftime(fmt, locale) {
      const format = fmt || DEFAULT_FORMAT_STRFTIME;
      const names = Datetime2.getLocale(locale || this.locale);
      const year = this.year(), year2 = this.year2(), month = this.month(), day = this.day(), weekDay = this.weekDay();
      const hour = this.hour(), hour12 = this.hour12(), minute = this.minute(), second = this.second(), ms = this.ms(), time = this.time();
      const aDay = lpad(day, 0, 2), aMonth = lpad(month + 1, 0, 2), aHour = lpad(hour, 0, 2), aHour12 = lpad(hour12, 0, 2), aMinute = lpad(minute, 0, 2), aSecond = lpad(second, 0, 2), aMs = lpad(ms, 0, 3);
      const that = this;
      const thursday = function() {
        return datetime2(that.value).day(that.day() - (that.weekDay() + 6) % 7 + 3);
      };
      const matches2 = {
        "%a": names.weekdaysShort[weekDay],
        "%A": names.weekdays[weekDay],
        "%b": names.monthsShort[month],
        "%h": names.monthsShort[month],
        "%B": names.months[month],
        "%c": this.toString().substring(0, this.toString().indexOf(" (")),
        "%C": this.century(),
        "%d": aDay,
        "%D": [aDay, aMonth, year].join("/"),
        "%e": day,
        "%F": [year, aMonth, aDay].join("-"),
        "%G": thursday().year(),
        "%g": ("" + thursday().year()).slice(2),
        "%H": aHour,
        "%I": aHour12,
        "%j": lpad(this.dayOfYear(), 0, 3),
        "%k": aHour,
        "%l": aHour12,
        "%m": aMonth,
        "%n": month + 1,
        "%M": aMinute,
        "%p": this.ampm(),
        "%P": this.ampm(true),
        "%s": Math.round(time / 1e3),
        "%S": aSecond,
        "%u": this.isoWeekDay(),
        "%V": this.isoWeekNumber(),
        "%w": weekDay,
        "%x": this.toLocaleDateString(),
        "%X": this.toLocaleTimeString(),
        "%y": year2,
        "%Y": year,
        "%z": this.timezone().replace(":", ""),
        "%Z": this.timezoneName(),
        "%r": [aHour12, aMinute, aSecond].join(":") + " " + this.ampm(),
        "%R": [aHour, aMinute].join(":"),
        "%T": [aHour, aMinute, aSecond].join(":"),
        "%Q": aMs,
        "%q": ms,
        "%t": this.timezone()
      };
      return format.replace(
        REGEX_FORMAT_STRFTIME,
        (match) => matches2[match] === 0 || matches2[match] ? matches2[match] : match
      );
    }
  });
  Object.assign(Datetime2, {
    isToday(date) {
      const d4 = datetime2(date).align("day");
      const c5 = datetime2().align("day");
      return d4.time() === c5.time();
    }
  });
  Object.assign(Datetime2.prototype, {
    isToday() {
      return Datetime2.isToday(this);
    },
    today() {
      const now = datetime2();
      if (!this.mutable) {
        return now;
      }
      return this.val(now.val());
    }
  });
  Object.assign(Datetime2, {
    isTomorrow(date) {
      const d4 = datetime2(date).align("day");
      const c5 = datetime2().align("day").add(1, "day");
      return d4.time() === c5.time();
    }
  });
  Object.assign(Datetime2.prototype, {
    isTomorrow() {
      return Datetime2.isTomorrow(this);
    },
    tomorrow() {
      if (!this.mutable) {
        return this.clone().immutable(false).add(1, "day").immutable(!this.mutable);
      }
      return this.add(1, "day");
    }
  });
  Object.assign(Datetime2.prototype, {
    toDateString() {
      return this.value.toDateString();
    },
    toISOString() {
      return this.value.toISOString();
    },
    toJSON() {
      return this.value.toJSON();
    },
    toGMTString() {
      return this.value.toGMTString();
    },
    toLocaleDateString() {
      return this.value.toLocaleDateString();
    },
    toLocaleString() {
      return this.value.toLocaleString();
    },
    toLocaleTimeString() {
      return this.value.toLocaleTimeString();
    },
    toTimeString() {
      return this.value.toTimeString();
    },
    toUTCString() {
      return this.value.toUTCString();
    },
    toDate() {
      return new Date(this.value);
    }
  });
  Object.assign(Datetime2, {
    timestamp() {
      return (/* @__PURE__ */ new Date()).getTime() / 1e3;
    }
  });
  Object.assign(Datetime2.prototype, {
    unix(val) {
      let _val;
      if (!arguments.length || not(val)) {
        return Math.floor(this.valueOf() / 1e3);
      }
      _val = val * 1e3;
      if (this.mutable) {
        return this.time(_val);
      }
      return datetime2(this.value).time(_val);
    },
    timestamp() {
      return this.unix();
    }
  });
  Object.assign(Datetime2, {
    isYesterday(date) {
      const d4 = datetime2(date).align("day");
      const c5 = datetime2().align("day").add(-1, "day");
      return d4.time() === c5.time();
    }
  });
  Object.assign(Datetime2.prototype, {
    isYesterday() {
      return Datetime2.isYesterday(this);
    },
    yesterday() {
      if (!this.mutable) {
        return this.clone().immutable(false).add(-1, "day").immutable(!this.mutable);
      }
      return this.add(-1, "day");
    }
  });
  var getResult = (val) => {
    let res;
    let seconds = Math.floor(val / 1e3), minutes = Math.floor(seconds / 60), hours = Math.floor(minutes / 60), days = Math.floor(hours / 24), months = Math.floor(days / 30), years = Math.floor(months / 12);
    if (years >= 1) res = `${years} year`;
    if (months >= 1 && years < 1) res = `${months} mon`;
    if (days >= 1 && days <= 30) res = `${days} days`;
    if (hours && hours < 24) res = `${hours} hour`;
    if (minutes && (minutes >= 40 && minutes < 60)) res = "less a hour";
    if (minutes && minutes < 40) res = `${minutes} min`;
    if (seconds && seconds >= 30 && seconds < 60) res = `${seconds} sec`;
    if (seconds < 30) res = `few sec`;
    return res;
  };
  Object.assign(Datetime2, {
    timeLapse(d4) {
      let old = datetime2(d4), now = datetime2(), val = now - old;
      return getResult(val);
    }
  });
  Object.assign(Datetime2.prototype, {
    timeLapse() {
      let val = datetime2() - +this;
      return getResult(val);
    }
  });
  var ParseTimeMixin = {
    parseTime(t) {
      if (!isNaN(t)) return Math.abs(+t);
      const pattern = /([0-9]+d)|([0-9]{1,2}h)|([0-9]{1,2}m)|([0-9]{1,2}s)/gm;
      const match = t.match(pattern);
      return match.reduce((acc, val) => {
        let res;
        if (val.includes("d")) {
          res = 1e3 * 60 * 60 * 24 * parseInt(val);
        } else if (val.includes("h")) {
          res = 1e3 * 60 * 60 * parseInt(val);
        } else if (val.includes("m")) {
          res = 1e3 * 60 * parseInt(val);
        } else if (val.includes("s")) {
          res = 1e3 * parseInt(val);
        }
        return acc + res;
      }, 0);
    }
  };
  Object.assign(Datetime2, ParseTimeMixin);
  Object.assign(Datetime2.prototype, {
    moon() {
      const phases = [
        "new-moon",
        "waxing-crescent",
        "first-quarter",
        "waxing-gibbous",
        "full-moon",
        "waning-gibbous",
        "last-quarter",
        "waning-crescent"
      ];
      const phase = () => {
        let year = this.year(), month = this.month(), day = this.day();
        let e2;
        let jd;
        let b5;
        let c5 = e2 = jd = b5 = 0;
        if (month < 3) {
          year--;
          month += 12;
        }
        ++month;
        c5 = 365.25 * year;
        e2 = 30.6 * month;
        jd = c5 + e2 + day - 694039.09;
        jd /= 29.5305882;
        b5 = parseInt(jd);
        jd -= b5;
        b5 = Math.round(jd * 8);
        if (b5 >= 8) b5 = 0;
        return { phase: b5, name: phases[b5] };
      };
      return phase();
    }
  });
  var version = "3.2.5";
  var build_time = "18.05.2025, 14:46:05";
  var info = () => {
    console.info(`%c Datetime %c v${version} %c ${build_time} `, "color: #ffffff; font-weight: bold; background: #003152", "color: white; background: darkgreen", "color: white; background: #0080fe;");
  };
  Datetime2.info = info;

  // ../metroui-lib/source/datetime/index.js
  Datetime2.correctDate = (date) => datetime2(date).addDay(1).align("day").addMinute((/* @__PURE__ */ new Date()).getTimezoneOffset());
  globalThis.Datetime = Datetime2;
  globalThis.datetime = datetime2;
  (() => {
    "use strict";
    const MONTHS = [
      "january",
      "february",
      "march",
      "april",
      "may",
      "june",
      "july",
      "august",
      "september",
      "october",
      "november",
      "december"
    ];
    const DAYS = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
    const getLocale = Datetime2.getLocale;
    Datetime2.getLocale = function(locale = "en") {
      let _locale = locale;
      if (!Metro) {
        return getLocale.call(this, locale);
      }
      if (!Metro.locales[_locale]) {
        _locale = "en";
      }
      const data = Metro.locales[_locale];
      const months = MONTHS.map((el, i3) => data[el]);
      const monthsShort = MONTHS.map((el, i3) => data[`${el}_short`]);
      const weekdays = DAYS.map((el, i3) => data[el]);
      const weekdaysShort = DAYS.map((el, i3) => data[`${el}_short`]);
      const weekdaysMin = DAYS.map((el, i3) => data[`${el}_short_2`]);
      return {
        months,
        monthsShort,
        weekdays,
        weekdaysShort,
        weekdaysMin,
        weekStart: data.weekStart
      };
    };
  })();

  // ../metroui-lib/node_modules/@olton/string/dist/string.js
  var pr = Object.defineProperty;
  var ar = (r2, t) => {
    for (var e2 in t) pr(r2, e2, { get: t[e2], enumerable: true });
  };
  var qt = {};
  ar(qt, { append: () => Xt, camelCase: () => z, capitalize: () => F, chars: () => c, count: () => tt, countChars: () => W, countSubstr: () => rt, countUniqueChars: () => O, countUniqueWords: () => er, countWords: () => rr, dashedName: () => H, decapitalize: () => U, endsWith: () => gt, escapeHtml: () => et, first: () => st, includes: () => wt, insert: () => ht, isAlpha: () => xt, isAlphaDigit: () => _t, isBlank: () => Et, isDigit: () => dt, isEmpty: () => X, isLower: () => At, isString: () => Tt, isUpper: () => St, kebab: () => Z, last: () => nt, lower: () => R, lpad: () => ft, ltrim: () => M2, matches: () => Gt, nvl: () => Bt, pad: () => ct, prepend: () => kt, prune: () => lt, repeat: () => x, reverse: () => K, rpad: () => mt, rtrim: () => q, shorten: () => Lt, shuffle: () => J, slice: () => at, snake: () => Y, split: () => yt, sprintf: () => w, startsWith: () => bt, strip: () => Ct, stripBoom: () => Pt, stripTags: () => Rt, stripTagsAll: () => Ft, substring: () => m, swap: () => V, title: () => Q, trim: () => _, truncate: () => j, truncateWithAlign: () => pt, unescapeHtml: () => ot, unique: () => ut, uniqueWords: () => it, upper: () => G2, vsprintf: () => vt, words: () => a, wrap: () => It, wrapTag: () => Dt });
  var $2 = "\\d";
  var L = "\\s\\uFEFF\\xA0";
  var E = "\\uD800-\\uDBFF";
  var A = "\\uDC00-\\uDFFF";
  var b = "\\u0300-\\u036F\\u1AB0-\\u1AFF\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F";
  var Wt = "\\0-\\u02FF\\u0370-\\u1AAF\\u1B00-\\u1DBF\\u1E00-\\u20CF\\u2100-\\uD7FF\\uE000-\\uFE1F\\uFE30-\\uFFFF";
  var $t = "\\u2000-\\u206F";
  var zt = "\\x00-\\x2F\\x3A-\\x40\\x5B-\\x60\\x7b-\\xBF\\xD7\\xF7";
  var Ht = "\\u2700-\\u27BF";
  var B = "a-z\\xB5\\xDF-\\xF6\\xF8-\\xFF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F";
  var N = "\\x41-\\x5a\\xc0-\\xd6\\xd8-\\xde\\u0100\\u0102\\u0104\\u0106\\u0108\\u010a\\u010c\\u010e\\u0110\\u0112\\u0114\\u0116\\u0118\\u011a\\u011c\\u011e\\u0120\\u0122\\u0124\\u0126\\u0128\\u012a\\u012c\\u012e\\u0130\\u0132\\u0134\\u0136\\u0139\\u013b\\u013d\\u013f\\u0141\\u0143\\u0145\\u0147\\u014a\\u014c\\u014e\\u0150\\u0152\\u0154\\u0156\\u0158\\u015a\\u015c\\u015e\\u0160\\u0162\\u0164\\u0166\\u0168\\u016a\\u016c\\u016e\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017b\\u017d\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018b\\u018e-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019c\\u019d\\u019f\\u01a0\\u01a2\\u01a4\\u01a6\\u01a7\\u01a9\\u01ac\\u01ae\\u01af\\u01b1-\\u01b3\\u01b5\\u01b7\\u01b8\\u01bc\\u01c4\\u01c5\\u01c7\\u01c8\\u01ca\\u01cb\\u01cd\\u01cf\\u01d1\\u01d3\\u01d5\\u01d7\\u01d9\\u01db\\u01de\\u01e0\\u01e2\\u01e4\\u01e6\\u01e8\\u01ea\\u01ec\\u01ee\\u01f1\\u01f2\\u01f4\\u01f6-\\u01f8\\u01fa\\u01fc\\u01fe\\u0200\\u0202\\u0204\\u0206\\u0208\\u020a\\u020c\\u020e\\u0210\\u0212\\u0214\\u0216\\u0218\\u021a\\u021c\\u021e\\u0220\\u0222\\u0224\\u0226\\u0228\\u022a\\u022c\\u022e\\u0230\\u0232\\u023a\\u023b\\u023d\\u023e\\u0241\\u0243-\\u0246\\u0248\\u024a\\u024c\\u024e";
  var vr = new RegExp("([" + Wt + "]|[" + E + "][" + A + "]|[" + E + "](?![" + A + "])|(?:[^" + E + "]|^)[" + A + "])([" + b + "]+)", "g");
  var wr = new RegExp("([" + E + "])([" + A + "])", "g");
  var yr = new RegExp("((?:[" + Wt + "]|[" + E + "][" + A + "]|[" + E + "](?![" + A + "])|(?:[^" + E + "]|^)[" + A + "])(?:[" + b + "]+))|([" + E + "][" + A + "])|([\\n\\r\\u2028\\u2029])|(.)", "g");
  var Cr = new RegExp("[" + L + "]");
  var Ut = new RegExp("^[" + L + "]+");
  var Zt = new RegExp("[" + L + "]+$");
  var Kt = new RegExp("^" + $2 + "+$");
  var Jt = /[<>&"'`]/g;
  var Yt = /(<([^>]+)>)/ig;
  var D = new RegExp("(?:[" + N + "][" + b + "]*)?(?:[" + B + "][" + b + "]*)+|(?:[" + N + "][" + b + "]*)+(?![" + B + "])|[" + $2 + "]+|[" + Ht + "]|[^" + zt + $t + L + "]+", "g");
  var I = /[A-Z\xC0-\xD6\xD8-\xDE]?[a-z\xDF-\xF6\xF8-\xFF]+|[A-Z\xC0-\xD6\xD8-\xDE]+(?![a-z\xDF-\xF6\xF8-\xFF])|\d+/g;
  var Vt = new RegExp("^(?:[" + B + N + "][" + b + "]*)+$");
  var Qt = new RegExp("^((?:[" + B + N + "][" + b + "]*)|[" + $2 + "])+$");
  var T = /^[\x01-\xFF]*$/;
  var u = (r2, t = "") => !r2 && typeof r2 != "number" && typeof r2 != "boolean" ? t : typeof r2 == "string" ? r2 : Array.isArray(r2) ? r2.join("") : JSON.stringify(r2);
  var Ot = (r2, t) => typeof r2 > "u" || r2 === null ? t : r2;
  var a = (r2, t, e2) => {
    let i3;
    return t ? t instanceof RegExp ? i3 = t : i3 = new RegExp(t, Ot(e2, "")) : i3 = T.test(r2) ? I : D, Ot(u(r2).match(i3), []);
  };
  var F = (r2, t = false) => {
    let e2 = u(r2), i3 = e2.substring(1);
    return e2.substring(0, 1).toUpperCase() + (t ? i3.toLowerCase() : i3);
  };
  var z = (r2) => a(u(r2)).map((t, e2) => e2 === 0 ? t.toLowerCase() : F(t)).join("");
  var H = (r2) => a(u(r2)).map((t) => t.toLowerCase()).join("-");
  var U = (r2) => {
    let t = u(r2);
    return t.substring(0, 1).toLowerCase() + t.substr(1);
  };
  var Z = (r2, t = "-") => a(u(r2)).map((e2) => e2.toLowerCase()).join(t);
  var R = (r2) => u(r2).toLowerCase();
  var c = (r2, t = []) => u(r2).split("").filter((e2) => !t.includes(e2));
  var K = (r2, t) => c(u(r2), t).reverse().join("");
  var tr = (r2 = []) => {
    let t = [...r2], e2 = t.length, i3, o2;
    for (; e2 !== 0; ) o2 = Math.floor(Math.random() * e2), e2 -= 1, i3 = t[e2], t[e2] = t[o2], t[o2] = i3;
    return t;
  };
  var J = (r2) => tr(u(r2).split("")).join("");
  var Y = (r2) => a(u(r2)).map((t) => t.toLowerCase()).join("_");
  var lr = (r2, t) => {
    let e2 = t.toLowerCase(), i3 = t.toUpperCase();
    return r2 + (t === e2 ? i3 : e2);
  };
  var V = (r2) => u(r2).split("").reduce(lr, "");
  var Q = (r2, t, e2 = "") => {
    let i3 = u(r2), o2 = T.test(i3) ? I : D, n3 = Array.isArray(t) ? t : typeof t != "string" ? [] : t.split(e2);
    return r2.replace(o2, (s2, p5) => p5 && n3.includes(i3[p5 - 1]) ? R(s2) : F(s2));
  };
  var G2 = (r2) => u(r2).toUpperCase();
  var tt = (r2) => u(r2).length;
  var v = (r2 = []) => {
    let t = [...r2];
    for (let e2 = 0; e2 < t.length; ++e2) for (let i3 = e2 + 1; i3 < t.length; ++i3) t[e2] === t[i3] && t.splice(i3--, 1);
    return t;
  };
  var W = (r2, t) => c(r2, t).length;
  var O = (r2, t) => v(c(r2, t)).length;
  var rt = (r2, t = "") => {
    let e2 = u(r2), i3 = u(t);
    return e2 === "" || i3 === "" ? 0 : e2.split(i3).length - 1;
  };
  var rr = (r2, t, e2) => a(r2, t, e2).length;
  var er = (r2, t, e2) => v(a(r2, t, e2)).length;
  var fr = { "<": "&lt;", ">": "&gt;", "&": "&amp;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;" };
  function mr(r2) {
    return fr[r2];
  }
  var et = (r2) => u(r2).replace(Jt, mr);
  var or = { "<": /(&lt;)|(&#x0*3c;)|(&#0*60;)/gi, ">": /(&gt;)|(&#x0*3e;)|(&#0*62;)/gi, "&": /(&amp;)|(&#x0*26;)|(&#0*38;)/gi, '"': /(&quot;)|(&#x0*22;)|(&#0*34;)/gi, "'": /(&#x0*27;)|(&#0*39;)/gi, "`": /(&#x0*60;)|(&#0*96;)/gi };
  var cr = Object.keys(or);
  function hr(r2, t) {
    return r2.replace(or[t], t);
  }
  var ot = (r2) => cr.reduce(hr, u(r2));
  var ut = (r2, t) => v(c(r2, t)).join("");
  var it = (r2, t, e2) => v(a(r2, t, e2)).join("");
  var m = (r2, t, e2) => u(r2).substring(t, e2);
  var st = (r2, t = 0) => m(u(r2), 0, t);
  var nt = (r2, t = 0) => {
    let e2 = u(r2);
    return e2 ? m(e2, e2.length - t) : "";
  };
  var ur = "\uFEFF";
  var S = (r2, t, e2 = 9007199254740991) => r2 < t ? t : r2 > e2 ? e2 : r2;
  var g = (r2) => r2 === 1 / 0 ? 9007199254740991 : r2 === -1 / 0 ? -9007199254740991 : ~~r2;
  var j = (r2, t = 0, e2 = "...") => {
    let i3 = u(r2), o2 = t ? S(g(t), 0, 9007199254740991) : i3.length;
    return m(i3, 0, o2) + (i3.length === o2 ? "" : e2);
  };
  var pt = (r2, t = 0, e2 = "...") => {
    let i3 = j(r2, t, "");
    return i3.slice(r2, i3.lastIndexOf(" ")) + e2;
  };
  var at = (r2, t = 1) => {
    let e2 = u(r2), i3 = [], o2 = Math.round(e2.length / t);
    for (let n3 = 0; n3 < t; n3++) i3.push(m(e2, n3 * o2, o2));
    return i3;
  };
  var lt = (r2, t = 0, e2 = "") => {
    let i3 = u(r2), o2 = t ? S(g(t), 0, 9007199254740991) : i3.length, n3 = 0, s2 = T.test(i3) ? I : D;
    return i3.replace(s2, (p5, h3) => {
      let d4 = h3 + p5.length;
      d4 <= o2 - e2.length && (n3 = d4);
    }), i3.substring(0, n3) + e2;
  };
  var x = (r2, t = 0) => {
    let e2 = u(r2), i3 = t ? S(g(t), 0, 9007199254740991) : e2.length, o2 = e2;
    if (t === 0) return "";
    for (let n3 = 0; n3 < i3 - 1; n3++) e2 += o2;
    return e2;
  };
  var jt = (r2, t = 0) => {
    let e2 = r2.length, i3 = t - e2;
    return x(r2, i3 + 1).substring(0, t);
  };
  var ir = (r2, t = "", e2 = 0, i3 = false) => {
    let o2 = u(r2), n3 = e2 ? S(g(e2), 0, 9007199254740991) : o2.length, s2 = t.length, p5 = n3 - o2.length, h3 = p5;
    if (p5 <= 0 || s2 === 0) return o2;
    let d4 = jt(t, h3);
    return i3 ? d4 + o2 : o2 + d4;
  };
  var ft = (r2, t = " ", e2 = 0) => ir(r2, t, e2, true);
  var mt = (r2, t = " ", e2 = 0) => ir(r2, t, e2, false);
  var ct = (r2, t = "", e2 = 0) => {
    let i3 = u(r2), o2 = e2 ? S(g(e2), 0, 9007199254740991) : i3.length, n3 = t.length, s2 = o2 - i3.length, p5 = g(s2 / 2), h3 = s2 % 2;
    return s2 <= 0 || n3 === 0 ? i3 : jt(t, p5) + i3 + jt(t, p5 + h3);
  };
  var ht = (r2, t = "", e2 = 0) => {
    let i3 = u(r2);
    return i3.substring(0, e2) + t + i3.substring(e2);
  };
  var gr = Array.prototype.reduce;
  var xr = Array.prototype.reduceRight;
  var _ = (r2, t) => M2(q(r2, t), t);
  var M2 = (r2, t) => {
    let e2 = u(r2);
    if (!t) return e2.replace(Ut, "");
    if (t === "" || e2 === "") return e2;
    typeof t != "string" && (t = "");
    let i3 = true;
    return gr.call(e2, (o2, n3) => i3 && t.includes(n3) ? o2 : (i3 = false, o2 + n3), "");
  };
  var q = (r2, t) => {
    let e2 = u(r2);
    if (!t) return e2.replace(Zt, "");
    if (t === "" || e2 === "") return e2;
    typeof t != "string" && (t = "");
    let i3 = true;
    return xr.call(e2, (o2, n3) => i3 && t.includes(n3) ? o2 : (i3 = false, n3 + o2), "");
  };
  var gt = (r2, t, e2) => u(r2).endsWith(t, e2);
  var xt = (r2) => Vt.test(u(r2));
  var _t = (r2) => Qt.test(u(r2));
  var dt = (r2) => Kt.test(u(r2));
  var Et = (r2, t = true) => t ? u(r2).length === 0 : _(r2).length === 0;
  var X = (r2) => _(r2).length === 0;
  var At = (r2) => R(r2) === r2;
  var St = (r2) => G2(r2) === r2;
  var bt = (r2, t, e2) => u(r2).startsWith(t, e2);
  var Ft = (r2) => u(r2).replace(Yt, "");
  var Rt = (r2, t = []) => {
    let e2 = u(r2), i3 = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi;
    return e2.replace(i3, (o2, n3) => t.includes(n3) ? o2 : "");
  };
  var f = { not_string: /[^s]/, not_bool: /[^t]/, not_type: /[^T]/, not_primitive: /[^v]/, number: /[diefg]/, numeric_arg: /[bcdiefguxX]/, json: /[j]/, not_json: /[^j]/, text: /^[^\x25]+/, modulo: /^\x25{2}/, placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/, key: /^([a-z_][a-z_\d]*)/i, key_access: /^\.([a-z_][a-z_\d]*)/i, index_access: /^\[(\d+)\]/, sign: /^[+-]/ };
  function _r(r2, t) {
    let e2 = 1, i3 = r2.length, o2, n3 = "", s2, p5, h3, d4, Nt2, y4;
    for (let C5 = 0; C5 < i3; C5++) if (typeof r2[C5] == "string") n3 += r2[C5];
    else if (typeof r2[C5] == "object") {
      if (s2 = r2[C5], s2.keys) {
        o2 = t[e2];
        for (let P4 = 0; P4 < s2.keys.length; P4++) {
          if (typeof o2 > "u") throw new Error(w('[sprintf] Cannot access property "%s" of undefined value "%s"', s2.keys[P4], s2.keys[P4 - 1]));
          o2 = o2[s2.keys[P4]];
        }
      } else s2.param_no ? o2 = t[s2.param_no] : o2 = t[e2++];
      if (f.not_type.test(s2.type) && f.not_primitive.test(s2.type) && o2 instanceof Function && (o2 = o2()), f.numeric_arg.test(s2.type) && typeof o2 != "number" && isNaN(o2)) throw new TypeError(w("[sprintf] expecting number but found %T", o2));
      switch (f.number.test(s2.type) && (Nt2 = o2 >= 0), s2.type) {
        case "b":
          o2 = parseInt(o2, 10).toString(2);
          break;
        case "c":
          o2 = String.fromCharCode(parseInt(o2, 10));
          break;
        case "d":
        case "i":
          o2 = parseInt(o2, 10);
          break;
        case "j":
          o2 = JSON.stringify(o2, null, s2.width ? parseInt(s2.width) : 0);
          break;
        case "e":
          o2 = s2.precision ? parseFloat(o2).toExponential(s2.precision) : parseFloat(o2).toExponential();
          break;
        case "f":
          o2 = s2.precision ? parseFloat(o2).toFixed(s2.precision) : parseFloat(o2);
          break;
        case "g":
          o2 = s2.precision ? String(Number(o2.toPrecision(s2.precision))) : parseFloat(o2);
          break;
        case "o":
          o2 = (parseInt(o2, 10) >>> 0).toString(8);
          break;
        case "s":
          o2 = String(o2), o2 = s2.precision ? o2.substring(0, s2.precision) : o2;
          break;
        case "t":
          o2 = String(!!o2), o2 = s2.precision ? o2.substring(0, s2.precision) : o2;
          break;
        case "T":
          o2 = Object.prototype.toString.call(o2).slice(8, -1).toLowerCase(), o2 = s2.precision ? o2.substring(0, s2.precision) : o2;
          break;
        case "u":
          o2 = parseInt(o2, 10) >>> 0;
          break;
        case "v":
          o2 = o2.valueOf(), o2 = s2.precision ? o2.substring(0, s2.precision) : o2;
          break;
        case "x":
          o2 = (parseInt(o2, 10) >>> 0).toString(16);
          break;
        case "X":
          o2 = (parseInt(o2, 10) >>> 0).toString(16).toUpperCase();
          break;
      }
      f.json.test(s2.type) ? n3 += o2 : (f.number.test(s2.type) && (!Nt2 || s2.sign) ? (y4 = Nt2 ? "+" : "-", o2 = o2.toString().replace(f.sign, "")) : y4 = "", h3 = s2.pad_char ? s2.pad_char === "0" ? "0" : s2.pad_char.charAt(1) : " ", d4 = s2.width - (y4 + o2).length, p5 = s2.width && d4 > 0 ? h3.repeat(d4) : "", n3 += s2.align ? y4 + o2 + p5 : h3 === "0" ? y4 + p5 + o2 : p5 + y4 + o2);
    }
    return n3;
  }
  var Mt = /* @__PURE__ */ Object.create(null);
  function dr(r2) {
    if (Mt[r2]) return Mt[r2];
    let t = r2, e2, i3 = [], o2 = 0;
    for (; t; ) {
      if ((e2 = f.text.exec(t)) !== null) i3.push(e2[0]);
      else if ((e2 = f.modulo.exec(t)) !== null) i3.push("%");
      else if ((e2 = f.placeholder.exec(t)) !== null) {
        if (e2[2]) {
          o2 |= 1;
          let n3 = [], s2 = e2[2], p5 = [];
          if ((p5 = f.key.exec(s2)) !== null) for (n3.push(p5[1]); (s2 = s2.substring(p5[0].length)) !== ""; ) if ((p5 = f.key_access.exec(s2)) !== null) n3.push(p5[1]);
          else if ((p5 = f.index_access.exec(s2)) !== null) n3.push(p5[1]);
          else throw new SyntaxError("[sprintf] failed to parse named argument key");
          else throw new SyntaxError("[sprintf] failed to parse named argument key");
          e2[2] = n3;
        } else o2 |= 2;
        if (o2 === 3) throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
        i3.push({ placeholder: e2[0], param_no: e2[1], keys: e2[2], sign: e2[3], pad_char: e2[4], align: e2[5], width: e2[6], precision: e2[7], type: e2[8] });
      } else throw new SyntaxError("[sprintf] unexpected placeholder");
      t = t.substring(e2[0].length);
    }
    return Mt[r2] = i3;
  }
  var w = (r2) => _r(dr(r2), arguments);
  var vt = (r2, t) => w.apply(null, [r2].concat(t || []));
  var wt = (r2, t, e2) => u(r2).includes(t, e2);
  var yt = (r2, t = void 0, e2 = void 0, i3 = true) => u(r2).split(t, e2).map((o2) => i3 ? o2.trim() : o2).filter((o2) => i3 ? !X(o2) : true);
  var Ct = (r2, t = null, e2 = "") => {
    let i3 = u(r2), o2;
    return t ? (o2 = new RegExp(t, "g"), i3.replace(o2, e2)) : i3;
  };
  var Dt = (r2, t = "div", e2 = {}) => {
    let i3 = u(r2), o2 = Object.keys(e2).map((n3) => `${n3}="${e2[n3]}"`).join(" ");
    return o2 && (o2 = " " + o2), `<${t}${o2}>${i3}</${t}>`;
  };
  var It = (r2, t = "", e2 = "") => t + u(r2) + e2;
  var Tt = (r2) => typeof r2 == "string";
  var Gt = (r2, t, e2 = "") => {
    let i3 = u(r2), o2;
    if (!(t instanceof RegExp)) {
      if (o2 = t ? _(u(t)) : "", !o2) return false;
      t = new RegExp(o2, e2);
    }
    return t.test(i3);
  };
  var Xt = (r2, t = "", e2 = 1) => u(r2) + x(t, e2);
  var kt = (r2, t = "", e2 = 1) => x(t, e2) + u(r2);
  var Pt = (r2) => {
    let t = u(r2);
    return t === "" ? t : t[0] === ur ? t.substring(1) : t;
  };
  var Lt = (r2, t = 5, e2 = "...") => r2 && `${r2.substring(0, t)}${e2}${r2.substring(r2.length - t)}`;
  var sr = (r2) => typeof r2 > "u" || r2 === null;
  var Bt = (r2, ...t) => {
    if (!sr(r2)) return r2;
    if (t.length === 0) throw new Error("nvl: No default value provided");
    for (let e2 of t) if (typeof e2 < "u" && e2 !== null) return e2;
  };
  var k = class {
    constructor(t = "", { mutable: e2 = true } = {}) {
      this.value = t.toString(), this.mutable = e2;
    }
    [Symbol.toPrimitive](t) {
      return t === "number" ? +this.value : this.value;
    }
    get [Symbol.toStringTag]() {
      return "Str";
    }
    val(t) {
      return typeof t > "u" || t === null ? this.value : (this.value = t.toString(), this);
    }
    get length() {
      return this.value.length;
    }
    immutable(t = true) {
      this.mutable = !t;
    }
    toString() {
      return Array.isArray(this.value) ? this.value.join("") : this.value;
    }
    _result(t) {
      return this.mutable ? (this.value = t, this) : nr(t);
    }
    camelCase() {
      return this._result(z(this.value));
    }
    capitalize(t) {
      return this._result(F(this.value, t));
    }
    chars(t) {
      return this._result(c(this.value, t));
    }
    count() {
      return tt(this.value);
    }
    countChars(t) {
      return W(this.value, t);
    }
    countUniqueChars(t) {
      return O(this.value, t);
    }
    countSubstr(t) {
      return rt(this.value, t);
    }
    countWords(t, e2) {
      return W(this.value, t, e2);
    }
    countUniqueWords(t, e2) {
      return O(this.value, t, e2);
    }
    dashedName() {
      return this._result(H(this.value));
    }
    decapitalize() {
      return this._result(U(this.value));
    }
    endsWith(t, e2) {
      return gt(this.value, t, e2);
    }
    escapeHtml() {
      return this._result(et(this.value));
    }
    first() {
      return this._result(st(this.value));
    }
    includes(t, e2) {
      return wt(this.value, t, e2);
    }
    insert(t, e2) {
      return this._result(ht(this.value, t, e2));
    }
    isAlpha() {
      return xt(this.value);
    }
    isAlphaDigit() {
      return _t(this.value);
    }
    isBlank(t) {
      return Et(this.value, t);
    }
    isDigit() {
      return dt(this.value);
    }
    isEmpty() {
      return X(this.value);
    }
    isLower() {
      return At(this.value);
    }
    static isString(t) {
      return Tt(t);
    }
    isUpper() {
      return St(this.value);
    }
    kebab(t) {
      return this._result(Z(this.value, t));
    }
    last(t) {
      return this._result(nt(this.value, t));
    }
    lower() {
      return this._result(R(this.value));
    }
    matches(t, e2) {
      return Gt(this.value, t, e2);
    }
    pad(t, e2) {
      return this._result(ct(this.value, t, e2));
    }
    lpad(t, e2) {
      return this._result(ft(this.value, t, e2));
    }
    rpad(t, e2) {
      return this._result(mt(this.value, t, e2));
    }
    prune(t, e2) {
      return this._result(lt(this.value, t, e2));
    }
    repeat(t) {
      return this._result(x(this.value, t));
    }
    append(t, e2) {
      return this._result(Xt(this.value, t, e2));
    }
    prepend(t, e2) {
      return this._result(kt(this.value, t, e2));
    }
    reverse(t) {
      return this._result(K(this.value, t));
    }
    shuffle() {
      return this._result(J(this.value));
    }
    slice(t) {
      return this._result(at(this.value, t));
    }
    snake() {
      return this._result(Y(this.value));
    }
    split(t, e2, i3) {
      return this._result(yt(this.value, t, e2, i3));
    }
    sprintf(...t) {
      return this._result(w(this.value, ...t));
    }
    vsprintf(...t) {
      return this._result(vt(this.value, ...t));
    }
    startsWith(t, e2) {
      return bt(this.value, t, e2);
    }
    stripBoom() {
      return this._result(Pt(this.value));
    }
    stripTags(t) {
      return this._result(Rt(this.value, t));
    }
    stripTagsAll() {
      return this._result(Ft(this.value));
    }
    strip(t, e2) {
      return this._result(Ct(this.value, t, e2));
    }
    substring(t, e2) {
      return this._result(m(this.value, t, e2));
    }
    swap() {
      return this._result(V(this.value));
    }
    title(t, e2) {
      return this._result(Q(this.value, t, e2));
    }
    trim(t) {
      return this._result(_(this.value, t));
    }
    ltrim(t) {
      return this._result(M2(this.value, t));
    }
    rtrim(t) {
      return this._result(q(this.value, t));
    }
    truncate(t, e2) {
      return this._result(j(this.value, t, e2));
    }
    truncateWithAlign(t, e2) {
      return this._result(pt(this.value, t, e2));
    }
    unescapeHtml() {
      return this._result(ot(this.value));
    }
    unique(t) {
      return this._result(ut(this.value, t));
    }
    uniqueWords(t, e2) {
      return this._result(it(this.value, t, e2));
    }
    upper() {
      return this._result(G2(this.value));
    }
    words(t, e2) {
      return a(this.value, t, e2);
    }
    wrap(t, e2) {
      return this._result(It(this.value, t, e2));
    }
    wrapTag(t) {
      return this._result(Dt(this.value, t));
    }
    shorten(t, e2) {
      return this._result(Lt(this.value, t, e2));
    }
    nvl(...t) {
      return this._result(Bt(this.value, ...t));
    }
  };
  Object.assign(k, qt);
  var nr = (r2, t = true) => new k(r2, { mutable: t });
  var Er = "0.10.2";
  var Ar = "18.05.2025, 14:39:06";
  var Sr = () => {
    console.info(`%c String %c v${Er} %c ${Ar} `, "color: #000000; font-weight: bold; background: #fff200", "color: white; background: darkgreen", "color: white; background: #0080fe;");
  };
  k.info = Sr;

  // ../metroui-lib/source/string/index.js
  globalThis.Str = k;
  globalThis.str = nr;

  // ../metroui-lib/node_modules/@olton/dom/dist/dom.js
  var numProps = ["opacity", "zIndex"];
  function nothing() {
    return null;
  }
  function isSimple(v5) {
    return typeof v5 === "string" || typeof v5 === "boolean" || typeof v5 === "number";
  }
  function isVisible(elem) {
    const computedStyle = getComputedStyle(elem);
    const hasDimensions = !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    const isNotHiddenByStyles = computedStyle.visibility !== "hidden" && computedStyle.display !== "none" && computedStyle.opacity !== "0" && elem.style.display !== "none";
    return hasDimensions && isNotHiddenByStyles;
  }
  function isHidden(elem) {
    const s2 = getComputedStyle(elem);
    return !isVisible(elem) || +s2.opacity === 0 || elem.hidden || s2.visibility === "hidden";
  }
  function not2(value) {
    return value === void 0 || value === null;
  }
  function camelCase(string) {
    return string.replace(/-([a-z])/g, function(all, letter) {
      return letter.toUpperCase();
    });
  }
  function dashedName(str2) {
    return str2.replace(/([A-Z])/g, function(u4) {
      return "-" + u4.toLowerCase();
    });
  }
  function isPlainObject(obj) {
    let proto;
    if (!obj || Object.prototype.toString.call(obj) !== "[object Object]") {
      return false;
    }
    proto = obj.prototype !== void 0;
    if (!proto) {
      return true;
    }
    return proto.constructor && typeof proto.constructor === "function";
  }
  function isEmptyObject(obj) {
    for (const name2 in obj) {
      if (hasProp(obj, name2)) return false;
    }
    return true;
  }
  function isArrayLike(o2) {
    return o2 instanceof Object && "length" in o2;
  }
  function str2arr(str2, sep) {
    sep = sep || " ";
    return str2.split(sep).map(function(el) {
      return ("" + el).trim();
    }).filter(function(el) {
      return el !== "";
    });
  }
  function parseUnit(str2, out) {
    if (!out) out = [0, ""];
    str2 = String(str2);
    out[0] = parseFloat(str2);
    out[1] = str2.match(/[\d.\-+]*\s*(.*)/)[1] || "";
    return out;
  }
  function getUnit(val, und) {
    const split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn|fr|lh|cqw|cqh|cqi|cqb|cqmin|cqmax|q)?$/.exec(val);
    return typeof split[1] !== "undefined" ? split[1] : und;
  }
  function setStyleProp(el, key, val) {
    key = camelCase(key);
    if (["scrollLeft", "scrollTop"].indexOf(key) > -1) {
      el[key] = parseInt(val);
    } else {
      el.style[key] = isNaN(val) || numProps.indexOf("" + key) > -1 ? val : parseInt(val) === 0 ? 0 : val + "px";
    }
  }
  function acceptData(owner) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
  }
  function normName(name2) {
    return typeof name2 !== "string" ? void 0 : name2.replace(/-/g, "").toLowerCase();
  }
  function hasProp(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  function isLocalhost(host) {
    const hostname = host || globalThis.location.hostname;
    return hostname === "localhost" || hostname === "127.0.0.1" || hostname === "[::1]" || hostname === "" || hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/) !== null;
  }
  function isTouch() {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0;
  }
  function isPrivateAddress(host) {
    const hostname = host || globalThis.location.hostname;
    return /(^localhost)|(^127\.)|(^192\.168\.)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2\d\.)|(^172\.3[0-1]\.)|(^::1$)|(^[fF][cCdD])/.test(hostname);
  }
  function safeJsonParse(str2) {
    try {
      return JSON.parse(str2);
    } catch (e2) {
      return str2;
    }
  }
  var matches = Element.prototype.matches;
  var $3 = (selector, context) => new $3.init(selector, context);
  $3.version = "1.5.1";
  $3.build_time = "18.05.2025, 14:45:23";
  $3.info = () => console.info(`%c Dom %c v${$3.version} %c ${$3.build_time} `, "color: white; font-weight: bold; background: #fd6a02", "color: white; background: darkgreen", "color: white; background: #0080fe;");
  $3.fn = $3.prototype = Object.create(Array.prototype);
  $3.prototype.constructor = $3;
  $3.prototype.uid = "";
  $3.extend = $3.fn.extend = function() {
    let options, name2, target = arguments[0] || {}, i3 = 1, length = arguments.length;
    if (typeof target !== "object" && typeof target !== "function") {
      target = {};
    }
    if (i3 === length) {
      target = this;
      i3--;
    }
    for (; i3 < length; i3++) {
      if ((options = arguments[i3]) != null) {
        for (name2 in options) {
          if (hasProp(options, name2))
            target[name2] = options[name2];
        }
      }
    }
    return target;
  };
  $3.assign = function() {
    let options, name2, target = arguments[0] || {}, i3 = 1, length = arguments.length;
    if (typeof target !== "object" && typeof target !== "function") {
      target = {};
    }
    if (i3 === length) {
      target = this;
      i3--;
    }
    for (; i3 < length; i3++) {
      if ((options = arguments[i3]) != null) {
        for (name2 in options) {
          if (hasProp(options, name2) && options[name2] !== void 0)
            target[name2] = options[name2];
        }
      }
    }
    return target;
  };
  (function(workerScript) {
    try {
      const blob = new Blob([`
            var fakeIdToId = {};
            onmessage = function (event) {
                var data = event.data,
                    name = data.name,
                    fakeId = data.fakeId,
                    time;
                if(data.hasOwnProperty('time')) {
                    time = data.time;
                }
                switch (name) {
                    case 'setInterval':
                        fakeIdToId[fakeId] = setInterval(function () {
                            postMessage({fakeId: fakeId});
                        }, time);
                        break;
                    case 'clearInterval':
                        if (fakeIdToId.hasOwnProperty (fakeId)) {
                            clearInterval(fakeIdToId[fakeId]);
                            delete fakeIdToId[fakeId];
                        }
                        break;
                    case 'setTimeout':
                        fakeIdToId[fakeId] = setTimeout(function () {
                            postMessage({fakeId: fakeId});
                            if (fakeIdToId.hasOwnProperty (fakeId)) {
                                delete fakeIdToId[fakeId];
                            }
                        }, time);
                        break;
                    case 'clearTimeout':
                        if (fakeIdToId.hasOwnProperty (fakeId)) {
                            clearTimeout(fakeIdToId[fakeId]);
                            delete fakeIdToId[fakeId];
                        }
                        break;
                }
            }
        `]);
      workerScript = window.URL.createObjectURL(blob);
    } catch (error) {
    }
    let worker, fakeIdToCallback = {}, lastFakeId = 0, maxFakeId = 2147483647, logPrefix = "";
    function getFakeId() {
      do {
        if (lastFakeId === maxFakeId) {
          lastFakeId = 0;
        } else {
          lastFakeId++;
        }
      } while (fakeIdToCallback.hasOwnProperty(lastFakeId));
      return lastFakeId;
    }
    if (typeof Worker === "undefined") {
      return;
    }
    try {
      worker = new Worker(workerScript);
      window.setInterval = function(callback, time) {
        const fakeId = getFakeId();
        fakeIdToCallback[fakeId] = {
          callback,
          parameters: Array.prototype.slice.call(arguments, 2)
        };
        worker.postMessage({
          name: "setInterval",
          fakeId,
          time
        });
        return fakeId;
      };
      window.clearInterval = function(fakeId) {
        if (fakeIdToCallback.hasOwnProperty(fakeId)) {
          delete fakeIdToCallback[fakeId];
          worker.postMessage({
            name: "clearInterval",
            fakeId
          });
        }
      };
      window.setTimeout = function(callback, time) {
        const fakeId = getFakeId();
        fakeIdToCallback[fakeId] = {
          callback,
          parameters: Array.prototype.slice.call(arguments, 2),
          isTimeout: true
        };
        worker.postMessage({
          name: "setTimeout",
          fakeId,
          time
        });
        return fakeId;
      };
      window.clearTimeout = function(fakeId) {
        if (fakeIdToCallback.hasOwnProperty(fakeId)) {
          delete fakeIdToCallback[fakeId];
          worker.postMessage({
            name: "clearTimeout",
            fakeId
          });
        }
      };
      window.setImmediate = function(callback) {
        return setTimeout(callback, 0);
      };
      window.clearImmediate = function(fakeId) {
        clearTimeout(fakeId);
      };
      worker.onmessage = function(event) {
        let data = event.data, fakeId = data.fakeId, request, parameters, callback;
        if (fakeIdToCallback.hasOwnProperty(fakeId)) {
          request = fakeIdToCallback[fakeId];
          callback = request.callback;
          parameters = request.parameters;
          if (request.hasOwnProperty("isTimeout") && request.isTimeout) {
            delete fakeIdToCallback[fakeId];
          }
        }
        if (typeof callback === "string") {
          try {
            callback = new Function(callback);
          } catch (error) {
            console.error(logPrefix + "Error parsing callback code string: ", error);
          }
        }
        if (typeof callback === "function") {
          callback.apply(window, parameters);
        }
      };
      worker.onerror = function(event) {
        console.error(event);
      };
    } catch (error) {
      console.log(`Can't create worker for Intervals, use standard functions.`);
    }
  })();
  $3.fn.extend({
    _getDefaultElement(sel) {
      let el;
      if (not2(sel)) {
        el = this[0];
      } else if (sel instanceof HTMLElement) {
        el = sel;
      } else if (sel instanceof $3 && sel.length > 0) {
        el = sel[0];
      } else if (typeof sel === "string") {
        el = $3(sel)[0];
      } else {
        el = void 0;
      }
      return el;
    },
    index: function(sel) {
      let el, _index = -1;
      if (this.length === 0) {
        return _index;
      }
      el = this._getDefaultElement(sel);
      if (!el) {
        return _index;
      }
      if (el && el.parentNode) $3.each(el.parentNode.children, function(i3) {
        if (this === el) {
          _index = i3;
        }
      });
      return _index;
    },
    indexOf: function(sel) {
      let el, _index = -1;
      if (this.length === 0) {
        return _index;
      }
      el = this._getDefaultElement(sel);
      if (!el) {
        return _index;
      }
      this.each(function(i3) {
        if (this === el) {
          _index = i3;
        }
      });
      return _index;
    },
    get: function(i3) {
      if (i3 === void 0) {
        return this;
      }
      return i3 < 0 ? this[i3 + this.length] : i3 > this.length - 1 ? void 0 : this[i3];
    },
    eq: function(i3) {
      if (not2(i3)) {
        return this;
      }
      return this.length > 0 ? $3.extend($3(this.get(i3)), { _prevObj: this }) : this;
    },
    is: function(s2) {
      let result = false;
      if (this.length === 0) {
        return false;
      }
      if (s2 instanceof $3) {
        return this.same(s2);
      }
      if (s2 === ":selected") {
        this.each(function() {
          if (this.selected) result = true;
        });
      } else if (s2 === ":checked") {
        this.each(function() {
          if (this.checked) result = true;
        });
      } else if (s2 === ":visible") {
        result = false;
        this.each(function() {
          if (isVisible(this)) result = true;
        });
      } else if (s2 === ":hidden") {
        this.each(function() {
          const styles = getComputedStyle(this);
          if (this.getAttribute("type") === "hidden" || this.hidden || styles.display === "none" || styles.visibility === "hidden" || parseInt(styles.opacity) === 0) result = true;
        });
      } else if (typeof s2 === "string" && [":selected"].indexOf(s2) === -1) {
        this.each(function() {
          if (matches.call(this, s2)) {
            result = true;
          }
        });
      } else if (isArrayLike(s2)) {
        this.each(function() {
          const el = this;
          $3.each(s2, function() {
            const sel = this;
            if (el === sel) {
              result = true;
            }
          });
        });
      } else if (typeof s2 === "object" && s2.nodeType === 1) {
        this.each(function() {
          if (this === s2) {
            result = true;
          }
        });
      }
      return result;
    },
    same: function(o2) {
      let result = true;
      if (!(o2 instanceof $3)) {
        o2 = $3(o2);
      }
      if (this.length !== o2.length) return false;
      this.each(function() {
        if (o2.items().indexOf(this) === -1) {
          result = false;
        }
      });
      return result;
    },
    last: function() {
      return this.eq(this.length - 1);
    },
    first: function() {
      return this.eq(0);
    },
    odd: function() {
      const result = this.filter(function(el, i3) {
        return (i3 + 1) % 2 !== 0;
      });
      return $3.extend(result, { _prevObj: this });
    },
    even: function() {
      const result = this.filter(function(el, i3) {
        return (i3 + 1) % 2 === 0;
      });
      return $3.extend(result, { _prevObj: this });
    },
    filter: function(fn) {
      if (typeof fn === "string") {
        const sel = fn;
        fn = function(el) {
          return matches.call(el, sel);
        };
      }
      return $3.extend($3.merge($3(), [].filter.call(this, fn)), { _prevObj: this });
    },
    find: function(s2) {
      let res = [], result;
      if (s2 instanceof $3) return s2;
      if (this.length === 0) {
        result = this;
      } else {
        this.each(function() {
          const el = this;
          if (typeof el.querySelectorAll === "undefined") {
            return;
          }
          res = res.concat([].slice.call(el.querySelectorAll(s2)));
        });
        result = $3.merge($3(), res);
      }
      return $3.extend(result, { _prevObj: this });
    },
    contains: function(s2) {
      return this.find(s2).length > 0;
    },
    children: function(s2) {
      let i3, res = [];
      if (s2 instanceof $3) return s2;
      this.each(function() {
        const el = this;
        for (i3 = 0; i3 < el.children.length; i3++) {
          if (el.children[i3].nodeType === 1)
            res.push(el.children[i3]);
        }
      });
      res = s2 ? res.filter(function(el) {
        return matches.call(el, s2);
      }) : res;
      return $3.extend($3.merge($3(), res), { _prevObj: this });
    },
    parent: function(s2) {
      let res = [];
      if (this.length === 0) {
        return;
      }
      if (s2 instanceof $3) return s2;
      this.each(function() {
        if (this.parentNode) {
          if (res.indexOf(this.parentNode) === -1) res.push(this.parentNode);
        }
      });
      res = s2 ? res.filter(function(el) {
        return matches.call(el, s2);
      }) : res;
      return res.length ? $3.extend($3.merge($3(), res), { _prevObj: this }) : void 0;
    },
    parents: function(s2) {
      let res = [];
      if (this.length === 0) {
        return;
      }
      if (s2 instanceof $3) return s2;
      this.each(function() {
        let par = this.parentNode;
        while (par) {
          if (par.nodeType === 1 && res.indexOf(par) === -1) {
            if (!not2(s2)) {
              if (matches.call(par, s2)) {
                res.push(par);
              }
            } else {
              res.push(par);
            }
          }
          par = par.parentNode;
        }
      });
      return $3.extend($3.merge($3(), res), { _prevObj: this });
    },
    siblings: function(s2) {
      let res = [];
      if (this.length === 0) {
        return void 0;
      }
      if (s2 instanceof $3) {
        return s2;
      }
      this.each(function() {
        const el = this;
        if (el.parentNode) {
          $3.each(el.parentNode.children, function() {
            if (el !== this) res.push(this);
          });
        }
      });
      if (s2) {
        res = res.filter(function(el) {
          return matches.call(el, s2);
        });
      }
      return $3.extend($3.merge($3(), res), { _prevObj: this });
    },
    _siblingAll: function(dir, s2) {
      let res = [];
      if (this.length === 0) {
        return;
      }
      if (s2 instanceof $3) return s2;
      this.each(function() {
        let el = this;
        while (el) {
          el = el[dir];
          if (!el) break;
          res.push(el);
        }
      });
      if (s2) {
        res = res.filter(function(el) {
          return matches.call(el, s2);
        });
      }
      return $3.extend($3.merge($3(), res), { _prevObj: this });
    },
    _sibling: function(dir, s2) {
      let res = [];
      if (this.length === 0) {
        return;
      }
      if (s2 instanceof $3) return s2;
      this.each(function() {
        const el = this[dir];
        if (el && el.nodeType === 1) {
          res.push(el);
        }
      });
      if (s2) {
        res = res.filter(function(el) {
          return matches.call(el, s2);
        });
      }
      return $3.extend($3.merge($3(), res), { _prevObj: this });
    },
    prev: function(s2) {
      return this._sibling("previousElementSibling", s2);
    },
    next: function(s2) {
      return this._sibling("nextElementSibling", s2);
    },
    prevAll: function(s2) {
      return this._siblingAll("previousElementSibling", s2);
    },
    nextAll: function(s2) {
      return this._siblingAll("nextElementSibling", s2);
    },
    closest: function(s2) {
      let res = [];
      if (this.length === 0) {
        return void 0;
      }
      if (!s2) {
        return this.parent();
      }
      let el = this[0];
      while (el) {
        if (matches.call(el, s2)) {
          res.push(el);
          break;
        }
        el = el.parentElement;
      }
      return $3.extend($3.merge($3(), res.reverse()), { _prevObj: this });
    },
    has: function(selector) {
      let res = [];
      if (this.length === 0) {
        return;
      }
      this.each(function() {
        const el = $3(this);
        const child = el.children(selector);
        if (child.length > 0) {
          res.push(this);
        }
      });
      return $3.extend($3.merge($3(), res), { _prevObj: this });
    },
    back: function(to_start) {
      let ret;
      if (to_start === true) {
        ret = this._prevObj;
        while (ret) {
          if (!ret._prevObj) break;
          ret = ret._prevObj;
        }
      } else {
        ret = this._prevObj ? this._prevObj : this;
      }
      return ret;
    }
  });
  function createScript(script, into = document.body) {
    const s2 = document.createElement("script");
    s2.type = "text/javascript";
    if (not2(script)) return $3(s2);
    const _script = $3(script)[0];
    if (_script.src) {
      s2.src = _script.src;
    } else {
      s2.textContent = _script.innerText;
    }
    if (_script.type) s2.type = _script.type;
    if (_script.async) s2.async = _script.async;
    into.appendChild(s2);
    if (_script.parentNode) _script.parentNode.removeChild(_script);
    return s2;
  }
  $3.extend({
    script: function(el, into) {
      if (not2(el)) {
        return;
      }
      if (el instanceof $3) {
        el = el[0];
      }
      if (el.tagName && el.tagName === "SCRIPT") {
        createScript(el, into);
      } else {
        const scripts = $3(el).find("script");
        $3.each(scripts, function() {
          createScript(this, into);
        });
      }
    },
    loadScript: function(url, into = document.body, callback) {
      const script = document.createElement("script");
      script.type = "text/javascript";
      script.src = url;
      script.onload = callback;
      into.appendChild(script);
    }
  });
  $3.fn.extend({
    script: function(into) {
      return this.each(function() {
        $3.script(this, into);
      });
    }
  });
  $3.fn.extend({
    _prop: function(prop, value) {
      if (arguments.length === 1) {
        return this.length === 0 ? void 0 : this[0][prop];
      }
      if (not2(value)) {
        value = "";
      }
      return this.each(function() {
        const el = this;
        el[prop] = value;
        if (prop === "innerHTML") {
          $3.script(el, el);
        }
      });
    },
    prop: function(prop, value) {
      return arguments.length === 1 ? this._prop(prop) : this._prop(prop, typeof value === "undefined" ? "" : value);
    },
    val: function(value) {
      if (not2(value)) {
        return this.length === 0 ? void 0 : this[0].value;
      }
      return this.each(function() {
        const el = $3(this);
        if (typeof this.value !== "undefined") {
          this.value = value;
        } else {
          el.html(value);
        }
      });
    },
    html: function(value) {
      const that = this, v5 = [];
      if (arguments.length === 0) {
        return this._prop("innerHTML");
      }
      if (value instanceof $3) {
        value.each(function() {
          v5.push($3(this).outerHTML());
        });
      } else {
        v5.push(value);
      }
      that._prop("innerHTML", v5.join("\n"));
      return this;
    },
    outerHTML: function() {
      return this._prop("outerHTML");
    },
    text: function(value) {
      return arguments.length === 0 ? this._prop("textContent") : this._prop("textContent", typeof value === "undefined" ? "" : value);
    },
    innerText: function(value) {
      return arguments.length === 0 ? this._prop("innerText") : this._prop("innerText", typeof value === "undefined" ? "" : value);
    },
    empty: function() {
      return this.each(function() {
        if (typeof this.innerHTML !== "undefined") this.innerHTML = "";
        if (typeof this.value !== "undefined") this.value = "";
      });
    },
    clear: function() {
      return this.empty();
    }
  });
  $3.each = function(ctx, cb) {
    let index = 0;
    if (typeof ctx !== "object") {
      ctx = [];
    }
    if (isArrayLike(ctx)) {
      [].forEach.call(ctx, function(val, key) {
        cb.apply(val, [key, val]);
      });
    } else {
      for (const key in ctx) {
        if (hasProp(ctx, key))
          cb.apply(ctx[key], [key, ctx[key], index++]);
      }
    }
    return ctx;
  };
  $3.fn.extend({
    each: function(cb) {
      return $3.each(this, cb);
    }
  });
  var Data = function(ns) {
    this.expando = "DATASET:UID:" + ns.toUpperCase();
    Data.uid++;
  };
  Data.uid = -1;
  Data.prototype = {
    cache: function(owner) {
      let value = owner[this.expando];
      if (!value) {
        value = {};
        if (acceptData(owner)) {
          if (owner.nodeType) {
            owner[this.expando] = value;
          } else {
            Object.defineProperty(owner, this.expando, {
              value,
              configurable: true
            });
          }
        }
      }
      return value;
    },
    set: function(owner, data, value) {
      let prop, cache = this.cache(owner);
      if (typeof data === "string") {
        cache[camelCase(data)] = value;
      } else {
        for (prop in data) {
          if (hasProp(data, prop))
            cache[camelCase(prop)] = data[prop];
        }
      }
      return cache;
    },
    get: function(owner, key) {
      let value = key === void 0 ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)];
      if (key) {
        return value !== void 0 ? value : owner.getAttribute && owner.getAttribute("data-" + dashedName(key)) || void 0;
      }
      value = { ...owner[this.expando] };
      for (const attr of owner.attributes) {
        if (attr.name.startsWith("data-")) {
          const name2 = attr.name.slice(5);
          value[camelCase(name2)] = attr.value;
        }
      }
      return isEmptyObject(value) ? void 0 : value;
    },
    access: function(owner, key, value) {
      if (key === void 0 || key && typeof key === "string" && value === void 0) {
        return this.get(owner, key);
      }
      this.set(owner, key, value);
      return value !== void 0 ? value : key;
    },
    remove: function(owner, key) {
      let cache = owner[this.expando];
      if (cache === void 0) {
        return;
      }
      if (key !== void 0) {
        const _keys = Array.isArray(key) ? key : [key];
        for (const k5 of _keys) {
          delete cache[camelCase(k5)];
          owner.removeAttribute && owner.removeAttribute("data-" + k5);
        }
      }
      if (key === void 0 || isEmptyObject(cache)) {
        if (owner.nodeType) {
          owner[this.expando] = void 0;
        } else {
          delete owner[this.expando];
        }
      }
      return true;
    },
    hasData: function(owner) {
      const cache = owner[this.expando];
      return cache !== void 0 && !isEmptyObject(cache);
    }
  };
  var dataSet = new Data("dom");
  $3.extend({
    hasData: function(elem) {
      return dataSet.hasData(elem);
    },
    data: function(elem, key, val) {
      return dataSet.access(elem, key, val);
    },
    removeData: function(elem, key) {
      return dataSet.remove(elem, key);
    },
    dataSet: function(ns) {
      if (not2(ns)) return dataSet;
      if (["INTERNAL", "DOM"].indexOf(ns.toUpperCase()) > -1) {
        throw Error("You can not use reserved name for your dataset");
      }
      return new Data(ns);
    }
  });
  $3.fn.extend({
    data: function(key, val) {
      let res, elem, data;
      if (this.length === 0) {
        return;
      }
      elem = this[0];
      if (arguments.length === 0) {
        if (elem) {
          data = dataSet.get(elem);
          if (elem.nodeType === 1) {
            for (const a2 of elem.attributes) {
              if (a2.name.startsWith("data-")) {
                const name2 = a2.name.slice(5);
                data[camelCase(name2)] = a2.value;
              }
            }
          }
        }
        return data;
      }
      if (arguments.length === 1 && (typeof key === "string" || Array.isArray(key))) {
        res = dataSet.get(elem, key);
        return safeJsonParse(res);
      }
      return this.each(function() {
        dataSet.set(this, key, val);
      });
    },
    removeData: function(key) {
      if (typeof key === "undefined") {
        return this;
      }
      return this.each(function() {
        const keys = Array.isArray(key) ? key : key.split(" ").map((el) => el.trim()).filter((el) => el !== "");
        for (const k5 of keys) {
          dataSet.remove(this, k5);
        }
      });
    },
    origin: function(name2, value, def) {
      if (this.length === 0) {
        return this;
      }
      if (not2(name2) && not2(value)) {
        return $3.data(this[0]);
      }
      if (not2(value)) {
        const res = $3.data(this[0], "origin-" + name2);
        return !not2(res) ? res : def;
      }
      this.data("origin-" + name2, value);
      return this;
    }
  });
  $3.extend({
    device: /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(navigator.userAgent.toLowerCase()),
    localhost: isLocalhost(),
    isLocalhost,
    touchable: isTouch(),
    isPrivateAddress,
    hashCode: function(str2) {
      let hash = 0, i3, chr;
      if (str2.length === 0) return hash;
      for (i3 = 0; i3 < str2.length; i3++) {
        chr = str2.charCodeAt(i3);
        hash = (hash << 5) - hash + chr;
        hash |= 0;
      }
      return hash;
    },
    uniqueId: function(salt = "salt") {
      let name2;
      if (typeof salt === "function") {
        name2 = salt.name;
      } else if (typeof salt === "string" && salt) {
        name2 = salt;
      } else if (typeof salt === "string" && salt.length === 0) {
        name2 = "salt";
      } else {
        name2 = salt.toString();
      }
      return "dom-" + $3.hashCode(name2);
    },
    toArray: function(n3) {
      let i3, out = [];
      for (i3 = 0; i3 < n3.length; i3++) {
        out.push(n3[i3]);
      }
      return out;
    },
    import: function(ctx) {
      const res = [];
      this.each(ctx, function() {
        res.push(this);
      });
      return this.merge($3(), res);
    },
    merge: function(first, second) {
      let len = +second.length, j5 = 0, i3 = first.length;
      for (; j5 < len; j5++) {
        first[i3++] = second[j5];
      }
      first.length = i3;
      return first;
    },
    type: function(obj) {
      return Object.prototype.toString.call(obj).replace(/^\[object (.+)]$/, "$1").toLowerCase();
    },
    isSelector: function(selector) {
      if (typeof selector !== "string" || selector.length === 0 || selector === "#" || selector === ".") {
        return false;
      }
      try {
        document.querySelector(selector);
        return true;
      } catch (error) {
        return false;
      }
    },
    remove: function(s2) {
      return $3(s2).remove();
    },
    isPlainObject,
    isEmptyObject,
    isArrayLike,
    acceptData,
    not: not2,
    parseUnit,
    getUnit,
    unit: parseUnit,
    isVisible,
    isHidden,
    matches: function(el, s2) {
      return matches.call(el, s2);
    },
    random: function(from, to2) {
      if (arguments.length === 1 && isArrayLike(from)) {
        return from[Math.floor(Math.random() * from.length)];
      }
      return Math.floor(Math.random() * (to2 - from + 1) + from);
    },
    hasProp,
    dark: globalThis.matchMedia && globalThis.matchMedia("(prefers-color-scheme: dark)").matches,
    serializeToArray: function(form) {
      const _form = $3(form)[0];
      if (!_form || _form.nodeName !== "FORM") {
        console.warn("Element is not a HTMLFromElement");
        return;
      }
      let i3, j5, q5 = [];
      for (i3 = _form.elements.length - 1; i3 >= 0; i3 = i3 - 1) {
        if (_form.elements[i3].name === "") {
          continue;
        }
        switch (_form.elements[i3].nodeName) {
          case "INPUT":
            switch (_form.elements[i3].type) {
              case "checkbox":
              case "radio":
                if (_form.elements[i3].checked) {
                  q5.push(_form.elements[i3].name + "=" + encodeURIComponent(_form.elements[i3].value));
                }
                break;
              case "file":
                break;
              default:
                q5.push(_form.elements[i3].name + "=" + encodeURIComponent(_form.elements[i3].value));
            }
            break;
          case "TEXTAREA":
            q5.push(_form.elements[i3].name + "=" + encodeURIComponent(_form.elements[i3].value));
            break;
          case "SELECT":
            switch (_form.elements[i3].type) {
              case "select-one":
                q5.push(_form.elements[i3].name + "=" + encodeURIComponent(_form.elements[i3].value));
                break;
              case "select-multiple":
                for (j5 = _form.elements[i3].options.length - 1; j5 >= 0; j5 = j5 - 1) {
                  if (_form.elements[i3].options[j5].selected) {
                    q5.push(_form.elements[i3].name + "=" + encodeURIComponent(_form.elements[i3].options[j5].value));
                  }
                }
                break;
            }
            break;
          case "BUTTON":
            switch (_form.elements[i3].type) {
              case "reset":
              case "submit":
              case "button":
                q5.push(_form.elements[i3].name + "=" + encodeURIComponent(_form.elements[i3].value));
                break;
            }
            break;
        }
      }
      return q5;
    },
    serialize: function(form) {
      return $3.serializeToArray(form).join("&");
    },
    viewport: function() {
      const w6 = window, d4 = document, e2 = d4.documentElement, g5 = d4.getElementsByTagName("body")[0], x5 = w6.innerWidth || e2.clientWidth || g5.clientWidth, y4 = w6.innerHeight || e2.clientHeight || g5.clientHeight;
      return { width: x5, height: y4 };
    }
  });
  $3.fn.extend({
    items: function() {
      return $3.toArray(this);
    }
  });
  var overriddenStop = Event.prototype.stopPropagation;
  var overriddenPrevent = Event.prototype.preventDefault;
  Event.prototype.stopPropagation = function() {
    this.isPropagationStopped = true;
    overriddenStop.apply(this, arguments);
  };
  Event.prototype.preventDefault = function() {
    this.isPreventedDefault = true;
    overriddenPrevent.apply(this, arguments);
  };
  Event.prototype.stop = function(immediate) {
    return immediate ? this.stopImmediatePropagation() : this.stopPropagation();
  };
  $3.extend({
    events: [],
    eventHooks: {},
    eventUID: -1,
    /*
    * el, eventName, handler, selector, ns, id, options
    * */
    setEventHandler: function(obj) {
      let i3, freeIndex = -1, eventObj, resultIndex;
      if (this.events.length > 0) {
        for (i3 = 0; i3 < this.events.length; i3++) {
          if (this.events[i3].handler === null) {
            freeIndex = i3;
            break;
          }
        }
      }
      eventObj = {
        element: obj.el,
        event: obj.event,
        handler: obj.handler,
        selector: obj.selector,
        ns: obj.ns,
        id: obj.id,
        options: obj.options
      };
      if (freeIndex === -1) {
        this.events.push(eventObj);
        resultIndex = this.events.length - 1;
      } else {
        this.events[freeIndex] = eventObj;
        resultIndex = freeIndex;
      }
      return resultIndex;
    },
    getEventHandler: function(index) {
      if (this.events[index] !== void 0 && this.events[index] !== null) {
        this.events[index] = null;
        return this.events[index].handler;
      }
      return void 0;
    },
    off: function() {
      $3.each(this.events, function() {
        this.element.removeEventListener(this.event, this.handler, true);
      });
      this.events = [];
      return this;
    },
    getEvents: function() {
      return this.events;
    },
    getEventHooks: function() {
      return this.eventHooks;
    },
    addEventHook: function(event, handler, type = "before") {
      $3.each(str2arr(event), (_5, eventName) => {
        const key = camelCase(`${type}-${eventName}`);
        this.eventHooks[key] = handler;
      });
      return this;
    },
    removeEventHook: function(event, type = "before") {
      $3.each(str2arr(event), (_5, eventName) => {
        delete this.eventHooks[camelCase(`${type}-${eventName}`)];
      });
      return this;
    },
    removeEventHooks: function(event) {
      const that = this;
      if (not2(event)) {
        this.eventHooks = {};
      } else {
        $3.each(str2arr(event), function() {
          delete that.eventHooks[camelCase("before-" + this)];
          delete that.eventHooks[camelCase("after-" + this)];
        });
      }
      return this;
    }
  });
  $3.fn.extend({
    on: function(eventsList, sel, handler, options) {
      if (this.length === 0) {
        return;
      }
      if (typeof sel === "function") {
        options = handler || {};
        handler = sel;
        sel = void 0;
      }
      if (typeof options !== "object") {
        options = {};
      }
      return this.each(function(_5, el) {
        $3.each(str2arr(eventsList), (_22, ev) => {
          let h3, event = ev.split("."), name2 = normName(event[0]), ns = options.ns ? options.ns : event[1], index, originEvent;
          $3.eventUID++;
          h3 = (e2) => {
            let target = e2.target;
            const beforeHook = $3.eventHooks[camelCase("before-" + name2)];
            const afterHook = $3.eventHooks[camelCase("after-" + name2)];
            if (typeof beforeHook === "function") {
              beforeHook.call(target, e2);
            }
            if (!sel) {
              handler.call(el, e2);
            } else {
              while (target && target !== el) {
                if (matches.call(target, sel)) {
                  handler.call(target, e2);
                  if (e2.isPropagationStopped) {
                    e2.stopImmediatePropagation();
                    break;
                  }
                }
                target = target.parentNode;
              }
            }
            if (typeof afterHook === "function") {
              afterHook.call(target, e2);
            }
            if (options.once) {
              index = +$3(el).origin("event-" + e2.type + (sel ? ":" + sel : "") + (ns ? ":" + ns : ""));
              if (!isNaN(index)) $3.events.splice(index, 1);
            }
          };
          Object.defineProperty(h3, "name", {
            value: handler.name && handler.name !== "" ? handler.name : "func_event_" + name2 + "_" + $3.eventUID
          });
          originEvent = name2 + (sel ? ":" + sel : "") + (ns ? ":" + ns : "");
          el.addEventListener(name2, h3, !isEmptyObject(options) ? options : false);
          index = $3.setEventHandler({
            el,
            event: name2,
            handler: h3,
            selector: sel,
            ns,
            id: $3.eventUID,
            options: !isEmptyObject(options) ? options : false
          });
          $3(el).origin("event-" + originEvent, index);
        });
      });
    },
    one: function(events, sel, handler, options = {}) {
      if (typeof sel === "function") {
        options = handler || {};
        handler = sel;
        sel = void 0;
      }
      options.once = true;
      return this.on.apply(this, [events, sel, handler, options]);
    },
    off: function(eventsList, sel, options) {
      if (isPlainObject(sel)) {
        options = sel;
        sel = null;
      }
      if (!isPlainObject(options)) {
        options = {};
      }
      if (not2(eventsList) || eventsList.toLowerCase() === "all") {
        return this.each(function() {
          const el = this;
          $3.each($3.events, function() {
            const e2 = this;
            if (e2.element === el) {
              el.removeEventListener(e2.event, e2.handler, e2.options);
              e2.handler = null;
              $3(el).origin("event-" + name + (e2.selector ? ":" + e2.selector : "") + (e2.ns ? ":" + e2.ns : ""), null);
            }
          });
        });
      }
      return this.each(function() {
        const el = this;
        $3.each(str2arr(eventsList), function() {
          let evMap = this.split("."), name2 = normName(evMap[0]), ns = options.ns ? options.ns : evMap[1], originEvent, index;
          originEvent = "event-" + name2 + (sel ? ":" + sel : "") + (ns ? ":" + ns : "");
          index = $3(el).origin(originEvent);
          if (index !== void 0 && $3.events[index].handler) {
            el.removeEventListener(name2, $3.events[index].handler, $3.events[index].options);
            $3.events[index].handler = null;
          }
          $3(el).origin(originEvent, null);
        });
      });
    },
    trigger: function(name2, data) {
      return this.fire(name2, data);
    },
    fire: function(name2, data) {
      let _name, e2;
      if (this.length === 0) {
        return;
      }
      _name = normName(name2);
      if (["focus", "blur"].indexOf(_name) > -1) {
        this[0][_name]();
        return this;
      }
      e2 = new CustomEvent(_name, {
        bubbles: true,
        cancelable: true,
        detail: data
      });
      return this.each(function() {
        this.dispatchEvent(e2);
      });
    }
  });
  "blur focus resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu touchstart touchend touchmove touchcancel".split(" ").forEach(
    function(name2) {
      $3.fn[name2] = function(sel, fn, opt2) {
        return arguments.length > 0 ? this.on(name2, sel, fn, opt2) : this.fire(name2);
      };
    }
  );
  $3.fn.extend({
    hover: function(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }
  });
  $3.ready = function(fn, options) {
    document.addEventListener("DOMContentLoaded", fn, options || false);
  };
  $3.load = function(fn) {
    return $3(window).on("load", fn);
  };
  $3.unload = function(fn) {
    return $3(window).on("unload", fn);
  };
  $3.fn.extend({
    unload: function(fn) {
      return this.length === 0 || this[0].self !== window ? void 0 : $3.unload(fn);
    }
  });
  $3.beforeunload = function(fn) {
    if (typeof fn === "string") {
      return $3(window).on("beforeunload", function(e2) {
        e2.returnValue = fn;
        return fn;
      });
    } else {
      return $3(window).on("beforeunload", fn);
    }
  };
  $3.fn.extend({
    beforeunload: function(fn) {
      return this.length === 0 || this[0].self !== window ? void 0 : $3.beforeunload(fn);
    }
  });
  $3.fn.extend({
    ready: function(fn) {
      if (this.length && this[0] === document && typeof fn === "function") {
        return $3.ready(fn);
      }
    }
  });
  $3.ajax = function(p5) {
    return new Promise(function(resolve, reject) {
      const xhr = new XMLHttpRequest();
      let method = (p5.method || "GET").toUpperCase();
      const headers = [];
      const async = not2(p5.async) ? true : p5.async;
      let url = p5.url;
      let data;
      const exec = function(fn, params) {
        if (typeof fn === "function") {
          fn.apply(null, params);
        }
      };
      const isGet = function(method2) {
        return ["GET", "JSON"].indexOf(method2) !== -1;
      };
      const plainObjectToData = function(obj) {
        const _data = [];
        $3.each(obj, function(k5, v5) {
          const _v = isSimple(v5) ? v5 : JSON.stringify(v5);
          _data.push(k5 + "=" + _v);
        });
        return _data.join("&");
      };
      if (p5.data instanceof HTMLFormElement) {
        let _action = p5.data.getAttribute("action").trim();
        let _method = p5.data.getAttribute("method").trim();
        if (not2(url) && _action) {
          url = _action;
        }
        if (_method) {
          method = _method.toUpperCase();
        }
      }
      if (p5.timeout) {
        xhr.timeout = p5.timeout;
      }
      if (p5.withCredentials) {
        xhr.withCredentials = p5.withCredentials;
      }
      if (p5.data instanceof HTMLFormElement) {
        data = $3.serialize(p5.data);
      } else if (p5.data instanceof HTMLElement && p5.data.getAttribute("type") && p5.data.getAttribute("type").toLowerCase() === "file") {
        const _name = p5.data.getAttribute("name");
        data = new FormData();
        for (let i3 = 0; i3 < p5.data.files.length; i3++) {
          data.append(_name, p5.data.files[i3]);
        }
      } else if (isPlainObject(p5.data)) {
        data = plainObjectToData(p5.data);
      } else if (p5.data instanceof FormData) {
        data = p5.data;
      } else if (typeof p5.data === "string") {
        data = p5.data;
      } else {
        data = new FormData();
        data.append("_data", JSON.stringify(p5.data));
      }
      if (isGet(method)) {
        url += typeof data === "string" ? "?" + data : isEmptyObject(data) ? "" : "?" + JSON.stringify(data);
      }
      xhr.open(method, url, async, p5.user, p5.password);
      if (p5.headers) {
        $3.each(p5.headers, function(k5, v5) {
          xhr.setRequestHeader(k5, v5);
          headers.push(k5);
        });
      }
      if (!isGet(method)) {
        if (headers.indexOf("Content-type") === -1 && p5.contentType !== false) {
          xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        }
      }
      xhr.send(data);
      xhr.addEventListener("load", function(e2) {
        if (xhr.readyState === 4 && xhr.status < 300) {
          let _return = p5.returnValue && p5.returnValue === "xhr" ? xhr : xhr.response;
          if (p5.parseJson) {
            try {
              _return = JSON.parse(_return);
            } catch (ex) {
              _return = {};
            }
          }
          exec(resolve, [_return]);
          exec(p5.onSuccess, [e2, xhr]);
        } else {
          exec(reject, [xhr]);
          exec(p5.onFail, [e2, xhr]);
        }
        exec(p5.onLoad, [e2, xhr]);
      });
      $3.each(["readystatechange", "error", "timeout", "progress", "loadstart", "loadend", "abort"], function() {
        const ev = camelCase("on-" + (this === "readystatechange" ? "state" : this));
        xhr.addEventListener(ev, function(e2) {
          exec(p5[ev], [e2, xhr]);
        });
      });
    });
  };
  ["GET", "POST", "PUT", "PATCH", "DELETE", "JSON"].forEach(function(method) {
    $3[method.toLowerCase()] = function(url, data, options) {
      const _options = {
        method: method === "JSON" ? "GET" : method,
        url,
        data,
        parseJson: method === "JSON"
      };
      return $3.ajax($3.extend({}, _options, options));
    };
  });
  $3.fn.extend({
    load: function(url, data, options) {
      const that = this;
      if (this.length && this[0].self === window) {
        return $3.load(url);
      }
      return $3.get(url, data, options).then(function(data2) {
        that.each(function() {
          this.innerHTML = data2;
        });
      });
    }
  });
  $3.fn.extend({
    style: function(name2, pseudo) {
      let el;
      function _getStyle2(el2, prop, pseudo2) {
        return ["scrollLeft", "scrollTop"].includes(prop) ? $3(el2)[prop]() : getComputedStyle(el2, pseudo2)[prop];
      }
      if (typeof name2 === "string" && this.length === 0) {
        return void 0;
      }
      if (this.length === 0) {
        return this;
      }
      el = this[0];
      if (!name2 || name2 === "all") {
        return getComputedStyle(el, pseudo);
      } else {
        let result = {};
        let names = name2.split(", ").map(function(el2) {
          return ("" + camelCase(el2)).trim();
        });
        if (names.length === 1) {
          return _getStyle2(el, names[0], pseudo);
        } else {
          $3.each(names, function() {
            const prop = this;
            result[this] = _getStyle2(el, prop, pseudo);
          });
          return result;
        }
      }
    },
    removeStyleProperty: function(name2) {
      if (not2(name2) || this.length === 0) return this;
      const names = name2.split(", ").map(function(el) {
        return ("" + el).trim();
      });
      return this.each(function() {
        const el = this;
        $3.each(names, function() {
          el.style.removeProperty(this);
        });
      });
    },
    removeStyle: function(name2) {
      if (!name2) return this;
      const names = str2arr(name2, ", ");
      return this.each(function() {
        const el = this;
        $3.each(names, function() {
          el.style[this] = "";
        });
      });
    },
    css: function(key, val) {
      key = key || "all";
      if (typeof key === "string" && not2(val)) {
        return this.style(key);
      }
      return this.each(function(_5, el) {
        if (typeof key === "object") {
          $3.each(key, function(key2, val2) {
            setStyleProp(el, key2, val2);
          });
        } else if (typeof key === "string") {
          setStyleProp(el, key, val);
        }
      });
    },
    cssVar: function(name2, val) {
      if (not2(name2)) return void 0;
      if (not2(val)) {
        return getComputedStyle(this[0]).getPropertyValue("--" + name2);
      } else {
        return this.each(function() {
          this.style.setProperty("--" + name2, val);
        });
      }
    }
  });
  $3.fn.extend({
    addClass: function() {
    },
    removeClass: function() {
    },
    toggleClass: function() {
    },
    containsClass: function(cls) {
      return this.hasClass(cls);
    },
    hasClass: function(cls) {
      if (not2(cls)) {
        return false;
      }
      let result = false;
      const classes = cls.split(" ").filter((v5) => ("" + v5).trim() !== "");
      this.each(function() {
        const el = this;
        $3.each(classes, function() {
          if (!result && el.classList && el.classList.contains(this)) {
            result = true;
          }
        });
      });
      return result;
    },
    clearClasses: function() {
      return this.each(function() {
        this.className = "";
      });
    },
    cls: function(array = false) {
      return this.length === 0 ? void 0 : array ? this[0].className.split(" ") : this[0].className;
    },
    removeClassBy: function(mask) {
      return this.each(function() {
        const el = $3(this);
        const classes = el.cls(true);
        $3.each(classes, function() {
          const elClass = this;
          if (elClass.indexOf(mask) > -1) {
            el.removeClass(elClass);
          }
        });
      });
    },
    classNames: function() {
      const args = Array.prototype.slice.call(arguments, 0);
      const classes = [];
      $3.each(args, function(_5, a2) {
        if (typeof a2 === "string") {
          classes.push(a2);
        } else if (isPlainObject(a2)) {
          $3.each(a2, function(k5, v5) {
            if (v5) {
              classes.push(k5);
            }
          });
        } else {
          nothing();
        }
      });
      return this.each(function() {
        this.className += " " + classes.join(" ");
      });
    }
  });
  ["add", "remove", "toggle"].forEach(function(method) {
    $3.fn[method + "Class"] = function(cls) {
      const _classes = !cls ? [] : Array.isArray(cls) ? cls : cls.split(" ").filter(function(v5) {
        return !!v5;
      });
      if (!_classes.length) return this;
      return this.each(function() {
        const el = this;
        const hasClassList = typeof el.classList !== "undefined";
        if (hasClassList) {
          $3.each(_classes, function(_5, v5) {
            el.classList[method](v5);
          });
        } else {
          el.className += _classes.join(" ");
        }
      });
    };
  });
  $3.parseHTML = function(data) {
    let base, singleTag, result = [], ctx, _context;
    const regexpSingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    if (typeof data !== "string" || data.trim() === "") {
      return [];
    }
    data = data.trim();
    singleTag = regexpSingleTag.exec(data);
    if (singleTag) {
      result.push(document.createElement(singleTag[1]));
    } else {
      if ($3.isSelector(data)) {
        const elements = document.querySelectorAll(data);
        if (elements.length) {
          for (const el of elements) {
            result.push(el);
          }
        }
        if (result.length === 0) {
          result.push(document.createTextNode(data));
        }
        return result;
      }
      ctx = document.implementation.createHTMLDocument("");
      base = ctx.createElement("base");
      base.href = document.location.href;
      ctx.head.appendChild(base);
      _context = ctx.body;
      _context.innerHTML = data;
      for (let i3 = 0; i3 < _context.childNodes.length; i3++) {
        result.push(_context.childNodes[i3].cloneNode(true));
      }
    }
    return result;
  };
  $3.fn.extend({
    _size: function(prop, val) {
      if (this.length === 0) return;
      if (not2(val)) {
        const el = this[0];
        if (prop === "height") {
          return el === window ? window.innerHeight : el === document ? el.body.clientHeight : parseInt(getComputedStyle(el).height);
        }
        if (prop === "width") {
          return el === window ? window.innerWidth : el === document ? el.body.clientWidth : parseInt(getComputedStyle(el).width);
        }
      }
      return this.each(function() {
        const el = this;
        if (el === window || el === document) {
          return;
        }
        el.style[prop] = isNaN(val) ? val : +val === 0 ? 0 : val + "px";
      });
    },
    height: function(val) {
      return this._size("height", val);
    },
    width: function(val) {
      return this._size("width", val);
    },
    _sizeOut: function(prop, val) {
      let el, size, style, result;
      if (this.length === 0) {
        return;
      }
      const setter = typeof val === "number";
      if (setter) {
        return this.each(function() {
          const el2 = this;
          if (el2 === window || el2 === document) {
            return;
          }
          let h3, style2 = getComputedStyle(el2), bs = prop === "width" ? parseInt(style2["borderLeftWidth"]) + parseInt(style2["borderRightWidth"]) : parseInt(style2["borderTopWidth"]) + parseInt(style2["borderBottomWidth"]), pa = prop === "width" ? parseInt(style2["paddingLeft"]) + parseInt(style2["paddingRight"]) : parseInt(style2["paddingTop"]) + parseInt(style2["paddingBottom"]);
          h3 = $3(this)[prop](val)[prop]() - bs - pa;
          el2.style[prop] = h3 + "px";
        });
      }
      const includeMargin = val === true;
      el = this[0];
      size = el[prop === "width" ? "offsetWidth" : "offsetHeight"];
      style = getComputedStyle(el);
      result = size + parseInt(style[prop === "width" ? "marginLeft" : "marginTop"]) + parseInt(style[prop === "width" ? "marginRight" : "marginBottom"]);
      return includeMargin ? result : size;
    },
    outerWidth: function(val) {
      return this._sizeOut("width", val);
    },
    outerHeight: function(val) {
      return this._sizeOut("height", val);
    },
    padding: function(p5) {
      if (this.length === 0) return;
      const s2 = getComputedStyle(this[0], p5);
      return {
        top: parseInt(s2["paddingTop"]),
        right: parseInt(s2["paddingRight"]),
        bottom: parseInt(s2["paddingBottom"]),
        left: parseInt(s2["paddingLeft"])
      };
    },
    margin: function(p5) {
      if (this.length === 0) return;
      const s2 = getComputedStyle(this[0], p5);
      return {
        top: parseInt(s2["marginTop"]),
        right: parseInt(s2["marginRight"]),
        bottom: parseInt(s2["marginBottom"]),
        left: parseInt(s2["marginLeft"])
      };
    },
    border: function(p5) {
      if (this.length === 0) return;
      const s2 = getComputedStyle(this[0], p5);
      return {
        top: parseInt(s2["borderTopWidth"]),
        right: parseInt(s2["borderRightWidth"]),
        bottom: parseInt(s2["borderBottomWidth"]),
        left: parseInt(s2["borderLeftWidth"])
      };
    }
  });
  $3.fn.extend({
    offset: function(val) {
      if (val === void 0) {
        if (this.length === 0) return void 0;
        let rect = this[0].getBoundingClientRect();
        return {
          top: rect.top + (window.scrollY || window.pageYOffset || document.documentElement.scrollTop || 0),
          left: rect.left + (window.scrollX || window.pageXOffset || document.documentElement.scrollLeft || 0)
        };
      }
      return this.each(function() {
        let { top, left } = val;
        let el = $3(this), position = getComputedStyle(this).position;
        let currentRect = this.getBoundingClientRect();
        let currentOffset = {
          top: currentRect.top + (window.scrollY || window.pageYOffset || 0),
          left: currentRect.left + (window.scrollX || window.pageXOffset || 0)
        };
        if (position === "static") {
          el.css("position", "relative");
        }
        if (["absolute", "fixed"].indexOf(position) === -1) {
          top = top - currentOffset.top;
          left = left - currentOffset.left;
        }
        if (top) el.css("top", top);
        if (left) el.css("left", left);
      });
    },
    position: function(margin = false) {
      let ml = 0, mt3 = 0, el, style;
      if (this.length === 0) {
        return void 0;
      }
      el = this[0];
      style = getComputedStyle(el);
      if (margin) {
        ml = parseInt(style["marginLeft"]);
        mt3 = parseInt(style["marginTop"]);
      }
      return {
        left: el.offsetLeft - ml,
        top: el.offsetTop - mt3
      };
    },
    left: function(val, margin) {
      if (this.length === 0) return;
      if (not2(val)) {
        return this.position(margin).left;
      }
      if (typeof val === "boolean") {
        margin = val;
        return this.position(margin).left;
      }
      return this.each(function() {
        $3(this).css({
          left: val
        });
      });
    },
    top: function(val, margin = false) {
      if (this.length === 0) return;
      if (not2(val)) {
        return this.position(margin).top;
      }
      if (typeof val === "boolean") {
        margin = val;
        return this.position(margin).top;
      }
      return this.each(function() {
        $3(this).css({
          top: val
        });
      });
    },
    rect: function() {
      return this.length === 0 ? void 0 : this[0].getBoundingClientRect();
    },
    pos: function() {
      if (this.length === 0) return;
      const el = $3(this[0]);
      return {
        top: parseInt(el.style("top")),
        left: parseInt(el.style("left"))
      };
    }
  });
  $3.fn.extend({
    attr: function(name2, val) {
      const attributes = {};
      if (this.length === 0 && arguments.length === 0) {
        return void 0;
      }
      if (this.length && arguments.length === 0) {
        $3.each(this[0].attributes, function() {
          attributes[this.name] = this.value;
        });
        return attributes;
      }
      if (arguments.length === 1 && typeof name2 === "string") {
        return this.length && this[0].nodeType === 1 && this[0].hasAttribute(name2) ? this[0].getAttribute(name2) : void 0;
      }
      return this.each(function() {
        const el = this;
        if (isPlainObject(name2)) {
          $3.each(name2, function(k5, v5) {
            el.setAttribute(k5, v5);
          });
        } else {
          el.setAttribute(name2, val);
        }
      });
    },
    removeAttr: function(name2) {
      let attributes;
      if (!name2) {
        return this.each(function(_5, el) {
          const attributes2 = $3(el).attr();
          $3.each(attributes2, function(k5) {
            el.removeAttribute(k5);
          });
        });
      }
      attributes = typeof name2 === "string" ? name2.split(",").map(function(el) {
        return el.trim();
      }) : name2;
      return this.each(function() {
        const el = this;
        $3.each(attributes, function() {
          if (el.hasAttribute(this)) el.removeAttribute(this);
        });
      });
    },
    toggleAttr: function(name2, val) {
      return this.each(function() {
        const el = this;
        if (not2(val)) {
          el.removeAttribute(name2);
        } else {
          el.setAttribute(name2, val);
        }
      });
    },
    id: function(val) {
      if (typeof val === "undefined") {
        return this.length === 1 ? $3(this[0]).attr("id") : this.map((el) => $3(el).attr("id"));
      }
      return this.each(function() {
        $3(this).attr("id", val);
      });
    },
    title: function(val) {
      if (typeof val === "undefined") {
        return this.length ? $3(this[0]).attr("title") : void 0;
      }
      return this.each(function() {
        $3(this).attr("title", val);
      });
    },
    href: function(val) {
      if (typeof val === "undefined") {
        return this.length ? this[0].tagName === "A" ? this[0].href : void 0 : void 0;
      }
      return this.each(function() {
        if (this.tagName === "A") {
          this.href = val;
        }
      });
    },
    name: function(val) {
      if (typeof val === "undefined") {
        return this.length ? this[0].name ? this[0].name : void 0 : void 0;
      }
      return this.each(function() {
        if (this.name) {
          this.name = val;
        }
      });
    },
    src: function(val) {
      if (typeof val === "undefined") {
        return this.length ? this[0].src ? this[0].src : void 0 : void 0;
      }
      return this.each(function() {
        if (this.src) {
          this.src = val;
        }
      });
    }
  });
  $3.extend({
    meta: function(name2) {
      return not2(name2) ? $3("meta") : $3("meta[name='$name']".replace("$name", name2));
    },
    metaBy: function(name2) {
      return not2(name2) ? $3("meta") : $3("meta[$name]".replace("$name", name2));
    },
    doctype: function() {
      return $3("doctype");
    },
    html: function() {
      return $3("html");
    },
    head: function() {
      return $3("html").find("head");
    },
    body: function() {
      return $3("body");
    },
    document: function() {
      return $3(document);
    },
    window: function() {
      return $3(window);
    },
    charset: function(val) {
      if (val) {
        const m5 = $3("meta[charset]");
        if (m5.length > 0) {
          m5.attr("charset", val);
        }
      }
      return document.characterSet;
    },
    lang: function(val) {
      if (val) {
        const h3 = $3("html");
        if (h3.length > 0) {
          h3.attr("lang", val);
        }
      }
      return document.documentElement.lang;
    },
    title: function(val) {
      if (typeof val === "undefined") {
        return document.title;
      }
      document.title = val;
    }
  });
  $3.extend({
    bind: (fn, ctx) => fn.bind(ctx)
  });
  (function(arr) {
    arr.forEach(function(item) {
      ["append", "prepend"].forEach(function(where) {
        if (hasProp(item, where)) {
          return;
        }
        Object.defineProperty(item, where, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: function() {
            const argArr = Array.prototype.slice.call(arguments), docFrag = document.createDocumentFragment();
            argArr.forEach(function(argItem) {
              const isNode = argItem instanceof Node;
              docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
            });
            if (where === "prepend")
              this.insertBefore(docFrag, this.firstChild);
            else
              this.appendChild(docFrag);
          }
        });
      });
    });
  })([Element.prototype, Document.prototype, DocumentFragment.prototype]);
  var normalizeElements = function(s2) {
    let result;
    if (typeof s2 === "string") result = $3.isSelector(s2) ? $3(s2) : $3.parseHTML(s2);
    else if (s2 instanceof HTMLElement) result = [s2];
    else if (isArrayLike(s2)) result = s2;
    return result;
  };
  $3.fn.extend({
    appendText: function(text) {
      return this.each(function(elIndex, el) {
        el.innerHTML += text;
      });
    },
    prependText: function(text) {
      return this.each(function(elIndex, el) {
        el.innerHTML = text + el.innerHTML;
      });
    },
    append: function(elements) {
      const _elements = normalizeElements(elements);
      return this.each(function(elIndex, el) {
        $3.each(_elements, function() {
          if (el === this) return;
          const child = elIndex === 0 ? this : this.cloneNode(true);
          if (child.tagName && child.tagName === "SCRIPT") {
            $3.script(child, el);
          } else {
            el.append(child);
          }
        });
      });
    },
    appendTo: function(elements) {
      const _elements = normalizeElements(elements);
      return this.each(function(_5, el) {
        $3.each(_elements, function(parIndex, parent2) {
          if (el === this) return;
          parent2.append(parIndex === 0 ? el : el.cloneNode(true));
        });
      });
    },
    prepend: function(elements) {
      const _elements = normalizeElements(elements);
      return this.each(function(elIndex, el) {
        $3.each(_elements, function() {
          if (el === this) return;
          const child = elIndex === 0 ? this : this.cloneNode(true);
          $3.script(child);
          if (child.tagName && child.tagName !== "SCRIPT") el.prepend(child);
        });
      });
    },
    prependTo: function(elements) {
      const _elements = normalizeElements(elements);
      return this.each(function() {
        const el = this;
        $3.each(_elements, function(parIndex, parent2) {
          if (el === this) return;
          $3(parent2).prepend(parIndex === 0 ? el : el.cloneNode(true));
        });
      });
    },
    insertBefore: function(elements) {
      const _elements = normalizeElements(elements);
      return this.each(function() {
        const el = this;
        $3.each(_elements, function(elIndex) {
          if (el === this) return;
          const parent2 = this.parentNode;
          if (parent2) {
            parent2.insertBefore(elIndex === 0 ? el : el.cloneNode(true), this);
          }
        });
      });
    },
    insertAfter: function(elements) {
      const _elements = normalizeElements(elements);
      return this.each(function() {
        const el = this;
        $3.each(_elements, function(elIndex, element2) {
          if (el === this) return;
          const parent2 = this.parentNode;
          if (parent2) {
            parent2.insertBefore(elIndex === 0 ? el : el.cloneNode(true), element2.nextSibling);
          }
        });
      });
    },
    after: function(html) {
      return this.each(function() {
        const el = this;
        if (typeof html === "string") {
          el.insertAdjacentHTML("afterend", html);
        } else {
          $3(html).insertAfter(el);
        }
      });
    },
    before: function(html) {
      return this.each(function() {
        const el = this;
        if (typeof html === "string") {
          el.insertAdjacentHTML("beforebegin", html);
        } else {
          $3(html).insertBefore(el);
        }
      });
    },
    clone: function(deep = false, withData = false) {
      const res = [];
      this.each(function() {
        const el = this.cloneNode(deep);
        const $el = $3(el);
        let data;
        if (withData && $3.hasData(this)) {
          data = $3(this).data();
          $3.each(data, function(k5, v5) {
            $el.data(k5, v5);
          });
        }
        res.push(el);
      });
      return $3.merge($3(), res);
    },
    import: function(deep) {
      const res = [];
      if (not2(deep)) {
        deep = false;
      }
      this.each(function() {
        res.push(document.importNode(this, deep));
      });
      return $3.merge($3(), res);
    },
    adopt: function() {
      const res = [];
      this.each(function() {
        res.push(document.adoptNode(this));
      });
      return $3.merge($3(), res);
    },
    remove: function(selector) {
      let i3 = 0, node, out, res = [];
      if (this.length === 0) {
        return;
      }
      out = selector ? this.filter(function(el) {
        return matches.call(el, selector);
      }) : this.items();
      for (; (node = out[i3]) != null; i3++) {
        if (node.parentNode) {
          res.push(node.parentNode.removeChild(node));
          $3.removeData(node);
        }
      }
      return $3.merge($3(), res);
    },
    wrap: function(el) {
      if (this.length === 0) {
        return;
      }
      const wrapper = $3(normalizeElements(el));
      if (!wrapper.length) {
        return;
      }
      const res = [];
      this.each(function() {
        let _target, _wrapper;
        _wrapper = wrapper.clone(true, true);
        _wrapper.insertBefore(this);
        _target = _wrapper;
        while (_target.children().length) {
          _target = _target.children().eq(0);
        }
        _target.append(this);
        res.push(_wrapper);
      });
      return $3(res);
    },
    wrapAll: function(el) {
      let wrapper, _wrapper, _target;
      if (this.length === 0) {
        return;
      }
      wrapper = $3(normalizeElements(el));
      if (!wrapper.length) {
        return;
      }
      _wrapper = wrapper.clone(true, true);
      _wrapper.insertBefore(this[0]);
      _target = _wrapper;
      while (_target.children().length) {
        _target = _target.children().eq(0);
      }
      this.each(function() {
        _target.append(this);
      });
      return _wrapper;
    },
    wrapInner: function(el) {
      if (this.length === 0) {
        return;
      }
      const wrapper = $3(normalizeElements(el));
      if (!wrapper.length) {
        return;
      }
      const res = [];
      this.each(function() {
        const elem = $3(this);
        const html = elem.html();
        const wrp = wrapper.clone(true, true);
        elem.html(wrp.html(html));
        res.push(wrp);
      });
      return $3(res);
    }
  });
  $3.extend({
    animation: {
      duration: 1e3,
      ease: "linear",
      elements: {}
    }
  });
  if (typeof window["setupAnimation"] === "object") {
    $3.each(window["setupAnimation"], function(key, val) {
      if (typeof $3.animation[key] !== "undefined" && !not2(val))
        $3.animation[key] = val;
    });
  }
  var transformProps = ["translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "scaleZ", "skew", "skewX", "skewY"];
  var numberProps = ["opacity", "zIndex"];
  var floatProps = ["opacity", "volume"];
  var scrollProps = ["scrollLeft", "scrollTop"];
  var reverseProps = ["opacity", "volume"];
  function _validElement(el) {
    return el instanceof HTMLElement || el instanceof SVGElement;
  }
  function _getRelativeValue(to2, from) {
    const operator = /^(\*=|\+=|-=)/.exec(to2);
    if (!operator) return to2;
    const u4 = getUnit(to2) || 0;
    const x5 = parseFloat(from);
    const y4 = parseFloat(to2.replace(operator[0], ""));
    switch (operator[0][0]) {
      case "+":
        return x5 + y4 + u4;
      case "-":
        return x5 - y4 + u4;
      case "*":
        return x5 * y4 + u4;
      case "/":
        return x5 / y4 + u4;
    }
  }
  function _getStyle(el, prop, pseudo) {
    if (typeof el[prop] !== "undefined") {
      if (scrollProps.indexOf(prop) > -1) {
        return prop === "scrollLeft" ? el === window ? scrollX : el.scrollLeft : el === window ? scrollY : el.scrollTop;
      } else {
        return el[prop] || 0;
      }
    }
    return el.style[prop] || getComputedStyle(el, pseudo)[prop];
  }
  function _setStyle(el, key, val, unit, toInt) {
    if (not2(toInt)) {
      toInt = false;
    }
    key = camelCase(key);
    if (toInt) {
      val = parseInt(val);
    }
    if (_validElement(el)) {
      if (typeof el[key] !== "undefined") {
        el[key] = val;
      } else {
        el.style[key] = key === "transform" || key.toLowerCase().indexOf("color") > -1 ? val : val + unit;
      }
    } else {
      el[key] = val;
    }
  }
  function _applyStyles(el, mapProps, p5) {
    $3.each(mapProps, function(key, val) {
      _setStyle(el, key, val[0] + val[2] * p5, val[3], val[4]);
    });
  }
  function _getElementTransforms(el) {
    if (!_validElement(el)) return {};
    const str2 = el.style.transform || "";
    const reg = /(\w+)\(([^)]*)\)/g;
    const transforms = {};
    let m5;
    while (m5 = reg.exec(str2))
      transforms[m5[1]] = m5[2];
    return transforms;
  }
  function _getColorArrayFromHex(val) {
    const a2 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(val ? val : "#000000");
    return a2.slice(1).map(function(v5) {
      return parseInt(v5, 16);
    });
  }
  function _getColorArrayFromElement(el, key) {
    return getComputedStyle(el)[key].replace(/[^\d.,]/g, "").split(",").map(function(v5) {
      return parseInt(v5);
    });
  }
  function _applyTransform(el, mapProps, p5) {
    const t = [];
    const elTransforms = _getElementTransforms(el);
    $3.each(mapProps, function(key, val) {
      let from = val[0], to2 = val[1], delta = val[2], unit = val[3];
      key = "" + key;
      if (key.indexOf("rotate") > -1 || key.indexOf("skew") > -1) {
        if (unit === "") unit = "deg";
      }
      if (key.indexOf("scale") > -1) {
        unit = "";
      }
      if (key.indexOf("translate") > -1 && unit === "") {
        unit = "px";
      }
      if (unit === "turn") {
        t.push(key + "(" + to2 * p5 + unit + ")");
      } else {
        t.push(key + "(" + (from + delta * p5) + unit + ")");
      }
    });
    $3.each(elTransforms, function(key, val) {
      if (mapProps[key] === void 0) {
        t.push(key + "(" + val + ")");
      }
    });
    el.style.transform = t.join(" ");
  }
  function _applyColors(el, mapProps, p5) {
    $3.each(mapProps, function(key, val) {
      let i3, result = [0, 0, 0], v5;
      for (i3 = 0; i3 < 3; i3++) {
        result[i3] = Math.floor(val[0][i3] + val[2][i3] * p5);
      }
      v5 = "rgb(" + result.join(",") + ")";
      el.style[key] = v5;
    });
  }
  function _expandColorValue(val) {
    const regExp = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    if (val[0] === "#" && val.length === 4) {
      return "#" + val.replace(regExp, function(m5, r2, g5, b5) {
        return r2 + r2 + g5 + g5 + b5 + b5;
      });
    }
    return val[0] === "#" ? val : "#" + val;
  }
  function applyProps(el, map, p5) {
    _applyStyles(el, map.props, p5);
    _applyTransform(el, map.transform, p5);
    _applyColors(el, map.color, p5);
  }
  function createAnimationMap(el, draw, dir) {
    const map = {
      props: {},
      transform: {},
      color: {}
    };
    let i3, from, to2, delta, unit, temp;
    const elTransforms = _getElementTransforms(el);
    if (not2(dir)) {
      dir = "normal";
    }
    $3.each(draw, function(key, val) {
      const isTransformProp = transformProps.indexOf("" + key) > -1;
      const isNumProp = numberProps.indexOf("" + key) > -1;
      const isColorProp = ("" + key).toLowerCase().indexOf("color") > -1;
      if (Array.isArray(val) && val.length === 1) {
        val = val[0];
      }
      if (!Array.isArray(val)) {
        if (isTransformProp) {
          from = elTransforms[key] || key === "scale" ? 1 : 0;
        } else if (isColorProp) {
          from = _getColorArrayFromElement(el, key);
        } else {
          from = _getStyle(el, key, void 0);
        }
        from = !isColorProp ? parseUnit(from) : from;
        to2 = !isColorProp ? parseUnit(_getRelativeValue(val, Array.isArray(from) ? from[0] : from)) : _getColorArrayFromHex(val);
      } else {
        from = !isColorProp ? parseUnit(val[0]) : _getColorArrayFromHex(_expandColorValue(val[0]));
        to2 = !isColorProp ? parseUnit(val[1]) : _getColorArrayFromHex(_expandColorValue(val[1]));
      }
      if (reverseProps.indexOf("" + key) > -1 && from[0] === to2[0]) {
        from[0] = to2[0] > 0 ? 0 : 1;
      }
      if (dir === "reverse") {
        temp = from;
        from = to2;
        to2 = temp;
      }
      unit = el instanceof HTMLElement && to2[1] === "" && !isNumProp && !isTransformProp ? "px" : to2[1];
      if (isColorProp) {
        delta = [0, 0, 0];
        for (i3 = 0; i3 < 3; i3++) {
          delta[i3] = to2[i3] - from[i3];
        }
      } else {
        delta = to2[0] - from[0];
      }
      if (isTransformProp) {
        map.transform[key] = [from[0], to2[0], delta, unit];
      } else if (isColorProp) {
        map.color[key] = [from, to2, delta, unit];
      } else {
        map.props[key] = [from[0], to2[0], delta, unit, floatProps.indexOf("" + key) === -1];
      }
    });
    return map;
  }
  function minMax(val, min, max) {
    return Math.min(Math.max(val, min), max);
  }
  var Easing = {
    linear: function() {
      return function(t) {
        return t;
      };
    }
  };
  Easing.default = Easing.linear;
  var eases = {
    Sine: function() {
      return function(t) {
        return 1 - Math.cos(t * Math.PI / 2);
      };
    },
    Circ: function() {
      return function(t) {
        return 1 - Math.sqrt(1 - t * t);
      };
    },
    Back: function() {
      return function(t) {
        return t * t * (3 * t - 2);
      };
    },
    Bounce: function() {
      return function(t) {
        let pow2, b5 = 4;
        while (t < ((pow2 = Math.pow(2, --b5)) - 1) / 11) {
        }
        return 1 / Math.pow(4, 3 - b5) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
      };
    },
    Elastic: function(amplitude, period) {
      if (not2(amplitude)) {
        amplitude = 1;
      }
      if (not2(period)) {
        period = 0.5;
      }
      const a2 = minMax(amplitude, 1, 10);
      const p5 = minMax(period, 0.1, 2);
      return function(t) {
        return t === 0 || t === 1 ? t : -a2 * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p5 / (Math.PI * 2) * Math.asin(1 / a2)) * (Math.PI * 2) / p5);
      };
    }
  };
  ["Quad", "Cubic", "Quart", "Quint", "Expo"].forEach(function(name2, i3) {
    eases[name2] = function() {
      return function(t) {
        return Math.pow(t, i3 + 2);
      };
    };
  });
  Object.keys(eases).forEach(function(name2) {
    const easeIn = eases[name2];
    Easing["easeIn" + name2] = easeIn;
    Easing["easeOut" + name2] = function(a2, b5) {
      return function(t) {
        return 1 - easeIn(a2, b5)(1 - t);
      };
    };
    Easing["easeInOut" + name2] = function(a2, b5) {
      return function(t) {
        return t < 0.5 ? easeIn(a2, b5)(t * 2) / 2 : 1 - easeIn(a2, b5)(t * -2 + 2) / 2;
      };
    };
  });
  var defaultAnimationProps = {
    id: null,
    el: null,
    draw: {},
    dur: $3.animation.duration,
    ease: $3.animation.ease,
    loop: 0,
    pause: 0,
    dir: "normal",
    defer: 0,
    onStart: function() {
    },
    onStop: function() {
    },
    onStopAll: function() {
    },
    onPause: function() {
    },
    onPauseAll: function() {
    },
    onResume: function() {
    },
    onResumeAll: function() {
    },
    onFrame: function() {
    },
    onDone: function() {
    }
  };
  function animate(args) {
    return new Promise(function(resolve) {
      const that = this;
      const props = $3.assign({}, defaultAnimationProps, { dur: $3.animation.duration, ease: $3.animation.ease }, args);
      let id = props.id, el = props.el, draw = props.draw, dur = props.dur, ease = props.ease, loop = props.loop, onStart = props.onStart, onFrame = props.onFrame, onDone = props.onDone, pauseStart = props.pause, dir = props.dir, defer = props.defer;
      let map = {};
      let easeName = "linear", easeArgs = [], easeFn = Easing.linear, matchArgs;
      let direction = dir === "alternate" ? "normal" : dir;
      let replay = false;
      let animationID = id ? id : +(performance.now() * Math.pow(10, 14));
      if (not2(el)) {
        throw new Error("Unknown element!");
      }
      if (typeof el === "string") {
        el = document.querySelector(el);
      }
      if (typeof draw !== "function" && typeof draw !== "object") {
        throw new Error("Unknown draw object. Must be a function or object!");
      }
      if (dur === 0) {
        dur = 1;
      }
      if (dir === "alternate" && typeof loop === "number") {
        loop *= 2;
      }
      if (typeof ease === "string") {
        matchArgs = /\(([^)]+)\)/.exec(ease);
        easeName = ease.split("(")[0];
        easeArgs = matchArgs ? matchArgs[1].split(",").map(function(p5) {
          return parseFloat(p5);
        }) : [];
        easeFn = Easing[easeName] || Easing.linear;
      } else if (typeof ease === "function") {
        easeFn = ease;
      } else {
        easeFn = Easing.linear;
      }
      $3.animation.elements[animationID] = {
        element: el,
        id: null,
        stop: 0,
        pause: 0,
        loop: 0,
        t: -1,
        started: 0,
        paused: 0
      };
      const play = function() {
        if (typeof draw === "object") {
          map = createAnimationMap(el, draw, direction);
        }
        if (typeof onStart === "function") {
          onStart.apply(el);
        }
        $3.animation.elements[animationID].loop += 1;
        $3.animation.elements[animationID].started = performance.now();
        $3.animation.elements[animationID].duration = dur;
        $3.animation.elements[animationID].id = requestAnimationFrame(animate1);
      };
      const done = function() {
        cancelAnimationFrame($3.animation.elements[animationID].id);
        delete $3.animation.elements[id];
        if (typeof onDone === "function") {
          onDone.apply(el);
        }
        resolve(that);
      };
      const animate1 = function(time) {
        let p5, t;
        let { stop, pause, started: start } = $3.animation.elements[animationID];
        if ($3.animation.elements[animationID].paused) {
          start = time - $3.animation.elements[animationID].t * dur;
          $3.animation.elements[animationID].started = start;
        }
        t = ((time - start) / dur).toFixed(4);
        if (t > 1) t = 1;
        if (t < 0) t = 0;
        p5 = easeFn.apply(null, easeArgs)(t);
        $3.animation.elements[animationID].t = t;
        $3.animation.elements[animationID].p = p5;
        if (pause) {
          $3.animation.elements[animationID].id = requestAnimationFrame(animate1);
          return;
        }
        if (stop > 0) {
          if (stop === 2) {
            if (typeof draw === "function") {
              draw.bind(el)(1, 1);
            } else {
              applyProps(el, map, 1);
            }
          }
          done();
          return;
        }
        if (typeof draw === "function") {
          draw.bind(el)(t, p5);
        } else {
          applyProps(el, map, p5);
        }
        if (typeof onFrame === "function") {
          onFrame.apply(el, [t, p5]);
        }
        if (t <= 1) {
          $3.animation.elements[animationID].id = requestAnimationFrame(animate1);
        }
        if (t >= 1) {
          if (loop) {
            if (dir === "alternate") {
              direction = direction === "normal" ? "reverse" : "normal";
            }
            if (typeof loop === "boolean") {
              setTimeout(function() {
                play();
              }, pauseStart);
            } else {
              if (loop > $3.animation.elements[animationID].loop) {
                setTimeout(function() {
                  play();
                }, pauseStart);
              } else {
                done();
              }
            }
          } else {
            if (dir === "alternate" && !replay) {
              direction = direction === "normal" ? "reverse" : "normal";
              replay = true;
              play();
            } else {
              done();
            }
          }
        }
      };
      if (defer > 0) {
        setTimeout(function() {
          play();
        }, defer);
      } else {
        play();
      }
    });
  }
  function stopAnimation(id, done) {
    const an = $3.animation.elements[id];
    if (typeof an === "undefined") {
      return;
    }
    if (not2(done)) {
      done = true;
    }
    an.stop = done === true ? 2 : 1;
    if (typeof an.onStop === "function") {
      an.onStop.apply(an.element);
    }
  }
  function stopAnimationAll(done, filter) {
    $3.each($3.animation.elements, function(k5, v5) {
      if (filter) {
        if (typeof filter === "string") {
          if (matches.call(v5.element, filter)) stopAnimation(k5, done);
        } else if (filter.length) {
          $3.each(filter, function() {
            if (v5.element === this) stopAnimation(k5, done);
          });
        } else if (filter instanceof Element) {
          if (v5.element === filter) stopAnimation(k5, done);
        }
      } else {
        stopAnimation(k5, done);
      }
    });
  }
  function pauseAnimation(id) {
    const an = $3.animation.elements[id];
    if (typeof an === "undefined") {
      return;
    }
    an.pause = 1;
    an.paused = performance.now();
    if (typeof an.onPause === "function") {
      an.onPause.apply(an.element);
    }
  }
  function pauseAnimationAll(filter) {
    $3.each($3.animation.elements, function(k5, v5) {
      if (filter) {
        if (typeof filter === "string") {
          if (matches.call(v5.element, filter)) pauseAnimation(k5);
        } else if (filter.length) {
          $3.each(filter, function() {
            if (v5.element === this) pauseAnimation(k5);
          });
        } else if (filter instanceof Element) {
          if (v5.element === filter) pauseAnimation(k5);
        }
      } else {
        pauseAnimation(k5);
      }
    });
  }
  function resumeAnimation(id) {
    const an = $3.animation.elements[id];
    if (typeof an === "undefined") {
      return;
    }
    an.pause = 0;
    an.paused = 0;
    if (typeof an.onResume === "function") {
      an.onResume.apply(an.element);
    }
  }
  function resumeAnimationAll(filter) {
    $3.each($3.animation.elements, function(k5, v5) {
      if (filter) {
        if (typeof filter === "string") {
          if (matches.call(v5.element, filter)) resumeAnimation(k5);
        } else if (filter.length) {
          $3.each(filter, function() {
            if (v5.element === this) resumeAnimation(k5);
          });
        } else if (filter instanceof Element) {
          if (v5.element === filter) resumeAnimation(k5);
        }
      } else {
        resumeAnimation(k5);
      }
    });
  }
  var defaultChainOptions = {
    loop: false,
    onChainItem: null,
    onChainItemComplete: null,
    onChainComplete: null
  };
  function chain(arr, opt2) {
    const o2 = $3.extend({}, defaultChainOptions, opt2);
    if (typeof o2.loop !== "boolean") {
      o2.loop--;
    }
    if (!Array.isArray(arr)) {
      console.warn("Chain array is not defined!");
      return false;
    }
    const reducer = function(acc, item) {
      return acc.then(function() {
        if (typeof o2["onChainItem"] === "function") {
          o2["onChainItem"](item);
        }
        return animate(item).then(function() {
          if (typeof o2["onChainItemComplete"] === "function") {
            o2["onChainItemComplete"](item);
          }
        });
      });
    };
    arr.reduce(reducer, Promise.resolve()).then(function() {
      if (typeof o2["onChainComplete"] === "function") {
        o2["onChainComplete"]();
      }
      if (o2.loop) {
        chain(arr, o2);
      }
    });
  }
  $3.easing = {};
  $3.extend($3.easing, Easing);
  $3.extend({
    animate: function(args) {
      let el, draw, dur, ease, cb;
      if (arguments.length > 1) {
        el = $3(arguments[0])[0];
        draw = arguments[1];
        dur = arguments[2] || $3.animation.duration;
        ease = arguments[3] || $3.animation.ease;
        cb = arguments[4];
        if (typeof dur === "function") {
          cb = dur;
          ease = $3.animation.ease;
          dur = $3.animation.duration;
        }
        if (typeof ease === "function") {
          cb = ease;
          ease = $3.animation.ease;
        }
        return animate({
          el,
          draw,
          dur,
          ease,
          onDone: cb
        });
      }
      return animate(args);
    },
    chain,
    stop: stopAnimation,
    stopAll: stopAnimationAll,
    resume: resumeAnimation,
    resumeAll: resumeAnimationAll,
    pause: pauseAnimation,
    pauseAll: pauseAnimationAll
  });
  $3.fn.extend({
    /**
         *
    
         args = {
         draw: {} | function,
         dur: 1000,
         ease: "linear",
         loop: 0,
         pause: 0,
         dir: "normal",
         defer: 0,
         onFrame: function,
         onDone: function
         }
    
         * @returns {this}
         */
    animate: function(args) {
      const that = this;
      let draw, dur, easing, cb;
      const a2 = args;
      let compatibilityMode;
      compatibilityMode = !Array.isArray(args) && (arguments.length > 1 || arguments.length === 1 && typeof arguments[0].draw === "undefined");
      if (compatibilityMode) {
        draw = arguments[0];
        dur = arguments[1] || $3.animation.duration;
        easing = arguments[2] || $3.animation.ease;
        cb = arguments[3];
        if (typeof dur === "function") {
          cb = dur;
          dur = $3.animation.duration;
          easing = $3.animation.ease;
        }
        if (typeof easing === "function") {
          cb = easing;
          easing = $3.animation.ease;
        }
        return this.each(function() {
          return $3.animate({
            el: this,
            draw,
            dur,
            ease: easing,
            onDone: cb
          });
        });
      }
      if (Array.isArray(args)) {
        $3.each(args, function() {
          const a22 = this;
          that.each(function() {
            a22.el = this;
            $3.animate(a22);
          });
        });
        return this;
      }
      return this.each(function() {
        a2.el = this;
        $3.animate(a2);
      });
    },
    chain: function(arr, loop) {
      return this.each(function() {
        const el = this;
        $3.each(arr, function() {
          this.el = el;
        });
        $3.chain(arr, loop);
      });
    },
    /**
     *
     * @param done
     * @returns {this}
     */
    stop: function(done) {
      return this.each(function() {
        const el = this;
        $3.each($3.animation.elements, function(k5, o2) {
          if (o2.element === el) {
            stopAnimation(k5, done);
          }
        });
      });
    },
    pause: function() {
      return this.each(function() {
        const el = this;
        $3.each($3.animation.elements, function(k5, o2) {
          if (o2.element === el) {
            pauseAnimation(k5);
          }
        });
      });
    },
    resume: function() {
      return this.each(function() {
        const el = this;
        $3.each($3.animation.elements, function(k5, o2) {
          if (o2.element === el) {
            resumeAnimation(k5);
          }
        });
      });
    }
  });
  $3.extend({
    hidden: function(el, val, cb) {
      el = $3(el)[0];
      if (typeof val === "undefined") {
        el.hidden = !el.hidden;
        return this;
      }
      if (typeof val === "string") {
        val = val.toLowerCase() === "true";
      }
      if (typeof val === "function") {
        cb = val;
        val = !el.hidden;
      }
      el.hidden = val;
      if (typeof cb === "function") {
        $3.bind(cb, el);
        cb.call(el, arguments);
      }
      return this;
    },
    hide: function(el, cb) {
      const $el = $3(el);
      el = $el[0];
      const inline = el.style.display;
      const css = getComputedStyle(el, null).display;
      $el.origin("display", {
        inline,
        css
      });
      el.style.display = "none";
      if (typeof cb === "function") {
        $3.bind(cb, el);
        cb.call(el, arguments);
      }
      return this;
    },
    show: function(el, cb) {
      const $el = $3(el);
      const display = $el.origin("display");
      el = $3(el)[0];
      el.style.display = "";
      if (display) {
        const inline = display.inline || "";
        const css = display.css || "";
        if (inline && inline !== "none") {
          el.style.display = inline;
        } else if (css === "none") {
          el.style.display = "block";
        }
      } else {
        el.style.display = "block";
      }
      if (parseInt(el.style.opacity) === 0) {
        el.style.opacity = "1";
      }
      if (typeof cb === "function") {
        $3.bind(cb, el);
        cb.call(el, arguments);
      }
      return this;
    },
    visible: function(el, mode, cb) {
      if (mode === void 0) {
        mode = true;
      }
      el.style.visibility = mode ? "visible" : "hidden";
      if (typeof cb === "function") {
        $3.bind(cb, el);
        cb.call(el, arguments);
      }
      return this;
    },
    toggle: function(el, cb) {
      const func = getComputedStyle(el, null).display !== "none" ? "hide" : "show";
      return $3[func](el, cb);
    }
  });
  $3.fn.extend({
    hide: function() {
      let callback;
      $3.each(arguments, function() {
        if (typeof this === "function") {
          callback = this;
        }
      });
      return this.each(function() {
        $3.hide(this, callback);
      });
    },
    show: function() {
      let callback;
      $3.each(arguments, function() {
        if (typeof this === "function") {
          callback = this;
        }
      });
      return this.each(function() {
        $3.show(this, callback);
      });
    },
    visible: function(mode, cb) {
      return this.each(function() {
        $3.visible(this, mode, cb);
      });
    },
    toggle: function(cb) {
      return this.each(function() {
        $3.toggle(this, cb);
      });
    },
    hidden: function(val, cb) {
      return this.each(function() {
        $3.hidden(this, val, cb);
      });
    }
  });
  $3.extend({
    fx: {
      off: false
    }
  });
  $3.fn.extend({
    fadeIn: function(dur, easing, cb) {
      return this.each(function() {
        const el = this;
        const $el = $3(el);
        const visible = !(!isVisible(el) || isVisible(el) && +$el.style("opacity") === 0);
        if (not2(dur) && not2(easing) && not2(cb)) {
          cb = null;
          dur = $3.animation.duration;
        } else if (typeof dur === "function") {
          cb = dur;
          dur = $3.animation.duration;
        }
        if (typeof easing === "function") {
          cb = easing;
          easing = $3.animation.ease;
        }
        if ($3.fx.off) {
          dur = 0;
        }
        if (visible) {
          if (typeof cb === "function") {
            $3.bind(cb, this)();
          }
          return this;
        }
        const originDisplay = $el.origin("display", void 0, "block");
        el.style.opacity = "0";
        el.style.display = originDisplay;
        return $3.animate({
          el,
          draw: {
            opacity: 1
          },
          dur,
          ease: easing,
          onDone: function() {
            if (typeof cb === "function") {
              $3.bind(cb, this)();
            }
          }
        });
      });
    },
    fadeOut: function(dur, easing, cb) {
      return this.each(function() {
        const el = this;
        const $el = $3(el);
        if (not2(dur) && not2(easing) && not2(cb)) {
          cb = null;
          dur = $3.animation.duration;
        } else if (typeof dur === "function") {
          cb = dur;
          dur = $3.animation.duration;
        }
        if (typeof easing === "function") {
          cb = easing;
          easing = $3.animation.ease;
        }
        $el.origin("display", $el.style("display"));
        if (!isVisible(el)) {
          if (typeof cb === "function") {
            $3.bind(cb, this)();
          }
          return this;
        }
        return $3.animate({
          el,
          draw: {
            opacity: 0
          },
          dur,
          ease: easing,
          onDone: function() {
            this.style.display = "none";
            if (typeof cb === "function") {
              $3.bind(cb, this)();
            }
          }
        });
      });
    },
    slideUp: function(dur, easing, cb) {
      return this.each(function() {
        const el = this;
        const $el = $3(el);
        let currHeight;
        if ($el.height() === 0) return;
        if (not2(dur) && not2(easing) && not2(cb)) {
          cb = null;
          dur = $3.animation.duration;
        } else if (typeof dur === "function") {
          cb = dur;
          dur = $3.animation.duration;
        }
        if (typeof easing === "function") {
          cb = easing;
          easing = $3.animation.ease;
        }
        currHeight = $el.height();
        $el.origin("height", currHeight);
        $el.origin("display", $3(el).style("display"));
        $el.css({
          overflow: "hidden"
        });
        return $3.animate({
          el,
          draw: {
            height: 0
          },
          dur,
          ease: easing,
          onDone: function() {
            $el.hide().removeStyleProperty("overflow, height");
            if (typeof cb === "function") {
              $3.bind(cb, this)();
            }
          }
        });
      });
    },
    slideDown: function(dur, easing, cb) {
      return this.each(function() {
        const el = this;
        const $el = $3(el);
        let targetHeight, originDisplay;
        if (not2(dur) && not2(easing) && not2(cb)) {
          cb = null;
          dur = $3.animation.duration;
        } else if (typeof dur === "function") {
          cb = dur;
          dur = $3.animation.duration;
        }
        if (typeof easing === "function") {
          cb = easing;
          easing = $3.animation.ease;
        }
        $el.show().visible(false);
        targetHeight = +$el.origin("height", void 0, $el.height());
        if (parseInt(targetHeight) === 0) {
          targetHeight = el.scrollHeight;
        }
        originDisplay = $el.origin("display", $el.style("display"), "block");
        $el.height(0).visible(true);
        $el.css({
          overflow: "hidden",
          display: originDisplay === "none" ? "block" : originDisplay
        });
        return $3.animate({
          el,
          draw: {
            height: targetHeight
          },
          dur,
          ease: easing,
          onDone: function() {
            $3(el).removeStyleProperty("overflow, height, visibility");
            if (typeof cb === "function") {
              $3.bind(cb, this)();
            }
          }
        });
      });
    },
    moveTo: function(x5, y4, dur, ease, cb) {
      const draw = {
        top: y4,
        left: x5
      };
      if (typeof dur === "function") {
        cb = dur;
        dur = $3.animation.duration;
        ease = $3.animation.ease;
      }
      if (typeof ease === "function") {
        cb = ease;
        ease = $3.animation.ease;
      }
      return this.each(function() {
        $3.animate({
          el: this,
          draw,
          dur,
          ease,
          onDone: cb
        });
      });
    },
    centerTo: function(x5, y4, dur, ease, cb) {
      if (typeof dur === "function") {
        cb = dur;
        dur = $3.animation.duration;
        ease = $3.animation.ease;
      }
      if (typeof ease === "function") {
        cb = ease;
        ease = $3.animation.ease;
      }
      return this.each(function() {
        const draw = {
          left: x5 - this.clientWidth / 2,
          top: y4 - this.clientHeight / 2
        };
        $3.animate({
          el: this,
          draw,
          dur,
          ease,
          onDone: cb
        });
      });
    },
    colorTo: function(color, dur, easing, cb) {
      const draw = {
        color
      };
      if (typeof dur === "function") {
        cb = dur;
        dur = $3.animation.duration;
        easing = $3.animation.ease;
      }
      if (typeof easing === "function") {
        cb = easing;
        easing = $3.animation.ease;
      }
      return this.each(function() {
        $3.animate({
          el: this,
          draw,
          dur,
          ease: easing,
          onDone: cb
        });
      });
    },
    backgroundTo: function(color, dur, easing, cb) {
      const draw = {
        backgroundColor: color
      };
      if (typeof dur === "function") {
        cb = dur;
        dur = $3.animation.duration;
        easing = $3.animation.ease;
      }
      if (typeof easing === "function") {
        cb = easing;
        easing = $3.animation.ease;
      }
      return this.each(function() {
        $3.animate({
          el: this,
          draw,
          dur,
          ease: easing,
          onDone: cb
        });
      });
    },
    zoomIn: function(dur, easing, cb) {
      const draw = {
        scale: [0, 1]
      };
      if (typeof dur === "function") {
        cb = dur;
        dur = $3.animation.duration;
        easing = $3.animation.ease;
      }
      if (typeof easing === "function") {
        cb = easing;
        easing = $3.animation.ease;
      }
      return this.each(function() {
        $3.animate({
          el: this,
          draw,
          dur,
          ease: easing,
          onDone: cb
        });
      });
    },
    zoomOut: function(dur = 1e3, ease = "linear", cb = () => {
    }) {
      if (typeof dur === "function") {
        cb = dur;
        dur = $3.animation.duration;
        ease = $3.animation.ease;
      }
      if (typeof ease === "function") {
        cb = ease;
        ease = $3.animation.ease;
      }
      return this.each(function() {
        $3.animate({
          el: this,
          draw: {
            scale: 0
          },
          dur,
          ease,
          onDone: cb
        });
      });
    }
  });
  $3.extend({
    scrollTop: function(val) {
      if (not2(val)) {
        return window.scrollY;
      }
      window.scrollTo(window.scrollX, val);
    },
    scrollLeft: function(val) {
      if (not2(val)) {
        return window.scrollX;
      }
      window.scrollTo(val, window.scrollY);
    },
    scrollTo: function(x5, y4) {
      window.scrollTo(x5, y4);
    },
    scrollToElement: function(el) {
      $3(el).scrollTo();
    }
  });
  $3.fn.extend({
    scrollTop: function(val) {
      if (not2(val)) {
        return this.length === 0 ? void 0 : this[0] === window ? scrollY : this[0].scrollTop;
      }
      return this.each(function() {
        if (this === window) {
          window.scrollTo(window.scrollX, val);
          return;
        }
        this.scrollTop = val;
      });
    },
    scrollLeft: function(val) {
      if (not2(val)) {
        return this.length === 0 ? void 0 : this[0] === window ? scrollX : this[0].scrollLeft;
      }
      return this.each(function() {
        if (this === window) {
          window.scrollTo(val, window.scrollY);
          return;
        }
        this.scrollLeft = val;
      });
    },
    scrollTo: function(relativeToViewport = false) {
      if (this.length === 0) {
        return this;
      }
      const rect = this[0].getBoundingClientRect();
      const x5 = rect.left + (relativeToViewport ? 0 : window.scrollX);
      const y4 = rect.top + (relativeToViewport ? 0 : window.scrollY);
      window.scrollTo(x5, y4);
      return this;
    }
  });
  $3.init = function(sel, ctx) {
    let parsed;
    const that = this;
    if (typeof sel === "string") {
      sel = sel.trim();
    }
    this.uid = $3.uniqueId();
    if (!sel) {
      return this;
    }
    if (typeof sel === "function") {
      return $3.ready(sel);
    }
    if (sel instanceof Element) {
      this.push(sel);
      return this;
    }
    if (sel instanceof $3) {
      $3.each(sel, function() {
        that.push(this);
      });
      return this;
    }
    if (sel === "window" || sel === window) {
      this.push(window);
      return this;
    }
    if (sel === "document" || sel === document) {
      this.push(document);
      return this;
    }
    if (sel === "body" || sel === document.body) {
      this.push(document.body);
      return this;
    }
    if (sel === "html" || sel === document.documentElement) {
      this.push(document.documentElement);
      return this;
    }
    if (sel === "doctype" || sel === document.doctype) {
      this.push(document.doctype);
      return this;
    }
    if (sel && sel.nodeType) {
      this.push(sel);
      return this;
    }
    if (isArrayLike(sel)) {
      $3.each(sel, function() {
        $3(this).each(function() {
          that.push(this);
        });
      });
      return this;
    }
    if (typeof sel !== "string" && (sel.self && sel.self !== window)) {
      return this;
    }
    if (sel === "#" || sel === ".") {
      return this;
    }
    if (sel[0] === "@") {
      $3("[data-role]").each(function() {
        const roles = str2arr($3(this).attr("data-role"), ",");
        if (roles.indexOf(sel.slice(1)) > -1) {
          that.push(this);
        }
      });
    } else {
      parsed = $3.parseHTML(sel);
      for (let i3 = 0; i3 < parsed.length; i3++) {
        if (parsed[i3].nodeType === 1) {
          this.push(parsed[i3]);
        }
      }
    }
    if (ctx !== void 0) {
      if (ctx instanceof $3) {
        this.each(function() {
          $3(ctx).append(that);
        });
      } else if (ctx instanceof HTMLElement) {
        $3(ctx).append(that);
      } else {
        if (isPlainObject(ctx)) {
          $3.each(this, function() {
            for (const name2 in ctx) {
              if (hasProp(ctx, name2))
                this.setAttribute(name2, ctx[name2]);
            }
          });
        }
      }
    }
    return this;
  };
  $3.init.prototype = $3.fn;

  // ../metroui-lib/source/dom/index.js
  globalThis.Dom = $3;
  if (typeof $ === "undefined") {
    globalThis.$ = $3;
  }

  // ../metroui-lib/node_modules/@olton/hooks/dist/hooks.js
  var hooks_exports = {};
  __export(hooks_exports, {
    EVENTS: () => EVENTS,
    info: () => info2,
    useClickOutside: () => useClickOutside,
    useCompose: () => useCompose,
    useCookie: () => useCookie,
    useCurry: () => useCurry,
    useDebounce: () => useDebounce,
    useEvent: () => useEvent,
    useId: () => useId,
    useInterval: () => useInterval,
    useMediaQuery: () => useMediaQuery,
    useMemo: () => useMemo,
    usePipe: () => usePipe,
    useQueue: () => useQueue,
    useState: () => useState,
    useThrottle: () => useThrottle,
    useToggle: () => useToggle
  });
  function useClickOutside(element2, callback) {
    if (!element2) return { attach: () => {
    }, detach: () => {
    } };
    const handleClick = (e2) => {
      if (!element2.contains(e2.target)) {
        callback();
      }
    };
    const attach = () => document.addEventListener("click", handleClick);
    const detach = () => document.removeEventListener("click", handleClick);
    return { attach, detach };
  }
  function useCompose(...functions) {
    if (!functions.every((fn) => typeof fn === "function")) {
      throw new Error("useCompose: All arguments should be functions");
    }
    switch (functions.length) {
      // No functions provided
      case 0:
        return (x5) => x5;
      // One function provided    
      case 1:
        return functions[0];
      // Two functions provided
      case 2: {
        const [f5, g5] = functions;
        return (...args) => f5(g5(...args));
      }
      // Three or more functions provided
      default:
        return function composed(...args) {
          let result = functions[functions.length - 1](...args);
          for (let i3 = functions.length - 2; i3 >= 0; i3--) {
            result = functions[i3](result);
          }
          return result;
        };
    }
  }
  function useCookie(name2) {
    function getCookie() {
      const matches2 = document.cookie.match(
        new RegExp(`(?:^|; )${name2.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, "\\$1")}=([^;]*)`)
      );
      return matches2 ? decodeURIComponent(matches2[1]) : null;
    }
    function setCookie(value, options = {}) {
      options = { path: "/", ...options };
      document.cookie = `${name2}=${encodeURIComponent(value)}; ${Object.keys(options).map((key) => `${key}=${options[key]}`).join("; ")}`;
    }
    function deleteCookie() {
      setCookie("", { "max-age": -1 });
    }
    return { get: getCookie, set: setCookie, delete: deleteCookie };
  }
  function useCurry(func) {
    if (typeof func !== "function") {
      throw new Error("useCurry: \u043F\u0435\u0440\u0432\u044B\u0439 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442 \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C \u0444\u0443\u043D\u043A\u0446\u0438\u0435\u0439");
    }
    return function curried(...args) {
      if (args.length >= func.length) {
        return func.apply(this, args);
      }
      return function(...args2) {
        return curried.apply(this, args.concat(args2));
      };
    };
  }
  function useDebounce(fn, wait, options = {}) {
    if (typeof fn !== "function") {
      throw new Error("useDebounce: \u043F\u0435\u0440\u0432\u044B\u0439 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442 \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C \u0444\u0443\u043D\u043A\u0446\u0438\u0435\u0439");
    }
    if (wait < 0) {
      throw new Error("useDebounce: \u0432\u0440\u0435\u043C\u044F \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043F\u043E\u043B\u043E\u0436\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u043C \u0447\u0438\u0441\u043B\u043E\u043C");
    }
    let timer = null;
    let result;
    function debounced(...args) {
      const context = this;
      const callNow = options.immediate && !timer;
      if (timer !== null) {
        clearTimeout(timer);
      }
      timer = setTimeout(() => {
        timer = null;
        if (!options.immediate) {
          result = fn.apply(context, args);
        }
      }, wait);
      if (callNow) {
        result = fn.apply(context, args);
      }
      return result;
    }
    debounced.cancel = function() {
      if (timer !== null) {
        clearTimeout(timer);
        timer = null;
      }
    };
    return debounced;
  }
  var EVENTS = /* @__PURE__ */ ((EVENTS2) => {
    EVENTS2["LOAD"] = "load";
    EVENTS2["VIEWPORT"] = "viewport";
    EVENTS2["ATTRIBUTE"] = "attribute";
    EVENTS2["CHILDREN"] = "children";
    EVENTS2["DATA"] = "data";
    return EVENTS2;
  })(EVENTS || {});
  var useEvent = ({ event, root, target, effect }) => {
    const _target = typeof target === "string" ? document.querySelector(target) : target;
    if (typeof effect !== "function") {
      throw Error("Side effect must be a function!");
    }
    if (!_target) {
      throw Error("Please specify a target element!");
    }
    switch (event) {
      case "load": {
        const observer = new MutationObserver((mutations, observer2) => {
          const el = document.querySelector(target);
          if (el !== null) {
            effect(el);
            observer2.disconnect();
          }
        });
        observer.observe(document.body, {
          childList: true,
          subtree: true
        });
        break;
      }
      case "viewport": {
        const _root = root instanceof HTMLElement ? root : typeof root === "string" ? document.querySelector(root) : null;
        const observerOptions = {
          root: _root,
          rootMargin: "0px",
          threshold: 0.5
        };
        const observer = new IntersectionObserver((entries, observer2) => {
          for (const entry of entries) {
            if (entry.isIntersecting) {
              effect(_target);
            }
          }
        }, observerOptions);
        observer.observe(_target);
        break;
      }
      case "attribute": {
        const observer = new MutationObserver((mutations) => {
          for (const mut of mutations) {
            if (mut.target === _target && mut.type === "attributes") {
              effect(_target, mut.attributeName, _target.getAttribute(mut.attributeName));
            }
          }
        });
        observer.observe(_target, {
          attributes: true
        });
        break;
      }
      case "children": {
        const observer = new MutationObserver((mutations) => {
          for (const mut of mutations) {
            if (mut.target === _target && mut.type === "childList") {
              effect(_target, mut.addedNodes, mut.removedNodes);
            }
          }
        });
        observer.observe(_target, {
          childList: true,
          subtree: true
        });
        break;
      }
      case "data": {
        const observer = new MutationObserver((mutations) => {
          for (const mut of mutations) {
            if (mut.target === _target && mut.type === "characterData") {
              effect(_target, _target.textContent);
            }
          }
        });
        observer.observe(_target, {
          characterData: true
        });
        break;
      }
      default: {
        if (_target instanceof HTMLElement) {
          _target.addEventListener(event, (e2) => {
            effect(_target, e2);
          });
        }
      }
    }
  };
  var idStore = /* @__PURE__ */ new Map();
  var idCounter = 0;
  function normalizeKeyForId(keyStr) {
    return keyStr.replace(/[^a-zA-Z0-9_-]/g, "_");
  }
  function useId(key, options = {}) {
    const actualKey = key ?? Symbol("id-key");
    const { divider = "-", prefix = "id", forceNew = false } = options;
    if (!forceNew && idStore.has(actualKey)) {
      return idStore.get(actualKey);
    }
    const isClient = typeof document !== "undefined";
    const maxAttempts = 1e3;
    let attempts = 0;
    const generateId = () => {
      let keyType;
      if (key instanceof HTMLElement) {
        keyType = key.tagName.toLowerCase();
      } else if (typeof key === "object" && key !== null) {
        keyType = "object";
      } else if (key !== void 0) {
        keyType = normalizeKeyForId(String(key));
      } else {
        keyType = "generic";
      }
      return `${prefix}${divider}${keyType}${divider}${idCounter++}`;
    };
    let id = generateId();
    if (isClient) {
      while (document.getElementById(id)) {
        if (attempts++ > maxAttempts) {
          throw new Error("useId: \u043D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u0433\u0435\u043D\u0435\u0440\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0443\u043D\u0438\u043A\u0430\u043B\u044C\u043D\u044B\u0439 ID \u043F\u043E\u0441\u043B\u0435 \u043C\u043D\u043E\u0433\u043E\u0447\u0438\u0441\u043B\u0435\u043D\u043D\u044B\u0445 \u043F\u043E\u043F\u044B\u0442\u043E\u043A");
        }
        id = generateId();
      }
    }
    idStore.set(actualKey, id);
    return id;
  }
  function useInterval(callback, delay) {
    let timerId = null;
    function start() {
      if (timerId) return;
      timerId = window.setInterval(() => callback(), delay);
    }
    function stop() {
      if (timerId) {
        window.clearInterval(timerId);
        timerId = null;
      }
    }
    return { start, stop };
  }
  function useMediaQuery(query) {
    const mediaQuery = window.matchMedia(query);
    function getMatches() {
      return mediaQuery.matches;
    }
    let matches2 = getMatches();
    function handleChange() {
      matches2 = getMatches();
    }
    mediaQuery.addEventListener("change", handleChange);
    return matches2;
  }
  var useMemo = (fn, options = {}) => {
    const cache = /* @__PURE__ */ new Map();
    const { maxSize } = options;
    const memoized = (...args) => {
      const key = JSON.stringify(args);
      if (cache.has(key)) {
        return cache.get(key);
      }
      const result = fn(...args);
      if (maxSize && cache.size >= maxSize) {
        const firstKey = cache.keys().next().value;
        if (typeof firstKey === "string") {
          cache.delete(firstKey);
        }
      }
      cache.set(key, result);
      return result;
    };
    memoized.clearCache = () => {
      cache.clear();
      return true;
    };
    return memoized;
  };
  function usePipe(...functions) {
    if (!functions.every((fn) => typeof fn === "function")) {
      throw new Error("usePipe: \u0432\u0441\u0435 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u044B \u0434\u043E\u043B\u0436\u043D\u044B \u0431\u044B\u0442\u044C \u0444\u0443\u043D\u043A\u0446\u0438\u044F\u043C\u0438");
    }
    switch (functions.length) {
      case 0:
        return (x5) => x5;
      case 1:
        return functions[0];
      case 2: {
        const [f5, g5] = functions;
        return (...args) => g5(f5(...args));
      }
      default:
        return function piped(...args) {
          let result = functions[0](...args);
          for (let i3 = 1; i3 < functions.length; i3++) {
            result = functions[i3](result);
          }
          return result;
        };
    }
  }
  function useQueue() {
    const queue = [];
    return {
      enqueue: (item) => {
        queue.push(item);
        return queue.length;
      },
      dequeue: () => queue.shift(),
      peek: () => queue[0] || null,
      size: () => queue.length,
      isEmpty: () => queue.length === 0,
      clear: () => {
        queue.length = 0;
      }
    };
  }
  var state = [];
  var stateIndex = -1;
  var StateValue = class {
    constructor(index) {
      this.index = index;
    }
    valueOf() {
      return state[this.index].value;
    }
    toString() {
      const value = state[this.index].value;
      return String(value);
    }
    [Symbol.toPrimitive](hint) {
      const value = state[this.index].value;
      if (hint === "number" && typeof value === "number") return value;
      if (hint === "string") return String(value);
      return value;
    }
  };
  var useState = (initialState, onStateChange) => {
    const index = stateIndex++;
    if (!state[index]) {
      state[index] = { value: initialState };
    }
    const stateValue = new StateValue(index);
    const setState = (arg) => {
      const old = state[index].value;
      const newValue = typeof arg === "function" ? arg(old) : arg;
      state[index].value = newValue;
      if (typeof onStateChange === "function") {
        onStateChange(newValue, old);
      }
    };
    return [stateValue, setState];
  };
  function useThrottle(fn, wait, options = {}) {
    if (typeof fn !== "function") {
      throw new Error("useThrottle: \u043F\u0435\u0440\u0432\u044B\u0439 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442 \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C \u0444\u0443\u043D\u043A\u0446\u0438\u0435\u0439");
    }
    if (wait < 0) {
      throw new Error("useThrottle: \u0432\u0440\u0435\u043C\u044F \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043F\u043E\u043B\u043E\u0436\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u043C \u0447\u0438\u0441\u043B\u043E\u043C");
    }
    let timer = null;
    let lastArgs = null;
    let lastThis = null;
    let result;
    let lastCallTime = null;
    const { leading = true, trailing = true } = options;
    function invokeFunction() {
      result = fn.apply(lastThis, lastArgs);
      lastArgs = lastThis = null;
      lastCallTime = Date.now();
    }
    function throttled(...args) {
      const now = Date.now();
      if (!lastCallTime && !leading) {
        lastCallTime = now;
      }
      const remainingTime = wait - (now - lastCallTime);
      lastArgs = args;
      lastThis = this;
      if (remainingTime <= 0 || remainingTime > wait) {
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        invokeFunction();
      } else if (!timer && trailing) {
        timer = setTimeout(() => {
          timer = null;
          if (trailing && lastArgs) {
            invokeFunction();
          }
        }, remainingTime);
      }
      return result;
    }
    throttled.cancel = function() {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      lastArgs = lastThis = null;
      lastCallTime = null;
    };
    return throttled;
  }
  function useToggle(initialValue = false) {
    let value = initialValue;
    return {
      get: () => value,
      toggle: () => {
        value = !value;
        return value;
      },
      set: (newValue) => {
        value = newValue;
        return value;
      }
    };
  }
  var version2 = "0.13.0";
  var build_time2 = "07.03.2025, 23:32:05";
  var info2 = () => {
    console.info(`%c Hooks %c v${version2} %c ${build_time2} `, "color: #ffffff; font-weight: bold; background: #5c2c05", "color: white; background: darkgreen", "color: white; background: #0080fe;");
  };

  // ../metroui-lib/source/hooks/index.js
  globalThis.Hooks = hooks_exports;

  // ../metroui-lib/node_modules/@olton/farbe/dist/farbe.js
  var Le = Object.defineProperty;
  var $e = (e2, t) => {
    for (var s2 in t) Le(e2, s2, { get: t[s2], enumerable: true });
  };
  var xe = {};
  $e(xe, { Primitives: () => ue, add: () => we, brighten: () => _e, cmyk2rgb: () => de, cmyk2websafe: () => He, colorDefaultProps: () => X2, colorToString: () => he, colorType: () => S2, colorTypes: () => p, create: () => Ne, createColor: () => Me, createColorScheme: () => ke, darken: () => pe, desaturate: () => ve, equal: () => fe, expand: () => Ee, expandHexColor: () => j2, grayscale: () => ce, hex2hsv: () => Ye, hex2rgb: () => ee, hex2websafe: () => Ce, hsl2hsv: () => ie, hsl2websafe: () => Ge, hsv2hex: () => Oe, hsv2hsl: () => se, hsv2rgb: () => H2, hsv2websafe: () => Be, hueShift: () => be, isCMYK: () => T2, isColor: () => y, isDark: () => Z2, isHEX: () => Q2, isHSL: () => I2, isHSLA: () => N2, isHSV: () => K2, isLight: () => oe, isPrimitive: () => Ae, isRGB: () => U2, isRGBA: () => L2, lighten: () => V2, mix: () => g2, multiply: () => re, parse: () => J2, parseColor: () => _2, random: () => qe, randomColor: () => ae, rgb2cmyk: () => le, rgb2hex: () => te, rgb2hsv: () => k2, rgb2websafe: () => F2, rgba2websafe: () => Se, saturate: () => P, shade: () => ge, spin: () => me, test: () => ye, toCMYK: () => D2, toColor: () => x2, toHEX: () => M3, toHSL: () => W2, toHSLA: () => $4, toHSV: () => E2, toRGB: () => c2, toRGBA: () => A2, websafe: () => ne });
  var d = class {
    constructor(t = 0, s2 = 0, n3 = 0) {
      this.h = t, this.s = s2, this.v = n3;
    }
    toString() {
      return "hsv(" + [Math.round(this.h), Math.round(this.s * 100) + "%", Math.round(this.v * 100) + "%"].join(",") + ")";
    }
  };
  var C2 = class {
    constructor(t = 0, s2 = 0, n3 = 0) {
      this.h = t, this.s = ("" + s2).includes("%") ? parseInt(s2) / 100 : s2, this.l = ("" + n3).includes("%") ? parseInt(n3) / 100 : n3;
    }
    toString() {
      return "hsl(" + [Math.round(this.h), Math.round(this.s * 100) + "%", Math.round(this.l * 100) + "%"].join(",") + ")";
    }
  };
  var B2 = class {
    constructor(t = 0, s2 = 0, n3 = 0, r2 = 0) {
      this.h = t, this.s = ("" + s2).includes("%") ? parseInt(s2) / 100 : s2, this.l = ("" + n3).includes("%") ? parseInt(n3) / 100 : n3, this.a = r2;
    }
    toString() {
      return "hsla(" + [Math.round(this.h), Math.round(this.s * 100) + "%", Math.round(this.l * 100) + "%", parseFloat(this.a).toFixed(2)].join(",") + ")";
    }
  };
  var b2 = class {
    constructor(t = 0, s2 = 0, n3 = 0) {
      this.r = t, this.g = s2, this.b = n3;
    }
    toString() {
      return `rgb(${this.r},${this.g},${this.b})`;
    }
  };
  var w2 = class {
    constructor(t = 0, s2 = 0, n3 = 0, r2 = 0) {
      this.r = t, this.g = s2, this.b = n3, this.a = r2;
    }
    toString() {
      return `rgba(${this.r},${this.g},${this.b},${this.a})`;
    }
  };
  var G3 = class {
    constructor(t = 0, s2 = 0, n3 = 0, r2 = 0) {
      this.c = t, this.m = s2, this.y = n3, this.k = r2;
    }
    toString() {
      return `cmyk(${this.c},${this.m},${this.y},${this.k})`;
    }
  };
  var q2 = { aliceBlue: "#f0f8ff", antiqueWhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000000", blanchedAlmond: "#ffebcd", blue: "#0000ff", blueViolet: "#8a2be2", brown: "#a52a2a", burlyWood: "#deb887", cadetBlue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerBlue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkBlue: "#00008b", darkCyan: "#008b8b", darkGoldenRod: "#b8860b", darkGray: "#a9a9a9", darkGreen: "#006400", darkKhaki: "#bdb76b", darkMagenta: "#8b008b", darkOliveGreen: "#556b2f", darkOrange: "#ff8c00", darkOrchid: "#9932cc", darkRed: "#8b0000", darkSalmon: "#e9967a", darkSeaGreen: "#8fbc8f", darkSlateBlue: "#483d8b", darkSlateGray: "#2f4f4f", darkTurquoise: "#00ced1", darkViolet: "#9400d3", deepPink: "#ff1493", deepSkyBlue: "#00bfff", dimGray: "#696969", dodgerBlue: "#1e90ff", fireBrick: "#b22222", floralWhite: "#fffaf0", forestGreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#DCDCDC", ghostWhite: "#F8F8FF", gold: "#ffd700", goldenRod: "#daa520", gray: "#808080", green: "#008000", greenYellow: "#adff2f", honeyDew: "#f0fff0", hotPink: "#ff69b4", indianRed: "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavender: "#e6e6fa", lavenderBlush: "#fff0f5", lawnGreen: "#7cfc00", lemonChiffon: "#fffacd", lightBlue: "#add8e6", lightCoral: "#f08080", lightCyan: "#e0ffff", lightGoldenRodYellow: "#fafad2", lightGray: "#d3d3d3", lightGreen: "#90ee90", lightPink: "#ffb6c1", lightSalmon: "#ffa07a", lightSeaGreen: "#20b2aa", lightSkyBlue: "#87cefa", lightSlateGray: "#778899", lightSteelBlue: "#b0c4de", lightYellow: "#ffffe0", lime: "#00ff00", limeGreen: "#32dc32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumAquaMarine: "#66cdaa", mediumBlue: "#0000cd", mediumOrchid: "#ba55d3", mediumPurple: "#9370db", mediumSeaGreen: "#3cb371", mediumSlateBlue: "#7b68ee", mediumSpringGreen: "#00fa9a", mediumTurquoise: "#48d1cc", mediumVioletRed: "#c71585", midnightBlue: "#191970", mintCream: "#f5fffa", mistyRose: "#ffe4e1", moccasin: "#ffe4b5", navajoWhite: "#ffdead", navy: "#000080", oldLace: "#fdd5e6", olive: "#808000", oliveDrab: "#6b8e23", orange: "#ffa500", orangeRed: "#ff4500", orchid: "#da70d6", paleGoldenRod: "#eee8aa", paleGreen: "#98fb98", paleTurquoise: "#afeeee", paleVioletRed: "#db7093", papayaWhip: "#ffefd5", peachPuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderBlue: "#b0e0e6", purple: "#800080", rebeccaPurple: "#663399", red: "#ff0000", rosyBrown: "#bc8f8f", royalBlue: "#4169e1", saddleBrown: "#8b4513", salmon: "#fa8072", sandyBrown: "#f4a460", seaGreen: "#2e8b57", seaShell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", slyBlue: "#87ceeb", slateBlue: "#6a5acd", slateGray: "#708090", snow: "#fffafa", springGreen: "#00ff7f", steelBlue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", white: "#ffffff", whiteSmoke: "#f5f5f5", yellow: "#ffff00", yellowGreen: "#9acd32" };
  var z2 = { lime: "#a4c400", green: "#60a917", emerald: "#008a00", blue: "#00AFF0", teal: "#00aba9", cyan: "#1ba1e2", cobalt: "#0050ef", indigo: "#6a00ff", violet: "#aa00ff", pink: "#dc4fad", magenta: "#d80073", crimson: "#a20025", red: "#CE352C", orange: "#fa6800", amber: "#f0a30a", yellow: "#fff000", brown: "#825a2c", olive: "#6d8764", steel: "#647687", mauve: "#76608a", taupe: "#87794e" };
  var Ve = { color: function(e2, t = q2, s2 = void 0) {
    return t[e2] !== void 0 ? t[e2] : s2;
  }, palette: function(e2 = q2) {
    return Object.keys(e2);
  }, colors: function(e2 = q2) {
    return Object.values(e2);
  } };
  var ue = { HSV: d, HSL: C2, HSLA: B2, RGB: b2, RGBA: w2, CMYK: G3 };
  var p = { HEX: "hex", RGB: "rgb", RGBA: "rgba", HSV: "hsv", HSL: "hsl", HSLA: "hsla", CMYK: "cmyk", UNKNOWN: "unknown" };
  var X2 = { angle: 30, algorithm: 1, step: 0.1, distance: 5, tint1: 0.8, tint2: 0.4, shade1: 0.6, shade2: 0.3, alpha: 1, baseLight: "#ffffff", baseDark: "self" };
  function Pe(e2, t) {
    let s2;
    switch (t) {
      case "hex":
        s2 = e2.map(function(n3) {
          return M3(n3);
        });
        break;
      case "rgb":
        s2 = e2.map(function(n3) {
          return c2(n3);
        });
        break;
      case "rgba":
        s2 = e2.map(function(n3) {
          return A2(n3, opt.alpha);
        });
        break;
      case "hsl":
        s2 = e2.map(function(n3) {
          return W2(n3);
        });
        break;
      case "hsla":
        s2 = e2.map(function(n3) {
          return $4(n3, opt.alpha);
        });
        break;
      case "cmyk":
        s2 = e2.map(function(n3) {
          return D2(n3);
        });
        break;
      default:
        s2 = e2;
    }
    return s2;
  }
  function R2(e2, t, s2) {
    return Math.max(t, Math.min(e2, s2));
  }
  function m2(e2, t, s2) {
    return e2 < t ? t : e2 > s2 ? s2 : e2;
  }
  function v2(e2, t) {
    for (e2 += t; e2 >= 360; ) e2 -= 360;
    for (; e2 < 0; ) e2 += 360;
    return e2;
  }
  var ye = (e2) => {
    let t = (a2) => /^#([A-Fa-f0-9]{3}){1,2}$/.test(a2), s2 = (a2) => /^rgb\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)$/.test(a2), n3 = (a2) => /^rgba\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*(0(\.\d+)?|1(\.0+)?)\s*\)$/.test(a2), r2 = (a2) => /^hsv\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)$/.test(a2), u4 = (a2) => /^hsl\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)$/.test(a2), i3 = (a2) => /^hsla\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*(0(\.\d+)?|1(\.0+)?)\s*\)$/.test(a2), o2 = (a2) => /^cmyk\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)$/.test(a2);
    return t(e2) || s2(e2) || r2(e2) || i3(e2) || i3(e2) || n3(e2) || u4(e2) || o2(e2);
  };
  var Me = (e2 = "hex", t = "#000000") => {
    let s2;
    return typeof t == "string" && (s2 = _2(t)), y(s2) || (s2 = "#000000"), x2(s2, e2.toLowerCase());
  };
  var Ne = Me;
  var j2 = function(e2) {
    if (y(e2) && typeof e2 != "string") return e2;
    if (typeof e2 != "string") throw new Error("Value is not a string!");
    if (e2[0] === "#" && e2.length === 4) {
      let t = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      return "#" + e2.replace(t, (s2, n3, r2, u4) => n3 + n3 + r2 + r2 + u4 + u4);
    }
    return e2[0] === "#" ? e2 : "#" + e2;
  };
  var Ee = j2;
  var Z2 = (e2) => {
    if (e2 = _2(e2), !y(e2)) return;
    let t = c2(e2);
    return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3 < 128;
  };
  var oe = (e2) => !Z2(e2);
  var K2 = (e2) => _2(e2) instanceof d;
  var I2 = (e2) => _2(e2) instanceof C2;
  var N2 = (e2) => _2(e2) instanceof B2;
  var U2 = (e2) => _2(e2) instanceof b2;
  var L2 = (e2) => _2(e2) instanceof w2;
  var T2 = (e2) => _2(e2) instanceof G3;
  var Q2 = (e2) => /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(e2);
  var y = (e2) => e2 ? typeof e2 == "string" ? ye(e2) : Q2(e2) || U2(e2) || L2(e2) || K2(e2) || I2(e2) || N2(e2) || T2(e2) : false;
  var S2 = (e2) => Q2(e2) ? p.HEX : U2(e2) ? p.RGB : L2(e2) ? p.RGBA : K2(e2) ? p.HSV : I2(e2) ? p.HSL : N2(e2) ? p.HSLA : T2(e2) ? p.CMYK : p.UNKNOWN;
  var fe = (e2, t) => !y(e2) || !y(t) ? false : M3(e2) === M3(t);
  var he = (e2) => e2.toString();
  var ee = (e2) => {
    let t = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(j2(e2)), s2 = [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)];
    return t ? new b2(...s2) : null;
  };
  var te = (e2) => "#" + ((1 << 24) + (e2.r << 16) + (e2.g << 8) + e2.b).toString(16).slice(1);
  var k2 = (e2) => {
    let t = new d(), s2, n3, r2, u4 = e2.r / 255, i3 = e2.g / 255, o2 = e2.b / 255, a2 = Math.max(u4, i3, o2), f5 = Math.min(u4, i3, o2), l2 = a2 - f5;
    return r2 = a2, a2 === 0 ? n3 = 0 : n3 = 1 - f5 / a2, a2 === f5 ? s2 = 0 : a2 === u4 && i3 >= o2 ? s2 = 60 * ((i3 - o2) / l2) : a2 === u4 && i3 < o2 ? s2 = 60 * ((i3 - o2) / l2) + 360 : a2 === i3 ? s2 = 60 * ((o2 - u4) / l2) + 120 : a2 === o2 ? s2 = 60 * ((u4 - i3) / l2) + 240 : s2 = 0, t.h = s2, t.s = n3, t.v = r2, t;
  };
  var H2 = (e2) => {
    let t, s2, n3, r2 = e2.h, u4 = e2.s * 100, i3 = e2.v * 100, o2 = Math.floor(r2 / 60), a2 = (100 - u4) * i3 / 100, f5 = (i3 - a2) * (r2 % 60 / 60), l2 = a2 + f5, h3 = i3 - f5;
    switch (o2) {
      case 0:
        t = i3, s2 = l2, n3 = a2;
        break;
      case 1:
        t = h3, s2 = i3, n3 = a2;
        break;
      case 2:
        t = a2, s2 = i3, n3 = l2;
        break;
      case 3:
        t = a2, s2 = h3, n3 = i3;
        break;
      case 4:
        t = l2, s2 = a2, n3 = i3;
        break;
      case 5:
        t = i3, s2 = a2, n3 = h3;
        break;
    }
    return new b2(Math.round(t * 255 / 100), Math.round(s2 * 255 / 100), Math.round(n3 * 255 / 100));
  };
  var Oe = (e2) => te(H2(e2));
  var Ye = (e2) => k2(ee(e2));
  var le = (e2) => {
    let t = new G3(), s2 = e2.r / 255, n3 = e2.g / 255, r2 = e2.b / 255;
    return t.k = Math.min(1 - s2, 1 - n3, 1 - r2), t.c = 1 - t.k === 0 ? 0 : (1 - s2 - t.k) / (1 - t.k), t.m = 1 - t.k === 0 ? 0 : (1 - n3 - t.k) / (1 - t.k), t.y = 1 - t.k === 0 ? 0 : (1 - r2 - t.k) / (1 - t.k), t.c = Math.round(t.c * 100), t.m = Math.round(t.m * 100), t.y = Math.round(t.y * 100), t.k = Math.round(t.k * 100), t;
  };
  var de = (e2) => {
    let t = Math.floor(255 * (1 - e2.c / 100) * (1 - e2.k / 100)), s2 = Math.ceil(255 * (1 - e2.m / 100) * (1 - e2.k / 100)), n3 = Math.ceil(255 * (1 - e2.y / 100) * (1 - e2.k / 100));
    return new b2(t, s2, n3);
  };
  var se = (e2) => {
    let t, s2, n3, r2;
    return t = parseInt(e2.h), n3 = (2 - e2.s) * e2.v, s2 = e2.s * e2.v, n3 === 0 ? s2 = 0 : (r2 = n3 <= 1 ? n3 : 2 - n3, r2 === 0 ? s2 = 0 : s2 /= r2), n3 /= 2, Number.isNaN(s2) && (s2 = 0), Number.isNaN(n3) && (n3 = 0), new C2(t, s2, n3);
  };
  var ie = (e2) => {
    let t, s2, n3, r2;
    return t = e2.h, r2 = e2.l * 2, s2 = e2.s * (r2 <= 1 ? r2 : 2 - r2), n3 = (r2 + s2) / 2, r2 + s2 === 0 ? s2 = 0 : s2 = 2 * s2 / (r2 + s2), new d(t, s2, n3);
  };
  var F2 = (e2) => new b2(Math.round(e2.r / 51) * 51, Math.round(e2.g / 51) * 51, Math.round(e2.b / 51) * 51);
  var Se = (e2) => {
    let t = F2(e2);
    return new w2(t.r, t.g, t.b, e2.a);
  };
  var Ce = (e2) => te(F2(ee(e2)));
  var Be = (e2) => k2(F2(c2(e2)));
  var Ge = (e2) => se(k2(F2(c2(e2))));
  var He = (e2) => le(F2(de(e2)));
  var ne = (e2) => Q2(e2) ? Ce(e2) : U2(e2) ? F2(e2) : L2(e2) ? Se(e2) : K2(e2) ? Be(e2) : I2(e2) ? Ge(e2) : T2(e2) ? He(e2) : e2;
  var x2 = (e2, t = "rgb", s2 = 1) => {
    let n3;
    switch (t.toLowerCase()) {
      case "hex":
        n3 = M3(e2);
        break;
      case "rgb":
        n3 = c2(e2);
        break;
      case "rgba":
        n3 = A2(e2, s2);
        break;
      case "hsl":
        n3 = W2(e2);
        break;
      case "hsla":
        n3 = $4(e2, s2);
        break;
      case "hsv":
        n3 = E2(e2);
        break;
      case "cmyk":
        n3 = D2(e2);
        break;
      default:
        n3 = e2;
    }
    return n3;
  };
  var M3 = (e2) => typeof e2 == "string" && e2[0] === "#" ? j2(e2) : te(c2(J2(e2)));
  var c2 = (e2) => {
    if (U2(e2)) return e2;
    if (L2(e2)) return new b2(e2.r, e2.g, e2.b);
    if (K2(e2)) return H2(e2);
    if (I2(e2) || N2(e2)) return H2(ie(e2));
    if (Q2(e2)) return ee(e2);
    if (T2(e2)) return de(e2);
    throw new Error("Unknown color format!");
  };
  var A2 = (e2, t) => {
    if (L2(e2)) return typeof t < "u" && (e2.a = t), e2;
    let s2 = c2(e2);
    return new w2(s2.r, s2.g, s2.b, typeof e2.a < "u" ? e2.a : t);
  };
  var E2 = (e2) => K2(e2) ? e2 : k2(c2(e2));
  var W2 = (e2) => I2(e2) ? e2 : se(k2(c2(e2)));
  var $4 = (e2, t = 1) => {
    if (N2(e2)) return t && (e2.a = t), e2;
    let s2 = se(k2(c2(e2)));
    return s2.a = typeof e2.a < "u" ? e2.a : t, new B2(s2.h, s2.s, s2.l, s2.a);
  };
  var D2 = (e2) => T2(e2) ? e2 : le(c2(e2));
  var ce = (e2) => {
    let t = c2(e2), s2 = S2(e2).toLowerCase(), n3 = Math.round(t.r * 0.2125 + t.g * 0.7154 + t.b * 0.0721), r2 = new b2(n3, n3, n3);
    return x2(r2, s2);
  };
  var pe = (e2, t = 10) => V2(e2, -1 * Math.abs(t));
  var V2 = (e2, t = 10) => {
    let s2 = S2(e2).toLowerCase(), n3 = $4(e2);
    return n3.l += t / 100, n3.l = R2(n3.l, 0, 1), x2(n3, s2);
  };
  var be = (e2, t, s2 = 1) => {
    let n3 = E2(e2), r2 = S2(e2).toLowerCase(), u4 = n3.h;
    for (u4 += t; u4 >= 360; ) u4 -= 360;
    for (; u4 < 0; ) u4 += 360;
    return n3.h = u4, x2(n3, r2, s2);
  };
  var g2 = (e2, t, s2) => {
    s2 = s2 === 0 ? 0 : s2 || 50;
    let n3 = new b2(0, 0, 0), r2 = c2(e2), u4 = c2(t), i3 = s2 / 100;
    return n3.r = Math.round((u4.r - r2.r) * i3 + r2.r), n3.g = Math.round((u4.g - r2.g) * i3 + r2.g), n3.b = Math.round((u4.b - r2.b) * i3 + r2.b), M3(n3);
  };
  var re = (e2, t) => {
    let s2 = c2(e2), n3 = c2(t), r2 = new b2();
    return s2.b = Math.floor(s2.b * n3.b / 255), s2.g = Math.floor(s2.g * n3.g / 255), s2.r = Math.floor(s2.r * n3.r / 255), M3(r2);
  };
  var ge = (e2, t) => {
    if (!y(e2)) throw new Error(e2 + " is not a valid color value!");
    t /= 100;
    let s2 = S2(e2).toLowerCase(), n3 = c2(e2), r2 = t < 0 ? 0 : 255, u4 = t < 0 ? t * -1 : t, i3, o2, a2, f5;
    return i3 = Math.round((r2 - n3.r) * u4) + n3.r, o2 = Math.round((r2 - n3.g) * u4) + n3.g, a2 = Math.round((r2 - n3.b) * u4) + n3.b, (s2 === p.RGBA || s2 === p.HSLA) && (f5 = e2.a), x2(new b2(i3, o2, a2), s2, f5);
  };
  var P = (e2, t) => {
    let s2 = S2(e2).toLowerCase(), n3 = $4(e2);
    return n3.s += t / 100, n3.s = R2(n3.s, 0, 1), x2(n3, s2);
  };
  var ve = (e2, t) => P(e2, -1 * Math.abs(t));
  var me = (e2, t) => {
    let s2, n3, r2, u4;
    if (!y(e2)) throw new Error(e2 + " is not a valid color value!");
    return s2 = W2(e2), u4 = s2.h + t, u4 > 360 ? u4 = u4 % 360 : u4 < 0 && (u4 = 360 + u4 % 360), s2.h = u4, n3 = S2(e2).toLowerCase(), (n3 === p.RGBA || n3 === p.HSLA) && (r2 = e2.a), n3 === "hsl" ? s2 : x2(s2, n3, r2);
  };
  var _e = (e2, t) => {
    let s2 = 1, n3 = S2(e2).toLowerCase(), r2 = E2(e2);
    return (n3 === p.RGBA || n3 === p.HSLA) && (s2 = e2.a), r2.v += t / 100, r2.v = R2(r2.v, 0, 1), x2(r2, n3, s2);
  };
  var we = (e2, t, s2) => {
    let n3 = J2(e2), r2 = J2(t), u4 = A2(n3, void 0), i3 = A2(r2, void 0), o2 = new w2(), a2 = ("" + s2).toLowerCase() || "hex";
    return o2.r = Math.round((u4.r + i3.r) / 2), o2.g = Math.round((u4.g + i3.g) / 2), o2.b = Math.round((u4.b + i3.b) / 2), o2.a = Math.round((u4.a + i3.a) / 2), x2(o2, s2, o2.a);
  };
  var ke = (e2, t, s2 = p.HEX, n3) => {
    let r2 = Object.assign({}, X2, n3), u4, i3 = [], o2, a2, f5, l2, h3;
    if (o2 = E2(e2), K2(o2) === false) return console.warn("The value is a not supported color format!"), false;
    switch (f5 = o2.h, l2 = o2.s, h3 = o2.v, t) {
      case "monochromatic":
      case "mono": {
        if (r2.algorithm === 1) a2 = H2(o2), a2.r = m2(Math.round(a2.r + (255 - a2.r) * r2.tint1), 0, 255), a2.g = m2(Math.round(a2.g + (255 - a2.g) * r2.tint1), 0, 255), a2.b = m2(Math.round(a2.b + (255 - a2.b) * r2.tint1), 0, 255), i3.push(k2(a2)), a2 = H2(o2), a2.r = m2(Math.round(a2.r + (255 - a2.r) * r2.tint2), 0, 255), a2.g = m2(Math.round(a2.g + (255 - a2.g) * r2.tint2), 0, 255), a2.b = m2(Math.round(a2.b + (255 - a2.b) * r2.tint2), 0, 255), i3.push(k2(a2)), i3.push(o2), a2 = H2(o2), a2.r = m2(Math.round(a2.r * r2.shade1), 0, 255), a2.g = m2(Math.round(a2.g * r2.shade1), 0, 255), a2.b = m2(Math.round(a2.b * r2.shade1), 0, 255), i3.push(k2(a2)), a2 = H2(o2), a2.r = m2(Math.round(a2.r * r2.shade2), 0, 255), a2.g = m2(Math.round(a2.g * r2.shade2), 0, 255), a2.b = m2(Math.round(a2.b * r2.shade2), 0, 255), i3.push(k2(a2));
        else if (r2.algorithm === 2) for (i3.push(o2), u4 = 1; u4 <= r2.distance; u4++) h3 = R2(h3 - r2.step, 0, 1), l2 = R2(l2 - r2.step, 0, 1), i3.push({ h: f5, s: l2, v: h3 });
        else if (r2.algorithm === 3) for (i3.push(o2), u4 = 1; u4 <= r2.distance; u4++) h3 = R2(h3 - r2.step, 0, 1), i3.push({ h: f5, s: l2, v: h3 });
        else h3 = R2(o2.v + r2.step * 2, 0, 1), i3.push({ h: f5, s: l2, v: h3 }), h3 = R2(o2.v + r2.step, 0, 1), i3.push({ h: f5, s: l2, v: h3 }), i3.push(o2), l2 = o2.s, h3 = o2.v, h3 = R2(o2.v - r2.step, 0, 1), i3.push({ h: f5, s: l2, v: h3 }), h3 = R2(o2.v - r2.step * 2, 0, 1), i3.push({ h: f5, s: l2, v: h3 });
        break;
      }
      case "complementary":
      case "complement":
      case "comp": {
        i3.push(o2), f5 = v2(o2.h, 180), i3.push(new d(f5, l2, h3));
        break;
      }
      case "double-complementary":
      case "double-complement":
      case "double": {
        i3.push(o2), f5 = v2(f5, 180), i3.push(new d(f5, l2, h3)), f5 = v2(f5, r2.angle), i3.push(new d(f5, l2, h3)), f5 = v2(f5, 180), i3.push(new d(f5, l2, h3));
        break;
      }
      case "analogous":
      case "analog": {
        f5 = v2(f5, r2.angle), i3.push(new d(f5, l2, h3)), i3.push(o2), f5 = v2(o2.h, 0 - r2.angle), i3.push(new d(f5, l2, h3));
        break;
      }
      case "triadic":
      case "triad": {
        for (i3.push(o2), u4 = 1; u4 < 3; u4++) f5 = v2(f5, 120), i3.push(new d(f5, l2, h3));
        break;
      }
      case "tetradic":
      case "tetra": {
        i3.push(o2), f5 = v2(o2.h, 180), i3.push(new d(f5, l2, h3)), f5 = v2(o2.h, -1 * r2.angle), i3.push(new d(f5, l2, h3)), f5 = v2(f5, 180), i3.push(new d(f5, l2, h3));
        break;
      }
      case "square": {
        for (i3.push(o2), u4 = 1; u4 < 4; u4++) f5 = v2(f5, 90), i3.push(new d(f5, l2, h3));
        break;
      }
      case "split-complementary":
      case "split-complement":
      case "split": {
        f5 = v2(f5, 180 - r2.angle), i3.push(new d(f5, l2, h3)), i3.push(o2), f5 = v2(o2.h, 180 + r2.angle), i3.push(new d(f5, l2, h3));
        break;
      }
      case "material": {
        var O4 = r2.baseLight, Y4 = r2.baseDark === "self" || !r2.baseDark ? re(e2, e2) : r2.baseDark;
        i3.push({ 50: g2(O4, e2, 10), 100: g2(O4, e2, 30), 200: g2(O4, e2, 50), 300: g2(O4, e2, 70), 400: g2(O4, e2, 85), 500: g2(O4, e2, 100), 600: g2(Y4, e2, 92), 700: g2(Y4, e2, 83), 800: g2(Y4, e2, 74), 900: g2(Y4, e2, 65), A100: V2(P(g2(Y4, e2, 15), 80), 65), A200: V2(P(g2(Y4, e2, 15), 80), 55), A400: V2(P(g2(O4, e2, 100), 55), 10), A700: V2(P(g2(Y4, e2, 83), 65), 10) });
        break;
      }
      default:
        console.error("Unknown schema name");
    }
    return t === "material" ? i3[0] : Pe(i3, s2);
  };
  var Ae = (e2) => e2 instanceof d || e2 instanceof C2 || e2 instanceof B2 || e2 instanceof b2 || e2 instanceof w2 || e2 instanceof G3;
  var _2 = function(e2) {
    if (Ae(e2)) return e2;
    let t = ("" + e2).toLowerCase();
    typeof q2[t] < "u" && (t = q2[t]), typeof z2[t] < "u" && (t = z2[t]);
    let s2 = t.replace(/[^\d.,%]/g, "").split(",").map((n3) => isNaN(n3) ? n3 : +n3);
    return t[0] === "#" ? j2(t) : t.includes("rgba") ? new w2(s2[0], s2[1], s2[2], s2[3]) : t.includes("rgb") ? new b2(s2[0], s2[1], s2[2]) : t.includes("cmyk") ? new G3(s2[0], s2[1], s2[2], s2[3]) : t.includes("hsv") ? new d(s2[0], s2[1], s2[2]) : t.includes("hsla") ? new B2(s2[0], s2[1], s2[2], s2[3]) : t.includes("hsl") ? new C2(s2[0], s2[1], s2[2]) : t;
  };
  var J2 = _2;
  var ae = (e2 = "hex", t = 1) => {
    let s2 = (o2, a2) => Math.floor(o2 + Math.random() * (a2 + 1 - o2)), n3, r2, u4, i3;
    return r2 = s2(0, 255), u4 = s2(0, 255), i3 = s2(0, 255), n3 = "#" + ((1 << 24) + (r2 << 16) + (u4 << 8) + i3).toString(16).slice(1), e2 === "hex" ? n3 : x2(n3, e2, t);
  };
  var qe = ae;
  var Re = class {
    _setValue(t) {
      t || (t = "#000000"), typeof t == "string" && (t = _2(t)), t && y(t) ? this._value = t : this._value = void 0;
    }
    _setOptions(t) {
      this._options = Object.assign({}, X2, t);
    }
    constructor(t = "#000000", s2 = null) {
      this._setValue(t), this._setOptions(s2);
    }
    get options() {
      return this._options;
    }
    set options(t) {
      this._setOptions(t);
    }
    get value() {
      return this._value ? this._value : void 0;
    }
    set value(t) {
      this._setValue(t);
    }
    toRGB() {
      if (this._value) return this._value = c2(this._value), this;
    }
    get rgb() {
      return this._value ? c2(this._value) : void 0;
    }
    toRGBA(t) {
      if (this._value) return L2(this._value) ? t && (this._value = A2(this._value, t)) : this._value = A2(this._value, t || X2.alpha), this;
    }
    get rgba() {
      return this._value ? L2(this._value) ? this._value : A2(this._value, this._options.alpha) : void 0;
    }
    toHEX() {
      if (this._value) return this._value = M3(this._value), this;
    }
    get hex() {
      return this._value ? M3(this._value) : void 0;
    }
    toHSV() {
      if (this._value) return this._value = E2(this._value), this;
    }
    get hsv() {
      return this._value ? E2(this._value) : void 0;
    }
    toHSL() {
      if (this._value) return this._value = W2(this._value), this;
    }
    get hsl() {
      return this._value ? W2(this._value) : void 0;
    }
    toHSLA(t) {
      if (this._value) return N2(this._value) ? t && (this._value = $4(this._value, t)) : this._value = $4(this._value, t), this;
    }
    get hsla() {
      return this._value ? N2(this._value) ? this._value : $4(this._value, this._options.alpha) : void 0;
    }
    toCMYK() {
      if (this._value) return this._value = D2(this._value), this;
    }
    get cmyk() {
      return this._value ? D2(this._value) : void 0;
    }
    toWebsafe() {
      if (this._value) return this._value = ne(this._value), this;
    }
    get websafe() {
      return this._value ? ne(this._value) : void 0;
    }
    toString() {
      return this._value ? he(this._value) : void 0;
    }
    darken(t = 10) {
      if (this._value) return this._value = pe(this._value, t), this;
    }
    lighten(t = 10) {
      if (this._value) return this._value = V2(this._value, t), this;
    }
    isDark() {
      return this._value ? Z2(this._value) : void 0;
    }
    isLight() {
      return this._value ? oe(this._value) : void 0;
    }
    hueShift(t) {
      if (this._value) return this._value = be(this._value, t), this;
    }
    grayscale() {
      if (!(!this._value || this.type === p.UNKNOWN)) return this._value = ce(this._value, ("" + this.type).toLowerCase()), this;
    }
    get type() {
      return S2(this._value);
    }
    getScheme(t, s2, n3) {
      return this._value ? ke(this._value, t, s2, n3) : void 0;
    }
    equal(t) {
      return fe(this._value, t);
    }
    random(t, s2) {
      this._value = ae(t, s2);
    }
    channel(t, s2) {
      let n3 = `${this.type}`.toUpperCase();
      if (["red", "green", "blue"].includes(t)) {
        this.toRGB();
        let r2 = { red: "r", green: "g", blue: "b" };
        this._value[r2[t]] = s2, this[`to${n3}`]();
      }
      if (t === "alpha" && this._value.a && (this._value.a = s2), ["hue", "saturation", "value"].includes(t)) {
        this.toHSV();
        let r2 = { hue: "h", saturation: "s", value: "v" };
        this._value[r2[t]] = s2, this[`to${n3}`]();
      }
      if (["lightness"].includes(t) && (this.toHSL(), this._value.l = s2, this[`to${n3}`]()), ["cyan", "magenta", "yellow", "black"].includes(t)) {
        this.toCMYK();
        let r2 = { cyan: "c", magenta: "m", yellow: "y", black: "k" };
        this._value[r2[t]] = s2, this[`to${n3}`]();
      }
      return this;
    }
    add(t) {
      this._setValue(we(this._value, t));
    }
    mix(t, s2) {
      this._setValue(g2(this._value, t, s2));
    }
    multiply(t) {
      this._setValue(re(this._value, t));
    }
    shade(t) {
      this._setValue(ge(this._value, t));
    }
    saturate(t) {
      this._setValue(P(this._value, t));
    }
    desaturate(t) {
      this._setValue(ve(this._value, t));
    }
    spin(t) {
      this._setValue(me(this._value, t));
    }
    brighten(t) {
      this._setValue(_e(this._value, t));
    }
  };
  var ut2 = { ...ue };
  var Ke = "1.0.4";
  var Fe = "11.08.2024, 23:47:03";
  var ot2 = () => {
    console.info(`%c Farbe %c v${Ke} %c ${Fe} `, "color: #ffffff; font-weight: bold; background: #ff00ff", "color: white; background: darkgreen", "color: white; background: #0080fe;");
  };

  // ../metroui-lib/source/farbe/index.js
  globalThis.Farbe = Re;
  globalThis.farbe = (c5) => new Re(c5);
  globalThis.Farbe.Routines = xe;
  globalThis.Farbe.Palette = Ve;
  globalThis.Farbe.StandardColors = q2;
  globalThis.Farbe.MetroColors = z2;
  globalThis.Farbe.Primitives = ut2;
  globalThis.Farbe.info = ot2;

  // ../metroui-lib/node_modules/@olton/html/dist/html.js
  var br = Object.defineProperty;
  var wr2 = (t, o2) => {
    for (var r2 in o2) br(t, r2, { get: o2[r2], enumerable: true });
  };
  function te2(t) {
    return t.replace(/([A-Z])/g, function(o2) {
      return "-" + o2.toLowerCase();
    });
  }
  function pe2(t = []) {
    return Array.isArray(t) ? t.join(" ") : t.toString();
  }
  var me2 = ["opacity", "zIndex", "order", "zoom"];
  function ee2(t = {}) {
    return typeof t == "string" ? t : Object.keys(t).map((o2) => {
      let r2 = te2(o2), a2 = t[o2];
      return !me2.includes(r2) && !isNaN(a2) && (a2 += "px"), `${r2}: ${a2}`;
    }).join(";");
  }
  var ce2 = ["accesskey", "autocapitalize", "autofocus", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "inert", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "popover", "spellcheck", "style", "tabindex", "title", "translate", "writingsuggestions"];
  var le2 = (t) => {
    let o2, r2, a2 = [], s2, l2, re3 = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    if (typeof t == "string") {
      if (t = t.trim(), s2 = document.implementation.createHTMLDocument(""), o2 = s2.createElement("base"), o2.href = document.location.href, s2.head.appendChild(o2), l2 = s2.body, r2 = re3.exec(t), r2) return document.createElement(r2[1]);
      l2.innerHTML = t;
      for (let se3 = 0; se3 < l2.childNodes.length; se3++) a2.push(l2.childNodes[se3]);
      return a2[0];
    }
  };
  var fe2 = ["onauxclick", "onbeforeinput", "onbeforematch", "onbeforetoggle", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncontextlost", "oncontextmenu", "oncontextrestored", "oncopy", "oncuechange", "oncut", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "onformdata", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onpaste", "onpause", "onplay", "onplaying", "onprogress", "onratechange", "onreset", "onresize", "onscroll", "onscrollend", "onsecuritypolicyviolation", "onseeked", "onseeking", "onselect", "onslotchange", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "ontoggle", "onvolumechange", "onwaiting", "onwheel"];
  var p2 = class {
    constructor(o2 = {}) {
      this.options = o2, this.tag = "div";
    }
    selfAttributes() {
      return [];
    }
    get attributes() {
      return this.getAttributes().join(" ");
    }
    getAttributes() {
      let o2 = [], r2 = ["hidden", "disabled", "required", "readonly", "selected", "open", "multiply", "default"], a2 = ["className", "style", "data", "tag", "events"];
      for (let s2 in this.options) if (!a2.includes(s2)) {
        if (r2.includes(s2) && this.options[s2] === true) {
          o2.push(s2);
          continue;
        }
        (this.selfAttributes().includes(s2) && !o2.includes(s2) || ce2.includes(s2)) && o2.push(`${s2}="${this.options[s2]}"`);
      }
      return this.classes && o2.push(`class="${this.classes}"`), this.styles && o2.push(`style="${this.styles}"`), this.dataSet && o2.push(this.dataSet), this.aria && o2.push(this.aria), o2;
    }
    draw() {
      return this.template();
    }
    get dataSet() {
      let { data: o2 = {} } = this.options, r2 = [];
      for (let a2 in o2) r2.push(`data-${te2(a2)}="${o2[a2]}"`);
      return r2.join(" ");
    }
    get aria() {
      let { aria: o2 = {} } = this.options, r2 = [];
      for (let a2 in o2) r2.push(`aria-${a2.toLowerCase()}="${o2[a2]}"`);
      return r2.join(" ");
    }
    get events() {
      let { events: o2 = {}, control: r2 = true } = this.options, a2 = [];
      for (let s2 in o2) r2 && !fe2.includes(s2) && console.info(`Event ${s2} for element ${this.tag} not specified in HTML specification`), a2.push(`${s2.toLowerCase()}="${o2[s2]}"`);
      return a2.join(" ");
    }
    get classes() {
      return pe2(this.options.class);
    }
    get styles() {
      return ee2(this.options.style);
    }
    template() {
      return "";
    }
    toString() {
      return this.draw();
    }
    toElement() {
      return le2(this.draw());
    }
  };
  var b3 = (t) => {
    if (Array.isArray(t)) return t.map(b3).join(`
`);
    if (typeof t == "string" || typeof t == "number" || typeof t == "boolean") return t;
    if (t.draw) return t.draw();
    throw new Error("Unknown element! " + t);
  };
  var e = class extends p2 {
    constructor(...o2) {
      let r2 = {}, a2 = [];
      for (let s2 of o2) typeof s2 == "object" && !(s2 instanceof p2) ? r2 = s2 : a2.push(s2);
      super(r2), this.children = a2;
    }
    template(o2) {
      let r2 = this.options.tag ? this.options.tag : this.tag;
      return `
            <${r2} ${this.attributes} ${this.events}>${o2}</${r2}>
        `;
    }
    draw() {
      return this.template(this.children.map(b3).join(""));
    }
  };
  var n2 = class extends p2 {
    constructor(o2 = {}) {
      super(o2), this.options = o2;
    }
    template() {
      return `
            <${this.options.tag ? this.options.tag : this.tag} ${this.attributes} ${this.events}/>
        `;
    }
  };
  var Tr = (t = [], o2 = document.body, r2 = {}) => {
    let a2, s2, { clear: l2 = true, where: re3 = "beforeend" } = r2;
    s2 = typeof o2 == "string" ? document.querySelector(o2) : o2, s2 instanceof HTMLElement || (s2 = document.body), l2 && (s2.innerHTML = ""), Array.isArray(t) || (t = [t]), a2 = t.map(b3).join(""), s2.insertAdjacentHTML(re3, a2);
  };
  var oe2 = (t = "", o2) => {
    let r2 = document.createElement("style");
    return o2 !== void 0 && r2.setAttribute("media", o2), r2.appendChild(document.createTextNode(t)), document.head.appendChild(r2), r2;
  };
  var ne2 = (t) => oe2(t).sheet;
  var ae2 = (t, o2, r2) => {
    t.insertRule(o2 + "{" + r2 + "}");
  };
  var de2 = (t, o2) => {
    if (typeof t == "string") {
      oe2(t, o2);
      return;
    }
    let r2 = ne2(o2);
    for (let a2 in t) ae2(r2, a2, ee2(t[a2]));
  };
  var ge2 = async (t, o2) => {
    let r2 = await fetch(t, o2), a2, s2;
    if (!r2.ok) throw new Error("HTTP error: " + r2.status);
    a2 = await r2.text(), s2 = document.createElement("style"), s2.appendChild(document.createTextNode(a2)), document.body.appendChild(s2);
  };
  var xe2 = async (t, o2) => {
    let r2 = await fetch(t, o2), a2, s2;
    if (!r2.ok) throw new Error("HTTP error: " + r2.status);
    a2 = await r2.text(), s2 = document.createElement("script"), s2.appendChild(document.createTextNode(a2)), document.body.appendChild(s2);
  };
  var Yt2 = {};
  wr2(Yt2, { Abbr: () => N3, Address: () => _3, Anchor: () => f2, Area: () => R3, Article: () => q3, Aside: () => H3, AudioTag: () => I3, Base: () => y2, Bdi: () => O2, Bdo: () => U3, Blockquote: () => V3, Body: () => v3, Bold: () => D3, Br: () => L3, Button: () => Z3, Canvas: () => F3, Caption: () => J3, Cite: () => X3, Code: () => Y2, Col: () => K3, Colgroup: () => Q3, Data: () => Kt2, Dd: () => ot3, Details: () => rt2, Dfn: () => nt2, Dialog: () => Wt2, Div: () => at2, Dl: () => tt2, Dt: () => et2, Em: () => it2, Embed: () => mt2, Fieldset: () => lt2, FigCaption: () => gt2, Figure: () => dt2, Footer: () => P2, Form: () => xt2, Frame: () => ht2, Frameset: () => ut3, Head: () => T3, Header: () => M4, Heading: () => j3, Hr: () => E3, Html: () => w3, IFrame: () => wt2, Img: () => S3, Input: () => $5, Ins: () => Tt2, Ital: () => g3, Kbd: () => yt2, Label: () => At2, Legend: () => ft2, Link: () => A3, List: () => m3, ListItem: () => x3, Main: () => Ot2, Map: () => B3, Mark: () => vt2, Meta: () => Ut2, Nav: () => z3, NoEmbed: () => ct2, NoFrames: () => bt2, NoScript: () => kt2, Option: () => Lt2, OptionGroup: () => $t2, Output: () => Et2, Paragraph: () => jt2, Picture: () => Qt2, Pre: () => Ct2, Quoted: () => u2, Rp: () => Jt2, Rt: () => Gt2, Ruby: () => Ft2, Script: () => Nt, Section: () => C3, Select: () => St2, Slot: () => Xt2, Small: () => qt2, Source: () => zt2, Span: () => k3, Strike: () => h, Strong: () => pt2, Sub: () => Ht2, Summary: () => st2, Sup: () => Mt2, Table: () => G4, TableCell: () => d2, TableRow: () => W3, TableSection: () => c3, Template: () => Zt2, Textarea: () => Pt2, Time: () => _t2, Title: () => Vt2, Track: () => Bt2, Var: () => Rt2, VideoTag: () => It2, Wbr: () => Dt2, a: () => He2, abbr: () => Me2, address: () => De, anchor: () => ze, area: () => Ue, article: () => Pe2, aside: () => Be2, audio: () => Ve2, b: () => Ze, base: () => be2, bdi: () => Fe2, bdo: () => Ge2, blockquote: () => Je, body: () => Te, br: () => ke2, button: () => Ke2, canvas: () => Qe, caption: () => Xe, cite: () => io, code: () => po, col: () => Ye2, colgroup: () => to, data: () => gr2, dd: () => lo, details: () => fo, dfn: () => xo, dialog: () => ur2, div: () => uo, dl: () => mo, dt: () => co, em: () => ho, embed: () => yo, fieldset: () => vo, figcaption: () => $o, figure: () => So, footer: () => Ie, form: () => Lo, frame: () => jo, frameset: () => Eo, h1: () => $e2, h2: () => Le2, h3: () => Ee2, h4: () => je, h5: () => Ce2, h6: () => Ne2, head: () => he2, header: () => Re2, hr: () => Se2, html: () => ue2, i: () => wo, iframe: () => No, img: () => Ae2, input: () => ve2, ins: () => qo, ital: () => bo, kbd: () => zo, label: () => Ho, legend: () => ko, li: () => _o, link: () => we2, main: () => ir2, map: () => Oe2, mark: () => Bo, meta: () => pr2, nav: () => _e2, noembed: () => Ao, noframes: () => Co, noscript: () => Ro, ol: () => Po, optgroup: () => Do, option: () => Oo, output: () => Uo, p: () => Vo, picture: () => xr2, pre: () => Zo, q: () => Fo, quoted: () => Go, rp: () => dr2, rt: () => fr2, ruby: () => lr2, s: () => Ko, script: () => Qo, section: () => qe2, select: () => Io, slot: () => hr2, small: () => Wo, source: () => Xo, span: () => ye2, strike: () => Jo, strong: () => To, sub: () => Yo, summary: () => go, sup: () => tr2, table: () => We, tbody: () => eo, td: () => ao, template: () => cr2, textarea: () => er2, tfoot: () => ro, th: () => no, thead: () => oo, time: () => or2, title: () => mr2, tr: () => so, track: () => rr2, ul: () => Mo, variable: () => sr2, video: () => nr2, wbr: () => ar2 });
  var w3 = class extends e {
    tag = "html";
    selfAttributes() {
      return ["lang"];
    }
  };
  var ue2 = (...t) => new w3(...t);
  var T3 = class extends e {
    tag = "head";
  };
  var he2 = (...t) => new T3(...t);
  var y2 = class extends n2 {
    tag = "base";
    selfAttributes() {
      return ["href", "target"];
    }
  };
  var be2 = (t) => new y2(t);
  var A3 = class extends n2 {
    tag = "link";
    selfAttributes() {
      return ["href", "crossorigin", "rel", "media", "integrity", "hreflang", "type", "referrerpolicy", "sizes", "imagesrcset", "imagesizes", "as", "blocking", "color", "disabled", "fetchpriority"];
    }
  };
  var we2 = (t) => new A3(t);
  var v3 = class extends e {
    tag = "body";
  };
  var Te = (...t) => new v3(...t);
  var k3 = class extends e {
    tag = "span";
  };
  var ye2 = (...t) => new k3(...t);
  var S3 = class extends n2 {
    tag = "img";
    selfAttributes() {
      return ["align", "alt", "border", "height", "hspace", "ismap", "longdesc", "lowsrc", "src", "vspace", "width", "usemap"];
    }
  };
  var Ae2 = (t = "", o2 = "", r2 = {}) => new S3({ ...r2, src: t, alt: o2 });
  var $5 = class extends n2 {
    tag = "input";
    selfAttributes() {
      return ["accept", "align", "alt", "autocomplete", "autofocus", "border", "checked", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "list", "max", "maxlength", "min", "multiple", "name", "pattern", "placeholder", "size", "src", "step", "type", "value"];
    }
  };
  var ve2 = (t = {}) => new $5(t);
  var L3 = class extends n2 {
    tag = "br";
    selfAttributes() {
      return ["clear"];
    }
  };
  var ke2 = (t) => new L3(t);
  var E3 = class extends n2 {
    tag = "hr";
  };
  var Se2 = (t) => new E3(t);
  var j3 = class extends e {
    constructor(o2 = "h1", ...r2) {
      super(...r2), this.tag = o2;
    }
  };
  var i = (t = "h1", ...o2) => new j3(t, ...o2);
  var $e2 = (...t) => i("h1", ...t);
  var Le2 = (...t) => i("h2", ...t);
  var Ee2 = (...t) => i("h3", ...t);
  var je = (...t) => i("h4", ...t);
  var Ce2 = (...t) => i("h5", ...t);
  var Ne2 = (...t) => i("h6", ...t);
  var C3 = class extends e {
    tag = "section";
  };
  var qe2 = (...t) => new C3(...t);
  var f2 = class extends e {
    tag = "a";
    selfAttributes() {
      return ["coords", "download", "hreflang", "name", "rel", "rev", "shape", "target", "type", "href"];
    }
  };
  var ze = (...t) => new f2(...t);
  var He2 = (...t) => new f2(...t);
  var N3 = class extends e {
    tag = "abbr";
  };
  var Me2 = (...t) => new N3(...t);
  var q3 = class extends e {
    tag = "article";
  };
  var Pe2 = (...t) => new q3(...t);
  var z3 = class extends e {
    tag = "nav";
  };
  var _e2 = (...t) => new z3(...t);
  var H3 = class extends e {
    tag = "aside";
  };
  var Be2 = (...t) => new H3(...t);
  var M4 = class extends e {
    tag = "header";
  };
  var Re2 = (...t) => new M4(...t);
  var P2 = class extends e {
    tag = "footer";
  };
  var Ie = (...t) => new P2(...t);
  var _3 = class extends e {
    tag = "address";
  };
  var De = (...t) => new _3(...t);
  var B3 = class extends e {
    tag = "map";
    selfAttributes() {
      return ["name"];
    }
  };
  var Oe2 = (...t) => new B3(...t);
  var R3 = class extends n2 {
    tag = "area";
    selfAttributes() {
      return ["alt", "coords", "hreflang", "nohref", "shape", "target", "type", "href"];
    }
  };
  var Ue = (t = {}) => new R3(t);
  var I3 = class extends e {
    tag = "audio";
    selfAttributes() {
      return ["autoplay", "controls", "loop", "preload", "src"];
    }
  };
  var Ve2 = (...t) => new I3(...t);
  var D3 = class extends e {
    tag = "b";
  };
  var Ze = (...t) => new D3(...t);
  var O2 = class extends e {
    tag = "bdi";
  };
  var Fe2 = (...t) => new O2(...t);
  var U3 = class extends e {
    tag = "bdo";
  };
  var Ge2 = (...t) => new U3(...t);
  var V3 = class extends e {
    tag = "blockquote";
    selfAttributes() {
      return ["cite"];
    }
  };
  var Je = (...t) => new V3(...t);
  var Z3 = class extends e {
    tag = "button";
    selfAttributes() {
      return ["autofocus", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "type", "value"];
    }
  };
  var Ke2 = (...t) => new Z3(...t);
  var F3 = class extends e {
    tag = "canvas";
    selfAttributes() {
      return ["width", "height"];
    }
  };
  var Qe = (...t) => new F3(...t);
  var G4 = class extends e {
    tag = "table";
    selfAttributes() {
      return ["align", "background", "bgcolor", "border", "bordercolor", "cellpadding", "cellspacing", "cols", "frame", "height", "rules", "summary", "width"];
    }
  };
  var We = (...t) => new G4(...t);
  var J3 = class extends e {
    tag = "caption";
    selfAttributes() {
      return ["align", "valign"];
    }
  };
  var Xe = (...t) => new J3(...t);
  var K3 = class extends n2 {
    tag = "col";
    selfAttributes() {
      return ["align", "valign", "char", "charoff", "span", "width"];
    }
  };
  var Ye2 = (t) => new K3(t);
  var Q3 = class extends n2 {
    tag = "colgroup";
    selfAttributes() {
      return ["align", "valign", "char", "charoff", "span", "width"];
    }
  };
  var to = (t) => new Q3(t);
  var c3 = class extends e {
    constructor(o2 = "tbody", ...r2) {
      super(...r2), this.tag = o2;
    }
    selfAttributes() {
      return ["align", "valign", "char", "charoff", "bgcolor"];
    }
  };
  var eo = (...t) => new c3("tbody", ...t);
  var oo = (...t) => new c3("thead", ...t);
  var ro = (...t) => new c3("tfoot", ...t);
  var W3 = class extends e {
    tag = "tr";
    selfAttributes() {
      return ["align", "bgcolor", "bordercolor", "char", "charoff", "valign"];
    }
  };
  var so = (...t) => new W3(...t);
  var d2 = class extends e {
    constructor(o2 = "td", ...r2) {
      super(...r2), this.tag = o2;
    }
    selfAttributes() {
      return ["abbr", "align", "axis", "background", "bgcolor", "bordercolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"];
    }
  };
  var no = (...t) => new d2("th", ...t);
  var ao = (...t) => new d2("td", ...t);
  var X3 = class extends e {
    tag = "cite";
  };
  var io = (...t) => new X3(...t);
  var Y2 = class extends e {
    tag = "code";
  };
  var po = (...t) => new Y2(...t);
  var tt2 = class extends e {
    tag = "dl";
  };
  var et2 = class extends e {
    tag = "dt";
  };
  var ot3 = class extends e {
    tag = "dd";
  };
  var mo = (...t) => new tt2(...t);
  var co = (...t) => new et2(...t);
  var lo = (...t) => new ot3(...t);
  var rt2 = class extends e {
    tag = "details";
  };
  var fo = (...t) => new rt2(...t);
  var st2 = class extends e {
    tag = "summary";
  };
  var go = (...t) => new st2(...t);
  var nt2 = class extends e {
    tag = "dfn";
  };
  var xo = (...t) => new nt2(...t);
  var at2 = class extends e {
    tag = "div";
    selfAttributes() {
      return ["align", "title"];
    }
  };
  var uo = (...t) => new at2(...t);
  var it2 = class extends e {
    tag = "em";
  };
  var ho = (...t) => new it2(...t);
  var g3 = class extends e {
    tag = "i";
  };
  var bo = (...t) => new g3(...t);
  var wo = (...t) => new g3(...t);
  var pt2 = class extends e {
    tag = "strong";
  };
  var To = (...t) => new pt2(...t);
  var mt2 = class extends e {
    tag = "embed";
    selfAttributes() {
      return ["align", "height", "hspace", "pluginspace", "src", "type", "vspace", "width"];
    }
  };
  var yo = (...t) => new mt2(...t);
  var ct2 = class extends e {
    tag = "noembed";
  };
  var Ao = (...t) => new ct2(...t);
  var lt2 = class extends e {
    tag = "fieldset";
    selfAttributes() {
      return ["form", "title"];
    }
  };
  var vo = (...t) => new lt2(...t);
  var ft2 = class extends e {
    tag = "legend";
    selfAttributes() {
      return ["align", "title"];
    }
  };
  var ko = (...t) => new ft2(...t);
  var dt2 = class extends e {
    tag = "figure";
  };
  var So = (...t) => new dt2(...t);
  var gt2 = class extends e {
    tag = "figcaption";
  };
  var $o = (...t) => new gt2(...t);
  var xt2 = class extends e {
    tag = "form";
    selfAttributes() {
      return ["accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"];
    }
  };
  var Lo = (...t) => new xt2(...t);
  var ut3 = class extends e {
    tag = "frameset";
    selfAttributes() {
      return ["border", "bordercolor", "cols", "frameborder", "framespacing", "rows"];
    }
  };
  var Eo = (...t) => new ut3(...t);
  var ht2 = class extends n2 {
    tag = "frame";
    selfAttributes() {
      return ["bordercolor", "frameborder", "noresize", "name", "src", "scrolling"];
    }
  };
  var jo = (t = {}) => new ht2(t);
  var bt2 = class extends e {
    tag = "noframes";
  };
  var Co = (...t) => new bt2(...t);
  var wt2 = class extends e {
    tag = "iframe";
    selfAttributes() {
      return ["align", "allowtransparency", "frameborder", "height", "hspace", "marginheight", "marginwidth", "name", "sandbox", "scrolling", "seamless", "src", "srcdoc", "vspace", "width"];
    }
  };
  var No = (...t) => new wt2(...t);
  var Tt2 = class extends e {
    tag = "ins";
    selfAttributes() {
      return ["cite", "datetime"];
    }
  };
  var qo = (...t) => new Tt2(...t);
  var yt2 = class extends e {
    tag = "kbd";
  };
  var zo = (...t) => new yt2(...t);
  var At2 = class extends e {
    tag = "label";
    selfAttributes() {
      return ["for"];
    }
  };
  var Ho = (...t) => new At2(...t);
  var m3 = class extends e {
    constructor(o2 = "ul", ...r2) {
      super(...r2), this.tag = o2;
    }
    selfAttributes() {
      return this.tag === "ul" ? ["type"] : ["type", "reserved", "start"];
    }
  };
  var x3 = class extends e {
    tag = "li";
    selfAttributes() {
      return ["type", "value"];
    }
  };
  var Mo = (...t) => new m3("ul", ...t);
  var Po = (...t) => new m3("ol", ...t);
  var _o = (...t) => new x3(...t);
  var vt2 = class extends e {
    tag = "mark";
  };
  var Bo = (...t) => new vt2(...t);
  var kt2 = class extends e {
    tag = "noscript";
  };
  var Ro = (...t) => new kt2(...t);
  var St2 = class extends e {
    tag = "select";
    selfAttributes() {
      return ["autofocus", "form", "name", "size"];
    }
  };
  var Io = (...t) => new St2(...t);
  var $t2 = class extends e {
    tag = "optgroup";
    selfAttributes() {
      return ["label"];
    }
  };
  var Do = (...t) => new $t2(...t);
  var Lt2 = class extends e {
    tag = "option";
    selfAttributes() {
      return ["label", "value"];
    }
  };
  var Oo = (...t) => new Lt2(...t);
  var Et2 = class extends e {
    tag = "output";
    selfAttributes() {
      return ["for", "form", "name"];
    }
  };
  var Uo = (...t) => new Et2(...t);
  var jt2 = class extends e {
    tag = "p";
    selfAttributes() {
      return ["align"];
    }
  };
  var Vo = (...t) => new jt2(...t);
  var Ct2 = class extends e {
    tag = "pre";
  };
  var Zo = (...t) => new Ct2(...t);
  var u2 = class extends e {
    tag = "q";
    selfAttributes() {
      return ["cite"];
    }
  };
  var Fo = (...t) => new u2(...t);
  var Go = (...t) => new u2(...t);
  var h = class extends e {
    tag = "strike";
  };
  var Jo = (...t) => new h(...t);
  var Ko = (...t) => new h(...t);
  var Nt = class extends e {
    tag = "script";
    selfAttributes() {
      return ["async", "defer", "language", "src", "type"];
    }
  };
  var Qo = (...t) => new Nt(...t);
  var qt2 = class extends e {
    tag = "small";
  };
  var Wo = (...t) => new qt2(...t);
  var zt2 = class extends n2 {
    tag = "source";
    selfAttributes() {
      return ["media", "src", "type"];
    }
  };
  var Xo = (t = {}) => new zt2(t);
  var Ht2 = class extends e {
    tag = "sub";
  };
  var Yo = (...t) => new Ht2(...t);
  var Mt2 = class extends e {
    tag = "sup";
  };
  var tr2 = (...t) => new Mt2(...t);
  var Pt2 = class extends e {
    tag = "textarea";
    selfAttributes() {
      return ["autofocus", "cols", "form", "maxlength", "name", "placeholder", "rows", "wrap"];
    }
  };
  var er2 = (...t) => new Pt2(...t);
  var _t2 = class extends e {
    tag = "time";
    selfAttributes() {
      return ["datetime", "pubdate"];
    }
  };
  var or2 = (...t) => new _t2(...t);
  var Bt2 = class extends n2 {
    tag = "track";
    selfAttributes() {
      return ["kind", "src", "srclang", "label"];
    }
  };
  var rr2 = (t = {}) => new Bt2(t);
  var Rt2 = class extends e {
    tag = "var";
  };
  var sr2 = (...t) => new Rt2(...t);
  var It2 = class extends e {
    tag = "video";
    selfAttributes() {
      return ["autoplay", "controls", "height", "loop", "loop", "poster", "preload", "src", "width"];
    }
  };
  var nr2 = (...t) => new It2(...t);
  var Dt2 = class extends n2 {
    tag = "wbr";
  };
  var ar2 = (t) => new Dt2(t);
  var Ot2 = class extends e {
    tag = "main";
  };
  var ir2 = (...t) => new Ot2(...t);
  var Ut2 = class extends n2 {
    tag = "meta";
    selfAttributes() {
      return ["content", "name", "http-equiv", "charset"];
    }
  };
  var pr2 = (t) => new Ut2(t);
  var Vt2 = class extends e {
    tag = "title";
  };
  var mr2 = (t) => new Vt2(t);
  var Zt2 = class extends e {
    tag = "template";
    selfAttributes() {
      return ["shadowrootmode", "shadowrootdelegatesfocus", "shadowrootclonable", "shadowrootserializable"];
    }
  };
  var cr2 = (...t) => new Zt2(...t);
  var Ft2 = class extends e {
    tag = "ruby";
  };
  var Gt2 = class extends n2 {
    tag = "rt";
  };
  var Jt2 = class extends n2 {
    tag = "rp";
  };
  var lr2 = (...t) => new Ft2(...t);
  var fr2 = (t) => new Gt2(t);
  var dr2 = (t) => new Jt2(t);
  var Kt2 = class extends e {
    tag = "data";
  };
  var gr2 = (...t) => new Kt2(...t);
  var Qt2 = class extends e {
    tag = "picture";
  };
  var xr2 = (...t) => new Qt2(...t);
  var Wt2 = class extends e {
    tag = "dialog";
    selfAttributes() {
      return ["open"];
    }
  };
  var ur2 = (...t) => new Wt2(...t);
  var Xt2 = class extends e {
    tag = "slot";
    selfAttributes() {
      return ["name"];
    }
  };
  var hr2 = (...t) => new Xt2(...t);
  var ie2 = {};
  var yr2 = "0.15.1";
  var Ar2 = "18.05.2025, 14:41:46";
  var am = () => {
    console.info(`%c Html.js %c v${yr2} %c ${Ar2} `, "color: #ffffff; font-weight: bold; background: #708238", "color: white; background: darkgreen", "color: white; background: #0080fe;");
  };
  var vr2 = (t = globalThis) => {
    for (let o2 in Yt2) globalThis[o2] && (ie2[o2] = globalThis[o2]), t[o2] = Yt2[o2];
  };
  var kr = (t = globalThis) => {
    for (let o2 in ie2) t[o2] = ie2[o2];
  };
  var im = { BaseElement: p2, Tag: e, SingleTag: n2, ...Yt2, extract: vr2, restore: kr };
  var pm = { addStyle: de2, addCssRule: ae2, createStyleSheet: ne2, createStyleElement: oe2 };

  // ../metroui-lib/source/html/index.js
  globalThis.HTML = {
    cssLoader: ge2,
    jsLoader: xe2,
    render: Tr,
    ...im,
    ...pm,
    info: am
  };

  // ../metroui-lib/node_modules/@olton/guardian/dist/guardian.js
  var guardian_exports = {};
  __export(guardian_exports, {
    americanExpress: () => fe3,
    array: () => pr3,
    base64: () => gr3,
    between: () => ur3,
    bigint: () => j4,
    boolean: () => _r2,
    bytes: () => Ee3,
    color: () => Wr,
    compose: () => I4,
    contains: () => be3,
    creditCard: () => ce3,
    date: () => H4,
    digits: () => _e3,
    diners: () => ie3,
    discover: () => me3,
    domain: () => Tr2,
    email: () => nr3,
    endsWith: () => O3,
    equal: () => Ue2,
    finite: () => Er2,
    float: () => Se3,
    func: () => W4,
    great: () => Ne3,
    greatOrEqual: () => Ce3,
    hexColor: () => Yr,
    hslColor: () => Zr,
    imei: () => br2,
    info: () => qe3,
    integer: () => J4,
    ip: () => Mr,
    ipv4: () => yr3,
    ipv6: () => Nr,
    jcb: () => Ae3,
    length: () => Rr,
    less: () => ve3,
    lessOrEqual: () => Oe3,
    mastercard: () => ae3,
    max: () => tr3,
    maxLength: () => xr3,
    min: () => rr3,
    minLength: () => kr2,
    notNull: () => ge3,
    notNumber: () => hr3,
    number: () => fr3,
    object: () => ir3,
    parse: () => A4,
    pattern: () => he3,
    pipe: () => y3,
    required: () => sr3,
    rgbColor: () => Jr,
    safeInteger: () => Q4,
    safeParse: () => D4,
    similar: () => Me3,
    startsWith: () => C4,
    string: () => i2,
    symbol: () => q4,
    type: () => xe3,
    unionPay: () => ue3,
    unknown: () => B4,
    url: () => Or,
    visa: () => se2
  });
  var x4 = Object.defineProperty;
  var l = Object.getOwnPropertySymbols;
  var w4 = Object.prototype.hasOwnProperty;
  var U4 = Object.prototype.propertyIsEnumerable;
  var E4 = (t, r2, e2) => r2 in t ? x4(t, r2, { enumerable: true, configurable: true, writable: true, value: e2 }) : t[r2] = e2;
  var d3 = (t, r2) => {
    for (var e2 in r2 || (r2 = {})) w4.call(r2, e2) && E4(t, e2, r2[e2]);
    if (l) for (var e2 of l(r2)) U4.call(r2, e2) && E4(t, e2, r2[e2]);
    return t;
  };
  var o = class extends Error {
    constructor(r2 = "", e2 = null, c5) {
      super(r2), this.message = r2, this.name = e2, this.value = c5;
    }
  };
  var A4 = (t, r2) => {
    let e2;
    if (!t) throw new Error("Schema object required for parse data!");
    if (typeof t == "function") {
      if (e2 = t.apply(null, [r2]), e2 instanceof o) throw e2;
    } else for (let c5 in t) {
      let s2 = r2[c5], a2 = t[c5];
      if (!a2) throw new o(`Guard not defined for field ${c5} in input data!`, "general", r2);
      if (!r2.hasOwnProperty(c5)) throw new o(`Field ${c5} doesn't exists in input data!`, "general", r2);
      if (typeof a2 == "function") {
        if (console.log(a2.name), e2 = a2.apply(null, [s2]), e2 instanceof o) throw e2;
      } else A4(a2, s2);
    }
    return r2;
  };
  var D4 = (t, r2) => {
    let e2;
    if (!t) throw new Error("Schema object required for parse data!");
    if (typeof t == "function") {
      if (e2 = t.apply(null, [r2]), e2 instanceof o) return { ok: false, error: e2 };
    } else for (let c5 in t) {
      let s2 = r2[c5], a2 = t[c5];
      if (a2) if (typeof a2 == "function") {
        if (e2 = a2.apply(null, [r2]), e2 instanceof o) return { ok: false, error: e2 };
      } else A4(a2, s2);
    }
    return { ok: true, output: r2 };
  };
  var M5 = (...t) => (r2) => t.reduce((e2, c5) => c5(e2), r2);
  var y3 = M5;
  var N4 = (...t) => (r2) => t.reduceRight((e2, c5) => c5(e2), r2);
  var I4 = N4;
  var v4 = "VAL must be a string";
  var i2 = (t = v4) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" ? r2 : new o(e2, "string", r2);
  };
  var f3 = (t) => typeof t != "undefined" && t !== null;
  var T4 = "VAL must starts with START_VAL";
  var C4 = (t, r2 = T4) => {
    if (!f3(t)) throw new Error("START_VALUE not defined!");
    return function(e2) {
      let c5 = r2.replace(/VAL/g, e2).replace(/START_VAL/g, t);
      return typeof e2 == "string" && e2.startsWith(t) ? e2 : new o(c5, "startsWith", e2);
    };
  };
  var $6 = "VAL must end with END_VAL";
  var O3 = (t, r2 = $6) => {
    if (!f3(t)) throw new Error("END_VALUE not defined!");
    return function(e2) {
      let c5 = r2.replace(/VAL/g, e2).replace(/END_VAL/g, t);
      return typeof e2 == "string" && e2.endsWith(t) ? e2 : new o(c5, "endsWith", e2);
    };
  };
  var B4 = () => function(t) {
    return t;
  };
  var F4 = "A symbol is required";
  var q4 = (t = F4) => function(r2) {
    return typeof r2 == "symbol" ? r2 : new o(t, "symbol", r2);
  };
  var P3 = "VAL must be a bigint";
  var j4 = (t = P3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "bigint" ? r2 : new o(e2, "bigint", r2);
  };
  var z4 = "VAL must be valid date object or date string";
  var H4 = (t = z4) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "object" && r2.getTime || typeof r2 == "string" && !isNaN(Date.parse(r2)) ? r2 : new o(e2, "date", r2);
  };
  var X4 = "The value must be a function";
  var W4 = (t = X4) => function(r2) {
    return typeof r2 == "function" ? r2 : new o(t, "function", r2);
  };
  var Y3 = "VAL must be an integer";
  var J4 = (t = Y3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return Number.isInteger(r2) ? r2 : new o(e2, "integer", r2);
  };
  var Z4 = "VAL must be an safe integer";
  var Q4 = (t = Z4) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return Number.isSafeInteger(r2) ? r2 : new o(e2, "safeInteger", r2);
  };
  var K4 = "VAL must be a great then MIN_VALUE";
  var rr3 = (t, r2 = K4) => {
    if (!f3(t)) throw new Error("MIN_VALUE not defined!");
    return function(e2) {
      let c5 = r2.replace(/VAL/g, e2).replace(/MIN_VALUE/g, t), s2 = +e2;
      return !isNaN(s2) && s2 >= +t ? e2 : new o(c5, "minValue", e2);
    };
  };
  var er3 = "VAL must be a less then MAX_VALUE";
  var tr3 = (t, r2 = er3) => {
    if (!f3(t)) throw new Error("MAX_VALUE not defined!");
    return function(e2) {
      let c5 = r2.replace(/VAL/g, e2).replace(/MAX_VALUE/g, t), s2 = +e2;
      return !isNaN(s2) && s2 <= +t ? e2 : new o(c5, "maxValue", e2);
    };
  };
  var or3 = "VAL must be a string in valid email format";
  var nr3 = (t = or3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(r2) ? r2 : new o(e2, "email", r2);
  };
  var cr3 = "Any value required";
  var sr3 = (t = cr3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 != "undefined" && r2 !== null && r2 !== "" ? r2 : new o(e2, "required", r2);
  };
  var ar3 = "VAL must be a number";
  var fr3 = (t = ar3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "number" && !isNaN(+r2) ? r2 : new o(e2, "number", r2);
  };
  var mr3 = "VAL must be an object";
  var ir3 = (t, r2 = mr3) => {
    if (!(typeof t == "object")) throw new o(r2.replace(/VAL/g, t), "object", t);
    return d3({}, t);
  };
  var Ar3 = "VAL must be between MIN_VAL and MAX_VAL";
  var ur3 = (t, r2, e2 = Ar3) => {
    if (!f3(t)) throw new Error("MIN_VALUE not defined!");
    if (!f3(r2)) throw new Error("MAX_VALUE not defined!");
    return function(c5) {
      let s2 = e2.replace(/VAL/g, c5).replace(/MIN_VAL/g, t).replace(/MAX_VAL/g, r2), a2 = +c5;
      return !isNaN(a2) && c5 >= +t && c5 <= +r2 ? c5 : new o(s2, "between", c5);
    };
  };
  var lr3 = "VAL must be a finite number";
  var Er2 = (t = lr3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return Number.isFinite(r2) ? r2 : new o(e2, "finite", r2);
  };
  var dr3 = "VAL must be a string in valid base 64 format";
  var gr3 = (t = dr3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/.test(r2) ? r2 : new o(e2, "base64", r2);
  };
  var Gr = "VAL can`t be a number";
  var hr3 = (t = Gr) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return isNaN(r2) ? r2 : new o(e2, "notNumber", r2);
  };
  var Lr = "VAL must be a boolean";
  var _r2 = (t = Lr) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "boolean" ? r2 : new o(e2, "boolean", r2);
  };
  var g4 = "VAL must be an array of TYPE";
  var pr3 = (t, r2 = g4) => (!t && !r2 && (t = i2(), r2 = g4), typeof t == "string" && (r2 = t, t = i2()), function(e2) {
    let c5 = r2.replace(/VAL/g, e2).replace(/TYPE/g, t.name);
    if (!Array.isArray(e2)) return new o(c5, "array", e2);
    for (let s2 of e2) if (t(s2) instanceof o) return new o(c5, "array", e2);
    return e2;
  });
  var Sr2 = "VAL must be a valid EMEI";
  var Vr = (t) => {
    let r2 = (s2) => {
      let a2 = 0;
      for (; s2 > 0; ) a2 = a2 + s2 % 10, s2 = parseInt("" + s2 / 10, 10);
      return a2;
    }, e2 = ("" + t).length;
    if (e2 !== 15) return false;
    let c5 = 0;
    for (let s2 = e2; s2 >= 1; s2--) {
      let a2 = t % 10;
      s2 % 2 === 0 && (a2 = 2 * a2), c5 += r2(a2), t = parseInt("" + t / 10, 10);
    }
    return c5 % 10 === 0;
  };
  var br2 = (t = Sr2) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return Vr(r2) ? r2 : new o(e2, "emei", r2);
  };
  var u3 = "VAL must be a string or array with length N";
  var Rr = (t, r2 = u3) => function(e2) {
    let c5 = r2.replace(/VAL/g, e2).replace(/N/g, t);
    return (typeof e2 == "string" || Array.isArray(e2)) && e2.length === +t ? e2 : new o(c5, "length", e2);
  };
  var kr2 = (t, r2 = u3) => function(e2) {
    let c5 = r2.replace(/VAL/g, e2).replace(/N/g, t);
    return (typeof e2 == "string" || Array.isArray(e2)) && e2.length >= +t ? e2 : new o(c5, "minLength", e2);
  };
  var xr3 = (t, r2 = u3) => function(e2) {
    let c5 = r2.replace(/VAL/g, e2).replace(/N/g, t);
    return (typeof e2 == "string" || Array.isArray(e2)) && e2.length <= +t ? e2 : new o(c5, "maxLength", e2);
  };
  var wr3 = "VAL must be a valid ip address ipv4 or ipv6";
  var Ur = "VAL must be a valid ipv4 address";
  var Dr = "VAL must be a valid ipv6 address";
  var G5 = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
  var h2 = /^[a-fA-F0-9]{1, 4}:[a-fA-F0-9]{1, 4}:[a-fA-F0-9]{1, 4}:[a-fA-F0-9]{1, 4}:[a-fA-F0-9]{1, 4}:[a-fA-F0-9]{1, 4}:[a-fA-F0-9]{1, 4}:[a-fA-F0-9]{1, 4}$/;
  var Mr = (t = wr3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && (G5.test(r2) || h2.test(r2)) ? r2 : new o(e2, "ip", r2);
  };
  var yr3 = (t = Ur) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && G5.test(r2) ? r2 : new o(e2, "ipv4", r2);
  };
  var Nr = (t = Dr) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && h2.test(r2) ? r2 : new o(e2, "ipv6", r2);
  };
  var Ir = "VAL must be a valid domain name, xn--* for internationalized names";
  var vr3 = /^((xn--)?[a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/;
  var Tr2 = (t = Ir) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && vr3.test(r2) ? r2 : new o(e2, "domain", r2);
  };
  var Cr2 = "VAL must be a valid url";
  var $r = /^(?:(?:(?:https?|ftp|wss?):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)+(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/i;
  var Or = (t = Cr2) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && $r.test(r2) ? r2 : new o(e2, "url", r2);
  };
  var Br = "VAL must be a valid color in HEX, RGB(A), or HSL(A) format";
  var Fr = "VAL must be a valid HEX color";
  var qr = "VAL must be a valid RGB(a) color";
  var Pr = "VAL must be a valid HSL(A) color";
  var jr = /^#(?:[\da-f]{3}){1,2}$|^#(?:[\da-f]{4}){1,2}$|^(rgb|hsl)a?\((\s*-?\d+%?\s*,){2}(\s*-?\d+%?\s*)\)$|^(rgb|hsl)a?\((\s*-?\d+%?\s*,){3}\s*(0|(0?\.\d+)|1)\)$/gmi;
  var zr = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i;
  var Hr = /^rgba?\((\s*-?\d+%?\s*,){2}(\s*-?\d+%?\s*)\)$|^rgba?\((\s*-?\d+%?\s*,){3}\s*(0|(0?\.\d+)|1)\)$/gmi;
  var Xr = /^hsla?\((\s*-?\d+%?\s*,){2}(\s*-?\d+%?\s*)\)$|^hsla?\((\s*-?\d+%?\s*,){3}\s*(0|(0?\.\d+)|1)\)$/gmi;
  var Wr = (t = Br) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && jr.test(r2) ? r2 : new o(e2, "color", r2);
  };
  var Yr = (t = Fr) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && zr.test(r2) ? r2 : new o(e2, "hexColor", r2);
  };
  var Jr = (t = qr) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && Hr.test(r2) ? r2 : new o(e2, "rgbColor", r2);
  };
  var Zr = (t = Pr) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && Xr.test(r2) ? r2 : new o(e2, "hslColor", r2);
  };
  var L4 = /^4\d{12}(?:\d{3,6})?$/u;
  var _4 = /^5[1-5]\d{2}|(?:222\d|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)\d{12}$/u;
  var p3 = /^3[47]\d{13}$/u;
  var S4 = /^6(?:011|5\d{2})\d{12,15}$/u;
  var V4 = /^3(?:0[0-5]|[68]\d)\d{11,13}$/u;
  var b4 = /^(?:2131|1800|35\d{3})\d{11}$/u;
  var R4 = /^(?:6[27]\d{14,17}|81\d{14,17})$/u;
  var k4 = "VAL must be a valid CC number (visa, mastercard, american express, discover, diners club, jcb, or union pay)";
  var Qr = "VAL must be a valid Visa card number";
  var Kr = "VAL must be a valid Mastercard card number";
  var re2 = "VAL must be a valid American Express card number";
  var ee3 = "VAL must be a valid DISCOVER card number";
  var te3 = "VAL must be a valid DINERS CLUB card number";
  var oe3 = "VAL must be a valid JCB card number";
  var ne3 = "VAL must be a valid Union Pay card number";
  var ce3 = (t = k4) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return typeof r2 == "string" && (L4.test(r2) || _4.test(r2) || p3.test(r2) || S4.test(r2) || V4.test(r2) || b4.test(r2) || R4.test(r2)) ? r2 : new o(e2, "creditCard", r2);
  };
  var m4 = (t, r2, e2 = k4) => function(c5) {
    let s2 = e2.replace(/VAL/g, c5);
    return typeof c5 == "string" && r2.test(c5) ? c5 : new o(s2, t, c5);
  };
  var se2 = (t = Qr) => m4("visa", L4, t);
  var ae3 = (t = Kr) => m4("mastercard", _4, t);
  var fe3 = (t = re2) => m4("american express", p3, t);
  var me3 = (t = ee3) => m4("discover", S4, t);
  var ie3 = (t = te3) => m4("diners club", V4, t);
  var Ae3 = (t = oe3) => m4("jcb card", b4, t);
  var ue3 = (t = ne3) => m4("union pay", R4, t);
  var le3 = "The length of string must be VAL bytes";
  var Ee3 = (t, r2 = le3) => function(e2) {
    let c5 = r2.replace(/VAL/g, e2);
    return typeof e2 == "string" && new TextEncoder().encode(e2).length === t ? e2 : new o(c5, "bytes", e2);
  };
  var de3 = "VAL can`t be null or undefined.";
  var ge3 = (t = de3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return f3(r2) ? r2 : new o(e2, "notNull", r2);
  };
  var Ge3 = "The value must match the pattern";
  var he3 = (t, r2 = Ge3) => function(e2) {
    let c5 = r2.replace(/VAL/g, e2);
    return (typeof t == "string" ? new RegExp(t, "g") : t).test("" + e2) ? e2 : new o(c5, "pattern", e2);
  };
  var Le3 = "VAL must contains only digits";
  var _e3 = (t = Le3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return /^\d+$/g.test("" + r2) ? r2 : new o(e2, "digits", r2);
  };
  var pe3 = "VAL must be a float";
  var Se3 = (t = pe3) => function(r2) {
    let e2 = t.replace(/VAL/g, r2);
    return !isNaN(r2) && +n % 1 !== 0 || /^\d*\.\d+$/.test(r2) ? r2 : new o(e2, "float", r2);
  };
  var Ve3 = "VAL must must contains OBJ";
  var be3 = (t, r2 = Ve3) => function(e2) {
    let c5 = r2.replace(/VAL/g, e2).replace(/OBJ/g, t);
    return e2.includes(t) ? e2 : new o(c5, "contains", e2);
  };
  var Re3 = "A VAL must have type TYPE";
  function ke3(t) {
    return Object.prototype.toString.call(t).replace(/^\[object (.+)]$/, "$1").toLowerCase();
  }
  var xe3 = (t = "string", r2 = Re3) => function(e2) {
    let c5 = r2.replace(/VAL/g, e2).replace(/TYPE/g, t);
    return t === ke3(e2) ? e2 : new o(c5, "type", e2);
  };
  var we3 = "VAL must be an equal to VALUE";
  var Ue2 = (t, r2 = we3) => function(e2) {
    let c5 = r2.replace(/VAL/g, e2).replace(/VALUE/g, t);
    return e2 === t ? e2 : new o(c5, "equal", e2);
  };
  var De2 = "VAL must be a similar to VALUE";
  var Me3 = (t, r2 = De2) => function(e2) {
    let c5 = r2.replace(/VAL/g, e2).replace(/VALUE/g, t);
    return e2 == t ? e2 : new o(c5, "similar", e2);
  };
  var ye3 = "VAL must be a great then VALUE";
  var Ne3 = (t, r2 = ye3) => function(e2) {
    let c5 = r2.replace(/VAL/g, e2).replace(/VALUE/g, t);
    return e2 > t ? e2 : new o(c5, "great", e2);
  };
  var Ie2 = "VAL must be a less then VALUE";
  var ve3 = (t, r2 = Ie2) => function(e2) {
    let c5 = r2.replace(/VAL/g, e2).replace(/VALUE/g, t);
    return e2 < t ? e2 : new o(c5, "less", e2);
  };
  var Te2 = "VAL must be a great or equal to VALUE";
  var Ce3 = (t, r2 = Te2) => function(e2) {
    let c5 = r2.replace(/VAL/g, e2).replace(/VALUE/g, t);
    return e2 >= t ? e2 : new o(c5, "greatOrEqual", e2);
  };
  var $e3 = "VAL must be a less or equal to VALUE";
  var Oe3 = (t, r2 = $e3) => function(e2) {
    let c5 = r2.replace(/VAL/g, e2).replace(/VALUE/g, t);
    return e2 <= t ? e2 : new o(c5, "lessOrEqual", e2);
  };
  var Be3 = "0.7.3";
  var Fe3 = "18.05.2025, 14:43:24";
  var qe3 = () => {
    console.info(`%c Guardian %c v${Be3} %c ${Fe3} `, "color: pink; font-weight: bold; background: #2b1700", "color: white; background: darkgreen", "color: white; background: #0080fe;");
  };

  // ../metroui-lib/source/guardian/index.js
  globalThis.G = guardian_exports;

  // ../metroui-lib/node_modules/@olton/router/dist/router.js
  var r = class s {
    static DEBUG_LEVELS = { NONE: 0, ERROR: 1, WARN: 2, INFO: 3, DEBUG: 4, TRACE: 5 };
    static DEBUG_LEVEL = s.DEBUG_LEVELS.NONE;
    static log(e2, t, i3) {
      if (e2 > s.DEBUG_LEVEL) return;
      let o2 = { error: "color: #ff5555; font-weight: bold", warn: "color: #ffaa00; font-weight: bold", info: "color: #0080fe; font-weight: bold", debug: "color: #00aa00; font-weight: bold", trace: "color: #888888", data: "color: #555; font-style: italic" }, a2, n3;
      switch (e2) {
        case s.DEBUG_LEVELS.ERROR:
          a2 = "error", n3 = console.error;
          break;
        case s.DEBUG_LEVELS.WARN:
          a2 = "warn", n3 = console.warn;
          break;
        case s.DEBUG_LEVELS.INFO:
          a2 = "info", n3 = console.info;
          break;
        case s.DEBUG_LEVELS.DEBUG:
          a2 = "debug", n3 = console.debug;
          break;
        case s.DEBUG_LEVELS.TRACE:
          a2 = "trace", n3 = console.log;
          break;
        default:
          return;
      }
      console.group(`%c Model: ${t}`, o2[a2]), i3 !== void 0 && console.log("%c Data:", o2.data, i3), console.groupEnd();
    }
    static error(e2, t) {
      s.log(s.DEBUG_LEVELS.ERROR, e2, t);
    }
    static warn(e2, t) {
      s.log(s.DEBUG_LEVELS.WARN, e2, t);
    }
    static info(e2, t) {
      s.log(s.DEBUG_LEVELS.INFO, e2, t);
    }
    static debug(e2, t) {
      s.log(s.DEBUG_LEVELS.DEBUG, e2, t);
    }
    static trace(e2, t) {
      s.log(s.DEBUG_LEVELS.TRACE, e2, t);
    }
  };
  var E5 = "0.4.1";
  var w5 = "18.05.2025, 14:39:57";
  var c4 = class {
    constructor(e2 = {}) {
      if (r.DEBUG_LEVEL = e2.debug ? 4 : 0, r.debug("[Router] Init Router"), this.routes = {}, this.fallbackRoute = e2.fallback || "/", this.maxRedirects = e2.maxRedirects || 5, this.redirectCount = 0, this.basePath = e2.base || "", this.middleware = [], this.beforeEachHooks = [], this.afterEachHooks = [], this.cache = /* @__PURE__ */ new Map(), this.cacheLimit = e2.cacheLimit ?? 50, this.touchStartX = 0, this.enableSwipeNavigation = e2.enableSwipeNavigation || false, this.current = null, this.redirects = {}, this.useHash = e2.useHash || false, this.events = { beforeNavigate: [], afterNavigate: [], routeNotFound: [], error: [] }, this.plugins = [], this.enableSwipeNavigation && this.initSwipeNavigation(), e2.routes) {
        r.debug("[Router] Registering routes");
        for (let [t, i3] of Object.entries(e2.routes)) this.addRoute(t, i3);
      }
      e2.plugins && Array.isArray(e2.plugins) && (r.debug("[Router] Registering plugins"), e2.plugins.forEach((t) => {
        Array.isArray(t) ? this.usePlugin(t[0], t[1] || {}) : this.usePlugin(t);
      })), r.debug("[Router] Subscribing to unhandledrejection event"), window.addEventListener("unhandledrejection", this.handleError.bind(this)), r.debug("[Router] Router Initialized");
    }
    on(e2, t) {
      return r.debug(`[Router] Subscribing to event ${e2}`), this.events[e2] && this.events[e2].push(t), this;
    }
    emit(e2, ...t) {
      if (r.debug(`[Router] Emitting event ${e2}`), this.events[e2]) for (let i3 of this.events[e2]) {
        let o2 = i3(...t);
        if (e2 === "beforeNavigate" && o2 === false) return false;
      }
      return true;
    }
    initSwipeNavigation() {
      r.debug("[Router] Initializing swipe navigation"), r.debug("[Router] Adding touchstart event listener"), document.addEventListener("touchstart", (e2) => {
        this.touchStartX = e2.touches[0].clientX;
      }, { passive: true }), r.debug("[Router] Adding touchend event listener"), document.addEventListener("touchend", (e2) => {
        let t = e2.changedTouches[0].clientX, i3 = this.touchStartX - t;
        Math.abs(i3) > 100 && (i3 > 0 ? (r.debug("[Router] Swiping right (forward)"), window.history.forward()) : (r.debug("[Router] Swiping left (backward)"), window.history.back()));
      }, { passive: true });
    }
    handleError(e2) {
      r.error("[Router] Error during navigation:", e2), this.emit("error", e2), this.routes["/error"] ? this.navigateTo("/error", true) : this.navigateTo(this.fallbackRoute, true);
    }
    sanitizePath(e2) {
      r.debug("[Router] Sanitizing path:", e2);
      try {
        if (!e2) return "/";
        let t = new URL(e2, window.location.origin), i3 = decodeURIComponent(t.pathname);
        return i3 = i3.replace(/[<>'"`;(){}]/g, "").replace(/[\u0000-\u001F\u007F-\u009F]/g, "").replace(/([^/])\/{2,}/g, "$1/").replace(/\/+/g, "/").replace(/(.+)\/$/, "$1").replace(/\.+/g, ".").split("/").filter((o2) => o2 !== ".." && o2 !== ".").join("/"), i3.startsWith("/") || (i3 = "/" + i3), this.isBlockedPath(i3) ? "/" : (r.debug("[Router] Sanitized path:", i3), i3);
      } catch (t) {
        return r.error("[Router] Error sanitizing path:", t), "/";
      }
    }
    isBlockedPath(e2) {
      return r.debug("[Router] Checking if path is blocked:", e2), [/^\/(api|admin|wp-admin|wp-content|wp-includes)/i, /\.(php|asp|aspx|jsp|cgi|config|env|git|sql|htaccess)$/i, /\/(.+\/)*\.{2,}\//, /javascript:/i, /data:/i, /vbscript:/i, /file:/i].some((i3) => i3.test(e2));
    }
    test(e2) {
      r.debug("[Router] Testing path:", e2);
      let t = e2, i3 = this.sanitizePath(e2), o2 = { original: t, sanitized: i3, isBlocked: this.isBlockedPath(i3), isModified: t !== i3 };
      return r.debug(`[Router] test result for path ${e2}:`, o2), o2;
    }
    beforeEach(e2) {
      return r.debug("[Router] Adding beforeEach hook"), this.beforeEachHooks.push(e2), this;
    }
    afterEach(e2) {
      return r.debug("[Router] Adding afterEach hook"), this.afterEachHooks.push(e2), this;
    }
    use(e2) {
      return r.debug("[Router] Adding middleware"), this.middleware.push(e2), this;
    }
    addRedirect(e2, t) {
      return r.debug("[Router] Adding redirect from", e2, "to", t), this.redirects[e2] ? false : (this.redirects[e2] = t, this);
    }
    addRoute(e2, t) {
      return r.debug("[Router] Adding route", e2), this.routes[e2] = t, this;
    }
    addNestedRoute(e2, t, i3) {
      r.debug(`[Router] Adding nested route ${t} to ${e2}`);
      let o2 = `${e2}${t}`.replace(/\/\//g, "/");
      return this.addRoute(o2, i3), this;
    }
    addLazyRoute(e2, t) {
      return r.debug("[Router] Adding lazy-loaded route", e2), this.addRoute(e2, async (i3) => {
        try {
          let o2 = await t();
          return (o2.default || o2)(i3);
        } catch (o2) {
          throw o2;
        }
      }), this;
    }
    addLazyNestedRoute(e2, t, i3) {
      r.debug("[Router] Adding lazy-loaded nested route", t, "to", e2);
      let o2 = `${e2}${t}`.replace(/\/\//g, "/");
      return this.addLazyRoute(o2, i3), this;
    }
    addFallbackRoute(e2) {
      return r.debug("[Router] Adding fallback route", e2), this.fallbackRoute = e2, this;
    }
    add404Route(e2) {
      return r.debug("[Router] Adding 404 route", e2), this.routes["/404"] = e2, this;
    }
    addErrorRoute(e2) {
      return r.debug("[Router] Adding error route", e2), this.routes["/error"] = e2, this;
    }
    addProtectedRoute(e2, t, i3, o2 = "/login") {
      return r.debug("[Router] Adding protected route", e2), this.addRoute(e2, async (a2) => {
        if (await i3(a2)) return r.debug("[Router] Guard function passed, executing callback"), t(a2);
        r.debug("[Router] Guard function failed, redirecting to", o2), await this.navigateTo(o2, true);
      }), this;
    }
    removeRoute(e2) {
      return r.debug("[Router] Removing route", e2), this.routes[e2] && delete this.routes[e2], this;
    }
    updateRoute(e2, t) {
      return r.debug("[Router] Updating route", e2), this.routes[e2] && (this.routes[e2] = t), this;
    }
    getRoutes() {
      return r.debug("[Router] Getting registered routes"), this.routes;
    }
    async navigate(e2) {
      if (r.debug("[Router] Navigating to", e2), this.redirectCount > this.maxRedirects) {
        r.error("[Router] Maximum redirect limit reached, redirecting to", this.fallbackRoute), console.error("Maximum redirect limit reached"), this.redirectCount = 0, this.emit("error", new Error("Maximum redirect limit reached")), await this.navigateTo("/error", true);
        return;
      }
      this.redirectCount++;
      let t = this.matchRoute(this.sanitizePath(e2));
      if (t) try {
        if (r.debug("[Router] Route matched:", t), this.emit("beforeNavigate", t) === false) {
          r.debug("[Router] Navigation cancelled by beforeNavigate hook");
          return;
        }
        if (this.redirects[t.path]) {
          r.debug("[Router] Redirecting to", this.redirects[t.path]), await this.navigateTo(this.redirects[t.path], true);
          return;
        }
        this.redirectCount++;
        for (let o2 of this.middleware) r.debug("[Router] Executing middleware"), await o2(t);
        for (let o2 of this.beforeEachHooks) r.debug("[Router] Executing beforeEach hook"), await o2(t);
        r.debug("[Router] Executing route callback"), await t.callback(t.params);
        for (let o2 of this.afterEachHooks) r.debug("[Router] Executing afterEach hook"), await o2(t);
        this.current = t, this.emit("afterNavigate", t), r.debug("[Router] Navigation completed");
      } catch (i3) {
        r.error("[Router] Error during navigation:", i3), console.error("Navigation error:", i3), this.emit("error", i3), this.routes["/error"] && this.routes["/error"](i3);
      }
      else r.warn("[Router] Route not found:", e2), this.redirectCount = 0, this.emit("routeNotFound", e2), this.routes["/404"] && this.routes["/404"]();
    }
    async navigateTo(e2, t = false) {
      r.debug(`[Router] Navigating to ${e2} ${t ? "with replace state" : ""}`), this.redirectCount = 0;
      let i3 = new URL(e2, window.location.origin);
      t ? (r.debug("[Router] Replacing state with", i3), window.history.replaceState({}, "", i3)) : (r.debug("[Router] Pushing state with", i3), window.history.pushState({}, "", i3)), r.debug("[Router] Navigating to", i3), await this.navigate(i3.pathname);
    }
    matchRoute(e2) {
      if (r.debug("[Router] Matching route for", e2), this.cache.has(e2)) return this.cache.get(e2);
      r.debug("[Router] Route not found in cache, performing match");
      let t = this._performMatch(e2);
      if (this.cache.size >= this.cacheLimit) {
        r.debug("[Router] Cache limit reached, removing oldest entry");
        let i3 = this.cache.keys().next().value;
        this.cache.delete(i3);
      }
      return r.debug("[Router] Caching result for", e2), this.cache.set(e2, t), t;
    }
    _performMatch(e2) {
      let [t, i3] = e2.split("?"), o2 = new URLSearchParams(i3), a2 = Object.fromEntries(o2);
      for (let n3 in this.routes) {
        let d4 = [], h3 = n3.replace(/:([^\/]+)/g, (l2, u4) => (d4.push(u4), "([^/]+)")), g5 = e2.match(new RegExp(`^${h3}$`));
        if (g5) {
          let l2 = g5.slice(1).reduce((u4, b5, R5) => (u4[d4[R5]] = b5, u4), {});
          return { path: e2, pattern: h3, callback: this.routes[n3], params: l2, query: a2 };
        }
      }
      return null;
    }
    clearCache() {
      r.debug("[Router] Clearing cache"), this.cache.clear();
    }
    resetRedirectCount() {
      r.debug("[Router] Resetting redirect count"), this.redirectCount = 0;
    }
    getFullPath(e2) {
      return r.debug("[Router] Getting full path for", e2), this.useHash ? `#${e2}` : e2;
    }
    getPathFromLocation() {
      return r.debug("[Router] Getting path from location"), this.useHash ? window.location.hash.slice(1) || "/" : window.location.pathname;
    }
    listen() {
      return r.debug("[Router] Starting to listen for navigation events"), this._handleNavigation = () => {
        this.redirectCount = 0, this.navigate(this.getPathFromLocation()).then((e2) => {
        });
      }, this._handleLinkClick = (e2) => {
        if (e2.target.tagName === "A") {
          let t = e2.target.getAttribute("href");
          if (t && (this.useHash && t.startsWith("#") || !this.useHash && e2.target.href.startsWith(window.location.origin))) {
            e2.preventDefault();
            let i3 = this.useHash ? t.slice(1) : e2.target.pathname;
            this.redirectCount = 0, this.navigateTo(i3).then((o2) => {
            });
          }
        }
      }, r.debug("[Router] Listening for navigation events"), window.addEventListener(this.useHash ? "hashchange" : "popstate", this._handleNavigation), r.debug("[Router] Listening for link clicks"), document.addEventListener("click", this._handleLinkClick), this._initPlugins(), this.redirectCount = 0, this.navigate(this.getPathFromLocation()).then((e2) => {
      }), this;
    }
    _initPlugins() {
      r.debug("[Router] Init plugins"), this.plugins.forEach(({ plugin: e2, options: t }) => {
        typeof e2.onInit == "function" && e2.onInit(this, t);
      });
    }
    usePlugin(e2, t = {}) {
      if (!e2) return this;
      if (r.debug("[Router] Using plugin", e2), typeof e2 == "object" && typeof e2.install == "function") r.debug("[Router] Installing plugin", e2), e2.install(this, t);
      else if (typeof e2 == "function") r.debug("[Router] Executing plugin", e2), e2(this, t);
      else return r.warn("Invalid plugin format. Plugin must be an object with install method or a function."), this;
      return r.debug("[Router] Add plugin to store", e2), this.plugins.push({ plugin: e2, options: t }), r.debug("[Router] Plugin initialized"), this;
    }
    destroy() {
      r.debug("[Router] Destroying router"), this.plugins.forEach(({ plugin: e2, options: t }) => {
        r.debug("[Router] Destroying plugin", e2), typeof e2.onDestroy == "function" && e2.onDestroy(this, t);
      }), r.debug("[Router] Removing event listeners"), window.removeEventListener(this.useHash ? "hashchange" : "popstate", this._handleNavigation), document.removeEventListener("click", this._handleLinkClick), window.removeEventListener("unhandledrejection", this.handleError), this._handleNavigation = null, this._handleLinkClick = null, this.routes = {}, this.plugins = [], this.cache.clear(), r.debug("[Router] Router destroyed");
    }
  };
  c4.info = () => {
    console.info(`%c Router %c v${E5} %c ${w5} `, "color: #ffffff; font-weight: bold; background: #ed1cab", "color: white; background: darkgreen", "color: white; background: #0080fe;");
  };
  var f4 = c4;
  var p4 = f4;

  // ../metroui-lib/source/router/index.js
  globalThis.Router = p4;

  // ../metroui-lib/node_modules/@olton/model/dist/model.js
  var EventEmitter = class {
    /**
     * Initializes a new EventEmitter instance.
     * Creates an empty Map where:
     * - Keys are event names (strings)
     * - Values are Sets of callback functions
     */
    constructor() {
      this.events = /* @__PURE__ */ new Map();
    }
    /**
     * Registers a new event listener for the specified event.
     * - Creates new Set for event if it doesn't exist
     * - Adds callback to the Set of listeners
     * - Returns unsubscribe function for cleanup
     *
     * @param {string} eventName - Event identifier
     * @param {Function} callback - Event handler function
     * @returns {Function} Unsubscribe function
     */
    on(eventName, callback) {
      if (!this.events.has(eventName)) {
        this.events.set(eventName, /* @__PURE__ */ new Set());
      }
      this.events.get(eventName).add(callback);
      return () => this.off(eventName, callback);
    }
    /**
     * Removes a specific event listener.
     * - Safely handles non-existent events
     * - Removes only the specified callback
     * - Keeps other listeners for the same event intact
     *
     * @param {string} eventName - Event to unsubscribe from
     * @param {Function} callback - Listener to remove
     */
    off(eventName, callback) {
      if (this.events.has(eventName)) {
        this.events.get(eventName).delete(callback);
      }
    }
    /**
     * Triggers all listeners for the specified event.
     * - Safely handles non-existent events
     * - Executes each listener in try-catch block
     * - Continues execution even if one listener fails
     * - Logs errors without breaking execution
     *
     * @param {string} eventName - Event to trigger
     * @param {*} [data] - Optional data for listeners
     */
    emit(eventName, data) {
      if (this.events.has(eventName)) {
        this.events.get(eventName).forEach((callback) => {
          try {
            callback(data);
          } catch (e2) {
            console.error(`Error when performing an event handler ${eventName}:`, e2);
          }
        });
      }
    }
  };
  var event_emitter_default = EventEmitter;
  var DevToolsStyle = `
    <style>
        #model-devtools-panel  { 
            position: fixed;
            bottom: 0;
            right: 0;
            width: 300px;
            height: 400px;
            background: #242424;
            color: #fff;
            border: 1px solid #333;
            z-index: 9999;
            font-family: monospace;
            
            *::-webkit-scrollbar {
              width: 10px;
            }
            
            * {
              scrollbar-width: thin;
            }
            
            .devtools-section {
                padding: 8px;
                margin: 4px;
                border: 1px solid #444;
                cursor: pointer;
                hover: background-color: #333;
                font-size: 12px;
            }
            
            h3 {
                margin: 0;
                font-size: 14px;
                border-bottom: 1px solid #333;
                padding-bottom: 4px;
            }
        }
        
        #model-dev-tools-toggle-button {
            position: fixed;
            bottom: 10px;
            right: 10px;
            z-index: 9998;
            height: 36px;
            width: 36px;
            background: #444;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }        

        #model-devtools-time-travel-dialog {
            position: fixed;
            bottom: 0;
            right: 304px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            height: 400px;
            width: 300px;
            z-index: 10000;
            color: #fff;
            font-family: monospace;
            
            *::-webkit-scrollbar {
              width: 10px;
            }
            
            * {
              scrollbar-width: thin;
            }
            
            .time-travel-items {
                padding: 4px; 
                height: calc(100% - 35px); 
                overflow: auto;
                position: relative;
            }
            
            .time-travel-item {
                padding: 8px;
                margin: 4px;
                border: 1px solid #444;
                cursor: pointer;
                hover: background-color: #333;
                font-size: 12px;
                
                button {
                    margin-top: 8px;
                    background: dodgerblue;
                }
            }
        }
        
        #model-devtools-panel, #model-devtools-time-travel-dialog {
            button {
                height: 20px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
                border-radius: 4px;
                border: 1px solid #444;
                background: #333;
                color: #fff;
                cursor: pointer;
                
                @media (hover: hover) {
                    &:hover {
                        background: #444;
                    }
                }

                @media (hover: none) {
                    &:hover {
                        background: #444;
                    }
                }
            }        
        }
        
        .dev-tools-header {
            padding: 8px; 
            border-bottom: 1px solid #333; 
            display: flex; 
            justify-content: space-between;
        }
    </style>
`;
  var dev_tools_style_default = DevToolsStyle;
  var ModelDevTools = class {
    constructor(model, options = {}) {
      this.model = model;
      this.options = {
        enabled: true,
        timeTravel: true,
        maxSnapshots: 50,
        ...options
      };
      this.history = [];
      this.currentIndex = -1;
      this.initializeDevTools();
    }
    /**
     * Initializes the model development tools by:
     * - Creating a global reference at window.__MODEL_DEVTOOLS__
     * - Creating the dev tools panel in the DOM
     * - Setting up model event listeners for debugging
     */
    initializeDevTools() {
      window.__MODEL_DEVTOOLS__ = this;
      this.createDevToolsPanel();
      this.setupModelListeners();
    }
    /**
     * Creates the development tools panel in the DOM with:
     * - A header with title and control buttons
     * - Content area for debugging information
     * - Styling from DevToolsWindowStyle
     * - Close and Time Travel buttons with event handlers
     * - Toggle button for panel visibility
     */
    createDevToolsPanel() {
      const panel = document.createElement("div");
      panel.id = "model-devtools-panel";
      panel.style.cssText = `display: none;`;
      const header = document.createElement("div");
      header.innerHTML = `
            ${dev_tools_style_default}
            <div class="dev-tools-header">
                <span>\u{1F6E0} Model DevTools</span>
                <div>
                    <button id="devtools-time-travel" title="Time Travel">\u23F1</button>
                    <button id="devtools-close" title="Close">\xD7</button>
                </div>
            </div>
        `;
      const content = document.createElement("div");
      content.style.cssText = `
            padding: 8px;
            height: calc(100% - 35px);
            overflow: auto;
        `;
      content.id = "model-devtools-content";
      panel.appendChild(header);
      panel.appendChild(content);
      document.body.appendChild(panel);
      this.createToggleButton();
      document.getElementById("devtools-close").onclick = () => this.togglePanel();
      document.getElementById("devtools-time-travel").onclick = () => this.showTimeTravelDialog();
    }
    /**
     * Displays the Time Travel dialog by:
     * - Creating or reusing existing dialog container
     * - Generating a reversed chronological list of snapshots
     * - Formatting snapshot data (timestamp, type, property, old/new values)
     * - Displaying changes in computed properties and value transitions
     */
    showTimeTravelDialog() {
      let dialog = document.getElementById("model-devtools-time-travel-dialog");
      if (!dialog) {
        dialog = document.createElement("div");
        dialog.id = "model-devtools-time-travel-dialog";
      }
      const statesList = [...this.history].reverse().map((snapshot, index) => `
            <div class="time-travel-item">
                <div>Time: ${new Date(snapshot.timestamp).toLocaleTimeString()}</div>
                <div>Type: ${snapshot.type}</div>
                <div>Property: ${snapshot.property || snapshot.event || snapshot.path || ""}</div>
                <div>Value: ${snapshot.type === "computed-update" ? snapshot.newValue : typeof snapshot.oldValue !== "undefined" && typeof snapshot.newValue !== "undefined" ? `${JSON.stringify(snapshot.oldValue)} -> ${JSON.stringify(snapshot.newValue)}` : JSON.stringify(snapshot.newValue || snapshot.value || "")}</div>
                <button style="display: none" onclick="window.__MODEL_DEVTOOLS__.timeTravel(${this.history.length - 1 - index})">Apply this state</button>
            </div>
        `).join("");
      dialog.innerHTML = `
            <div class="dev-tools-header">
                <span>\u23F1 Time Travel</span>
                <div>
                    <button style="margin-left: auto;" onclick="window.__MODEL_DEVTOOLS__.clearTimeTravel()">CLear</button>
                    <button onclick="this.parentElement.parentElement.parentElement.remove()">\xD7</button>                
                </div>
            </div>
            <div class="time-travel-items">${statesList || "Nothing to show!"}</div>
        `;
      document.body.appendChild(dialog);
    }
    /**
     * Creates a toggle button for the Model DevTools panel.
     * The button is appended to the page and provides
     * functionality to show or hide the dev tools panel.
     */
    createToggleButton() {
      const button = document.createElement("button");
      button.id = "model-dev-tools-toggle-button";
      button.textContent = "\u{1F6E0}";
      button.title = "Model DevTools";
      button.onclick = () => this.togglePanel();
      document.body.appendChild(button);
    }
    /**
     * Sets up listeners for the model and its store to track and log changes,
     * events, computed property updates, and array operations. This enables
     * the Model DevTools to record snapshot history, provide time travel
     * functionality, and update the display with relevant data changes.
     */
    setupModelListeners() {
      this.model.store.on("change", (data) => {
        this.logChange({
          type: "data-change",
          path: data.path,
          oldValue: data.oldValue,
          newValue: data.newValue,
          timestamp: Date.now()
        });
      });
      this.model.store.on("*", (eventName, data) => {
        if (eventName !== "change" && eventName !== "compute" && eventName !== "arrayChange") {
          this.logChange({
            type: "store-event",
            event: eventName,
            data,
            timestamp: Date.now()
          });
        }
      });
      this.model.on("*", (eventName, data) => {
        if (eventName !== "change" && eventName !== "compute") {
          this.logChange({
            type: "model-event",
            event: eventName,
            data,
            timestamp: Date.now()
          });
        }
      });
      this.model.store.on("compute", (data) => {
        this.logChange({
          type: "computed-update",
          property: data.key,
          dependencies: Array.from(data.dependencies),
          newValue: data.value,
          timestamp: Date.now()
        });
      });
      this.model.store.on("arrayChange", (data) => {
        this.logChange({
          type: "array-operation",
          path: data.path,
          method: data.method,
          args: data.args,
          oldValue: data.oldValue,
          newValue: data.newValue,
          timestamp: Date.now()
        });
      });
    }
    /**
     * Logs a change entry and updates the Model DevTools display if enabled.
     *
     * - If the `timeTravel` option is enabled, the method saves a snapshot of the current state.
     * - Updates the DevTools display to reflect the new changes.
     *
     * @param {Object} entry - The change entry to log.
     * @param {string} entry.type - The type of change (for example, 'data-change', 'model-event', etc.).
     * @param {string} [entry.path] - Path of the property being changed (if applicable).
     * @param {any} [entry.oldValue] - The previous value of the changed property (if applicable).
     * @param {any} [entry.newValue] - The new value of the changed property (if applicable).
     * @param {string} [entry.event] - The event name associated with the change (if applicable).
     * @param {number} entry.timestamp - A timestamp indicating when the change occurred.
     */
    logChange(entry) {
      if (!this.options.enabled) return;
      if (this.options.timeTravel) {
        this.saveSnapshot(entry);
      }
      this.updateDisplay();
    }
    /**
     * Saves a snapshot of the current model state, including computed properties and relevant metadata.
     *
     * - Trims the history to ensure the size does not exceed `maxSnapshots`.
     * - Updates the snapshot history and current snapshot index.
     *
     * @param {Object} entry - The change entry that triggered the snapshot.
     * @param {string} entry.type - The type of change (for example, 'data-change', 'model-event', etc.).
     * @param {string} [entry.path] - Path of the property being changed (if applicable).
     * @param {any} [entry.oldValue] - The previous value before the change (if applicable).
     * @param {any} [entry.newValue] - The new value after the change (if applicable).
     * @param {number} entry.timestamp - A timestamp indicating when the change occurred.
     */
    saveSnapshot(entry) {
      const snapshot = {
        ...entry,
        state: JSON.parse(JSON.stringify(this.model.data)),
        computed: this.getComputedValues()
      };
      this.history = this.history.slice(0, this.currentIndex + 1);
      this.history.push(snapshot);
      this.currentIndex++;
      if (this.history.length > this.options.maxSnapshots) {
        this.history.shift();
        this.currentIndex--;
      }
    }
    /**
     * Updates the display of the Model DevTools.
     *
     * - Retrieves and formats the current state, computed values, DOM dependencies, and
     *   recent changes in the model.
     * - Creates and dynamically sets the innerHTML content of the Model DevTools panel.
     * - Triggers the time travel dialog if the corresponding element is present.
     *
     * This method ensures that the visual representation of the model remains up-to-date
     * for debugging and monitoring purposes.
     */
    updateDisplay() {
      const content = document.getElementById("model-devtools-content");
      if (!content) return;
      const formatValue = (value) => {
        if (value === void 0) return "undefined";
        if (value === null) return "null";
        try {
          if (Array.isArray(value)) {
            return `Array(${value.length}) ${JSON.stringify(value, null, 2)}`;
          }
          return JSON.stringify(value, null, 2);
        } catch (e2) {
          return String(value);
        }
      };
      const recentChanges = this.getRecentChanges();
      let changes = ``;
      for (const change of recentChanges) {
        let changeContent;
        try {
          const formattedChange = {
            ...change,
            timestamp: new Date(change.timestamp).toLocaleTimeString()
          };
          changeContent = JSON.stringify(formattedChange, null, 2);
        } catch (e2) {
          changeContent = `Error formatting change: ${e2.message}`;
        }
        changes += `
            <div style="border-bottom: 1px solid #444; padding-bottom: 8px; overflow-x: auto">
                <pre>${changeContent}</pre>
            </div>
`;
      }
      const computedValues = this.getComputedValues();
      content.innerHTML = `
        <div class="devtools-section">
            <h3>Current State:</h3>
            <pre>${formatValue(this.model.data)}</pre>
        </div>
        <div class="devtools-section">
            <h3>Computed Values:</h3>
            <pre>${formatValue(computedValues)}</pre>
        </div>
        <div class="devtools-section">
            <h3>DOM Dependencies:</h3>
            <pre>${this.formatDOMDependencies()}</pre>
        </div>
        <div class="devtools-section">
            <h3>Recent Changes:</h3>
            ${changes}
        </div>
    `;
      const timeTravelDialog = document.getElementById("model-devtools-time-travel-dialog");
      if (timeTravelDialog) {
        this.showTimeTravelDialog();
      }
    }
    /**
     * Formats and returns a structured representation of model's DOM dependencies.
     *
     * - Loops through the DOM dependencies managed in the model.
     * - Converts the `Map` structure into a plain object for easier inspection.
     * - Each dependency entry includes the type of dependency and the tag name of the associated element.
     *
     * @returns {string} A JSON string representing the formatted DOM dependencies.
     */
    formatDOMDependencies() {
      try {
        const dependencies = {};
        this.model.dom.domDependencies.forEach((value, key) => {
          dependencies[key] = Array.from(value).map((dep) => ({
            type: dep.type,
            element: dep.element.tagName
          }));
        });
        return JSON.stringify(dependencies, null, 2);
      } catch (e2) {
        return `Error formatting DOM dependencies: ${e2.message}`;
      }
    }
    /**
     * Retrieves computed values from the model and returns them in a structured format.
     *
     * - If the model's `computed.all` function is available, all computed values are fetched at once.
     * - If the model has a list of computed keys, their values are retrieved individually.
     * - Falls back to iterating over model data keys and extracting computed values if present.
     *
     * @returns {Object} An object containing the computed values from the model.
     */
    getComputedValues() {
      if (!this.model.computed) return {};
      if (typeof this.model.computed.all === "function") {
        return this.model.computed.all();
      }
      if (this.model.computed.keys && Array.isArray(this.model.computed.keys)) {
        const result = {};
        for (const key of this.model.computed.keys) {
          result[key] = this.model.computed.getValue(key);
        }
        return result;
      }
      const computedValues = {};
      for (const key in this.model.data) {
        if (this.model.computed && typeof this.model.computed[key] !== "undefined") {
          computedValues[key] = this.model.data[key];
        }
      }
      return computedValues;
    }
    /**
     * Retrieves the most recent changes from the history.
     *
     * - This method fetches the last 5 changes from the `history` array.
     * - The returned changes are reversed to display the most recent change first.
     *
     * @returns {Array} An array of recent changes from the history.
     */
    getRecentChanges() {
      return this.history.slice(-5).reverse();
    }
    /**
     * Toggles the visibility of the development tools panel.
     *
     * - If the panel is currently hidden (`display: none`), it will be made visible.
     * - If the panel is currently visible, it will be hidden.
     */
    togglePanel() {
      const panel = document.getElementById("model-devtools-panel");
      if (panel) {
        panel.style.display = panel.style.display === "none" ? "block" : "none";
      }
      if (panel.style.display === "none") {
        document.getElementById("model-devtools-time-travel-dialog").remove();
      }
    }
    /**
     * Retrieves the data stored at the specified path in the model's store.
     *
     * - The `path` parameter is used to access specific data within the store.
     * - The method returns the value found at the given path.
     *
     * @param {string} path - The dot-notated path to retrieve the value from the store.
     * @returns {*} The data stored at the specified path.
     */
    inspect(path) {
      return this.model.store.get(path);
    }
    /**
     * Toggles the visibility of the development tools panel in the UI.
     *
     * - The method checks the current display state of the panel element.
     * - If the panel is hidden (`display: none`), it becomes visible (`block`).
     * - If the panel is visible, it gets hidden.
     *
     * @example
     * // Assuming an element with ID 'model-devtools-panel' exists:
     * devTools.togglePanel();
     *
     * // This will toggle the panel's visibility between shown and hidden.
     */
    timeTravel(index) {
      if (!this.options.timeTravel || true) return;
      if (index < 0 || index >= this.history.length) return;
      const snapshot = this.history[index];
      try {
        const origEnabled = this.options.enabled;
        this.options.enabled = false;
        this.model.store.setState(snapshot.state);
        if (this.model.computed) {
          if (typeof this.model.computed.recomputeAll === "function") {
            this.model.computed.recomputeAll();
          } else {
            for (const key in snapshot.computed) {
              if (typeof this.model.computed.evaluate === "function") {
                this.model.computed.evaluate(key, true);
              } else if (typeof this.model.computed.recompute === "function") {
                this.model.computed.recompute(key);
              }
            }
          }
        }
        this.model.dom.updateAllDOM();
        this.currentIndex = index;
        this.options.enabled = origEnabled;
      } catch (e2) {
        console.error("Error during time travel:", e2);
      }
    }
    clearTimeTravel() {
      this.history = [];
      this.currentIndex = -1;
      this.showTimeTravelDialog();
    }
    /**
     * Starts performance monitoring for the model's store.
     *
     * - Sets up initial metrics counters for updates, computations, and DOM updates.
     * - Begins tracking the performance of the model store.
     * - Records changes and computations triggered on the store.
     *
     * @example
     * const devTools = new ModelDevTools(model);
     * devTools.startPerfMonitoring();
     *
     * // After some operations on the model:
     * console.log(devTools.getPerfReport());
     * // Outputs the performance metrics report.
     */
    startPerfMonitoring() {
      this.perfMetrics = {
        updates: 0,
        computations: 0,
        domUpdates: 0,
        startTime: Date.now()
      };
      this.model.store.on("change", () => {
        this.perfMetrics.updates++;
      });
      this.model.store.on("compute", () => {
        this.perfMetrics.computations++;
      });
    }
    getPerfReport() {
      const duration = (Date.now() - this.perfMetrics.startTime) / 1e3;
      return {
        totalUpdates: this.perfMetrics.updates,
        updatesPerSecond: this.perfMetrics.updates / duration,
        computationsPerSecond: this.perfMetrics.computations / duration,
        domUpdatesPerSecond: this.perfMetrics.domUpdates / duration
      };
    }
  };
  var dev_tools_default = ModelDevTools;
  var MiddlewareManager = class {
    /**
     * Creates a new MiddlewareManager instance.
     * Initializes empty array for middleware functions.
     */
    constructor() {
      this.middlewares = [];
    }
    /**
     * Registers a new middleware function.
     * - Validates that middleware is a function
     * - Logs error if invalid middleware provided
     * - Adds valid middleware to execution chain
     *
     * @param {Function} middleware - Function(context, next)
     * @returns {void}
     * @throws {Error} Logs error for non-function middleware
     */
    use(middleware) {
      if (typeof middleware !== "function") {
        console.error("MIDDLEWARE should be a function!");
        return;
      }
      this.middlewares.push(middleware);
    }
    /**
     * Executes middleware chain sequentially.
     * - Maintains execution order using index counter
     * - Creates and passes next() function to each middleware
     * - Supports async middleware execution
     * - Preserves and returns modified context
     * - Stops chain when no more middleware exists
     *
     * @param {Object} context - Data passed through middleware chain
     * @returns {Promise<Object>} Modified context after chain completion
     */
    async process(context) {
      let index = -1;
      const next = async () => {
        index++;
        if (index < this.middlewares.length) {
          await this.middlewares[index](context, next);
        }
      };
      await next();
      return context;
    }
  };
  var middleware_default = MiddlewareManager;
  var Logger = class _Logger {
    /**
     * Enumeration of available debug levels from lowest (NONE) to highest (TRACE).
     * Used to control the verbosity of logging output.
     */
    static DEBUG_LEVELS = {
      NONE: 0,
      ERROR: 1,
      WARN: 2,
      INFO: 3,
      DEBUG: 4,
      TRACE: 5
    };
    /**
     * The current debug level for the Logger class. Determines the types of logs
     * that will be displayed. To adjust the logging behavior, set this property
     * to one of the predefined levels in `Logger.DEBUG_LEVELS`.
     *
     * @type {number}
     * @default Logger.DEBUG_LEVELS.NONE
     */
    static DEBUG_LEVEL = _Logger.DEBUG_LEVELS.NONE;
    /**
     * Core logging method that handles message formatting and output.
     * @param {number} level - Debug level from Logger.DEBUG_LEVELS
     * @param {string} message - Message to log
     * @param {any} [data] - Optional data to display
     * @private
     */
    static log(level, message, data) {
      if (level > _Logger.DEBUG_LEVEL) return;
      const styles = {
        error: "color: #ff5555; font-weight: bold",
        warn: "color: #ffaa00; font-weight: bold",
        info: "color: #0080fe; font-weight: bold",
        debug: "color: #00aa00; font-weight: bold",
        trace: "color: #888888",
        data: "color: #555; font-style: italic"
      };
      let styleType;
      let method;
      switch (level) {
        case _Logger.DEBUG_LEVELS.ERROR:
          styleType = "error";
          method = console.error;
          break;
        case _Logger.DEBUG_LEVELS.WARN:
          styleType = "warn";
          method = console.warn;
          break;
        case _Logger.DEBUG_LEVELS.INFO:
          styleType = "info";
          method = console.info;
          break;
        case _Logger.DEBUG_LEVELS.DEBUG:
          styleType = "debug";
          method = console.debug;
          break;
        case _Logger.DEBUG_LEVELS.TRACE:
          styleType = "trace";
          method = console.log;
          break;
        default:
          return;
      }
      console.group(`%c Model: ${message}`, styles[styleType]);
      if (data !== void 0) {
        console.log("%c Data:", styles.data, data);
      }
      console.groupEnd();
    }
    /**
     * Logs an error message with an optional data object.
     * This method uses the `Logger.DEBUG_LEVELS.ERROR` level.
     *
     * @param {string} message - The error message to log.
     * @param {any} [data] - Additional data to log alongside the message.
     */
    static error(message, data) {
      _Logger.log(_Logger.DEBUG_LEVELS.ERROR, message, data);
    }
    /**
     * Logs a warning message with an optional data object.
     * This method uses the `Logger.DEBUG_LEVELS.WARN` level.
     *
     * @param {string} message - The warning message to log.
     * @param {any} [data] - Additional data to log alongside the message.
     */
    static warn(message, data) {
      _Logger.log(_Logger.DEBUG_LEVELS.WARN, message, data);
    }
    /**
     * Logs an informational message with an optional data object.
     * This method uses the `Logger.DEBUG_LEVELS.INFO` level.
     *
     * @param {string} message - The informational message to log.
     * @param {any} [data] - Additional data to log alongside the message.
     */
    static info(message, data) {
      _Logger.log(_Logger.DEBUG_LEVELS.INFO, message, data);
    }
    /**
     * Logs a debug message with an optional data object.
     * This method uses the `Logger.DEBUG_LEVELS.DEBUG` level.
     *
     * @param {string} message - The debug message to log.
     * @param {any} [data] - Additional data to log alongside the message.
     */
    static debug(message, data) {
      _Logger.log(_Logger.DEBUG_LEVELS.DEBUG, message, data);
    }
    /**
     * Logs a trace message with an optional data object.
     * This method uses the `Logger.DEBUG_LEVELS.TRACE` level.
     *
     * @param {string} message - The trace message to log.
     * @param {any} [data] - Additional data to log alongside the message.
     */
    static trace(message, data) {
      _Logger.log(_Logger.DEBUG_LEVELS.TRACE, message, data);
    }
  };
  var ReactiveStore = class extends event_emitter_default {
    /**
     * Initializes a new ReactiveStore.
     * - Creates reactive proxy for state management
     * - Sets up watchers for property observation
     * - Stores previous state for change detection
     * - Initializes middleware system for state updates
     *
     * @param {Object} [initialState={}] - Initial store state
     * @param model
     * @property {Proxy} state - Reactive state object
     * @property {Map} watchers - Property change observers
     * @property {Object} previousState - Last known state
     * @property {MiddlewareManager} middleware - State update pipeline
     */
    constructor(initialState = {}, model) {
      Logger.DEBUG_LEVEL = model.options.debug ? 4 : 0;
      Logger.debug("Init ReactiveStore");
      super();
      this.model = model;
      Logger.DEBUG_LEVEL = this.model.options.debug ? 4 : 0;
      Logger.debug("Init ReactiveStore");
      this.state = this.createReactiveProxy(initialState);
      this.watchers = /* @__PURE__ */ new Map();
      this.previousState = JSON.parse(JSON.stringify(initialState));
      Logger.debug("Init MiddlewareManager");
      this.middleware = new middleware_default();
      Logger.debug("MiddlewareManager initialized");
      Logger.debug("ReactiveStore initialized");
    }
    /**
     * Registers state change middleware.
     * Middleware receives context object with:
     * - prop: Changed property name
     * - oldValue: Previous value
     * - newValue: New value
     * - preventDefault: Control flag
     *
     * @param {Function} middleware - Handler(context, next)
     */
    use(middleware) {
      Logger.debug("Registering middleware:", middleware);
      this.middleware.use(middleware);
    }
    /**
     * Creates reactive proxy for state objects.
     * Features:
     * - Special handling for arrays via separate proxy
     * - Deep reactivity for nested objects
     * - Property path tracking
     * - Value validation support
     * - Value formatting support
     * - Middleware integration
     * - Change prevention capability
     *
     * @param {Object|Array} obj - Target object
     * @param {string} [path=''] - Property path
     * @returns {Proxy} Reactive proxy
     */
    createReactiveProxy(obj, path = "") {
      Logger.debug(`Creating reactive object with path ${path} for`, obj);
      if (Array.isArray(obj)) {
        return this.createArrayProxy(obj, path);
      }
      return new Proxy(obj, {
        get: (target, prop) => {
          if (typeof prop === "symbol") {
            return target[prop];
          }
          const value = target[prop];
          const fullPath = path ? `${path}.${prop}` : prop;
          if (value && typeof value === "object") {
            return this.createReactiveProxy(value, fullPath);
          }
          return value;
        },
        set: async (target, prop, value) => {
          if (typeof prop === "symbol") {
            target[prop] = value;
            return true;
          }
          const fullPath = path ? `${path}.${prop}` : prop;
          const oldValue = target[prop];
          if (oldValue === value) {
            return true;
          }
          if (this.validators?.has(`${fullPath}`)) {
            const isValid = this.validators.get(`${fullPath}`)(value);
            if (!isValid) return false;
          }
          if (this.formatters?.has(`${fullPath}`)) {
            value = this.formatters.get(`${fullPath}`)(value);
          }
          if (value && typeof value === "object") {
            value = this.createReactiveProxy(value, fullPath);
          }
          const context = {
            prop,
            oldValue,
            newValue: value,
            preventDefault: false
          };
          await this.middleware.process(context);
          if (context.preventDefault) {
            return true;
          }
          target[prop] = value;
          this.emit("change", {
            path: fullPath,
            oldValue,
            newValue: value
          });
          if (this.watchers.has(fullPath)) {
            this.watchers.get(fullPath).forEach((callback) => {
              callback(value, oldValue);
            });
          }
          return true;
        },
        deleteProperty: (target, prop) => {
          if (typeof prop === "symbol") {
            return delete target[prop];
          }
          const fullPath = path ? `${path}.${prop}` : prop;
          const oldValue = target[prop];
          const result = delete target[prop];
          if (result) {
            this.emit("delete", {
              path: fullPath,
              oldValue
            });
            if (this.watchers.has(fullPath)) {
              this.watchers.get(fullPath).forEach((callback) => {
                callback(void 0, oldValue);
              });
            }
          }
          return result;
        }
      });
    }
    /**
     * Creates a reactive proxy for an array.
     * The proxy intercepts standard array methods (for example, push, pop, shift, etc.)
     * to enable detection and reaction to structural changes in the array.
     * It also ensures that array elements are made reactive.
     *
     * @param {Array} array - The array to be proxied.
     * @param {string} path - The path to the current property in the state tree.
     *
     * @returns {Proxy} A proxy that wraps the given array to make it reactive.
     */
    createArrayProxy(array, path) {
      Logger.debug(`Creating reactive array with path ${path} for`, array);
      return new Proxy(array, {
        get: (target, prop) => {
          if (typeof prop === "symbol") {
            return target[prop];
          }
          const value = target[prop];
          if (typeof value === "function" && ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].includes(prop)) {
            return (...args) => {
              const oldValue = [...target];
              const result = target[prop].apply(target, args);
              const context = {
                prop: path,
                oldValue,
                newValue: target,
                method: prop,
                args,
                preventDefault: false
              };
              this.middleware.process(context).then(() => {
                if (!context.preventDefault) {
                  this.emit("arrayChange", {
                    path,
                    method: prop,
                    args,
                    oldValue,
                    newValue: target
                  });
                  this.emit("change", {
                    path,
                    oldValue,
                    newValue: target,
                    method: prop,
                    args
                  });
                  if (this.watchers.has(path)) {
                    this.watchers.get(path).forEach((callback) => {
                      callback(target, oldValue);
                    });
                  }
                }
              });
              return result;
            };
          }
          if (typeof prop !== "symbol" && !isNaN(Number(prop))) {
            if (value && typeof value === "object") {
              return this.createReactiveProxy(value, `${path}[${prop}]`);
            }
          }
          return value;
        },
        set: async (target, prop, value) => {
          if (typeof prop === "symbol") {
            target[prop] = value;
            return true;
          }
          const fullPath = path ? `${path}.${prop}` : prop;
          const oldValue = target[prop];
          if (oldValue === value) {
            return true;
          }
          if (this.validators?.has(fullPath)) {
            const isValid = this.validators.get(fullPath)(value);
            if (!isValid) return false;
          }
          if (this.formatters?.has(fullPath)) {
            value = this.formatters.get(fullPath)(value);
          }
          target[prop] = value;
          if (value && typeof value === "object") {
            value = this.createReactiveProxy(value, `${path}[${prop}]`);
          }
          const context = {
            prop,
            oldValue,
            newValue: value,
            preventDefault: false
          };
          await this.middleware.process(context);
          if (context.preventDefault) {
            return true;
          }
          target[prop] = value;
          this.middleware.process(context).then(() => {
            if (!context.preventDefault) {
              this.emit("arrayChange", {
                path: fullPath,
                method: null,
                args: null,
                oldValue,
                newValue: value
              });
              this.emit("change", {
                path: fullPath,
                oldValue,
                newValue: value,
                arrayIndex: Number(prop)
              });
              if (this.watchers.has(fullPath)) {
                this.watchers.get(fullPath).forEach((callback) => {
                  callback(value, oldValue);
                });
              }
            }
          });
          return true;
        }
      });
    }
    /**
     * Applies the specified array method (for example, push, pop, splice) on the array
     * located at the given path in the state tree. The function ensures
     * that the changes are reactive by emitting appropriate events and invoking watchers.
     *
     * @param {string} path - The path to the array in the state tree.
     * @param {string} method - The name of the array method to apply (for example, 'push', 'pop').
     * @param {...any} args - Arguments to pass to the array method.
     *
     * @returns {any} The result of applying the array method to the array.
     */
    applyArrayMethod(path, method, ...args) {
      Logger.debug(`Applying array method ${method} to path ${path} with args`, args);
      const array = this.get(path);
      if (!Array.isArray(array)) {
        console.error(`\u041F\u0443\u0442\u044C ${path} \u043D\u0435 \u044F\u0432\u043B\u044F\u0435\u0442\u0441\u044F \u043C\u0430\u0441\u0441\u0438\u0432\u043E\u043C!`);
        return false;
      }
      const oldArray = [...array];
      const result = array[method].apply(array, args);
      this.emit("arrayChange", {
        path,
        method,
        args,
        oldValue: oldArray,
        newValue: [...array]
      });
      this.emit("change", {
        path,
        oldValue: oldArray,
        newValue: [...array]
      });
      if (this.watchers.has(path)) {
        this.watchers.get(path).forEach((callback) => {
          callback([...array], oldArray);
        });
      }
      return result;
    }
    /**
     * Watches for changes to an array located at the specified path in the state tree
     * and applies the provided callback to make modifications.
     * Emitted events ensure that watchers are notified and reactivity is maintained.
     *
     * @param {string} path - The path to the array in the state tree.
     * @param {Function} callback - A function to modify the array.
     *                               Receives the array as an argument and applies changes to it.
     *
     * @returns {any} The result of the callback function applied to the array.
     */
    applyArrayChanges(path, callback) {
      Logger.debug(`Applying custom array changes to path ${path} with callback`, callback);
      const array = this.get(path);
      if (!Array.isArray(array)) {
        console.error(`The path ${path} is not an array!`);
        return false;
      }
      const oldArray = [...array];
      const result = callback(array);
      this.emit("arrayChange", {
        path,
        method: "custom",
        args: null,
        oldValue: oldArray,
        newValue: [...array]
      });
      this.emit("change", {
        path,
        oldValue: oldArray,
        newValue: [...array]
      });
      if (this.watchers.has(path)) {
        this.watchers.get(path).forEach((callback2) => {
          callback2([...array], oldArray);
        });
      }
      return result;
    }
    /**
     * Detects changes between two arrays, identifying items that were added, removed,
     * or moved. This function compares items by their JSON stringified values.
     *
     * @param {Array} newArray - The new array to compare.
     * @param {Array} [oldArray=[]] - The old array to compare against. Defaults to an empty array.
     *
     * @returns {Object} An object containing the changes between the arrays.
     */
    detectArrayChanges(newArray, oldArray = []) {
      Logger.debug(`Detecting changes between arrays`);
      const changes = {
        added: [],
        removed: [],
        moved: []
      };
      for (let i3 = 0; i3 < newArray.length; i3++) {
        const item = newArray[i3];
        const oldIndex = oldArray.findIndex(
          (oldItem) => JSON.stringify(oldItem) === JSON.stringify(item)
        );
        if (oldIndex === -1) {
          changes.added.push({ index: i3, item });
        } else if (oldIndex !== i3) {
          changes.moved.push({ oldIndex, newIndex: i3, item });
        }
      }
      for (let i3 = 0; i3 < oldArray.length; i3++) {
        const item = oldArray[i3];
        const newIndex = newArray.findIndex(
          (newItem) => JSON.stringify(newItem) === JSON.stringify(item)
        );
        if (newIndex === -1) {
          changes.removed.push({ index: i3, item });
        }
      }
      Logger.debug(`Detected changes:`, changes);
      return changes;
    }
    /**
     * Watches for changes to the specified path in the state tree
     * and allows the addition of callbacks that execute when changes occur.
     *
     * @param {string} path - The path in the state tree to watch for changes.
     * @param {Function} callback - A function to execute when the value at the path changes.
     *                                The callback receives the new and old values as parameters.
     *
     * @returns {Function} A function to unsubscribe the callback from the watcher.
     */
    watch(path, callback) {
      Logger.debug(`Watching path ${path} with callback`, callback);
      if (!this.watchers.has(path)) {
        this.watchers.set(path, /* @__PURE__ */ new Set());
      }
      this.watchers.get(path).add(callback);
      return () => {
        if (this.watchers.has(path)) {
          this.watchers.get(path).delete(callback);
        }
      };
    }
    /**
     * Retrieves the value at the specified path in the state tree.
     * @param {string} [path] - The dot-delimited path to the desired value within the state tree.
     * @returns {any} - The value at the specified path or `undefined` if the path does not exist.
     */
    get(path) {
      Logger.debug(`Getting value at path ${path}`);
      if (!path) return this.state;
      const parts = path.split(".");
      let value = this.state;
      for (const part of parts) {
        if (value === void 0 || value === null) {
          return void 0;
        }
        value = value[part];
      }
      return value;
    }
    /**
     * Sets a new value at the specified path in the state tree.
     * @param {String} path - The dot-delimited path to the desired value within the state tree.
     * @param {any} value - The new value to set at the specified path.
     */
    set(path, value) {
      Logger.debug(`Setting value at path ${path} to`, value);
      const parts = path.split(".");
      let current = this.state;
      for (let i3 = 0; i3 < parts.length - 1; i3++) {
        if (current[parts[i3]] === void 0) {
          current[parts[i3]] = {};
        }
        current = current[parts[i3]];
      }
      current[parts[parts.length - 1]] = value;
      return value;
    }
    /**
     * Executes the given updater as a batch operation on the state.
     *
     * If the `updater` is a function, it will be invoked with the state as an argument,
     * allowing for multiple updates within a single call. If the `updater` is an object,
     * its key-value pairs will be used to update specific paths in the state.
     *
     * After the batch operation completes, an event (`batchUpdate`) is emitted containing
     * both the previous state (before changes) and the current state (after changes).
     *
     * @param {Function|Object} updater - Either a function to modify the state or an object where keys represent
     *                                    paths (dot-delimited) and values are the new values to set for those paths.
     */
    batch(updater) {
      Logger.debug(`Batch updating state with`, updater);
      this.previousState = JSON.parse(JSON.stringify(this.state));
      if (typeof updater === "function") {
        updater(this.state);
      } else if (typeof updater === "object") {
        Object.entries(updater).forEach(([path, value]) => {
          this.set(path, value);
        });
      }
      this.emit("batchComplete", {
        previousState: this.previousState,
        currentState: this.state
      });
    }
    /**
     * Retrieves the current state tree.
     * @returns {Object} The entire state object.
     */
    getState() {
      Logger.debug(`Getting entire state`);
      return this.state;
    }
    /**
     * Retrieves the previous state of the state tree.
     *
     * This method returns the state as it was prior to the last update,
     * enabling comparison or rollback operations if needed.
     *
     * @returns {Object} The previous state object.
     */
    getPreviousState() {
      Logger.debug(`Getting previous state`);
      return this.previousState;
    }
    /**
     * Converts the current state tree to a JSON string.
     *
     * This method serializes the entire state tree into a JSON-formatted string,
     * which can be used for storage, transmission, or debugging purposes.
     *
     * @returns {string} A JSON string representation of the current state.
     */
    toJSON() {
      Logger.debug(`Converting state to JSON`);
      return JSON.stringify(this.state);
    }
    /**
     * Reconstructs the state tree from a JSON string.
     *
     * This method accepts a JSON-formatted string representing the state,
     * replaces the current state with the contents of the JSON, and emits a `restore` event
     * to notify listeners about the restoration operation. The previous state is preserved
     * for potential comparisons or rollback operations.
     *
     * @param {string} json - A JSON-formatted string representing the new state.
     */
    fromJSON(json) {
      Logger.debug(`Restoring state from JSON`, json);
      const newState = JSON.parse(json);
      this.previousState = JSON.parse(JSON.stringify(this.state));
      Object.keys(this.state).forEach((key) => {
        delete this.state[key];
      });
      Object.entries(newState).forEach(([key, value]) => {
        this.state[key] = value;
      });
      this.emit("restore", {
        previousState: this.previousState,
        currentState: this.state
      });
    }
    /**
     * Adds a validator function for a specific property in the state tree.
     *
     * The validator function should accept the new value as a parameter
     * and return `true` if the value is valid, or `false` if it is invalid.
     *
     * @param {string} propertyPath - The dot-delimited path to the property in the state tree to validate.
     * @param {Function} validator - A function that checks the validity of the property value.
     */
    addValidator(propertyPath, validator) {
      Logger.debug(`Adding validator for path ${propertyPath}`);
      if (!this.validators) {
        this.validators = /* @__PURE__ */ new Map();
      }
      this.validators.set(propertyPath, validator);
    }
    /**
     * Adds a formatter function for a specific property in the state tree.
     *
     * The formatter function modifies the value of a property before it is returned.
     * This can be helpful when the stored value needs to be presented in a specific format.
     *
     * @param {string} propertyPath - The dot-delimited path to the property in the state tree to format.
     * @param {Function} formatter - A function that transforms the value of the property.
     *                                The function receives the current value as a parameter
     *                                and returns the formatted value.
     */
    addFormatter(propertyPath, formatter) {
      Logger.debug(`Adding formatter for path ${propertyPath}`);
      if (!this.formatters) {
        this.formatters = /* @__PURE__ */ new Map();
      }
      this.formatters.set(propertyPath, formatter);
    }
    /**
     * Validates if the provided path exists in the state tree.
     *
     * This method checks whether the specified dot-delimited path
     * in the state tree resolves to a defined value.
     *
     * @param {string} path - The dot-delimited path to validate.
     * @returns {boolean} - `true` if the path exists and has a defined value, `false` otherwise.
     */
    isValidPath(path) {
      Logger.debug(`Validating path ${path}`);
      try {
        const value = this.get(path);
        return value !== void 0;
      } catch (e2) {
        Logger.error(`Error validating path ${path}:`, e2);
        return false;
      }
    }
    /**
     * Destroys the current state object and clears all associated watchers and previous states.
     *
     * This method is useful for cleanup operations, ensuring no residual state,
     * watchers, or references are left in memory.
     */
    destroy() {
      this.state = null;
      this.watchers.clear();
      this.previousState = null;
      Logger.debug("ReactiveStore destroyed");
    }
  };
  var LoopManager = class {
    /**
     * Creates a new instance of LoopManager.
     *
     * @param {Object} domManager - Manages DOM operations and template bindings
     * @param {Object} model - Contains the data store and bindings
     * @property {Map} loops - Stores array loop templates and configurations
     * @property {Array} loopsIn - Stores object loop configurations and elements
     */
    constructor(domManager, model) {
      Logger.DEBUG_LEVEL = model.options.debug ? 4 : 0;
      Logger.debug("Init LoopManager");
      this.domManager = domManager;
      this.model = model;
      this.loops = /* @__PURE__ */ new Map();
      this.loopsIn = [];
      Logger.debug("LoopManager initialized");
    }
    /**
     * Parses and initializes both array and object loops in the DOM.
     *
     * For data-for loops:
     * - Validates loop expression syntax (item[, index] in array)
     * - Creates template clones for future updates
     * - Registers array dependencies for reactive updates
     * - Performs initial loop rendering
     *
     * For data-in loops:
     * - Validates loop expression (key in object)
     * - Stores original templates
     * - Creates placeholder comments for loop position
     * - Hides original elements
     * - Performs initial object iteration rendering
     *
     * @param {HTMLElement} rootElement - Root element to scan for loop directives
     * @throws {Error} Logs error for invalid loop expressions
     */
    parseLoops(rootElement) {
      Logger.debug("Parsing loops with data-for...");
      const loopElements = rootElement.querySelectorAll("[data-for]");
      Logger.debug("Found elements with data-for:", loopElements.length);
      loopElements.forEach((element2) => {
        const expression = element2.getAttribute("data-for").trim();
        const matches2 = expression.match(/^\s*(\w+)(?:\s*,\s*(\w+))?\s+in\s+(\w+(?:\.\w+)*)\s*$/);
        if (!matches2) {
          console.error("Invalid expression format data-for:", expression);
          return;
        }
        const [_5, itemName, indexName, arrayPath] = matches2;
        const array = this.model.store.get(arrayPath);
        if (!Array.isArray(array)) {
          console.error(`The value in the ${arrayPath} path is not an array:`, array);
          return;
        }
        const template = element2.cloneNode(true);
        this.loops.set(element2, {
          template,
          itemName,
          indexName,
          arrayPath,
          parentNode: element2.parentNode
        });
        this.domManager.registerDomDependency(arrayPath, element2, {
          type: "loop",
          arrayPath
        });
        this.updateLoop(element2);
      });
      Logger.debug("Parsing loops with data-in...");
      const inLoops = rootElement.querySelectorAll("[data-in]");
      Logger.debug("Found elements with data-in:", inLoops.length);
      inLoops.forEach((element2) => {
        const attributeValue = element2.getAttribute("data-in");
        const match = attributeValue.match(/^\s*(\w+)\s+in\s+(\S+)\s*$/);
        if (!match) {
          console.error(`Invalid data-in syntax: ${attributeValue}`);
          return;
        }
        const [_5, keyVar, objectPath] = match;
        const template = element2.innerHTML;
        const parent2 = element2.parentNode;
        const placeholder = document.createComment(`data-in: ${attributeValue}`);
        element2.style.display = "none";
        parent2.insertBefore(placeholder, element2);
        this.loopsIn.push({
          type: "in",
          originalElement: element2,
          template,
          placeholder,
          objectPath,
          keyVar,
          elements: []
        });
        const objectData = this.model.store.get(objectPath);
        if (objectData && typeof objectData === "object" && !Array.isArray(objectData)) {
          this.updateInLoop(this.loopsIn[this.loopsIn.length - 1], objectData);
        }
      });
    }
    /**
     * Updates the content of object-based loops (`data-in`) when the associated object data changes.
     *
     * This method clears the current DOM elements generated for the loop, then iterates through
     * the provided `objectData` to render new elements based on the loop's template. It uses the
     * `keyVar` for the object's keys and binds the DOM elements for further updates.
     *
     * @param {Object} loop - The loop configuration containing details such as the template,
     *                        placeholder, and object path.
     * @param {Object} objectData - The new object data used to generate loop elements.
     */
    updateInLoop(loop, objectData) {
      loop.elements.forEach((el) => el.remove());
      loop.elements = [];
      if (!objectData || typeof objectData !== "object" || Array.isArray(objectData)) {
        return;
      }
      Object.keys(objectData).forEach((key) => {
        Logger.debug(`Updating loop for key: ${key}`);
        const newElement = loop.originalElement.cloneNode(true);
        newElement.removeAttribute("data-in");
        newElement.style.display = "";
        const itemContext = {
          [loop.keyVar]: key
        };
        newElement.innerHTML = this.processTemplate(loop.template, objectData, key, itemContext);
        loop.placeholder.parentNode.insertBefore(newElement, loop.placeholder.nextSibling);
        loop.elements.push(newElement);
        this.domManager.bindDOM(newElement);
      });
    }
    /**
     * Processes a template string by replacing placeholders with computed values
     * based on the given object data, key, and context.
     *
     * Placeholder syntax: `{{ path }}`, where `path` can refer to variable keys,
     * object properties, or dynamic expressions.
     *
     * @param {string} template - The template string containing placeholders.
     * @param {Object} objectData - The object data used for resolving placeholders.
     * @param {string} key - The current key in the object data.
     * @param {Object} itemContext - The context containing additional data such as the key variable.
     * @returns {string} - The processed template string with placeholders replaced by their respective values.
     */
    processTemplate(template, objectData, key, itemContext) {
      Logger.debug("Processing template:", template);
      Logger.debug("	 With data:", objectData);
      Logger.debug(`	 For key: ${key}`);
      Logger.debug(`	 With context:`, itemContext);
      return template.replace(/\{\{\s*([^}]+)\s*\}\}/g, (match, path) => {
        path = path.trim();
        const keyVar = Object.keys(itemContext)[0];
        if (path === keyVar) {
          return key;
        }
        Logger.debug(`Template: Processing path: ${path}`);
        const bracketRegex = new RegExp(`(\\w+)\\[${keyVar}\\]`);
        const bracketMatch = path.match(bracketRegex);
        if (bracketMatch) {
          const objName = bracketMatch[1];
          const obj = objectData;
          if (obj && typeof obj === "object") {
            return obj[key] !== void 0 ? obj[key] : "";
          }
        }
        const value = this.model.store.get(path);
        if (value !== void 0) {
          return value;
        }
        return "";
      });
    }
    /**
     * Updates all the loops (`data-for` and `data-in`) when the data in the store changes.
     *
     * Specifically:
     * - Updates array-based loops (`data-for`) if the associated array data changes.
     * - Updates object-based loops (`data-in`) if the associated object or its child properties change.
     *
     * @param {string} path - The path of the data in the store that has changed.
     * @param {*} value - The new value at the given path.
     */
    updateLoops(path, value) {
      Logger.debug("Updating data-for loops for ${path}", this.loops);
      this.loops.forEach((loopInfo, element2) => {
        if (loopInfo.arrayPath === path) {
          this.updateLoop(element2);
        }
      });
      Logger.debug(`Updating data-in loops for ${path}`, this.loopsIn);
      this.loopsIn.forEach((loop) => {
        if (loop.type === "in" && (loop.objectPath === path || path.startsWith(loop.objectPath + "."))) {
          const objectData = this.model.store.get(loop.objectPath);
          if (objectData && typeof objectData === "object") {
            this.updateInLoop(loop, objectData);
          }
        }
      });
    }
    /**
     * Updates the entire loop for a given element.
     * @param element
     */
    updateLoop(element2) {
      Logger.debug("Updating loop for element:", element2);
      const loopInfo = this.loops.get(element2) || this.loopsIn.find((loop) => loop.originalElement === element2)[0];
      if (!loopInfo) {
        console.error("\u0418\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F \u043E \u0446\u0438\u043A\u043B\u0435 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u0430 \u0434\u043B\u044F \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430");
        return;
      }
      const { template, itemName, indexName, arrayPath, parentNode } = loopInfo;
      const array = this.model.store.get(arrayPath);
      if (!Array.isArray(array)) {
        console.error("\u0417\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u043D\u0435 \u044F\u0432\u043B\u044F\u0435\u0442\u0441\u044F \u043C\u0430\u0441\u0441\u0438\u0432\u043E\u043C:", array);
        return;
      }
      const generated = parentNode.querySelectorAll(`[data-generated-for="${arrayPath}"]`);
      generated.forEach((el) => el.remove());
      array.forEach((item, index) => {
        const newNode = template.cloneNode(true);
        newNode.style.display = "";
        newNode.removeAttribute("data-for");
        newNode.setAttribute("data-generated-for", arrayPath);
        newNode.setAttribute("data-item-index", "" + index);
        Logger.debug(`Creating new loop element for ${arrayPath} at index ${index}`);
        this.domManager.processTemplateNode(newNode, {
          [itemName]: item,
          [indexName || "index"]: index
        });
        Logger.debug(`Insert new node`, newNode);
        parentNode.insertBefore(newNode, element2);
      });
      element2.style.display = "none";
    }
    /**
     * Partially updates a single DOM element within a loop based on changes in
     * the associated array. Specifically:
     * - If the changed index is provided, updates only the element at that index.
     * - If no changed index is provided or if the array length does not match
     *   the number of generated elements, falls back to a full loop update.
     *
     * @param {HTMLElement} element - The loop's original template element.
     * @param {string} arrayPath - The path to the array in the data store associated with this loop.
     * @param {*} changedValue - The updated value in the array (optional).
     * @param {number} changedIndex - The index of the updated value in the array (optional).
     */
    updateLoopPart(element2, arrayPath, changedValue, changedIndex) {
      const loopInfo = this.loops.get(element2);
      if (!loopInfo) return;
      const { template, itemName, indexName, parentNode } = loopInfo;
      const array = this.model.store.get(arrayPath);
      if (!Array.isArray(array)) return;
      const generated = Array.from(
        parentNode.querySelectorAll(`[data-generated-for="${arrayPath}"]`)
      );
      if (changedIndex === void 0 || generated.length !== array.length) {
        return this.updateLoop(element2);
      }
      const elementToUpdate = generated[changedIndex];
      if (elementToUpdate) {
        const newNode = template.cloneNode(true);
        this.domManager.processTemplateNode(newNode, {
          [itemName]: array[changedIndex],
          [indexName || "index"]: changedIndex
        });
        while (elementToUpdate.firstChild) {
          elementToUpdate.removeChild(elementToUpdate.firstChild);
        }
        while (newNode.firstChild) {
          elementToUpdate.appendChild(newNode.firstChild);
        }
        Array.from(newNode.attributes).forEach((attr) => {
          elementToUpdate.setAttribute(attr.name, attr.value);
        });
      }
    }
    /**
     * Returns an object containing the tracked loops in the current instance.
     *
     * @returns {Object} An object with two properties:
     * - `for`: A Map of loops associated with array-based (`data-for`) rendering.
     * - `in`: An array of loops associated with object-based (`data-in`) rendering.
     */
    getLoops() {
      return {
        "for": this.loops,
        "in": this.loopsIn
      };
    }
    /**
     * Destroys all tracked loops by clearing the internal Map of `data-for` loops.
     *
     * This method should be called when the instance is no longer needed
     * to release memory and cleanup loop references.
     */
    destroy() {
      this.loops.clear();
      this.loopsIn = [];
      Logger.debug("LoopManager destroyed");
    }
  };
  var ExpressionManager = class {
    /**
     * Evaluates a given expression within a specific context.
     *
     * This method can handle three types of input:
     * 1. Expressions wrapped in double curly braces (`{{ }}`) are treated as
     *    context paths and their values are retrieved using the `getValueFromContext` method.
     * 2. Ternary, logical, and comparison operations within the expression
     *    are parsed and evaluated using the `parseExpression` method.
     * 3. Literal or primitive values (for example, numbers, strings, booleans) are directly returned.
     *
     * Any parsing or evaluation errors are caught and logged.
     *
     * @param {string} expression - The expression to evaluate.
     * @param {Object} context - The object representing the evaluation context.
     * @returns {*} The result of evaluating the expression. Returns `false` if an error occurs.
     */
    static evaluateExpression(expression, context) {
      try {
        if (expression.startsWith("{{") && expression.endsWith("}}")) {
          const path = expression.substring(2, expression.length - 2).trim();
          return this.getValueFromContext(context, path);
        }
        return this.parseExpression(expression, context);
      } catch (error) {
        console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0432\u044B\u0447\u0438\u0441\u043B\u0435\u043D\u0438\u0438 \u0432\u044B\u0440\u0430\u0436\u0435\u043D\u0438\u044F:", error);
        return false;
      }
    }
    /**
     * Retrieves a value from a given context object based on a dot-separated path.
     *
     * This method allows accessing nested properties or array elements from an object
     * using a path string. If a part of the path references an array, you can include
     * an array index (for example, 'path.toArray[0]'). If the path is invalid or the property
     * doesn't exist, the method will return undefined.
     *
     * @param {Object} obj - The context object to retrieve values from.
     * @param {string} path - The dot-separated string representing the path to the value.
     * @returns {*} The value located at the specified path, or undefined if not found.
     */
    static getValueFromContext(obj, path) {
      if (!path) return obj;
      return path.split(".").reduce((acc, part) => {
        const arrayMatch = part.match(/^([^\[]+)(?:\[(\d+)\])?$/);
        if (arrayMatch) {
          const [_5, propName, arrayIndex] = arrayMatch;
          const propValue = acc?.[propName];
          return arrayIndex !== void 0 && Array.isArray(propValue) ? propValue[parseInt(arrayIndex, 10)] : propValue;
        }
        return acc?.[part];
      }, obj);
    }
    /**
     * Parses and evaluates a given expression within a provided context.
     *
     * This method handles several types of expressions, including:
     * 1. Ternary expressions (`condition ? trueValue : falseValue`).
     * 2. Logical expressions with `&&` (AND) and `||` (OR).
     * 3. Comparison expressions (for example, `===`, `!==`, `>`, `<`, `>=`, `<=`).
     * 4. String literals inside single or double quotes.
     * 5. Numeric literals (integers and floats).
     * 6. Boolean literals (`true`, `false`), and `null`, `undefined`.
     * 7. Context-based values, retrieved using the `getValueFromContext` method if the expression
     *    is not a primitive value or an operation.
     *
     * The method uses recursion to parse and evaluate nested expressions.
     *
     * @param {string} expression - The expression to parse and evaluate.
     * @param {Object} context - The object providing the evaluation context.
     * @returns {*} The evaluated result of the expression, or `undefined` if the path does not exist in the context.
     */
    static parseExpression(expression, context) {
      expression = expression.trim();
      const ternaryMatch = expression.match(/(.+?)\s*\?\s*(.+?)\s*:\s*(.+)/);
      if (ternaryMatch) {
        const [_5, condition, trueExpr, falseExpr] = ternaryMatch;
        return this.parseExpression(condition, context) ? this.parseExpression(trueExpr, context) : this.parseExpression(falseExpr, context);
      }
      if (expression.includes("&&")) {
        const parts = expression.split("&&");
        return parts.every((part) => this.parseExpression(part.trim(), context));
      }
      if (expression.includes("||")) {
        const parts = expression.split("||");
        return parts.some((part) => this.parseExpression(part.trim(), context));
      }
      const comparisonMatch = expression.match(/(.+?)\s*(===|==|!==|!=|>=|<=|>|<)\s*(.+)/);
      if (comparisonMatch) {
        const [_5, left, operator, right] = comparisonMatch;
        const leftValue = this.parseExpression(left.trim(), context);
        const rightValue = this.parseExpression(right.trim(), context);
        switch (operator) {
          case "==":
            return leftValue == rightValue;
          case "===":
            return leftValue === rightValue;
          case "!=":
            return leftValue != rightValue;
          case "!==":
            return leftValue !== rightValue;
          case ">":
            return leftValue > rightValue;
          case "<":
            return leftValue < rightValue;
          case ">=":
            return leftValue >= rightValue;
          case "<=":
            return leftValue <= rightValue;
        }
      }
      if (expression.startsWith("'") && expression.endsWith("'") || expression.startsWith('"') && expression.endsWith('"')) {
        return expression.substring(1, expression.length - 1);
      }
      if (/^-?\d+(\.\d+)?$/.test(expression)) {
        return parseFloat(expression);
      }
      if (expression === "true") return true;
      if (expression === "false") return false;
      if (expression === "null") return null;
      if (expression === "undefined") return void 0;
      return this.getValueFromContext(context, expression);
    }
    /**
     * Extracts variables from a given expression string.
     *
     * This method parses the expression and returns a list of variable names that are used
     * in the expression. The variables are determined based on alphanumeric and underscore
     * naming conventions, excluding JavaScript reserved keywords and primitive constants.
     *
     * @param {string} expression - The expression string to extract variables from.
     * @returns {Array<string>} An array of unique variable names found in the expression.
     * Variables are returned in their base form (in other words, the part before any dot notation or brackets).
     */
    static extractVariables(expression) {
      const variables = [];
      const cleanExpr = expression.replace(/'[^']*'/g, "''").replace(/"[^"]*"/g, '""');
      const matches2 = cleanExpr.match(/[a-zA-Z_][a-zA-Z0-9_]*(\.([a-zA-Z_][a-zA-Z0-9_]*))*(\[\d+\])*/g);
      if (matches2) {
        matches2.forEach((match) => {
          const baseName = match.split(".")[0].split("[")[0].trim();
          if (!["true", "false", "null", "undefined"].includes(baseName)) {
            if (!variables.includes(baseName)) {
              variables.push(baseName);
            }
          }
        });
      }
      return variables;
    }
  };
  var ConditionalManager = class {
    /**
     * Initializes a new instance of the ConditionalManager class.
     *
     * @constructor
     * @param {Object} dom - The root DOM element or DOM-related utilities.
     * @param {Object} model - The data model containing state (for example, `store` or `data`).
     */
    constructor(dom, model) {
      Logger.DEBUG_LEVEL = model.options.debug ? 4 : 0;
      Logger.debug("ConditionalManager: Init ConditionalManager");
      this.dom = dom;
      this.model = model;
      this.dependencies = /* @__PURE__ */ new Map();
      this.conditionalGroups = [];
      this.subscribe();
      Logger.debug("ConditionalManager: ConditionalManager initialized");
    }
    /**
     * Subscribes to the model's store 'change' event to automatically update
     * affected conditional groups when data changes.
     * - Listens for store changes
     * - Identifies affected groups using getGroupsByPath
     * - Triggers updates for affected conditional groups
     *
     * @method subscribe
     * @private
     */
    subscribe() {
      Logger.debug("ConditionalManager: Subscribe to store changes");
      this.model.store.on("change", (data) => {
        const dependentGroups = this.getGroupsByPath(data.path);
        dependentGroups.forEach((group) => {
          this.updateConditionalGroup(group);
        });
      });
    }
    /**
     * Finds all conditional groups that depend on a specific model path.
     * - Uses Set to avoid duplicate groups
     * - Checks direct path matches and path prefix matches
     * - Filters groups based on their expressions
     *
     * @param {string} path - The model path to check dependencies against
     * @returns {Array} Array of unique conditional groups dependent on the path
     * @private
     */
    getGroupsByPath(path) {
      if (!path) {
        return [];
      }
      const result = /* @__PURE__ */ new Set();
      this.conditionalGroups.forEach((group) => {
        const hasDependency = group.some((item) => {
          if (!item.expression) return false;
          return item.expression.includes(path) || path.startsWith(this.extractBasePath(item.expression));
        });
        if (hasDependency) {
          result.add(group);
        }
      });
      return Array.from(result);
    }
    /**
     * Extracts the base path from an expression using regex pattern matching.
     * - Matches valid JavaScript variable names
     * - Returns the first match or empty string
     * - Valid names start with letter/underscore followed by alphanumeric/underscore
     *
     * @param {string} expression - Expression to analyze
     * @returns {string} First valid variable name or empty string
     * @private
     */
    extractBasePath(expression) {
      const matches2 = expression.match(/[a-zA-Z_][a-zA-Z0-9_]*/g);
      return matches2 ? matches2[0] : "";
    }
    /**
     * Parses and creates a map of conditional elements (`data-if`, `data-else-if`, and `data-else`)
     * within the given `rootElement`. Groups related conditional elements and attach 
     * them to the `conditionalGroups` property for dynamic evaluation.
     *
     * This method identifies `data-if`, `data-else-if`, and `data-else` attributes in the DOM and
     * ensures their relationships are correctly established (for example, ensuring `data-else` elements have
     * preceding `data-if` or `data-else-if` elements). It also handles invalid sequences of attributes
     * and logs warnings for cases where a `data-else` doesn't follow valid prerequisites.
     *
     * After parsing and grouping, conditional groups are evaluated, and their dependencies
     * are registered for reactive re-evaluation when relevant model paths change.
     *
     * @method parseConditionals
     * @param {Element} rootElement - The root DOM element to scan for conditional attributes.
     * @public
     */
    parseConditionals(rootElement) {
      Logger.debug("ConditionalManager: Parse conditionals (data-if, data-else-if, data-else)...");
      const nodes = rootElement.querySelectorAll("[data-if],[data-else-if],[data-else]");
      let currentGroup = [];
      const groups = [];
      nodes.forEach((node) => {
        if (node.hasAttribute("data-if")) {
          Logger.debug(`ConditionalManager: Found data-if in element:`, node);
          if (currentGroup.length) {
            groups.push(currentGroup);
          }
          currentGroup = [{
            element: node,
            type: "if",
            expression: node.getAttribute("data-if")
          }];
        } else if (node.hasAttribute("data-else-if")) {
          Logger.debug(`ConditionalManager: Found data-else-if in element:`, node);
          if (currentGroup.length && this.isAdjacentNode(currentGroup[currentGroup.length - 1].element, node)) {
            currentGroup.push({
              element: node,
              type: "else-if",
              expression: node.getAttribute("data-else-if")
            });
          } else {
            if (currentGroup.length) {
              groups.push(currentGroup);
            }
            currentGroup = [{
              element: node,
              type: "if",
              expression: node.getAttribute("data-else-if")
            }];
          }
        } else if (node.hasAttribute("data-else")) {
          Logger.debug(`ConditionalManager: Found data-else in element:`, node);
          if (currentGroup.length && this.isAdjacentNode(currentGroup[currentGroup.length - 1].element, node)) {
            currentGroup.push({
              element: node,
              type: "else",
              expression: null
            });
            groups.push(currentGroup);
            currentGroup = [];
          } else {
            Logger.warn("data-else without previous data-if or data-else-if", node);
          }
        }
      });
      if (currentGroup.length) {
        groups.push(currentGroup);
      }
      this.conditionalGroups = groups;
      groups.forEach((group) => this.updateConditionalGroup(group));
      this.setupDependencies(nodes);
    }
    /**
     * Checks if two DOM nodes are adjacent siblings, ignoring whitespace nodes.
     *
     * This method iterates over the sibling nodes of `node1` until it encounters
     * either `node2` (indicating adjacency) or another element node that is not
     * a whitespace text node (indicating they are not adjacent).
     *
     * @param {Node} node1 - The first DOM node.
     * @param {Node} node2 - The second DOM node to check adjacency with.
     * @returns {boolean} `true` if `node2` is an adjacent sibling of `node1`, ignoring whitespace; otherwise `false`.
     * @private
     */
    isAdjacentNode(node1, node2) {
      let current = node1.nextSibling;
      while (current) {
        if (current === node2) return true;
        if (current.nodeType === 1 && !this.isWhitespaceNode(current)) return false;
        current = current.nextSibling;
      }
      return false;
    }
    /**
     * Determines if a given DOM node is a whitespace text node.
     *
     * A whitespace text node is a text node (nodeType === 3)
     * whose content consists only of whitespace characters (spaces, tabs, newlines).
     *
     * @param {Node} node - The DOM node to check.
     * @returns {boolean} `true` if the node is a whitespace text node; otherwise `false`.
     * @private
     */
    isWhitespaceNode(node) {
      return node.nodeType === 3 && node.textContent.trim() === "";
    }
    /**
     * Evaluates and updates the visibility of elements within a group of conditionals.
     *
     * A group represents a logical chain of `data-if`, `data-else-if`, and `data-else` elements.
     * This method determines the first condition in the group that evaluates to `true`
     * and sets the corresponding element to be displayed while hiding others.
     *
     * @param {Array<Object>} group - An array representing a logical group of conditionals.
     * Each object in the array contains:
     *    - {HTMLElement} element: The DOM element.
     *    - {string} type: The type of conditional ('if', 'else-if', 'else').
     *    - {string|null} expression: The conditional expression, null for 'else'.
     */
    updateConditionalGroup(group) {
      const context = this.model && this.model.store ? { ...this.model.store.getState() } : this.model && this.model.data ? this.model.data : {};
      let conditionMet = false;
      for (const item of group) {
        if (item.type === "if" || item.type === "else-if") {
          const result = !conditionMet && ExpressionManager.evaluateExpression(item.expression, context);
          if (result) {
            item.element.style.display = "";
            conditionMet = true;
          } else {
            item.element.style.display = "none";
          }
        } else if (item.type === "else") {
          item.element.style.display = conditionMet ? "none" : "";
        }
      }
    }
    /**
     * Updates the visibility of DOM elements based on conditional expressions.
     *
     * This method processes groups of elements with `data-if`, `data-else-if`, and `data-else` attributes,
     * updating their visibility based on the evaluation of corresponding expressions.
     *
     * It also sets up dependencies between variables used in the expressions and their corresponding DOM elements,
     * allowing for dynamic updates when the context or variables change.
     *
     * This functionality is used to implement conditional rendering in the DOM.
     *
     * @param {HTMLElement} element - The DOM element to update.
     * @param {string} expression - The conditional expression to evaluate.
     * Nodes are expected to contain attributes like `data-if`, `data-else-if`, or `data-else`.
     */
    updateConditional(element2, expression) {
      const group = this.findGroupForElement(element2);
      if (group) {
        this.updateConditionalGroup(group);
      } else {
        const context = this.model && this.model.store ? { ...this.model.store.getState() } : this.model && this.model.data ? this.model.data : {};
        const result = ExpressionManager.evaluateExpression(expression, context);
        element2.style.display = result ? "" : "none";
      }
    }
    /**
     * Finds and returns the group of conditional elements that contains the specified element.
     *
     * This method searches through the existing groups of conditional elements to determine
     * the group where the given element belongs. Each group represents a logical chain of
     * `data-if`, `data-else-if`, and `data-else` elements.
     *
     * @param {Element} element - The DOM element to find the group for.
     * @returns {Array<Object>|null} The group containing the specified element, or `null` if not found.
     * Each group object comprises:
     *    - {Element} element: The DOM element.
     *    - {string} type: The type of conditional ('if', 'else-if', 'else').
     *    - {string|null} expression: The conditional expression, null for 'else'.
     */
    findGroupForElement(element2) {
      for (const group of this.conditionalGroups || []) {
        if (group.some((item) => item.element === element2)) {
          return group;
        }
      }
      return null;
    }
    /**
     * Sets up and configures the dependencies for the provided DOM nodes.
     *
     * This method scans through the given list of nodes and determines
     * which variables are referenced in their conditional expressions (`data-if`, `data-else-if`).
     * It maps these variables to the corresponding DOM elements, building a dependency tree
     * that allows tracking of changes and their impact on the visibility of elements.
     *
     * @param {NodeList|Array<Element>} nodes - The list of DOM elements to process.
     */
    setupDependencies(nodes) {
      this.dependencies = /* @__PURE__ */ new Map();
      nodes.forEach((element2) => {
        let expression;
        if (element2.hasAttribute("data-if")) {
          expression = element2.getAttribute("data-if");
        } else if (element2.hasAttribute("data-else-if")) {
          expression = element2.getAttribute("data-else-if");
        } else {
          return;
        }
        const variables = ExpressionManager.extractVariables(expression);
        variables.forEach((variable) => {
          if (!this.dependencies.has(variable)) {
            this.dependencies.set(variable, []);
          }
          this.dependencies.get(variable).push({
            element: element2,
            expression,
            type: element2.hasAttribute("data-if") ? "if" : "else-if"
          });
        });
      });
    }
    /**
     * Retrieves all dependencies related to a specific path.
     *
     * This method scans through the dependency map and collects all elements and their details
     * that are associated with the given path. It also includes dependencies that match the base
     * path and/or any sub-paths (for example, 'path' and 'path.sub').
     *
     * @param {string} path - The path of the dependency to look for.
     * @returns {Array<Object>} An array of dependency objects containing:
     *    - {Element} element: The DOM element associated with the dependency.
     *    - {string} expression: The original conditional expression linked to the dependency.
     *    - {string} type: The type of the conditional ('if' or 'else-if').
     */
    getDependenciesByPath(path) {
      const result = [];
      this.dependencies.forEach((deps, variable) => {
        if (variable === path || path.startsWith(variable + ".")) {
          result.push(...deps);
        }
      });
      return result;
    }
    /**
     * Cleans up the instance by clearing dependencies and resetting conditional groups.
     *
     * This method should be called to release resources and avoid memory leaks when
     * the instance of the class is no longer required.
     */
    destroy() {
      this.dependencies.clear();
      this.conditionalGroups = [];
      Logger.debug("ConditionalManager: Destroyed");
    }
  };
  var AttributeManager = class {
    constructor(dom, model) {
      this.domManager = dom;
      this.model = model;
      Logger.DEBUG_LEVEL = this.model.options.debug ? 4 : 0;
      Logger.debug("AttributeManager: Init AttributeManager");
    }
    /**
     * Parses the attributes of elements with 'data-bind' attribute within the root element.
     * - Searches for elements with data-bind attribute
     * - Parses JSON binding expressions (converts single quotes to double quotes)
     * - Extracts variables from expressions
     * - Registers DOM dependencies for each variable
     * - Initializes attribute values
     *
     * @param {HTMLElement} rootElement - The root element containing elements with data bindings.
     * @throws {Error} When binding expression parsing fails
     */
    parseAttributesBind(rootElement) {
      Logger.debug("AttributeManager: Parsing attributes bind with data-bind...");
      const elements = rootElement.querySelectorAll("[data-bind]");
      Logger.debug("AttributeManager: Found elements with data-bind:", elements.length);
      elements.forEach((element2) => {
        Logger.debug("AttributeManager: Parsing element with data-bind:", element2);
        const bindingExpression = element2.getAttribute("data-bind");
        try {
          const bindings = JSON.parse(bindingExpression.replace(/'/g, '"'));
          for (const [attributeName, expression] of Object.entries(bindings)) {
            const variables = ExpressionManager.extractVariables(expression);
            Logger.debug(`AttributeManager: Found variables for ${attributeName}:`, variables);
            variables.forEach((variable) => {
              this.domManager.registerDomDependency(variable, element2, {
                type: "attribute",
                attribute: attributeName,
                expression
              });
            });
            this.updateAttributes(element2, attributeName, expression);
          }
        } catch (error) {
          console.error("An error of analysis of attachments:", error);
        }
      });
    }
    /**
     * Updates a DOM element's attribute based on a provided expression.
     * Evaluates the expression using the current state of the application model, and
     * updates the attribute only if its value has changed.
     *
     * - If the expression represents a falsy value (false, null, undefined), the attribute is removed.
     * - If the value is `true`, the attribute is added without a value ("").
     * - Otherwise, the attribute is set to the string field value of the evaluated expression.
     *
     * @param {HTMLElement} element - The DOM element whose attribute needs to be updated.
     * @param {string} attributeName - The name of the attribute to be updated.
     * @param {string} expression - The expression to be evaluated to determine the attribute's value.
     *
     * Special cases:
     * - Handles template expressions in format {{expression}}
     * - Direct model path access for template expressions
     * - Expression evaluation for non-template strings
     * 
     */
    updateAttributes(element2, attributeName, expression) {
      const context = { ...this.model.store.getState() };
      let value;
      if (expression.startsWith("{{") && expression.endsWith("}}")) {
        const path = expression.substring(2, expression.length - 2).trim();
        value = this.model.store.get(path);
      } else {
        value = ExpressionManager.evaluateExpression(expression, context);
      }
      const previousValue = element2.getAttribute(attributeName);
      if (String(value) !== previousValue) {
        if (value === false || value === null || value === void 0) {
          element2.removeAttribute(attributeName);
        } else if (value === true) {
          element2.setAttribute(attributeName, "");
        } else {
          element2.setAttribute(attributeName, String(value));
        }
        Logger.debug(`AttributeManager: Updated attribute ${attributeName} with value:`, value);
      }
    }
    /**
     * Parses and processes attribute bindings in the provided root DOM element. 
     * Attributes prefixed with a colon (for example, `:class`) * are treated as dynamic bindings.
     *
     * For each dynamically bound attribute:
     * - Updates the attribute value on the element based on the
     *   current model store state.
     * - Registers a dependency between the element and the attribute
     *   expression in the DOM dependency tracker.
     * - Removes the colon-prefixed attribute from the DOM.
     *
     * @param {HTMLElement} rootElement - The root element to search
     *                                    for attribute bindings.
     */
    parseAttributes(rootElement) {
      Logger.debug("AttributeManager: Parsing attributes with colon...");
      const allElements = rootElement.querySelectorAll("*");
      for (const element2 of allElements) {
        const attributes = element2.attributes;
        for (let i3 = 0; i3 < attributes.length; i3++) {
          const attr = attributes[i3];
          if (attr.name.startsWith(":")) {
            Logger.debug(`AttributeManager: Found attribute:`, attr);
            const realAttrName = attr.name.substring(1);
            const expression = attr.value;
            this.updateElementAttribute(element2, realAttrName, expression);
            this.domManager.registerDomDependency(expression, element2, {
              type: "attribute",
              attribute: realAttrName,
              expression
            });
            element2.removeAttribute(attr.name);
          }
        }
      }
    }
    /**
     * Updates the value of a DOM element's attribute based on the current
     * state of the model store.
     *
     * Dynamically handles specific attributes like `class`, `disabled`,
     * `checked`, `selected`, and `readonly` to ensure they're properly assigned
     * for Boolean or string values. For other attributes, it assigns the value
     * directly.
     *
     * If the value for the given expression can't be resolved from the model store,
     * a warning is logged to the console.
     *
     * @param {HTMLElement} element - The DOM element whose attribute is being updated.
     * @param {string} attribute - The name of the attribute to update.
     * @param {string} expression - The model store expression to retrieve the value.
     */
    updateElementAttribute(element2, attribute, expression) {
      const value = "" + this.model.store.get(expression);
      if (value === void 0 || value === "undefined") {
        return;
      }
      Logger.debug(`AttributeManager: Updating attribute ${attribute} with ${value}`);
      if (attribute === "class") {
        element2.className = value;
      } else if (attribute === "disabled" || attribute === "checked" || attribute === "selected" || attribute === "readonly") {
        if (value) {
          element2.setAttribute(attribute, "");
        } else {
          element2.removeAttribute(attribute);
        }
      } else {
        element2.setAttribute(attribute, value);
      }
    }
    update(element2, attribute, expression) {
      Logger.debug(`AttributeManager: Updating element:`, element2);
      Logger.debug(`	 Attribute: ${attribute} for:`, expression);
      this.updateAttributes(element2, attribute, expression);
      this.updateElementAttribute(element2, attribute, expression);
    }
  };
  var EventManager = class {
    /**
     * Creates a copy of the event manager
     * @param {Object} domManager - DOM manager for working with DOM elements
     * @param {Object} model - Data model that will be used as a context in events
     */
    constructor(domManager, model) {
      Logger.DEBUG_LEVEL = model.options.debug ? 4 : 0;
      Logger.debug("EventManager: Init EventManager");
      this.domManager = domManager;
      this.model = model;
      this.eventHandlers = /* @__PURE__ */ new Map();
      Logger.debug("EventManager: EventManager initialized");
    }
    /**
     * Analyzes DOM-Vreyevo and finds all attributes starting with @,
     * Registering them as events
     * @param {HTMLElement} rootElement - Root element for searching for events
     */
    parseEvents(rootElement) {
      Logger.debug("EventManager: Parsing events with @...");
      const allElements = rootElement.querySelectorAll("*");
      const elements = [rootElement, ...Array.from(allElements)];
      elements.forEach((element2) => {
        const attributes = Array.from(element2.attributes || []);
        attributes.forEach((attr) => {
          if (attr.name.startsWith("@")) {
            Logger.debug(`EventManager: Found attribute with "@" ${attr.name} in`, element2);
            const eventName = attr.name.substring(1);
            const handler = attr.value.trim();
            this.bindEventHandler(element2, eventName, handler);
            element2.removeAttribute(attr.name);
          }
        });
      });
    }
    /**
     * Binds the event handler to the DOM element
     * @param {HTMLElement} element - DOM element
     * @param {string} eventName - Event name (without @)
     * @param {string} handlerExpression - Line with an event processor
     */
    bindEventHandler(element2, eventName, handlerExpression) {
      Logger.debug(`EventManager: Binding event handler with expression ${handlerExpression} for ${eventName} on`, element2);
      const eventHandler = (event) => {
        try {
          const context = {
            $model: this.model,
            $event: event,
            $data: this.model.data,
            $dom: this.domManager
          };
          const methodMatch = handlerExpression.match(/(\w+)\((.*)\)/);
          if (methodMatch) {
            const methodName = methodMatch[1];
            const paramsString = methodMatch[2];
            const resolveMethod = (path, context2) => {
              return path.split(".").reduce((obj, key) => obj && obj[key] !== void 0 ? obj[key] : void 0, context2);
            };
            let method = resolveMethod(methodName, this.model);
            if (!method) {
              method = resolveMethod(methodName, window);
            }
            if (typeof method === "function") {
              let params = [];
              if (paramsString.trim()) {
                params = paramsString.split(",").map((param) => {
                  param = param.trim();
                  if (param.startsWith('"') && param.endsWith('"') || param.startsWith("'") && param.endsWith("'")) {
                    return param.slice(1, -1);
                  }
                  if (!isNaN(param)) {
                    return Number(param);
                  }
                  if (param === "$event") {
                    Logger.debug(`EventManager: Requested Event`, event);
                    return event;
                  }
                  if (param === "$model") {
                    Logger.debug(`EventManager: Requested Model`, this.model);
                    return this.model;
                  }
                  if (param === "$data") {
                    Logger.debug(`EventManager: Requested Model Context`, this.model.data);
                    return this.model.data;
                  }
                  if (param === "$dom") {
                    Logger.debug(`EventManager: Requested DOMManager`, this.domManager);
                    return this.domManager;
                  }
                  return this.model.store.get(param);
                });
              }
              method.apply(context, params);
            } else {
              console.warn(`EventManager: The method '${methodName}' not found in a model or global space!`);
            }
          } else {
            if (this.model.options.useSimpleExpressions) {
              const result = new Function(`return ${handlerExpression}`);
              result.apply(this.model.data);
            } else {
              console.warn(`EventManager: Unknown format of the event handler: '${handlerExpression}'`);
            }
          }
        } catch (error) {
          console.error(`EventManager: Error when performing an event processor '${eventName}': ${error.message}`);
        }
      };
      if (!this.eventHandlers.has(element2)) {
        this.eventHandlers.set(element2, /* @__PURE__ */ new Map());
      }
      const elementHandlers = this.eventHandlers.get(element2);
      if (elementHandlers.has(eventName)) {
        element2.removeEventListener(eventName, elementHandlers.get(eventName));
      }
      elementHandlers.set(eventName, eventHandler);
      element2.addEventListener(eventName, eventHandler);
    }
    /**
     * Removes the event processor from the DOM element
     * @param {HTMLElement} element - DOM element
     * @param {string} eventName - Event name (without @)
     */
    removeEventHandler(element2, eventName) {
      Logger.debug(`EventManager: Removing event handler for ${eventName} on`, element2);
      if (this.eventHandlers.has(element2)) {
        const elementHandlers = this.eventHandlers.get(element2);
        if (elementHandlers.has(eventName)) {
          const handler = elementHandlers.get(eventName);
          element2.removeEventListener(eventName, handler);
          elementHandlers.delete(eventName);
          if (elementHandlers.size === 0) {
            this.eventHandlers.delete(element2);
          }
        }
      }
    }
    /**
     * Updates events for the element
     * @param {HTMLElement} element - DOM element for updating
     */
    updateEvents(element2) {
      Logger.debug("EventManager: Updating events for", element2);
      Array.from(element2.attributes || []).forEach((attr) => {
        if (attr.name.startsWith("@")) {
          const eventName = attr.name.substring(1);
          const handler = attr.value.trim();
          this.bindEventHandler(element2, eventName, handler);
          element2.removeAttribute(attr.name);
        }
      });
    }
    /**
     * Releases all resources and removes all events
     */
    destroy() {
      Logger.debug("EventManager: Destroying EventManager");
      this.eventHandlers.forEach((handlers, element2) => {
        handlers.forEach((handler, eventName) => {
          Logger.debug(`EventManager: Removing event handler for ${eventName} on`, element2);
          element2.removeEventListener(eventName, handler);
        });
      });
      this.eventHandlers.clear();
      Logger.debug("EventManager: Destroyed");
    }
  };
  var DOMManager = class {
    /**
     * Creates an instance of the DOMManager class, initializing necessary properties and dependencies
     * for managing the DOM in relation to the model. Sets up managers for loops, conditionals, and attributes,
     * and prepares structures for DOM dependencies and virtual DOM.
     *
     * @param {Object} model - The model that serves as the data source for the DOMManager.
     *                         It is used for data binding and template rendering in the DOM.
     */
    constructor(model) {
      Logger.DEBUG_LEVEL = model.options.debug ? 4 : 0;
      Logger.debug("DOMManager: Init DOMManager");
      this.model = model;
      this.elements = [];
      this.inputs = [];
      this.domDependencies = /* @__PURE__ */ new Map();
      this.virtualDom = /* @__PURE__ */ new Map();
      this.loopManager = new LoopManager(this, model);
      this.conditionalManager = new ConditionalManager(this, model);
      this.attributeManager = new AttributeManager(this, model);
      this.eventManager = new EventManager(this, model);
      Logger.debug("DOMManager: DOMManager initialized");
    }
    /**
     * Registers a dependency between a model property path and a DOM element.
     * - Creates a new Set for the property path if it doesn't exist
     * - Adds element and additional info to the dependency set
     * - Supports multiple elements depending on the same property
     *
     * @param {string} propertyPath - Model property path to watch
     * @param {HTMLElement} domElement - DOM element to update
     * @param {Object} info - Additional dependency metadata
     */
    registerDomDependency(propertyPath, domElement, info3) {
      if (!this.domDependencies.has(propertyPath)) {
        this.domDependencies.set(propertyPath, /* @__PURE__ */ new Set());
      }
      this.domDependencies.get(propertyPath).add({
        element: domElement,
        ...info3
      });
    }
    /**
     * Recursively processes template nodes and replaces placeholders with values.
     * - Handles text nodes: replaces {{expression}} with actual values
     * - For text nodes: compares original and new content to avoid unnecessary updates
     * - For element nodes: recursively processes all child nodes
     * - Supports both context values and model store values
     *
     * @param {Node} node - DOM node to process
     * @param {Object} context - Optional context data for placeholder replacement
     */
    processTemplateNode(node, context) {
      Logger.debug("DOMManager: processTemplateNode", { node, context });
      if (node.nodeType === Node.TEXT_NODE) {
        const originalText = node.textContent;
        const newText = node.textContent.replace(/\{\{\s*([^}]+)\s*\}\}/g, (match, path) => {
          path = path.trim();
          const getValueByPath = (obj, path2) => {
            return path2.split(".").reduce((value2, key) => {
              return value2 ? value2[key] : void 0;
            }, obj);
          };
          let value = context ? getValueByPath(context, path) : void 0;
          if (value === void 0) {
            value = this.model.store.get(path);
          }
          return value !== void 0 ? value : "";
        });
        if (originalText !== newText) {
          Logger.debug(`DOMManager: updated node text from ${originalText} to ${newText}`);
          node.textContent = newText;
        }
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        Array.from(node.childNodes).forEach((child) => {
          this.processTemplateNode(child, context);
        });
      }
    }
    /**
     * Parses DOM tree for template placeholders and sets up reactive bindings.
     * - Uses TreeWalker to efficiently traverse text nodes
     * - Detects template expressions using regex pattern
     * - Registers dependencies for each found template expression
     * - Preserves original template text for future updates
     * - Handles regex state reset between matches
     *
     * @param {HTMLElement} root - Starting point for DOM traversal
     */
    parse(root) {
      Logger.debug("DOMManager: parse from", root);
      const walker = document.createTreeWalker(
        root,
        NodeFilter.SHOW_TEXT,
        null
      );
      let node;
      const regex = /\{\{\s*([^}]+)\s*\}\}/g;
      while (node = walker.nextNode()) {
        let match;
        const text = node.textContent;
        const originalText = text;
        regex.lastIndex = 0;
        while ((match = regex.exec(text)) !== null) {
          Logger.debug(`DOMManager: parse match found for ${text}`, match);
          const propPath = match[1].trim();
          this.registerDomDependency(propPath, node, {
            type: "template",
            template: originalText
          });
          this.elements.push({
            node,
            propName: propPath,
            template: originalText
          });
        }
        Logger.debug(`DOMManager: update virtual DOM set`, { node, text: node.textContent });
        this.virtualDom.set(node, node.textContent);
      }
      Logger.debug("DOMManager: Find inputs with data-model directive...");
      const inputs = root.querySelectorAll("[data-model]");
      Logger.debug("DOMManager: Found inputs with data-model:", inputs.length);
      inputs.forEach((input) => {
        const property = input.getAttribute("data-model");
        Logger.debug("DOMManager: Register handler for:", { input, property });
        const handler = (e2) => {
          const value = input.type === "checkbox" || input.type === "radio" ? e2.target.checked : e2.target.value;
          this.model.store.set(property, value);
        };
        input.__modelInputHandler = handler;
        input.addEventListener("input", handler);
        this.inputs.push({
          element: input,
          property
        });
      });
    }
    /**
     * Sets the value of the input element based on the provided value.
     * For checkboxes and radio buttons, it sets the `checked` property.
     * For other input types, it sets the `value` property.
     *
     * @param {HTMLInputElement} input - The input element to update.
     * @param {*} value - The value to set for the input. For checkboxes and radio buttons, it should be a boolean.
     */
    setInputValue(input, value) {
      if (input.type === "checkbox" || input.type === "radio") {
        input.checked = Boolean(value);
      } else {
        input.value = value;
      }
    }
    /**
     * Updates all input elements associated with the specified property with the provided value.
     * It ensures that the value in the DOM accurately reflects the value in the model.
     *
     * @param {string} propName - The name of the property whose value should be updated in the inputs.
     * @param {*} value - The value to set for the associated inputs.
     */
    updateInputs(propName, value) {
      Logger.debug("DOMManager: updateInputs", { propName, value });
      this.inputs.forEach((item) => {
        if (item.property === propName) {
          Logger.debug("DOMManager: update input", { item, value });
          this.setInputValue(item.element, value);
        }
      });
    }
    /**
     * Updates all DOM elements based on the current state of the model.
     * This includes:
     * - Text nodes containing template placeholders.
     * - Input elements bound using `data-model` attributes.
     *
     * Iterates through registered nodes and inputs, updating their content
     * or values to reflect the latest model state.
     *
     * Ensures that the UI remains synchronized with the underlying model.
     */
    updateAllDOM() {
      Logger.debug("DOMManager: updateAllDOM");
      this.elements.forEach((element2) => {
        let newContent = element2.template;
        newContent = newContent.replace(/\{\{\s*([^}]+)\s*\}\}/g, (match, path) => {
          path = path.trim();
          return this.model.store.get(path);
        });
        element2.node.textContent = newContent;
        Logger.debug(`DOMManager: updated node`, { element: element2, newContent });
      });
      Logger.debug("DOMManager: update inputs");
      this.inputs.forEach((item) => {
        Logger.debug("DOMManager: update input", { item });
        const value = this.model.store.get(item.property);
        this.setInputValue(item.element, value);
        Logger.debug("DOMManager: updated input", { item, value });
      });
    }
    /**
     * Updates the DOM elements or attributes whenever a property in the model changes.
     * It resolves what elements depending on the property should be updated,
     * including templates, conditionals, loops, and attributes.
     *
     * @param {string} propertyPath - Path of the property in the model that triggered the change.
     * @param {*} value - New value of the property (could be a primitive, object, or array).
     */
    updateDOM(propertyPath, value) {
      Logger.debug(`DOMManager: update DOM for ${propertyPath} with ${value}`);
      if (!propertyPath) {
        console.warn("Path is undefined in updateDOM");
        return;
      }
      const isArrayMethodChange = value && typeof value === "object" && "method" in value;
      if (isArrayMethodChange) {
        propertyPath = value.path || propertyPath;
      }
      const elementsToUpdate = /* @__PURE__ */ new Set();
      if (this.domDependencies.has(propertyPath)) {
        this.domDependencies.get(propertyPath).forEach(
          (dep) => elementsToUpdate.add(dep)
        );
      }
      const pathParts = propertyPath.split(".");
      let currentPath = "";
      for (let i3 = 0; i3 < pathParts.length; i3++) {
        currentPath = currentPath ? `${currentPath}.${pathParts[i3]}` : pathParts[i3];
        if (this.domDependencies.has(currentPath)) {
          this.domDependencies.get(currentPath).forEach(
            (dep) => elementsToUpdate.add(dep)
          );
        }
      }
      const conditionalElements = this.conditionalManager.getDependenciesByPath(propertyPath);
      conditionalElements.forEach((dep) => {
        if (dep.type === "if") {
          this.conditionalManager.updateConditional(dep.element, dep.expression);
        }
      });
      this.domDependencies.forEach((deps, path) => {
        if (path.startsWith(`${propertyPath}.`) || path.startsWith(`${propertyPath}[`)) {
          deps.forEach((dep) => elementsToUpdate.add(dep));
        }
      });
      if (Array.isArray(value) || isArrayMethodChange || typeof value === "object") {
        this.loopManager.updateLoops(propertyPath, value);
      }
      if (elementsToUpdate.size === 0) return;
      const updates = {
        template: [],
        conditional: [],
        loop: [],
        attribute: []
      };
      elementsToUpdate.forEach((dep) => {
        if (dep && dep.type) {
          updates[dep.type].push(dep);
        }
      });
      updates.template.forEach((dep) => this.updateTemplateNode(dep.element, dep.template));
      updates.conditional.forEach((dep) => this.conditionalManager.updateConditional(dep.element, dep.expression));
      updates.attribute.forEach((dep) => this.attributeManager.update(dep.element, dep.attribute, dep.expression));
      updates.loop.forEach((dep) => this.loopManager.updateLoopPart(dep.element, dep.arrayPath, value, dep.index));
    }
    /**
     * Updates a template-based DOM node's content with the latest values
     * from the model store.
     *
     * This method uses a Mustache-like syntax (for example, `{{propertyName}}`)
     * to replace placeholders in the template with actual values retrieved
     * from the model store. If the content changes compared to the virtual DOM,
     * the DOM node is updated, and the new content is recorded in the virtual DOM.
     *
     * @param {HTMLElement} node - The DOM node to update.
     * @param {string} template - The template string containing placeholders
     *                            for dynamic values.
     */
    updateTemplateNode(node, template) {
      const newContent = template.replace(/\{\{\s*([^}]+)\s*\}\}/g, (match, path) => {
        path = path.trim();
        return this.model.store.get(path);
      });
      if (this.virtualDom.get(node) !== newContent) {
        node.textContent = newContent;
        this.virtualDom.set(node, newContent);
      }
    }
    /**
     * Checks whether the given pathA is a dependency of pathB.
     *
     * A path is considered a dependency if:
     * - It is identical to the other path.
     * - It is a hierarchical descendent of the other path (for example, pathB starts with pathA).
     * - It is an array element of the other path (for example, pathB starts with pathA followed by an array index).
     *
     * @param {string} pathA - The base path to check against.
     * @param {string} pathB - The path to verify as a dependency.
     * @returns {boolean} - Returns `true` if pathB is a dependency of pathA, otherwise `false`.
     */
    isPathDependency(pathA, pathB) {
      return pathB === pathA || pathB.startsWith(`${pathA}.`) || pathB.startsWith(`${pathA}[`);
    }
    /**
     * Retrieves all paths from the DOM dependency tracker that are
     * dependent on the given path. A path is considered dependent if:
     * - It is hierarchically related (for example, a path starts with the given path).
     * - It matches exactly with the given path.
     *
     * This method collects and returns all such dependent paths.
     *
     * @param {string} path - The path for which to find dependent paths.
     * @returns {string[]} - An array of dependent paths.
     */
    getDependentPaths(path) {
      const dependentPaths = [];
      this.domDependencies.forEach((_5, depPath) => {
        if (this.isPathDependency(path, depPath)) {
          dependentPaths.push(depPath);
        }
      });
      return dependentPaths;
    }
    /**
     * Binds and processes the DOM for data binding, conditional rendering,
     * loops, and attribute updates. This method integrates the different
     * managers and processes involved in setting up the live DOM bindings.
     *
     * Steps performed:
     * 1. Parses loops within the DOM using the loop manager.
     * 2. Parses conditional elements using the conditional manager.
     * 3. Parses standard attributes using the attribute manager.
     * 4. Processes custom attribute bindings (colon-prefixed attributes).
     * 5. Parses any additional elements or bindings.
     * 6. Updates the DOM to reflect the current state of the model.
     *
     * @param {HTMLElement} rootElement - The root element to initiate the DOM binding process.
     */
    bindDOM(rootElement) {
      Logger.debug("DOMManager: bind DOM from", rootElement);
      this.loopManager.parseLoops(rootElement);
      this.conditionalManager.parseConditionals(rootElement);
      this.attributeManager.parseAttributesBind(rootElement);
      this.attributeManager.parseAttributes(rootElement);
      this.eventManager.parseEvents(rootElement);
      this.parse(rootElement);
      this.updateAllDOM();
      Logger.debug("DOMManager: binding completed");
    }
    /**
     * Destroys the instance by performing cleanup tasks.
     *
     * This method removes event listeners from input elements, clears out
     * internal data structures like `elements`, `inputs`, `domDependencies`,
     * and `virtualDom`, and calls the `destroy` methods of `loopManager` and
     * `conditionalManager`. It is intended to completely clean up the instance
     * and free resources to avoid memory leaks.
     */
    destroy() {
      this.inputs.forEach(({ element: element2 }) => {
        if (element2.__modelInputHandler) {
          element2.removeEventListener("input", element2.__modelInputHandler);
          delete element2.__modelInputHandler;
        }
      });
      this.elements = [];
      this.inputs = [];
      this.domDependencies.clear();
      this.virtualDom.clear();
      this.loopManager.destroy();
      this.conditionalManager.destroy();
      this.eventManager.destroy();
      Logger.debug("DOMManager: destroyed");
    }
  };
  var ComputedProps = class {
    constructor(model, computed = {}) {
      Logger.DEBUG_LEVEL = model.options.debug ? 4 : 0;
      Logger.debug("Model: Init ComputedProps:", computed);
      this.model = model;
      this.computed = computed;
      this.store = model.store;
      this.asyncCache = /* @__PURE__ */ new Map();
      this.init().then(() => {
        Object.getOwnPropertyNames(this.computed).forEach((prop) => {
          if (typeof this.computed[prop]["getter"] === "function") {
            try {
              const value = this.computed[prop]["getter"].call(this.store.getState());
              Logger.debug(`Initializing computed property ${prop}:`, value);
            } catch (e2) {
              console.error(`Error initializing computed property ${prop}:`, e2);
            }
          }
        });
        Logger.debug("Model: ComputedProps initialized");
      });
    }
    /**
     * Sets up computed properties in the model.
     * - Performs initial evaluation of all computed properties
     * - Defines getter proxies on model.data
     * - Makes computed properties enumerable and configurable
     * - Ensures reactive updates through getter access
     *
     * @method init
     */
    async init() {
      const initPromises = [];
      for (const key in this.computed) {
        const valuePromise = this.evaluate(key);
        initPromises.push(valuePromise);
        Object.defineProperty(this.model.data, key, {
          get: () => {
            const computed = this.computed[key];
            return computed.isAsync ? this.asyncCache.get(key) : computed.value;
          },
          enumerable: true,
          configurable: true
        });
      }
      await Promise.all(initPromises);
      for (const key in this.computed) {
        const value = this.computed[key].isAsync ? this.asyncCache.get(key) : this.computed[key].value;
        this.model.dom.updateDOM(key, value);
        this.model.dom.updateInputs(key, value);
      }
      return true;
    }
    /**
     * Evaluates computed property and tracks its dependencies.
     * - Creates proxy for dependency tracking
     * - Handles nested object dependencies
     * - Records all accessed properties during evaluation
     * - Emits computation events with results
     * - Supports forced re-evaluation
     *
     * @method evaluate
     * @param {string} key - Computed property name
     * @param {boolean} [force=false] - Force re-evaluation flag
     * @returns {*} New computed value
     * @emits compute
     */
    async evaluate(key, force = false) {
      const computed = this.computed[key];
      const dependencies = /* @__PURE__ */ new Set();
      const dataTracker = new Proxy(this.store.getState(), {
        get: (target, prop) => {
          dependencies.add(prop);
          let value = target[prop];
          if (value && typeof value === "object") {
            return new Proxy(value, {
              get: (obj, nestedProp) => {
                dependencies.add(`${prop}.${nestedProp}`);
                return obj[nestedProp];
              }
            });
          }
          return value;
        }
      });
      const isAsync = computed.getter.constructor.name === "AsyncFunction";
      computed.isAsync = isAsync;
      try {
        const result = await computed.getter.call(dataTracker);
        computed.dependencies = [...dependencies];
        if (isAsync) {
          this.asyncCache.set(key, result);
        } else {
          computed.value = result;
        }
        this.store.emit("compute", {
          key,
          value: result,
          dependencies,
          isAsync
        });
        return result;
      } catch (error) {
        console.error(`Error evaluating computed property "${key}":`, error);
        throw error;
      }
    }
    /**
     * Updates computed properties affected by model changes.
     * Checks three types of dependencies:
     * - Direct property matches
     * - Nested property changes (parent changed)
     * - Parent property changes (child changed)
     * Re-evaluates affected computed properties
     *
     * @method update
     * @param {string} changedProp - Changed property path
     */
    async update(changedProp) {
      const updatePromises = [];
      for (const key in this.computed) {
        const updatePromise = (async () => {
          const newValue = await this.evaluate(key);
          this.model.dom.updateDOM(key, newValue);
          this.model.dom.updateInputs(key, newValue);
        })();
        updatePromises.push(updatePromise);
      }
      await Promise.all(updatePromises);
    }
    /**
     * @method all
     * @description Retrieves all computed properties and their current values.
     * Converts the `computed` object into a plain object, mapping each computed
     * property's name to its current value.
     *
     * @returns {Object} An object containing all computed property names and their values.
     */
    all() {
      return Object.fromEntries(
        Object.entries(this.computed).map(([key, comp]) => [key, comp.value])
      );
    }
  };
  var StateManager = class _StateManager extends event_emitter_default {
    /**
     * Creates a new StateManager instance.
     * @param {Object} store - The store object to manage state for.
     * @param {Object} [options={}] - Configuration options for the StateManager.
     * @param {string} [options.id="model"] - Unique identifier for the state in localStorage.
     */
    constructor(store, options = {}) {
      Logger.DEBUG_LEVEL = store.model.options.debug ? 4 : 0;
      Logger.debug("Init StateManager:", options);
      super();
      this.store = store;
      this.options = Object.assign({ id: "model" }, options);
      Logger.debug("StateManager initialized");
    }
    /**
     * Checks if localStorage is available.
     * @returns {boolean}
     */
    static isStorageAvailable() {
      try {
        const test = "__test__";
        localStorage.setItem(test, test);
        localStorage.removeItem(test);
        return true;
      } catch (e2) {
        return false;
      }
    }
    /**
     * Saves the current state to localStorage.
     * @returns {{data: any, timestamp: number}|null}
     */
    saveState() {
      if (!_StateManager.isStorageAvailable()) {
        console.warn("localStorage is not available");
        return null;
      }
      const dataToSave = JSON.parse(JSON.stringify(this.store.getState()));
      const state2 = {
        data: dataToSave,
        timestamp: Date.now()
      };
      try {
        localStorage.setItem(this.options.id, JSON.stringify(state2));
        this.emit("saveState", state2);
        return state2;
      } catch (error) {
        console.error("Error saving state:", error);
        this.emit("saveStateError", error);
        return null;
      }
    }
    /**
     * Restores the state from localStorage.
     * @returns {any|null}
     */
    restoreState() {
      if (!_StateManager.isStorageAvailable()) {
        console.warn("localStorage is not available");
        return null;
      }
      try {
        const savedState = localStorage.getItem(this.options.id);
        if (savedState) {
          const parsed = JSON.parse(savedState);
          Object.assign(this.store.state, parsed.data);
          this.emit("restoreState", parsed);
          return parsed;
        }
      } catch (error) {
        this.emit("restoreStateError", error);
      }
    }
    /**
     * Creates a snapshot of the current state.
     * @returns {{data: any, timestamp: number}|null}
     */
    createSnapshot() {
      if (!_StateManager.isStorageAvailable()) {
        console.warn("localStorage is not available");
        return null;
      }
      const dataToSave = JSON.parse(JSON.stringify(this.store.getState()));
      const snapshot = {
        data: dataToSave,
        timestamp: Date.now()
      };
      this.emit("createSnapshot", snapshot);
      return snapshot;
    }
    /**
     * Restores the state from a snapshot.  
     * @param snapshot
     * @returns {*|null}
     */
    restoreSnapshot(snapshot) {
      if (!_StateManager.isStorageAvailable()) {
        console.warn("localStorage is not available");
        return null;
      }
      if (snapshot) {
        Object.assign(this.store.state, snapshot.data);
        this.emit("restoreSnapshot", snapshot);
        return snapshot;
      }
      return null;
    }
    /**
     * Enables automatic state-saving at a specified interval.
     * @param interval
     */
    enableAutoSave(interval = 5e3) {
      this.autoSaveInterval = setInterval(() => {
        this.saveState();
      }, interval);
    }
    /**
     * Disables automatic state-saving.
     */
    disableAutoSave() {
      clearInterval(this.autoSaveInterval);
    }
  };
  var ModelOptions = {
    id: "model",
    useSimpleExpressions: true,
    debug: false,
    plugins: [],
    validators: [],
    formatters: []
  };
  var Model2 = class extends event_emitter_default {
    /**
     * Creates a new instance of the Model class.
     * @param {Object} [data={}] - Initial data for the model.
     * @param {Object} [options={}] - Configuration options for the model.
     */
    constructor(data = {}, options = {}) {
      super();
      this.options = { ...ModelOptions, ...options };
      Logger.DEBUG_LEVEL = this.options.debug ? 4 : 0;
      Logger.debug("Creating a model with data:", data);
      Logger.debug("Configuration options:", options);
      this.computed = {};
      for (const key in data) {
        if (typeof data[key] === "function") {
          Logger.debug(`Registration calculated property "${key}"`);
          this.computed[key] = {
            getter: data[key],
            value: null,
            dependencies: []
          };
          delete data[key];
        }
      }
      this.store = new ReactiveStore(data, this);
      this.data = this.store.state;
      this.dom = new DOMManager(this);
      this.computedProps = new ComputedProps(this, this.computed);
      this.stateManager = new StateManager(this.store);
      this.plugins = /* @__PURE__ */ new Map();
      if (this.options.plugins) {
        for (const p5 of this.options.plugins) {
          const { name: name2, plugin, options: options2 } = p5;
          if (name2 && plugin && typeof plugin === "function") {
            this.registerPlugin(name2, plugin, options2);
          }
        }
      }
      if (this.options.validators) {
        for (const p5 of this.options.validators) {
          const { path, validator } = p5;
          if (path && validator && typeof validator === "function") {
            this.addValidator(path, validator);
          }
        }
      }
      if (this.options.formatters) {
        for (const p5 of this.options.formatters) {
          const { path, formatter } = p5;
          if (path && formatter && typeof formatter === "function") {
            this.addValidator(path, formatter);
          }
        }
      }
      this.subscribe();
      Logger.debug("The model was created successfully!");
    }
    /**
     * Subscribes to changes from the ReactiveStore and handles DOM updates,
     * input field updates, and computed properties recalculation.
     */
    subscribe() {
      Logger.debug("Subscribing to store changes");
      this.store.on("change", (data) => {
        this.dom.updateDOM(data.path, data.newValue);
        this.dom.updateInputs(data.path, data.newValue);
        this.computedProps.update(data.path).then(() => {
        });
        this.emit("change", data);
      });
      this.store.on("compute", (data) => this.emit("compute", data));
      this.store.on("arrayChange", (data) => this.emit("arrayChange", data));
      this.store.on("batchComplete", (data) => this.emit("batchComplete", data));
      Logger.debug("Subscribing to state manager events");
      this.stateManager.on("saveState", (data) => this.emit("saveState", data));
      this.stateManager.on("saveStateError", (error) => this.emit("saveStateError", error));
      this.stateManager.on("restoreState", (data) => this.emit("restoreState", data));
      this.stateManager.on("restoreStateError", (error) => this.emit("restoreStateError", error));
      this.stateManager.on("createSnapshot", (data) => this.emit("createSnapshot", data));
      this.stateManager.on("restoreSnapshot", (data) => this.emit("restoreSnapshot", data));
    }
    /**
     * Adds a validator function to a specified path.
     * @param {string} path - Path within the state to attach the validator.
     * @param {Function} validator - Validation function to execute on path changes.
     */
    addValidator(path, validator) {
      this.store.addValidator(path, validator);
    }
    /**
     * Adds a formatter function to a specified path.
     * @param {string} path - Path within the state to attach the formatter.
     * @param {Function} formatter - Formatting function to execute on path changes.
     */
    addFormatter(path, formatter) {
      this.store.addFormatter(path, formatter);
    }
    /**
     * Adds middleware to the ReactiveStore for intercepting and processing state changes.
     * @param {Function} middleware - Middleware function that receives and can modify state changes before they're applied.
     */
    use(middleware) {
      this.store.use(middleware);
    }
    /**
     * Watches a specific path in the state and triggers a callback on changes.
     * @param {string} path - Path to watch.
     * @param {Function} callback - Callback function to execute when the path changes.
     */
    watch(path, callback) {
      this.store.watch(path, callback);
    }
    /**
     * Executes a batch of state changes in a single update cycle.
     * @param callback
     */
    batch(callback) {
      return this.store.batch(callback);
    }
    /**
     * Detects changes between two arrays and returns the differences.
     * @param newArray
     * @param oldArray
     * @returns {{added: [], removed: [], moved: []}}
     */
    diffArrays(newArray, oldArray) {
      return this.store.detectArrayChanges(newArray, oldArray);
    }
    diff() {
    }
    /**
     * Validates the model for potential issues, including:
     *
     * 1. Cyclic dependencies in computed properties: Ensures that no property in the `computed`
     *    object of the model depends on itself through a chain of other properties.
     * 2. Invalid paths in DOM dependencies: Ensures that all paths used in the DOM template
     *    exist within the model's store.
     *
     * @returns {{errors: Array<Object>, warnings: Array<Object>}} - Returns an object containing arrays
     *          of errors and warnings. Each error or warning is represented as an object with details
     *          about the issue.
     *
     * Errors include:
     * - `CYCLIC_DEPENDENCY`: Indicates a cyclic dependency was found in `computed` properties.
     *   - `property`: The property with the cyclic dependency.
     *   - `message`: Description of the cyclic dependency.
     *
     * Warnings include:
     * - `INVALID_PATH`: Indicates a path used in the DOM does not exist in the model.
     *   - `path`: The invalid path.
     *   - `message`: Description of the invalid path.
     */
    validate() {
      const errors = [];
      const warnings = [];
      for (const key in this.computed) {
        const visited = /* @__PURE__ */ new Set();
        const cyclePath = this._checkCyclicDependencies(key, visited);
        if (cyclePath) {
          errors.push({
            type: "CYCLIC_DEPENDENCY",
            property: key,
            message: `Cyclic dependence is found: ${cyclePath.join(" -> ")}`
          });
        }
      }
      this.dom.domDependencies.forEach((deps, path) => {
        if (!this.store.isValidPath(path)) {
          warnings.push({
            type: "INVALID_PATH",
            path,
            message: `Property ${path} used in the template, but does not exist in the model`
          });
        }
      });
      return { errors, warnings };
    }
    /**
     * Checks for cyclic dependencies in the computed properties of the model.
     *
     * This method recursively traverses the dependencies of a given property to determine
     * if a cyclic dependency exists. A cyclic dependency occurs when a property ultimately
     * depends on itself through a chain of other properties.
     *
     * @param {string} key - The key of the property to check for cyclic dependencies.
     * @param {Set<string>} visited - A set of visited properties during the traversal.
     * @param {string[]} [path=[]] - The current path of dependencies being checked.
     * @returns {string[]|null} - Returns an array representing the cyclic path if a cycle is found,
     *                            otherwise `null`.
     */
    _checkCyclicDependencies(key, visited, path = []) {
      if (visited.has(key)) {
        return [...path, key];
      }
      visited.add(key);
      path.push(key);
      const computed = this.computed[key];
      if (!computed || !computed.dependencies) {
        return null;
      }
      for (const dep of computed.dependencies) {
        if (dep in this.computed) {
          const cyclePath = this._checkCyclicDependencies(dep, new Set(visited), [...path]);
          if (cyclePath) {
            return cyclePath;
          }
        }
      }
      return null;
    }
    /**
     * Validates a given path to check if it exists in the model's store.
     * @param path
     * @returns {boolean}
     */
    validatePath(path) {
      return this.store.isValidPath(path);
    }
    /**
     * Initializes the DOM bindings for the model.
     * @param {string|HTMLElement} selector - Selector or root element to bind on.
     * @returns {Model|undefined} - Returns the model instance, or undefined if the root element is not found.
     */
    init(selector) {
      Logger.debug("Initializing DOM bindings");
      let rootElement = typeof selector === "string" ? document.querySelector(selector) : selector;
      if (!rootElement) {
        rootElement = document.body;
      }
      Logger.debug(`Model initialized in ${selector ?? "body"}`);
      Logger.debug("Binding DOM");
      this.dom.bindDOM(rootElement);
      this.emit("init");
      Logger.debug("Initialization complete!");
      return this;
    }
    /**
     * Initializes development tools for the model.
     * @param {Object} [options={}] - Options for the development tools.
     * @returns {DevTools} - An instance of the DevTools class.
     */
    runDevTools(options = {}) {
      return new dev_tools_default(this, options);
    }
    /**
     * Saves the current state of the model.
     * @returns {{data: *, timestamp: number}|null}
     */
    save() {
      return this.stateManager.saveState();
    }
    /**
     * Restores the model to a previously saved state.
     * @returns {*|null}
     */
    restore() {
      return this.stateManager.restoreState();
    }
    /**
     * Creates a snapshot of the current state.
     * @param _snapshot
     * @returns {*|null|{data: *, timestamp: number}}
     */
    snapshot(_snapshot) {
      if (!_snapshot) {
        return this.stateManager.createSnapshot();
      }
      return this.stateManager.restoreSnapshot(_snapshot);
    }
    /**
     * Enables or disables auto-saving of the model's state.
     * @param interval
     */
    autoSave(interval) {
      if (!interval) {
        this.stateManager.disableAutoSave();
      } else {
        this.stateManager.enableAutoSave(interval);
      }
    }
    /**
     * Registers a plugin for the model.
     * @param {string} name - Name of the plugin.
     * @param {Function} plugin - Plugin class or constructor function.
     * @param options
     * @throws {Error} If a plugin with the same name is already registered.
     */
    registerPlugin(name2, plugin, options = {}) {
      if (this.plugins.has(name2)) {
        throw new Error(`Plugin ${name2} already registered`);
      }
      this.plugins.set(name2, new plugin(this, options));
    }
    /**
     * Uses a registered plugin by name.
     * @param {string} name - Name of the plugin to use.
     * @param {Object} [options={}] - Options to pass to the plugin.
     * @returns {Model} - Returns the model instance to allow method chaining.
     */
    usePlugin(name2, options = {}) {
      const pluginInstance = this.plugins.get(name2);
      if (!pluginInstance) {
        console.error(`Plugin ${name2} not found`);
        return this;
      }
      pluginInstance.run();
      return this;
    }
    /**
     * Removes a registered plugin by name.
     * @param name
     */
    removePlugin(name2) {
      if (this.plugins.has(name2)) {
        this.plugins.delete(name2);
      }
    }
    /**
     * Destroys the model instance and cleans up resources.
     */
    destroy() {
      this.dom.destroy();
      this.store.destroy();
      this.emit("destroy");
    }
  };
  var model_default = Model2;
  var version3 = "0.18.1";
  var build_time3 = "18.05.2025, 14:40:40";
  model_default.info = () => {
    console.info(`%c Model %c v${version3} %c ${build_time3} `, "color: white; font-weight: bold; background: #0080fe", "color: white; background: darkgreen", "color: white; background: #0080fe;");
  };
  var index_default = model_default;

  // ../metroui-lib/source/model/index.js
  globalThis.Model = index_default;

  // ../metroui-lib/source/core/global.js
  (($7) => {
    "use strict";
    globalThis["__version__"] = "5.1.18";
    globalThis["__build_time__"] = "29.08.2025, 10:45:22";
    const meta_init = $7.meta("metro:init").attr("content");
    const meta_cloak = $7.meta("metro:cloak").attr("content");
    const meta_cloak_duration = $7.meta("metro:cloak_duration").attr("content");
    const meta_blur_image = $7.meta("metro:blur").attr("content");
    const meta_smooth_scroll = $7.meta("metro:smooth").attr("content");
    const meta_theme = $7.meta("metro:theme").attr("content");
    const meta_info = $7.meta("metro:info").attr("content");
    const meta_jquery = $7.meta("metro:jquery").attr("content");
    const meta_debug = $7.meta("metro:debug").attr("content");
    globalThis.METRO_INIT = meta_init ? JSON.parse(meta_init) : true;
    if (meta_theme !== void 0) {
      $7("html").addClass(
        meta_theme === "auto" ? $7.dark ? "dark-side" : "" : meta_theme === "dark" ? "dark-side" : "light-side"
      );
    }
    globalThis.METRO_BLUR_IMAGE = meta_blur_image ? JSON.parse(meta_blur_image) : false;
    globalThis.jquery_present = typeof globalThis.jQuery !== "undefined";
    globalThis.METRO_JQUERY = meta_jquery ? JSON.parse(meta_jquery) : true;
    globalThis.useJQuery = globalThis.jquery_present && globalThis.METRO_JQUERY;
    globalThis.METRO_SHOW_INFO = meta_info ? JSON.parse(meta_info) : false;
    globalThis.METRO_DEBUG = meta_debug ? JSON.parse(meta_debug) : false;
    globalThis.METRO_CLOAK_REMOVE = meta_cloak ? `${meta_cloak}`.toLowerCase() : "fade";
    globalThis.METRO_CLOAK_DURATION = meta_cloak_duration ? Number.parseInt(meta_cloak_duration) : 300;
    globalThis.METRO_SMOOTH_SCROLL = meta_smooth_scroll ? JSON.parse(meta_smooth_scroll) : true;
    globalThis.METRO_DATE_FORMAT = "DD.MM.YYYY";
    globalThis.METRO_TIME_FORMAT = "HH:mm:ss";
    globalThis.METRO_DATETIME_FORMAT = "DD.MM.YYYY HH:mm:ss";
    globalThis.METRO_TIMEOUT = 3e3;
    globalThis.METRO_MEDIA = [];
  })(Dom);

  // ../metroui-lib/source/core/component.js
  var normalizeComponentName = (name2) => typeof name2 !== "string" ? void 0 : name2.replace(/-/g, "").toLowerCase();
  var Component = (nameName, compObj) => {
    const name2 = normalizeComponentName(nameName);
    const component = $3.extend(
      { name: name2, instanceOf: "MetroComponent" },
      {
        _super: function(el, options, defaults, setup) {
          this.elem = el;
          this.element = $3(el);
          this.options = $3.extend({}, defaults, options);
          this.component = this.elem;
          this.locale = "en";
          this.strings = {};
          this._setOptionsFromDOM();
          this._runtime();
          this._setLocale();
          if (setup && typeof setup === "object") {
            $3.each(setup, (key, val) => {
              this[key] = val;
            });
          }
          this._createExec();
        },
        _setOptionsFromDOM: function() {
          const element2 = this.element;
          const o2 = this.options;
          $3.each(element2.data(), (key, value) => {
            if (key in o2) {
              try {
                o2[key] = JSON.parse(value);
              } catch {
                o2[key] = value;
              }
            }
          });
        },
        _runtime: function() {
          const element2 = this.element;
          let mc;
          const roles = (element2.attr("data-role") || "").toArray(",").map((v5) => normalizeComponentName(v5)).filter((v5) => v5.trim() !== "");
          if (!element2.attr(`data-role-${this.name}`)) {
            element2.attr(`data-role-${this.name}`, true);
            if (roles.indexOf(this.name) === -1) {
              roles.push(this.name);
              element2.attr("data-role", roles.join(","));
            }
            mc = element2.data("metroComponent");
            if (mc === void 0) {
              mc = [this.name];
            } else {
              mc.push(this.name);
            }
            element2.data("metroComponent", mc);
          }
        },
        _createExec: function() {
          const timeout = this.options[`${this.name}Deferred`];
          if (timeout) {
            setTimeout(() => {
              this._create();
            }, timeout);
          } else {
            this._create();
          }
        },
        _fireEvent: function(eventName, data = null, log = false, noFire = false, context = null) {
          const element2 = this.element;
          const o2 = this.options;
          const event = str(eventName).camelCase().capitalize(false).value;
          const _data = $3.extend({}, data, { __this: element2[0] });
          if (log) {
            console.warn(log);
            console.warn(`Event: on${event}`);
            console.warn("Data: ", data);
            console.warn("Element: ", element2[0]);
          }
          if (noFire !== true) element2.fire(event.toLowerCase(), data);
          return Metro.utils.exec(o2[`on${event}`], Object.values(_data), context ? context : element2[0]);
        },
        // _fireEvents: function (events, data, log, noFire, context) {
        _fireEvents: function(...rest) {
          const that = this;
          if (rest.length === 0) {
            return;
          }
          const [events, data, log, noFire, context] = rest;
          const _events = Array.isArray(events) ? events : events.toArray(",");
          if (rest.length === 1) {
            $3.each(_events, (_events2, event) => {
              that._fireEvent(event);
            });
            return _events.length;
          }
          $3.each(_events, function() {
            that._fireEvent(this, data, log, noFire, context);
          });
        },
        _setLocale: function() {
          const lang = this.element.closest("[lang]");
          if (lang.length > 0) {
            this.locale = lang.attr("lang");
          } else {
            this.locale = $3("html").attr("lang") || "en";
          }
          this.strings = $3.extend({}, Metro.locales.en, Metro.locales[this.locale]);
        },
        _addLabel: (text, target, { id, dir = "ltr", className } = {}) => {
          if (!text) return;
          const label = $3("<label>").addClass("label-for-input").addClass(className).html(text).insertBefore($3(target));
          if (id) {
            label.attr("for", id);
          }
          if (dir === "rtl") {
            label.addClass("rtl");
          }
        },
        _setAttributes: (element2, attributes) => {
          if (typeof attributes !== "object") return;
          const el = $3(element2);
          $3.each(attributes, (k5, v5) => {
            el.attr(Str.dashedName(k5), v5);
          });
        },
        _waitForRole: async function(role, callback) {
          const element2 = this.element;
          const _role = normalizeComponentName(role);
          return new Promise((resolve) => {
            if (element2.attr(`data-role-${_role}`)) {
              resolve(callback());
            }
          });
        },
        getComponent: function() {
          return this.component;
        },
        getComponentName: function() {
          return this.name;
        }
      },
      compObj
    );
    Metro.plugin(name2, component);
    return component;
  };

  // ../metroui-lib/source/core/props.js
  var isTouch2 = "ontouchstart" in window;
  var Props = {
    controlsPosition: {
      INSIDE: "inside",
      OUTSIDE: "outside"
    },
    groupMode: {
      ONE: "one",
      MULTI: "multi"
    },
    aspectRatio: {
      HD: "hd",
      SD: "sd",
      CINEMA: "cinema"
    },
    fullScreenMode: {
      WINDOW: "window",
      DESKTOP: "desktop"
    },
    position: {
      TOP: "top",
      BOTTOM: "bottom",
      LEFT: "left",
      RIGHT: "right",
      TOP_RIGHT: "top-right",
      TOP_LEFT: "top-left",
      BOTTOM_LEFT: "bottom-left",
      BOTTOM_RIGHT: "bottom-right",
      LEFT_BOTTOM: "left-bottom",
      LEFT_TOP: "left-top",
      RIGHT_TOP: "right-top",
      RIGHT_BOTTOM: "right-bottom"
    },
    popoverEvents: {
      CLICK: "click",
      HOVER: "hover",
      FOCUS: "focus"
    },
    stepperView: {
      SQUARE: "square",
      CYCLE: "cycle",
      DIAMOND: "diamond"
    },
    listView: {
      LIST: "list",
      CONTENT: "content",
      ICONS: "icons",
      ICONS_MEDIUM: "icons-medium",
      ICONS_LARGE: "icons-large",
      TILES: "tiles",
      TABLE: "table"
    },
    events: {
      click: "click",
      start: isTouch2 ? "touchstart" : "mousedown",
      stop: isTouch2 ? "touchend" : "mouseup",
      move: isTouch2 ? "touchmove" : "mousemove",
      enter: isTouch2 ? "touchstart" : "mouseenter",
      startAll: "mousedown touchstart",
      stopAll: "mouseup touchend",
      moveAll: "mousemove touchmove",
      leave: "mouseleave",
      focus: "focus",
      blur: "blur",
      resize: "resize",
      keyup: "keyup",
      keydown: "keydown",
      keypress: "keypress",
      dblclick: "dblclick",
      input: "input",
      change: "change",
      cut: "cut",
      paste: "paste",
      scroll: "scroll",
      mousewheel: "mousewheel",
      inputchange: "change input propertychange cut paste copy drop",
      dragstart: "dragstart",
      dragend: "dragend",
      dragenter: "dragenter",
      dragover: "dragover",
      dragleave: "dragleave",
      drop: "drop",
      drag: "drag"
    },
    keyCode: {
      BACKSPACE: 8,
      TAB: 9,
      ENTER: 13,
      SHIFT: 16,
      CTRL: 17,
      ALT: 18,
      BREAK: 19,
      CAPS: 20,
      ESCAPE: 27,
      SPACE: 32,
      PAGEUP: 33,
      PAGEDOWN: 34,
      END: 35,
      HOME: 36,
      LEFT_ARROW: 37,
      UP_ARROW: 38,
      RIGHT_ARROW: 39,
      DOWN_ARROW: 40,
      COMMA: 188
    },
    media_queries: {
      FS: "(min-width: 0px)",
      XS: "(min-width: 360px)",
      SM: "(min-width: 576px)",
      LD: "(min-width: 640px)",
      MD: "(min-width: 768px)",
      LG: "(min-width: 992px)",
      XL: "(min-width: 1200px)",
      XXL: "(min-width: 1452px)",
      XXXL: "(min-width: 2000px)"
    },
    media_sizes: {
      FS: 0,
      XS: 360,
      SM: 576,
      LD: 640,
      MD: 768,
      LG: 992,
      XL: 1200,
      XXL: 1452,
      XXXL: 2e3
    },
    media_mode: {
      FS: "fs",
      XS: "xs",
      SM: "sm",
      LD: "ld",
      MD: "md",
      LG: "lg",
      XL: "xl",
      XXL: "xxl",
      XXXL: "xxxl"
    },
    media_modes: ["fs", "xs", "sm", "ld", "md", "lg", "xl", "xxl", "xxxl"],
    actions: {
      NONE: 0,
      REMOVE: 1,
      HIDE: 2,
      MINIMIZE: 3,
      MAXIMIZE: 4,
      CLOSE: 5,
      RESTORE: 6,
      SHOW: 7
    },
    theme: {
      LIGHT: "light",
      DARK: "dark"
    }
  };

  // ../metroui-lib/source/core/metro.js
  (($7) => {
    "use strict";
    if (typeof Dom === "undefined") {
      throw new Error("Metro UI requires Dom library!");
    }
    if (!("MutationObserver" in window)) {
      throw new Error("Metro UI requires MutationObserver!");
    }
    const isTouch3 = "ontouchstart" in window;
    const normalizeComponentName2 = (name2) => typeof name2 !== "string" ? void 0 : name2.replace(/-/g, "").toLowerCase();
    const Metro2 = {
      version: "5.1.18",
      build_time: "29.08.2025, 10:45:22",
      buildNumber: 0,
      isTouchable: isTouch3,
      fullScreenEnabled: document.fullscreenEnabled,
      sheet: null,
      hotkeys: {},
      locales: {},
      utils: {},
      colors: {},
      dialog: null,
      pagination: null,
      md5: null,
      storage: null,
      export: null,
      animations: null,
      cookie: null,
      template: null,
      defaults: {},
      info: () => {
        if (globalThis.METRO_SHOW_INFO) {
          Metro2.welcome();
        }
      },
      welcome: () => {
        console.info(
          `%c METRO UI %c v${Metro2.version} %c ${Metro2.build_time} `,
          "color: pink; font-weight: bold; background: #800000",
          "color: white; background: darkgreen",
          "color: white; background: #0080fe;"
        );
        if (globalThis.$ && $7.info) $7.info();
        if (globalThis.Hooks && Hooks.info) Hooks.info();
        if (globalThis.HTML && HTML.info) HTML.info();
        if (globalThis.Farbe && Farbe.info) Farbe.info();
        if (globalThis.Datetime && Datetime.info) Datetime.info();
        if (globalThis.Str && Str.info) Str.info();
        if (globalThis.G && G.info) G.info();
        if (globalThis.Router && Router.info) Router.info();
        if (globalThis.Model && Model.info) Model.info();
      },
      aboutDlg: () => {
        alert(`Metro UI - v${Metro2.version}`);
      },
      observe: () => {
        const observerConfig = {
          childList: true,
          attributes: true,
          subtree: true
        };
        const observerCallback = (mutations) => {
          mutations.map((mutation) => {
            if (mutation.type === "attributes" && mutation.attributeName !== "data-role") {
              if (mutation.attributeName === "data-hotkey") {
                Metro2.initHotkeys([mutation.target], true);
              } else {
                const element2 = $7(mutation.target);
                const mc = element2.data("metroComponent");
                const attr = mutation.attributeName;
                const newValue = element2.attr(attr);
                const oldValue = mutation.oldValue;
                if (mc !== void 0) {
                  element2.fire("attr-change", {
                    attr,
                    newValue,
                    oldValue,
                    __this: element2[0]
                  });
                  $7.each(mc, function() {
                    const plug = Metro2.getPlugin(element2, this);
                    if (plug && typeof plug.changeAttribute === "function") {
                      plug.changeAttribute(attr, newValue, oldValue);
                    }
                  });
                }
              }
            } else if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
              const widgets = [];
              const hotkeys = [];
              let $node;
              let node;
              const nodes = mutation.addedNodes;
              if (nodes.length) {
                for (const node2 of $7(nodes).find("[data-hotkey]")) {
                  hotkeys.push($7(node2));
                }
                for (let i3 = 0; i3 < nodes.length; i3++) {
                  node = nodes[i3];
                  $node = $7(node);
                  if ($node.attr("data-role") !== void 0) {
                    widgets.push(node);
                  }
                  $7.each($node.find("[data-role]"), function() {
                    if (widgets.indexOf(this) !== -1) {
                      return;
                    }
                    widgets.push(this);
                  });
                }
                if (widgets.length) Metro2.initWidgets(widgets, "observe");
                if (hotkeys.length) Metro2.initHotkeys(hotkeys);
              }
            } else {
            }
          });
        };
        const observer = new MutationObserver(observerCallback);
        observer.observe($7("html")[0], observerConfig);
      },
      init: () => {
        const widgets = $7("[data-role]");
        const hotkeys = $7("[data-hotkey]");
        const html = $7("html");
        Metro2.i18n.load(html.attr("lang"));
        Metro2.info();
        if (isTouch3 === true) {
          html.addClass("touchable-device");
        }
        Metro2.sheet = Metro2.utils.newCssSheet();
        Metro2.utils.addCssRule(Metro2.sheet, "*, *::before, *::after", "box-sizing: border-box;");
        globalThis.METRO_MEDIA = [];
        $7.each(Metro2.media_queries, (key, query) => {
          if (Metro2.utils.media(query)) {
            globalThis.METRO_MEDIA.push(Metro2.media_mode[key]);
          }
        });
        Metro2.observe();
        Metro2.initHotkeys(hotkeys);
        Metro2.initWidgets(widgets, "init");
        if (globalThis.METRO_CLOAK_REMOVE !== "fade") {
          $7(".m4-cloak").removeClass("m4-cloak");
          $7(".cloak").removeClass("cloak");
          $7(globalThis).fire("metro-initiated");
        } else {
          $7(".m4-cloak, .cloak").animate({
            draw: {
              opacity: [0, 1]
            },
            dur: 300,
            onDone: () => {
              $7(".m4-cloak").removeClass("m4-cloak");
              $7(".cloak").removeClass("cloak");
              $7(globalThis).fire("metro-initiated");
            }
          });
        }
        $7(document).on("click", "[data-copy-to-clipboard]", function() {
          const val = $7(this).attr("data-copy-to-clipboard");
          Metro2.utils.copy2clipboard(val);
          if (Metro2.toast) {
            Metro2.toast.create(`Data ${val} copied to clipboard!`);
          }
        });
        if (METRO_SMOOTH_SCROLL) {
          const smoothLinks = document.querySelectorAll('a.smooth-scroll[href^="#"]');
          for (const smoothLink of smoothLinks) {
            smoothLink.addEventListener("click", (e2) => {
              e2.preventDefault();
              const id = smoothLink.getAttribute("href");
              document.querySelector(id).scrollIntoView({
                behavior: "smooth",
                block: "start"
              });
            });
          }
        }
      },
      initHotkeys: (hotkeys, redefine) => {
        $7.each(hotkeys, function() {
          const element2 = $7(this);
          const hotkey = element2.attr("data-hotkey") ? element2.attr("data-hotkey").toLowerCase() : false;
          const fn = element2.attr("data-hotkey-func") ? element2.attr("data-hotkey-func") : false;
          if (hotkey === false) {
            return;
          }
          if (element2.data("hotKeyBonded") === true && redefine !== true) {
            return;
          }
          Metro2.hotkeys[hotkey] = [this, fn];
          element2.data("hotKeyBonded", true);
          element2.fire("hot-key-bonded", {
            __this: element2[0],
            hotkey,
            fn
          });
        });
      },
      initWidgets: (widgets) => {
        $7.each(widgets, function() {
          const $this = $7(this);
          if (!this.hasAttribute("data-role")) {
            return;
          }
          const roles = $this.attr("data-role").split(/\s*,\s*/);
          roles.map((func) => {
            const $$ = Metro2.utils.$();
            const _func = normalizeComponentName2(func);
            if ($$.fn[_func] !== void 0 && $this.attr(`data-role-${_func}`) === void 0) {
              try {
                $$.fn[_func].call($this);
                $this.attr(`data-role-${_func}`, true);
                let mc = $this.data("metroComponent");
                if (mc === void 0) {
                  mc = [_func];
                } else {
                  mc.push(_func);
                }
                $this.data("metroComponent", mc);
                $this.fire("create", {
                  __this: $this[0],
                  name: _func
                });
                $7(document).fire("component-create", {
                  element: $this[0],
                  name: _func
                });
              } catch (e2) {
                console.error(`Error creating component ${func} for `, $this[0]);
                throw e2;
              }
            }
          });
        });
        Metro2.i18n.updateUI();
      },
      plugin: (name2, object) => {
        const _name = normalizeComponentName2(name2);
        const register = ($8) => {
          $8.fn[_name] = function(options) {
            return this.each(function() {
              $8.data(this, _name, Object.create(object).init(options, this));
            });
          };
        };
        register(Dom);
        if (globalThis.useJQuery) {
          register(globalThis.jQuery);
        }
      },
      pluginExists: (name2) => {
        const $8 = globalThis.useJQuery ? globalThis.jQuery : Dom;
        return typeof $8.fn[normalizeComponentName2(name2)] === "function";
      },
      destroyPlugin: (element2, name2) => {
        const el = $7(element2);
        const _name = normalizeComponentName2(name2);
        const p5 = Metro2.getPlugin(el, _name);
        if (typeof p5 === "undefined") {
          console.warn(`Component ${name2} can not be destroyed: the element is not a Metro UI component.`);
          return;
        }
        if (typeof p5.destroy !== "function") {
          console.warn(`Component ${name2} can not be destroyed: method destroy not found.`);
          return;
        }
        p5.destroy();
        const mc = el.data("metroComponent");
        Metro2.utils.arrayDelete(mc, _name);
        el.data("metroComponent", mc);
        $7.removeData(el[0], _name);
        el.removeAttr(`data-role-${_name}`);
      },
      destroyPluginAll: (element2) => {
        const el = $7(element2);
        const mc = el.data("metroComponent");
        if (mc !== void 0 && mc.length > 0)
          $7.each(mc, function() {
            Metro2.destroyPlugin(el[0], this);
          });
      },
      noop: () => {
      },
      noop_true: () => true,
      noop_false: () => false,
      noop_arg: (a2) => a2,
      requestFullScreen: (element2) => {
        if (element2.mozRequestFullScreen) {
          element2.mozRequestFullScreen();
        } else if (element2.webkitRequestFullScreen) {
          element2.webkitRequestFullScreen();
        } else if (element2.msRequestFullscreen) {
          element2.msRequestFullscreen();
        } else {
          element2.requestFullscreen().catch((err) => {
            console.warn(`Error attempting to enable full-screen mode: ${err.message} ${err.name}`);
          });
        }
      },
      exitFullScreen: () => {
        if (document.mozCancelFullScreen) {
          document.mozCancelFullScreen();
        } else if (document.webkitCancelFullScreen) {
          document.webkitCancelFullScreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        } else {
          document.exitFullscreen().catch((err) => {
            console.warn(`Error attempting to disable full-screen mode: ${err.message} ${err.name}`);
          });
        }
      },
      inFullScreen: () => {
        const fsm = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
        return fsm !== void 0;
      },
      $: () => globalThis.useJQuery ? globalThis.jQuery : Dom,
      get$el: (el) => Metro2.$()($7(el)[0]),
      get$elements: (el) => Metro2.$()($7(el)),
      getPlugin: (el, name2) => {
        const _name = normalizeComponentName2(name2);
        const $el = Metro2.get$el(el);
        return $el.length ? $el.data(_name) : void 0;
      },
      // TODO: need test
      getPlugins: (el) => {
        const $el = Metro2.get$el(el);
        const mc = $el.data("metroComponent");
        if (mc === void 0) {
          return [];
        }
        return mc.map((name2) => {
          const _name = normalizeComponentName2(name2);
          return $el.data(_name);
        });
      },
      makePlugin: (el, name2, options) => {
        const _name = normalizeComponentName2(name2);
        const $el = Metro2.get$elements(el);
        if (!$el.length || typeof $el[_name] !== "function") {
          return void 0;
        }
        $el[_name](options);
        return Metro2.getPlugin($el[0], name2);
      },
      fetch: {
        status: (response) => response.ok ? Promise.resolve(response) : Promise.reject(new Error(response.statusText)),
        json: (response) => response.json(),
        text: (response) => response.text(),
        form: (response) => response.formData(),
        blob: (response) => response.blob(),
        buffer: (response) => response.arrayBuffer()
      },
      i18n: {
        language: "en",
        load(lang = "en") {
          Metro2.i18n.language = Metro2.locales[lang] ? lang : "en";
          Metro2.locale = Metro2.locales[Metro2.i18n.language];
        },
        add(id, data) {
          Metro2.locales[id] = data;
        },
        get(key, locale) {
          return Metro2.locales[locale] && Metro2.locales[locale][key] ? Metro2.locales[locale][key] : "";
        },
        updateUI(from, lang) {
          const _lang = lang || $7.html().attr("lang") || "en";
          const _from = from || document;
          if (!Metro2.locales[_lang]) {
            return;
          }
          Metro2.i18n.load(_lang);
          $7.html().attr("lang", _lang);
          for (const el of _from.querySelectorAll("[data-i18n]")) {
            const key = el.getAttribute("data-i18n");
            el.innerHTML = Metro2.i18n.get(key, _lang);
          }
        },
        extend(data) {
          $7.each(data, (key, value) => {
            Metro2.locales[key] = Object.assign({}, Metro2.locales[key], value);
          });
        }
      },
      globalMousePosition: { x: 0, y: 0 }
    };
    Metro2.Component = Component;
    Object.assign(Metro2, Props);
    $7(document).on(Metro2.events.moveAll, (e2) => {
      Metro2.globalMousePosition.x = e2.clientX;
      Metro2.globalMousePosition.y = e2.clientY;
    });
    $7(globalThis).on(Metro2.events.resize, () => {
      globalThis.METRO_MEDIA = [];
      $7.each(Metro2.media_queries, (key, query) => {
        if (Metro2.utils.media(query)) {
          globalThis.METRO_MEDIA.push(Metro2.media_mode[key]);
        }
      });
    });
    globalThis.Metro = Metro2;
    if (globalThis.METRO_INIT === true) {
      $7(() => {
        Metro2.init();
      });
    }
    return Metro2;
  })(Dom);

  // ../metroui-lib/source/i18n/en.js
  (() => {
    Metro.i18n.add("en", {
      weekStart: 0,
      january: "January",
      february: "February",
      march: "March",
      april: "April",
      may: "May",
      june: "June",
      july: "July",
      august: "August",
      september: "September",
      october: "October",
      november: "November",
      december: "December",
      january_short: "Jan",
      february_short: "Feb",
      march_short: "Mar",
      april_short: "Apr",
      may_short: "May",
      june_short: "Jun",
      july_short: "Jul",
      august_short: "Aug",
      september_short: "Sep",
      october_short: "Oct",
      november_short: "Nov",
      december_short: "Dec",
      sunday: "Sunday",
      monday: "Monday",
      tuesday: "Tuesday",
      wednesday: "Wednesday",
      thursday: "Thursday",
      friday: "Friday",
      saturday: "Saturday",
      sunday_short: "Sun",
      monday_short: "Mon",
      tuesday_short: "Tue",
      wednesday_short: "Wed",
      thursday_short: "Thu",
      friday_short: "Fri",
      saturday_short: "Sat",
      sunday_short_2: "Su",
      monday_short_2: "Mo",
      tuesday_short_2: "Tu",
      wednesday_short_2: "We",
      thursday_short_2: "Th",
      friday_short_2: "Fr",
      saturday_short_2: "Sa",
      label_ok: "OK",
      label_cancel: "Cancel",
      label_done: "Done",
      label_today: "Today",
      label_now: "Now",
      label_clear: "Clear",
      label_help: "Help",
      label_yes: "Yes",
      label_no: "No",
      label_random: "Random",
      label_save: "Save",
      label_reset: "Reset",
      label_submit: "Submit",
      label_add_user_color: "Add to swatches",
      label_send: "Send",
      label_accept: "Accept",
      label_cookies_title: "This site uses cookies",
      label_cookies_text: "This website uses cookies to ensure you get the best experience on our website.",
      label_choose_file: "Choose file(s)",
      label_drop_file: "Click or drop file(s) here",
      label_files_selected: "{n} file(s) selected",
      label_days: "days",
      label_hours: "hours",
      label_minutes: "min",
      label_seconds: "sec",
      label_month: "mon",
      label_months: "mon's",
      label_day: "day",
      label_year: "year",
      label_years: "years",
      label_rows_count: "Show:",
      label_search: "Search:",
      label_table_info: "Showing $1 to $2 of $3 entries",
      label_prev: "Prev",
      label_next: "Next",
      label_all: "All",
      label_inspector: "Inspector",
      label_goto_page: "Goto",
      label_enter_page: "Enter page...",
      label_empty: "Nothing to show",
      label_user_colors: "User Colors",
      label_tiles: "Tiles",
      label_list: "List",
      label_load_more: "Load more",
      label_buy: "Buy",
      label_buy_now: "Buy now",
      label_buy_today: "Buy today",
      label_download: "Download",
      label_search_results: "Search results",
      label_add: "Add",
      label_edit: "Edit",
      label_delete: "Delete",
      label_new: "New",
      label_sell: "Sell",
      label_details: "Details",
      label_sorting: "Sorting",
      label_finish: "Finish",
      label_play: "Play",
      label_pause: "Pause",
      label_stop: "Stop",
      label_mute: "Mute",
      label_loop: "Loop",
      label_on: "on",
      label_off: "off",
      label_rename_tab: "Rename tab",
      label_close_tab: "Close tab",
      label_close_other_tabs: "Close other tabs",
      label_close_tabs_left: "Close tabs left",
      label_close_tabs_right: "Close tabs right",
      label_close_all_tabs: "Close all tabs",
      label_close_inactive_tabs: "Close inactive tabs",
      label_clear_input: "Clear input",
      label_reveal_password: "Reveal password",
      label_hide_password: "Hide password",
      label_generate_random: "Generate random value",
      label_search_input: "Search for the entered value",
      label_note: "Note",
      label_tip: "Tip",
      label_info: "Info",
      label_warning: "Warning",
      label_question: "Question",
      label_error: "Error",
      label_success: "Success",
      label_caution: "Caution",
      label_alert: "Alert",
      label_bug: "Bug",
      label_fuck: "Fuck",
      label_important: "Important",
      label_shit: "Shit",
      label_air: "Air",
      label_select_all: "Select all",
      label_select_more: "Select...",
      label_select: "Select",
      label_filter: "Filter",
      label_collapse: "Collapse",
      label_attach: "Attach"
    });
  })();

  // ../metroui-lib/source/i18n/uk.js
  (() => {
    Metro.i18n.add("uk", {
      weekStart: 1,
      january: "\u0421\u0456\u0447\u0435\u043D\u044C",
      february: "\u041B\u044E\u0442\u0438\u0439",
      march: "\u0411\u0435\u0440\u0435\u0437\u0435\u043D\u044C",
      april: "\u041A\u0432\u0456\u0442\u0435\u043D\u044C",
      may: "\u0422\u0440\u0430\u0432\u0435\u043D\u044C",
      june: "\u0427\u0435\u0440\u0432\u0435\u043D\u044C",
      july: "\u041B\u0438\u043F\u0435\u043D\u044C",
      august: "\u0421\u0435\u0440\u043F\u0435\u043D\u044C",
      september: "\u0412\u0435\u0440\u0435\u0441\u0435\u043D\u044C",
      october: "\u0416\u043E\u0432\u0442\u0435\u043D\u044C",
      november: "\u041B\u0438\u0441\u0442\u043E\u043F\u0430\u0434",
      december: "\u0413\u0440\u0443\u0434\u0435\u043D\u044C",
      january_short: "\u0421\u0456\u0447",
      february_short: "\u041B\u044E\u0442",
      march_short: "\u0411\u0435\u0440",
      april_short: "\u041A\u0432\u0456",
      may_short: "\u0422\u0440\u0430",
      june_short: "\u0427\u0435\u0440",
      july_short: "\u041B\u0438\u043F",
      august_short: "\u0421\u0435\u0440",
      september_short: "\u0412\u0435\u0440",
      october_short: "\u0416\u043E\u0432",
      november_short: "\u041B\u0438\u0441",
      december_short: "\u0413\u0440\u0443",
      sunday: "\u041D\u0435\u0434\u0456\u043B\u044F",
      monday: "\u041F\u043E\u043D\u0435\u0434\u0456\u043B\u043E\u043A",
      tuesday: "\u0412\u0456\u0432\u0442\u043E\u0440\u043E\u043A",
      wednesday: "\u0421\u0435\u0440\u0435\u0434\u0430",
      thursday: "\u0427\u0435\u0442\u0432\u0435\u0440",
      friday: "\u041F'\u044F\u0442\u043D\u0438\u0446\u044F",
      saturday: "\u0421\u0443\u0431\u043E\u0442\u0430",
      sunday_short: "\u041D\u0435\u0434",
      monday_short: "\u041F\u043E\u043D",
      tuesday_short: "\u0412\u0456\u0432",
      wednesday_short: "\u0421\u0435\u0440",
      thursday_short: "\u0427\u0435\u0442",
      friday_short: "\u041F\u0442\u043D",
      saturday_short: "\u0421\u0443\u0431",
      sunday_short_2: "\u041D\u0434",
      monday_short_2: "\u041F\u043D",
      tuesday_short_2: "\u0412\u0442",
      wednesday_short_2: "\u0421\u0440",
      thursday_short_2: "\u0427\u0442",
      friday_short_2: "\u041F\u0442",
      saturday_short_2: "\u0421\u0431",
      label_ok: "OK",
      label_cancel: "\u0412\u0456\u0434\u043C\u0456\u043D\u0430",
      label_done: "\u0412\u0438\u043A\u043E\u043D\u0430\u043D\u043E",
      label_today: "\u0421\u044C\u043E\u0433\u043E\u0434\u043D\u0456",
      label_now: "\u0417\u0430\u0440\u0430\u0437",
      label_clear: "\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u0438",
      label_help: "\u0414\u043E\u043F\u043E\u043C\u043E\u0433\u0430",
      label_yes: "\u0422\u0430\u043A",
      label_no: "\u041D\u0456",
      label_random: "\u0412\u0438\u043F\u0430\u0434\u043A\u043E\u0432\u043E",
      label_save: "\u0417\u0431\u0435\u0440\u0456\u0433\u0442\u0438",
      label_reset: "\u0421\u043A\u0438\u043D\u0443\u0442\u0438",
      label_submit: "\u0412\u0456\u0434\u043F\u0440\u0430\u0432\u0438\u0442\u0438",
      label_add_user_color: "\u0414\u043E\u0434\u0430\u0442\u0438 \u0434\u043E \u0437\u0440\u0430\u0437\u043A\u0456\u0432",
      label_send: "\u0412\u0456\u0434\u043F\u0440\u0430\u0432\u0438\u0442\u0438",
      label_accept: "\u041F\u0440\u0438\u0439\u043D\u044F\u0442\u0438",
      label_cookies_title: "\u0426\u0435\u0439 \u0441\u0430\u0439\u0442 \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u0454 \u0444\u0430\u0439\u043B\u0438 cookie",
      label_cookies_text: "\u0426\u0435\u0439 \u0432\u0435\u0431-\u0441\u0430\u0439\u0442 \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\u0443\u0454 \u0444\u0430\u0439\u043B\u0438 cookie, \u0449\u043E\u0431 \u0437\u0430\u0431\u0435\u0437\u043F\u0435\u0447\u0438\u0442\u0438 \u0432\u0430\u043C \u043D\u0430\u0439\u043A\u0440\u0430\u0449\u0438\u0439 \u0434\u043E\u0441\u0432\u0456\u0434 \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u0430\u043D\u043D\u044F \u043D\u0430\u0448\u043E\u0433\u043E \u0432\u0435\u0431-\u0441\u0430\u0439\u0442\u0443.",
      label_choose_file: "\u0412\u0438\u0431\u0435\u0440\u0456\u0442\u044C \u0444\u0430\u0439\u043B(\u0438)",
      label_drop_file: "\u041D\u0430\u0442\u0438\u0441\u043D\u0456\u0442\u044C \u0430\u0431\u043E \u043F\u0435\u0440\u0435\u0442\u044F\u0433\u043D\u0456\u0442\u044C \u0444\u0430\u0439\u043B(\u0438) \u0441\u044E\u0434\u0438",
      label_files_selected: "\u0412\u0438\u0431\u0440\u0430\u043D\u043E {n} \u0444\u0430\u0439\u043B(\u0456\u0432)",
      label_days: "\u0434\u043D\u0456",
      label_hours: "\u0433\u043E\u0434",
      label_minutes: "\u0445\u0432\u0438\u043B",
      label_seconds: "\u0441\u0435\u043A",
      label_month: "\u043C\u0456\u0441",
      label_months: "\u043C\u0456\u0441\u044F\u0446\u0456",
      label_day: "\u0434\u0435\u043D\u044C",
      label_year: "\u0440\u0456\u043A",
      label_years: "\u0440\u043E\u043A\u0456\u0432",
      label_rows_count: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u0438:",
      label_search: "\u041F\u043E\u0448\u0443\u043A:",
      label_table_info: "\u0412\u0456\u0434\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u043E \u0437 $1 \u043F\u043E $2 \u0456\u0437 $3 \u0437\u0430\u043F\u0438\u0441\u0456\u0432",
      label_prev: "\u041F\u043E\u043F\u0435\u0440\u0435\u0434\u043D\u0456\u0439",
      label_next: "\u041D\u0430\u0441\u0442\u0443\u043F\u043D\u0438\u0439",
      label_all: "\u0423\u0441\u0456",
      label_inspector: "\u0406\u043D\u0441\u043F\u0435\u043A\u0442\u043E\u0440",
      label_goto_page: "\u041F\u0435\u0440\u0435\u0439\u0442\u0438",
      label_enter_page: "\u0412\u0432\u0435\u0434\u0456\u0442\u044C \u0441\u0442\u043E\u0440\u0456\u043D\u043A\u0443...",
      label_empty: "\u041D\u0456\u0447\u043E\u0433\u043E \u043F\u043E\u043A\u0430\u0437\u0430\u0442\u0438",
      label_user_colors: "\u041A\u043E\u043B\u044C\u043E\u0440\u0438 \u043A\u043E\u0440\u0438\u0441\u0442\u0443\u0432\u0430\u0447\u0430",
      label_tiles: "\u041F\u043B\u0438\u0442\u043A\u0430",
      label_list: "\u0421\u043F\u0438\u0441\u043E\u043A",
      label_load_more: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u0438 \u0449\u0435",
      label_buy: "\u041A\u0443\u043F\u0438\u0442\u0438",
      label_buy_now: "\u041A\u0443\u043F\u0438\u0442\u0438 \u0437\u0430\u0440\u0430\u0437",
      label_buy_today: "\u041A\u0443\u043F\u0438\u0442\u0438 \u0441\u044C\u043E\u0433\u043E\u0434\u043D\u0456",
      label_download: "\u0417\u0430\u0432\u0430\u043D\u0442\u0430\u0436\u0438\u0442\u0438",
      label_search_results: "\u0420\u0435\u0437\u0443\u043B\u044C\u0442\u0430\u0442\u0438 \u043F\u043E\u0448\u0443\u043A\u0443",
      label_add: "\u0414\u043E\u0434\u0430\u0442\u0438",
      label_edit: "\u0420\u0435\u0434\u0430\u0433\u0443\u0432\u0430\u0442\u0438",
      label_delete: "\u0412\u0438\u0434\u0430\u043B\u0438\u0442\u0438",
      label_new: "\u041D\u043E\u0432\u0435",
      label_sell: "\u041F\u0440\u043E\u0434\u0430\u0442\u0438",
      label_details: "\u041F\u043E\u0434\u0440\u043E\u0431\u0438\u0446\u0456",
      label_sorting: "\u0421\u043E\u0440\u0442\u0443\u0432\u0430\u043D\u043D\u044F",
      label_finish: "\u0417\u0430\u0432\u0435\u0440\u0448\u0438\u0442\u0438",
      label_play: "\u0412\u0456\u0434\u0442\u0432\u043E\u0440\u0438\u0442\u0438",
      label_pause: "\u041F\u0430\u0443\u0437\u0430",
      label_stop: "\u0417\u0443\u043F\u0438\u043D\u0438\u0442\u0438",
      label_mute: "\u0411\u0435\u0437 \u0437\u0432\u0443\u043A\u0443",
      label_loop: "\u041F\u043E\u0432\u0442\u043E\u0440\u044E\u0432\u0430\u0442\u0438",
      label_on: "\u0443\u0432\u043C",
      label_off: "\u0432\u0438\u043C",
      label_rename_tab: "\u041F\u0435\u0440\u0435\u0439\u043C\u0435\u043D\u0443\u0432\u0430\u0442\u0438 \u0432\u043A\u043B\u0430\u0434\u043A\u0443",
      label_close_tab: "\u0417\u0430\u043A\u0440\u0438\u0442\u0438 \u0432\u043A\u043B\u0430\u0434\u043A\u0443",
      label_close_other_tabs: "\u0417\u0430\u043A\u0440\u0438\u0442\u0438 \u0456\u043D\u0448\u0456 \u0432\u043A\u043B\u0430\u0434\u043A\u0438",
      label_close_tabs_left: "\u0417\u0430\u043A\u0440\u0438\u0442\u0438 \u0432\u043A\u043B\u0430\u0434\u043A\u0438 \u043B\u0456\u0432\u043E\u0440\u0443\u0447",
      label_close_tabs_right: "\u0417\u0430\u043A\u0440\u0438\u0442\u0438 \u0432\u043A\u043B\u0430\u0434\u043A\u0438 \u043F\u0440\u0430\u0432\u043E\u0440\u0443\u0447",
      label_close_all_tabs: "\u0417\u0430\u043A\u0440\u0438\u0439\u0442\u0435 \u0432\u0441\u0456 \u0432\u043A\u043B\u0430\u0434\u043A\u0438",
      label_close_inactive_tabs: "\u0417\u0430\u043A\u0440\u0438\u0442\u0438 \u043D\u0435\u0430\u043A\u0442\u0438\u0432\u043D\u0456 \u0432\u043A\u043B\u0430\u0434\u043A\u0438",
      label_clear_input: "\u041E\u0447\u0438\u0441\u0442\u0438\u0442\u0438 \u0432\u0432\u0435\u0434\u0435\u043D\u043D\u044F",
      label_reveal_password: "\u0412\u0456\u0434\u043A\u0440\u0438\u0442\u0438 \u043F\u0430\u0440\u043E\u043B\u044C",
      label_hide_password: "\u041F\u0440\u0438\u0445\u043E\u0432\u0430\u0442\u0438 \u043F\u0430\u0440\u043E\u043B\u044C",
      label_generate_random: "\u0413\u0435\u043D\u0435\u0440\u0443\u0432\u0430\u0442\u0438 \u0432\u0438\u043F\u0430\u0434\u043A\u043E\u0432e \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F",
      label_search_input: "\u0428\u0443\u043A\u0430\u0442\u0438 \u0432\u0432\u0435\u0434\u0435\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F",
      label_note: "\u041F\u0440\u0438\u043C\u0456\u0442\u043A\u0430",
      label_tip: "\u041F\u0456\u0434\u043A\u0430\u0437\u043A\u0430",
      label_info: "\u0406\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0456\u044F",
      label_warning: "\u0423\u0432\u0430\u0433\u0430",
      label_question: "\u041F\u0438\u0442\u0430\u043D\u043D\u044F",
      label_error: "\u041F\u043E\u043C\u0438\u043B\u043A\u0430",
      label_success: "\u0423\u0441\u043F\u0456\u0445",
      label_caution: "\u041E\u0431\u0435\u0440\u0435\u0436\u043D\u043E",
      label_alert: "\u041F\u043E\u043F\u0435\u0440\u0435\u0434\u0436\u0435\u043D\u043D\u044F",
      label_bug: "\u041F\u043E\u043C\u0438\u043B\u043A\u0430",
      label_fuck: "\u0411\u043B\u044F",
      label_important: "\u0412\u0430\u0436\u043B\u0438\u0432\u043E",
      label_shit: "\u041E\u0442 \u043B\u0430\u0439\u043D\u043E",
      label_air: "\u041F\u0443\u0444\u0444\u0444...",
      label_select_all: "\u0412\u0438\u0431\u0440\u0430\u0442\u0438 \u0443\u0441\u0456",
      label_select_more: "\u0412\u0438\u0431\u0435\u0440\u0456\u0442\u044C...",
      label_select: "\u0412\u0438\u0431\u0440\u0430\u0442\u0438",
      label_filter: "\u0424\u0456\u043B\u044C\u0442\u0440",
      label_collapse: "\u0417\u0433\u043E\u0440\u043D\u0443\u0442\u0438",
      label_attach: "\u041F\u0440\u0438\u043A\u0440\u0456\u043F\u0438\u0442\u0438"
    });
  })();

  // ../metroui-lib/source/i18n/pt.js
  (() => {
    Metro.i18n.add("pt", {
      weekStart: 0,
      january: "Janeiro",
      february: "Fevereiro",
      march: "Mar\xE7o",
      april: "Abril",
      may: "Maio",
      june: "Junho",
      july: "Julho",
      august: "Agosto",
      september: "Setembro",
      october: "Outubro",
      november: "Novembro",
      december: "Dezembro",
      january_short: "Jan",
      february_short: "Fev",
      march_short: "Mar",
      april_short: "Abr",
      may_short: "Mai",
      june_short: "Jun",
      july_short: "Jul",
      august_short: "Ago",
      september_short: "Set",
      october_short: "Out",
      november_short: "Nov",
      december_short: "Dez",
      sunday: "Domingo",
      monday: "Segunda-feira",
      tuesday: "Ter\xE7a-feira",
      wednesday: "Quarta-feira",
      thursday: "Quinta-feira",
      friday: "Sexta-feira",
      saturday: "S\xE1bado",
      sunday_short: "Dom",
      monday_short: "Seg",
      tuesday_short: "Ter",
      wednesday_short: "Qua",
      thursday_short: "Qui",
      friday_short: "Sex",
      saturday_short: "S\xE1b",
      sunday_short_2: "D",
      monday_short_2: "S",
      tuesday_short_2: "T",
      wednesday_short_2: "Q",
      thursday_short_2: "Q",
      friday_short_2: "S",
      saturday_short_2: "S",
      label_ok: "OK",
      label_cancel: "Cancelar",
      label_done: "Conclu\xEDdo",
      label_today: "Hoje",
      label_now: "Agora",
      label_clear: "Limpar",
      label_help: "Ajuda",
      label_yes: "Sim",
      label_no: "N\xE3o",
      label_random: "Aleat\xF3rio",
      label_save: "Salvar",
      label_reset: "Redefinir",
      label_submit: "Enviar",
      label_add_user_color: "Adicionar aos tons",
      label_send: "Enviar",
      label_accept: "Aceitar",
      label_cookies_title: "Este site usa cookies",
      label_cookies_text: "Este site utiliza cookies para garantir a melhor experi\xEAncia em nosso site.",
      label_choose_file: "Escolher arquivo(s)",
      label_drop_file: "Clique ou solte o(s) arquivo(s) aqui",
      label_files_selected: "{n} arquivo(s) selecionado(s)",
      label_days: "dias",
      label_hours: "horas",
      label_minutes: "min",
      label_seconds: "seg",
      label_month: "m\xEAs",
      label_months: "meses",
      label_day: "dia",
      label_year: "ano",
      label_years: "anos",
      label_rows_count: "Mostrar:",
      label_search: "Pesquisar:",
      label_table_info: "Mostrando $1 a $2 de $3 entradas",
      label_prev: "Anterior",
      label_next: "Pr\xF3ximo",
      label_all: "Todos",
      label_inspector: "Inspetor",
      label_goto_page: "Ir para",
      label_enter_page: "Digite a p\xE1gina...",
      label_empty: "Nada para mostrar",
      label_user_colors: "Cores do usu\xE1rio",
      label_tiles: "Blocos",
      label_list: "Lista",
      label_load_more: "Carregar mais",
      label_buy: "Comprar",
      label_buy_now: "Comprar agora",
      label_buy_today: "Comprar hoje",
      label_download: "Baixar",
      label_search_results: "Resultados da pesquisa",
      label_add: "Adicionar",
      label_edit: "Editar",
      label_delete: "Excluir",
      label_new: "Novo",
      label_sell: "Vender",
      label_details: "Detalhes",
      label_sorting: "Ordena\xE7\xE3o",
      label_finish: "Finalizar",
      label_play: "Reproduzir",
      label_pause: "Pausar",
      label_stop: "Parar",
      label_mute: "Silenciar",
      label_loop: "Repetir",
      label_on: "lig",
      label_off: "des",
      label_rename_tab: "Renomear aba",
      label_close_tab: "Fechar aba",
      label_close_other_tabs: "Fechar outras abas",
      label_close_tabs_left: "Fechar abas \xE0 esquerda",
      label_close_tabs_right: "Fechar abas \xE0 direita",
      label_close_all_tabs: "Fechar todas as abas",
      label_close_inactive_tabs: "Fechar abas inativas",
      label_clear_input: "Limpar entrada",
      label_reveal_password: "Mostrar senha",
      label_hide_password: "Ocultar senha",
      label_generate_random: "Gerar valor aleat\xF3rio",
      label_search_input: "Pesquisar o valor inserido",
      label_note: "Nota",
      label_tip: "Dica",
      label_info: "Informa\xE7\xE3o",
      label_warning: "Aviso",
      label_question: "Pergunta",
      label_error: "Erro",
      label_success: "Sucesso",
      label_caution: "Cuidado",
      label_alert: "Alerta",
      label_bug: "Erro",
      label_fuck: "Droga",
      label_important: "Importante",
      label_shit: "Merda",
      label_air: "Ar",
      label_select_all: "Selecionar tudo",
      label_select_more: "Selecionar...",
      label_select: "Selecionar",
      label_filter: "Filtrar",
      label_collapse: "Recolher",
      label_attach: "Anexar"
    });
  })();

  // ../metroui-lib/source/i18n/pt-BR.js
  (() => {
    Metro.i18n.add("pt-BR", {
      weekStart: 0,
      january: "Janeiro",
      february: "Fevereiro",
      march: "Mar\xE7o",
      april: "Abril",
      may: "Maio",
      june: "Junho",
      july: "Julho",
      august: "Agosto",
      september: "Setembro",
      october: "Outubro",
      november: "Novembro",
      december: "Dezembro",
      january_short: "Jan",
      february_short: "Fev",
      march_short: "Mar",
      april_short: "Abr",
      may_short: "Mai",
      june_short: "Jun",
      july_short: "Jul",
      august_short: "Ago",
      september_short: "Set",
      october_short: "Out",
      november_short: "Nov",
      december_short: "Dez",
      sunday: "Domingo",
      monday: "Segunda-feira",
      tuesday: "Ter\xE7a-feira",
      wednesday: "Quarta-feira",
      thursday: "Quinta-feira",
      friday: "Sexta-feira",
      saturday: "S\xE1bado",
      sunday_short: "Dom",
      monday_short: "Seg",
      tuesday_short: "Ter",
      wednesday_short: "Qua",
      thursday_short: "Qui",
      friday_short: "Sex",
      saturday_short: "S\xE1b",
      sunday_short_2: "Do",
      monday_short_2: "Se",
      tuesday_short_2: "Te",
      wednesday_short_2: "Qu",
      thursday_short_2: "Qi",
      friday_short_2: "Sx",
      saturday_short_2: "Sa",
      label_ok: "OK",
      label_cancel: "Cancelar",
      label_done: "Conclu\xEDdo",
      label_today: "Hoje",
      label_now: "Agora",
      label_clear: "Limpar",
      label_help: "Ajuda",
      label_yes: "Sim",
      label_no: "N\xE3o",
      label_random: "Aleat\xF3rio",
      label_save: "Salvar",
      label_reset: "Redefinir",
      label_submit: "Enviar",
      label_add_user_color: "Adicionar \xE0s amostras",
      label_send: "Enviar",
      label_accept: "Aceitar",
      label_cookies_title: "Este site usa cookies",
      label_cookies_text: "Este site usa cookies para garantir que voc\xEA tenha a melhor experi\xEAncia em nosso site.",
      label_choose_file: "Escolher arquivo(s)",
      label_drop_file: "Clique ou arraste arquivo(s) aqui",
      label_files_selected: "{n} arquivo(s) selecionado(s)",
      label_days: "dias",
      label_hours: "horas",
      label_minutes: "min",
      label_seconds: "seg",
      label_month: "m\xEAs",
      label_months: "meses",
      label_day: "dia",
      label_year: "ano",
      label_years: "anos",
      label_rows_count: "Mostrar:",
      label_search: "Pesquisar:",
      label_table_info: "Mostrando $1 a $2 de $3 registros",
      label_prev: "Anterior",
      label_next: "Pr\xF3ximo",
      label_all: "Todos",
      label_inspector: "Inspetor",
      label_goto_page: "Ir para",
      label_enter_page: "Digite a p\xE1gina...",
      label_empty: "Nada para mostrar",
      label_user_colors: "Cores do Usu\xE1rio",
      label_tiles: "Blocos",
      label_list: "Lista",
      label_load_more: "Carregar mais",
      label_buy: "Comprar",
      label_buy_now: "Compre agora",
      label_buy_today: "Compre hoje",
      label_download: "Baixar",
      label_search_results: "Resultados da pesquisa",
      label_add: "Adicionar",
      label_edit: "Editar",
      label_delete: "Excluir",
      label_new: "Novo",
      label_sell: "Vender",
      label_details: "Detalhes",
      label_sorting: "Ordena\xE7\xE3o",
      label_finish: "Finalizar",
      label_play: "Reproduzir",
      label_pause: "Pausar",
      label_stop: "Parar",
      label_mute: "Silenciar",
      label_loop: "Repetir",
      label_on: "ligado",
      label_off: "desligado",
      label_rename_tab: "Renomear aba",
      label_close_tab: "Fechar aba",
      label_close_other_tabs: "Fechar outras abas",
      label_close_tabs_left: "Fechar abas \xE0 esquerda",
      label_close_tabs_right: "Fechar abas \xE0 direita",
      label_close_all_tabs: "Fechar todas as abas",
      label_close_inactive_tabs: "Fechar abas inativas",
      label_clear_input: "Limpar entrada",
      label_reveal_password: "Revelar senha",
      label_hide_password: "Ocultar senha",
      label_generate_random: "Gerar valor aleat\xF3rio",
      label_search_input: "Pesquisar pelo valor digitado",
      label_note: "Nota",
      label_tip: "Dica",
      label_info: "Informa\xE7\xE3o",
      label_warning: "Aviso",
      label_question: "Pergunta",
      label_error: "Erro",
      label_success: "Sucesso",
      label_caution: "Cuidado",
      label_alert: "Alerta",
      label_bug: "Bug",
      label_fuck: "Droga",
      label_important: "Importante",
      label_shit: "Merda",
      label_air: "Ar",
      label_select_all: "Selecionar tudo",
      label_select_more: "Selecionar...",
      label_select: "Selecionar",
      label_filter: "Filtrar",
      label_collapse: "Recolher",
      label_attach: "Anexar"
    });
  })();

  // ../metroui-lib/source/i18n/es.js
  (() => {
    Metro.i18n.add("es", {
      weekStart: 0,
      january: "Enero",
      february: "Febrero",
      march: "Marzo",
      april: "Abril",
      may: "Mayo",
      june: "Junio",
      july: "Julio",
      august: "Agosto",
      september: "Septiembre",
      october: "Octubre",
      november: "Noviembre",
      december: "Diciembre",
      january_short: "Ene",
      february_short: "Feb",
      march_short: "Mar",
      april_short: "Abr",
      may_short: "May",
      june_short: "Jun",
      july_short: "Jul",
      august_short: "Ago",
      september_short: "Sep",
      october_short: "Oct",
      november_short: "Nov",
      december_short: "Dic",
      sunday: "Domingo",
      monday: "Lunes",
      tuesday: "Martes",
      wednesday: "Mi\xE9rcoles",
      thursday: "Jueves",
      friday: "Viernes",
      saturday: "S\xE1bado",
      sunday_short: "Dom",
      monday_short: "Lun",
      tuesday_short: "Mar",
      wednesday_short: "Mi\xE9",
      thursday_short: "Jue",
      friday_short: "Vie",
      saturday_short: "S\xE1b",
      sunday_short_2: "D",
      monday_short_2: "L",
      tuesday_short_2: "M",
      wednesday_short_2: "X",
      thursday_short_2: "J",
      friday_short_2: "V",
      saturday_short_2: "S",
      label_ok: "OK",
      label_cancel: "Cancelar",
      label_done: "Hecho",
      label_today: "Hoy",
      label_now: "Ahora",
      label_clear: "Limpiar",
      label_help: "Ayuda",
      label_yes: "S\xED",
      label_no: "No",
      label_random: "Aleatorio",
      label_save: "Guardar",
      label_reset: "Restablecer",
      label_submit: "Enviar",
      label_add_user_color: "A\xF1adir a colores",
      label_send: "Enviar",
      label_accept: "Aceptar",
      label_cookies_title: "Este sitio utiliza cookies",
      label_cookies_text: "Este sitio web utiliza cookies para garantizar que obtenga la mejor experiencia en nuestro sitio web.",
      label_choose_file: "Seleccionar archivo(s)",
      label_drop_file: "Haga clic o suelte archivo(s) aqu\xED",
      label_files_selected: "{n} archivo(s) seleccionado(s)",
      label_days: "d\xEDas",
      label_hours: "horas",
      label_minutes: "min",
      label_seconds: "seg",
      label_month: "mes",
      label_months: "meses",
      label_day: "d\xEDa",
      label_year: "a\xF1o",
      label_years: "a\xF1os",
      label_rows_count: "Mostrar:",
      label_search: "Buscar:",
      label_table_info: "Mostrando $1 a $2 de $3 entradas",
      label_prev: "Anterior",
      label_next: "Siguiente",
      label_all: "Todo",
      label_inspector: "Inspector",
      label_goto_page: "Ir a",
      label_enter_page: "Introducir p\xE1gina...",
      label_empty: "Nada que mostrar",
      label_user_colors: "Colores de usuario",
      label_tiles: "Cuadr\xEDculas",
      label_list: "Lista",
      label_load_more: "Cargar m\xE1s",
      label_buy: "Comprar",
      label_buy_now: "Comprar ahora",
      label_buy_today: "Comprar hoy",
      label_download: "Descargar",
      label_search_results: "Resultados de b\xFAsqueda",
      label_add: "A\xF1adir",
      label_edit: "Editar",
      label_delete: "Eliminar",
      label_new: "Nuevo",
      label_sell: "Vender",
      label_details: "Detalles",
      label_sorting: "Ordenar",
      label_finish: "Finalizar",
      label_play: "Reproducir",
      label_pause: "Pausa",
      label_stop: "Detener",
      label_mute: "Silenciar",
      label_loop: "Repetir",
      label_on: "enc",
      label_off: "apa",
      label_rename_tab: "Renombrar pesta\xF1a",
      label_close_tab: "Cerrar pesta\xF1a",
      label_close_other_tabs: "Cerrar otras pesta\xF1as",
      label_close_tabs_left: "Cerrar pesta\xF1as a la izquierda",
      label_close_tabs_right: "Cerrar pesta\xF1as a la derecha",
      label_close_all_tabs: "Cerrar todas las pesta\xF1as",
      label_close_inactive_tabs: "Cerrar pesta\xF1as inactivas",
      label_clear_input: "Limpiar entrada",
      label_reveal_password: "Mostrar contrase\xF1a",
      label_hide_password: "Ocultar contrase\xF1a",
      label_generate_random: "Generar valor aleatorio",
      label_search_input: "Buscar el valor ingresado",
      label_note: "Nota",
      label_tip: "Consejo",
      label_info: "Informaci\xF3n",
      label_warning: "Advertencia",
      label_question: "Pregunta",
      label_error: "Error",
      label_success: "\xC9xito",
      label_caution: "Precauci\xF3n",
      label_alert: "Alerta",
      label_bug: "Error",
      label_fuck: "Maldici\xF3n",
      label_important: "Importante",
      label_shit: "Mierda",
      label_air: "Aire",
      label_select_all: "Seleccionar todo",
      label_select_more: "Seleccionar...",
      label_select: "Seleccionar",
      label_filter: "Filtrar",
      label_collapse: "Colapsar",
      label_attach: "Adjuntar"
    });
  })();

  // ../metroui-lib/source/i18n/de.js
  (() => {
    Metro.i18n.add("de", {
      weekStart: 1,
      january: "Januar",
      february: "Februar",
      march: "M\xE4rz",
      april: "April",
      may: "Mai",
      june: "Juni",
      july: "Juli",
      august: "August",
      september: "September",
      october: "Oktober",
      november: "November",
      december: "Dezember",
      january_short: "Jan",
      february_short: "Feb",
      march_short: "M\xE4r",
      april_short: "Apr",
      may_short: "Mai",
      june_short: "Jun",
      july_short: "Jul",
      august_short: "Aug",
      september_short: "Sep",
      october_short: "Okt",
      november_short: "Nov",
      december_short: "Dez",
      sunday: "Sonntag",
      monday: "Montag",
      tuesday: "Dienstag",
      wednesday: "Mittwoch",
      thursday: "Donnerstag",
      friday: "Freitag",
      saturday: "Samstag",
      sunday_short: "So",
      monday_short: "Mo",
      tuesday_short: "Di",
      wednesday_short: "Mi",
      thursday_short: "Do",
      friday_short: "Fr",
      saturday_short: "Sa",
      sunday_short_2: "S",
      monday_short_2: "M",
      tuesday_short_2: "D",
      wednesday_short_2: "M",
      thursday_short_2: "D",
      friday_short_2: "F",
      saturday_short_2: "S",
      label_ok: "OK",
      label_cancel: "Abbrechen",
      label_done: "Fertig",
      label_today: "Heute",
      label_now: "Jetzt",
      label_clear: "L\xF6schen",
      label_help: "Hilfe",
      label_yes: "Ja",
      label_no: "Nein",
      label_random: "Zuf\xE4llig",
      label_save: "Speichern",
      label_reset: "Zur\xFCcksetzen",
      label_submit: "Absenden",
      label_add_user_color: "Zu den Farben hinzuf\xFCgen",
      label_send: "Senden",
      label_accept: "Akzeptieren",
      label_cookies_title: "Diese Seite verwendet Cookies",
      label_cookies_text: "Diese Website verwendet Cookies, um sicherzustellen, dass Sie die beste Erfahrung auf unserer Website machen.",
      label_choose_file: "Datei(en) ausw\xE4hlen",
      label_drop_file: "Klicken oder Datei(en) hier ablegen",
      label_files_selected: "{n} Datei(en) ausgew\xE4hlt",
      label_days: "Tage",
      label_hours: "Stunden",
      label_minutes: "Min",
      label_seconds: "Sek",
      label_month: "Monat",
      label_months: "Monate",
      label_day: "Tag",
      label_year: "Jahr",
      label_years: "Jahre",
      label_rows_count: "Anzeigen:",
      label_search: "Suchen:",
      label_table_info: "Zeige $1 bis $2 von $3 Eintr\xE4gen",
      label_prev: "Zur\xFCck",
      label_next: "Weiter",
      label_all: "Alle",
      label_inspector: "Inspektor",
      label_goto_page: "Gehe zu",
      label_enter_page: "Seite eingeben...",
      label_empty: "Nichts zu zeigen",
      label_user_colors: "Benutzerfarben",
      label_tiles: "Kacheln",
      label_list: "Liste",
      label_load_more: "Mehr laden",
      label_buy: "Kaufen",
      label_buy_now: "Jetzt kaufen",
      label_buy_today: "Heute kaufen",
      label_download: "Herunterladen",
      label_search_results: "Suchergebnisse",
      label_add: "Hinzuf\xFCgen",
      label_edit: "Bearbeiten",
      label_delete: "L\xF6schen",
      label_new: "Neu",
      label_sell: "Verkaufen",
      label_details: "Details",
      label_sorting: "Sortierung",
      label_finish: "Beenden",
      label_play: "Abspielen",
      label_pause: "Pause",
      label_stop: "Stopp",
      label_mute: "Stummschalten",
      label_loop: "Wiederholen",
      label_on: "an",
      label_off: "aus",
      label_rename_tab: "Tab umbenennen",
      label_close_tab: "Tab schlie\xDFen",
      label_close_other_tabs: "Andere Tabs schlie\xDFen",
      label_close_tabs_left: "Tabs links schlie\xDFen",
      label_close_tabs_right: "Tabs rechts schlie\xDFen",
      label_close_all_tabs: "Alle Tabs schlie\xDFen",
      label_close_inactive_tabs: "Inaktive Tabs schlie\xDFen",
      label_clear_input: "Eingabe l\xF6schen",
      label_reveal_password: "Passwort anzeigen",
      label_hide_password: "Passwort verbergen",
      label_generate_random: "Zuf\xE4lligen Wert generieren",
      label_search_input: "Nach eingegebenem Wert suchen",
      label_note: "Notiz",
      label_tip: "Tipp",
      label_info: "Info",
      label_warning: "Warnung",
      label_question: "Frage",
      label_error: "Fehler",
      label_success: "Erfolg",
      label_caution: "Vorsicht",
      label_alert: "Alarm",
      label_bug: "Fehler",
      label_fuck: "Mist",
      label_important: "Wichtig",
      label_shit: "Schei\xDFe",
      label_air: "Luft",
      label_select_all: "Alles ausw\xE4hlen",
      label_select_more: "Mehr ausw\xE4hlen...",
      label_select: "Ausw\xE4hlen",
      label_filter: "Filter",
      label_collapse: "Einklappen",
      label_attach: "Befestigen"
    });
  })();

  // ../metroui-lib/source/i18n/fr.js
  (() => {
    Metro.i18n.add("fr", {
      weekStart: 1,
      january: "Janvier",
      february: "F\xE9vrier",
      march: "Mars",
      april: "Avril",
      may: "Mai",
      june: "Juin",
      july: "Juillet",
      august: "Ao\xFBt",
      september: "Septembre",
      october: "Octobre",
      november: "Novembre",
      december: "D\xE9cembre",
      january_short: "Jan",
      february_short: "F\xE9v",
      march_short: "Mar",
      april_short: "Avr",
      may_short: "Mai",
      june_short: "Juin",
      july_short: "Juil",
      august_short: "Ao\xFB",
      september_short: "Sep",
      october_short: "Oct",
      november_short: "Nov",
      december_short: "D\xE9c",
      sunday: "Dimanche",
      monday: "Lundi",
      tuesday: "Mardi",
      wednesday: "Mercredi",
      thursday: "Jeudi",
      friday: "Vendredi",
      saturday: "Samedi",
      sunday_short: "Dim",
      monday_short: "Lun",
      tuesday_short: "Mar",
      wednesday_short: "Mer",
      thursday_short: "Jeu",
      friday_short: "Ven",
      saturday_short: "Sam",
      sunday_short_2: "D",
      monday_short_2: "L",
      tuesday_short_2: "M",
      wednesday_short_2: "M",
      thursday_short_2: "J",
      friday_short_2: "V",
      saturday_short_2: "S",
      label_ok: "OK",
      label_cancel: "Annuler",
      label_done: "Termin\xE9",
      label_today: "Aujourd'hui",
      label_now: "Maintenant",
      label_clear: "Effacer",
      label_help: "Aide",
      label_yes: "Oui",
      label_no: "Non",
      label_random: "Al\xE9atoire",
      label_save: "Enregistrer",
      label_reset: "R\xE9initialiser",
      label_submit: "Soumettre",
      label_add_user_color: "Ajouter aux couleurs",
      label_send: "Envoyer",
      label_accept: "Accepter",
      label_cookies_title: "Ce site utilise des cookies",
      label_cookies_text: "Ce site utilise des cookies pour vous garantir la meilleure exp\xE9rience sur notre site.",
      label_choose_file: "Choisir le(s) fichier(s)",
      label_drop_file: "Cliquez ou d\xE9posez le(s) fichier(s) ici",
      label_files_selected: "{n} fichier(s) s\xE9lectionn\xE9(s)",
      label_days: "jours",
      label_hours: "heures",
      label_minutes: "min",
      label_seconds: "sec",
      label_month: "mois",
      label_months: "mois",
      label_day: "jour",
      label_year: "ann\xE9e",
      label_years: "ann\xE9es",
      label_rows_count: "Afficher :",
      label_search: "Rechercher :",
      label_table_info: "Affichage de $1 \xE0 $2 sur $3 entr\xE9es",
      label_prev: "Pr\xE9c",
      label_next: "Suiv",
      label_all: "Tout",
      label_inspector: "Inspecteur",
      label_goto_page: "Aller \xE0",
      label_enter_page: "Entrer la page...",
      label_empty: "Rien \xE0 afficher",
      label_user_colors: "Couleurs utilisateur",
      label_tiles: "Tuiles",
      label_list: "Liste",
      label_load_more: "Charger plus",
      label_buy: "Acheter",
      label_buy_now: "Acheter maintenant",
      label_buy_today: "Acheter aujourd'hui",
      label_download: "T\xE9l\xE9charger",
      label_search_results: "R\xE9sultats de recherche",
      label_add: "Ajouter",
      label_edit: "Modifier",
      label_delete: "Supprimer",
      label_new: "Nouveau",
      label_sell: "Vendre",
      label_details: "D\xE9tails",
      label_sorting: "Tri",
      label_finish: "Terminer",
      label_play: "Lire",
      label_pause: "Pause",
      label_stop: "Arr\xEAter",
      label_mute: "Muet",
      label_loop: "Boucle",
      label_on: "act",
      label_off: "d\xE9s",
      label_rename_tab: "Renommer l'onglet",
      label_close_tab: "Fermer l'onglet",
      label_close_other_tabs: "Fermer les autres onglets",
      label_close_tabs_left: "Fermer les onglets \xE0 gauche",
      label_close_tabs_right: "Fermer les onglets \xE0 droite",
      label_close_all_tabs: "Fermer tous les onglets",
      label_close_inactive_tabs: "Fermer les onglets inactifs",
      label_clear_input: "Effacer l'entr\xE9e",
      label_reveal_password: "Afficher le mot de passe",
      label_hide_password: "Masquer le mot de passe",
      label_generate_random: "G\xE9n\xE9rer une valeur al\xE9atoire",
      label_search_input: "Rechercher la valeur saisie",
      label_note: "Note",
      label_tip: "Astuce",
      label_info: "Info",
      label_warning: "Avertissement",
      label_question: "Question",
      label_error: "Erreur",
      label_success: "Succ\xE8s",
      label_caution: "Prudence",
      label_alert: "Alerte",
      label_bug: "Bug",
      label_fuck: "Merde",
      label_important: "Important",
      label_shit: "Fichu",
      label_air: "Air",
      label_select_all: "Tout s\xE9lectionner",
      label_select_more: "S\xE9lectionner...",
      label_select: "S\xE9lectionner",
      label_filter: "Filtrer",
      label_collapse: "R\xE9duire",
      label_attach: "Attacher"
    });
  })();

  // ../metroui-lib/source/i18n/it.js
  (() => {
    Metro.i18n.add("it", {
      weekStart: 1,
      january: "Gennaio",
      february: "Febbraio",
      march: "Marzo",
      april: "Aprile",
      may: "Maggio",
      june: "Giugno",
      july: "Luglio",
      august: "Agosto",
      september: "Settembre",
      october: "Ottobre",
      november: "Novembre",
      december: "Dicembre",
      january_short: "Gen",
      february_short: "Feb",
      march_short: "Mar",
      april_short: "Apr",
      may_short: "Mag",
      june_short: "Giu",
      july_short: "Lug",
      august_short: "Ago",
      september_short: "Set",
      october_short: "Ott",
      november_short: "Nov",
      december_short: "Dic",
      sunday: "Domenica",
      monday: "Luned\xEC",
      tuesday: "Marted\xEC",
      wednesday: "Mercoled\xEC",
      thursday: "Gioved\xEC",
      friday: "Venerd\xEC",
      saturday: "Sabato",
      sunday_short: "Dom",
      monday_short: "Lun",
      tuesday_short: "Mar",
      wednesday_short: "Mer",
      thursday_short: "Gio",
      friday_short: "Ven",
      saturday_short: "Sab",
      sunday_short_2: "D",
      monday_short_2: "L",
      tuesday_short_2: "M",
      wednesday_short_2: "M",
      thursday_short_2: "G",
      friday_short_2: "V",
      saturday_short_2: "S",
      label_ok: "OK",
      label_cancel: "Annulla",
      label_done: "Fatto",
      label_today: "Oggi",
      label_now: "Adesso",
      label_clear: "Cancella",
      label_help: "Aiuto",
      label_yes: "S\xEC",
      label_no: "No",
      label_random: "Casuale",
      label_save: "Salva",
      label_reset: "Reimposta",
      label_submit: "Invia",
      label_add_user_color: "Aggiungi ai colori",
      label_send: "Invia",
      label_accept: "Accetta",
      label_cookies_title: "Questo sito utilizza i cookie",
      label_cookies_text: "Questo sito utilizza i cookie per garantire la migliore esperienza sul nostro sito.",
      label_choose_file: "Scegli file",
      label_drop_file: "Clicca o trascina qui il file",
      label_files_selected: "{n} file selezionati",
      label_days: "giorni",
      label_hours: "ore",
      label_minutes: "min",
      label_seconds: "sec",
      label_month: "mese",
      label_months: "mesi",
      label_day: "giorno",
      label_year: "anno",
      label_years: "anni",
      label_rows_count: "Mostra:",
      label_search: "Cerca:",
      label_table_info: "Mostra da $1 a $2 di $3 elementi",
      label_prev: "Prec",
      label_next: "Succ",
      label_all: "Tutti",
      label_inspector: "Ispettore",
      label_goto_page: "Vai a",
      label_enter_page: "Inserisci pagina...",
      label_empty: "Niente da mostrare",
      label_user_colors: "Colori utente",
      label_tiles: "Piastrelle",
      label_list: "Lista",
      label_load_more: "Carica altro",
      label_buy: "Compra",
      label_buy_now: "Compra ora",
      label_buy_today: "Compra oggi",
      label_download: "Scarica",
      label_search_results: "Risultati di ricerca",
      label_add: "Aggiungi",
      label_edit: "Modifica",
      label_delete: "Elimina",
      label_new: "Nuovo",
      label_sell: "Vendi",
      label_details: "Dettagli",
      label_sorting: "Ordinamento",
      label_finish: "Termina",
      label_play: "Riproduci",
      label_pause: "Pausa",
      label_stop: "Arresta",
      label_mute: "Silenzia",
      label_loop: "Ripeti",
      label_on: "acc",
      label_off: "spe",
      label_rename_tab: "Rinomina scheda",
      label_close_tab: "Chiudi scheda",
      label_close_other_tabs: "Chiudi altre schede",
      label_close_tabs_left: "Chiudi schede a sinistra",
      label_close_tabs_right: "Chiudi schede a destra",
      label_close_all_tabs: "Chiudi tutte le schede",
      label_close_inactive_tabs: "Chiudi schede inattive",
      label_clear_input: "Cancella input",
      label_reveal_password: "Mostra password",
      label_hide_password: "Nascondi password",
      label_generate_random: "Genera valore casuale",
      label_search_input: "Cerca il valore inserito",
      label_note: "Nota",
      label_tip: "Suggerimento",
      label_info: "Info",
      label_warning: "Avviso",
      label_question: "Domanda",
      label_error: "Errore",
      label_success: "Successo",
      label_caution: "Attenzione",
      label_alert: "Allarme",
      label_bug: "Bug",
      label_fuck: "Cavolo",
      label_important: "Importante",
      label_shit: "Accidenti",
      label_air: "Aria",
      label_select_all: "Seleziona tutto",
      label_select_more: "Seleziona...",
      label_select: "Seleziona",
      label_filter: "Filtro",
      label_collapse: "Riduci",
      label_attach: "Allegare"
    });
  })();

  // ../metroui-lib/source/i18n/zh-CN.js
  (() => {
    Metro.i18n.add("zh-CN", {
      weekStart: 0,
      january: "\u4E00\u6708",
      february: "\u4E8C\u6708",
      march: "\u4E09\u6708",
      april: "\u56DB\u6708",
      may: "\u4E94\u6708",
      june: "\u516D\u6708",
      july: "\u4E03\u6708",
      august: "\u516B\u6708",
      september: "\u4E5D\u6708",
      october: "\u5341\u6708",
      november: "\u5341\u4E00\u6708",
      december: "\u5341\u4E8C\u6708",
      january_short: "1\u6708",
      february_short: "2\u6708",
      march_short: "3\u6708",
      april_short: "4\u6708",
      may_short: "5\u6708",
      june_short: "6\u6708",
      july_short: "7\u6708",
      august_short: "8\u6708",
      september_short: "9\u6708",
      october_short: "10\u6708",
      november_short: "11\u6708",
      december_short: "12\u6708",
      sunday: "\u661F\u671F\u65E5",
      monday: "\u661F\u671F\u4E00",
      tuesday: "\u661F\u671F\u4E8C",
      wednesday: "\u661F\u671F\u4E09",
      thursday: "\u661F\u671F\u56DB",
      friday: "\u661F\u671F\u4E94",
      saturday: "\u661F\u671F\u516D",
      sunday_short: "\u5468\u65E5",
      monday_short: "\u5468\u4E00",
      tuesday_short: "\u5468\u4E8C",
      wednesday_short: "\u5468\u4E09",
      thursday_short: "\u5468\u56DB",
      friday_short: "\u5468\u4E94",
      saturday_short: "\u5468\u516D",
      sunday_short_2: "\u65E5",
      monday_short_2: "\u4E00",
      tuesday_short_2: "\u4E8C",
      wednesday_short_2: "\u4E09",
      thursday_short_2: "\u56DB",
      friday_short_2: "\u4E94",
      saturday_short_2: "\u516D",
      label_ok: "\u786E\u5B9A",
      label_cancel: "\u53D6\u6D88",
      label_done: "\u5B8C\u6210",
      label_today: "\u4ECA\u5929",
      label_now: "\u73B0\u5728",
      label_clear: "\u6E05\u9664",
      label_help: "\u5E2E\u52A9",
      label_yes: "\u662F",
      label_no: "\u5426",
      label_random: "\u968F\u673A",
      label_save: "\u4FDD\u5B58",
      label_reset: "\u91CD\u7F6E",
      label_submit: "\u63D0\u4EA4",
      label_add_user_color: "\u6DFB\u52A0\u5230\u8272\u677F",
      label_send: "\u53D1\u9001",
      label_accept: "\u63A5\u53D7",
      label_cookies_title: "\u672C\u7AD9\u4F7F\u7528cookies",
      label_cookies_text: "\u672C\u7F51\u7AD9\u4F7F\u7528cookies\u4EE5\u786E\u4FDD\u60A8\u5728\u6211\u4EEC\u7684\u7F51\u7AD9\u4E0A\u83B7\u5F97\u6700\u4F73\u4F53\u9A8C\u3002",
      label_choose_file: "\u9009\u62E9\u6587\u4EF6",
      label_drop_file: "\u70B9\u51FB\u6216\u62D6\u653E\u6587\u4EF6\u5230\u8FD9\u91CC",
      label_files_selected: "\u5DF2\u9009\u62E9 {n} \u4E2A\u6587\u4EF6",
      label_days: "\u5929",
      label_hours: "\u5C0F\u65F6",
      label_minutes: "\u5206\u949F",
      label_seconds: "\u79D2",
      label_month: "\u6708",
      label_months: "\u6708",
      label_day: "\u65E5",
      label_year: "\u5E74",
      label_years: "\u5E74",
      label_rows_count: "\u663E\u793A\uFF1A",
      label_search: "\u641C\u7D22\uFF1A",
      label_table_info: "\u663E\u793A\u7B2C $1 \u5230 $2 \u9879\uFF0C\u5171 $3 \u9879",
      label_prev: "\u4E0A\u4E00\u9875",
      label_next: "\u4E0B\u4E00\u9875",
      label_all: "\u5168\u90E8",
      label_inspector: "\u68C0\u67E5\u5668",
      label_goto_page: "\u524D\u5F80",
      label_enter_page: "\u8F93\u5165\u9875\u7801...",
      label_empty: "\u6CA1\u6709\u5185\u5BB9\u53EF\u663E\u793A",
      label_user_colors: "\u7528\u6237\u989C\u8272",
      label_tiles: "\u78C1\u8D34",
      label_list: "\u5217\u8868",
      label_load_more: "\u52A0\u8F7D\u66F4\u591A",
      label_buy: "\u8D2D\u4E70",
      label_buy_now: "\u7ACB\u5373\u8D2D\u4E70",
      label_buy_today: "\u4ECA\u65E5\u8D2D\u4E70",
      label_download: "\u4E0B\u8F7D",
      label_search_results: "\u641C\u7D22\u7ED3\u679C",
      label_add: "\u6DFB\u52A0",
      label_edit: "\u7F16\u8F91",
      label_delete: "\u5220\u9664",
      label_new: "\u65B0\u5EFA",
      label_sell: "\u51FA\u552E",
      label_details: "\u8BE6\u60C5",
      label_sorting: "\u6392\u5E8F",
      label_finish: "\u5B8C\u6210",
      label_play: "\u64AD\u653E",
      label_pause: "\u6682\u505C",
      label_stop: "\u505C\u6B62",
      label_mute: "\u9759\u97F3",
      label_loop: "\u5FAA\u73AF",
      label_on: "\u5F00",
      label_off: "\u5173",
      label_rename_tab: "\u91CD\u547D\u540D\u6807\u7B7E",
      label_close_tab: "\u5173\u95ED\u6807\u7B7E",
      label_close_other_tabs: "\u5173\u95ED\u5176\u4ED6\u6807\u7B7E",
      label_close_tabs_left: "\u5173\u95ED\u5DE6\u4FA7\u6807\u7B7E",
      label_close_tabs_right: "\u5173\u95ED\u53F3\u4FA7\u6807\u7B7E",
      label_close_all_tabs: "\u5173\u95ED\u6240\u6709\u6807\u7B7E",
      label_close_inactive_tabs: "\u5173\u95ED\u975E\u6D3B\u52A8\u6807\u7B7E",
      label_clear_input: "\u6E05\u9664\u8F93\u5165",
      label_reveal_password: "\u663E\u793A\u5BC6\u7801",
      label_hide_password: "\u9690\u85CF\u5BC6\u7801",
      label_generate_random: "\u751F\u6210\u968F\u673A\u503C",
      label_search_input: "\u641C\u7D22\u8F93\u5165\u7684\u503C",
      label_note: "\u5907\u6CE8",
      label_tip: "\u63D0\u793A",
      label_info: "\u4FE1\u606F",
      label_warning: "\u8B66\u544A",
      label_question: "\u95EE\u9898",
      label_error: "\u9519\u8BEF",
      label_success: "\u6210\u529F",
      label_caution: "\u6CE8\u610F",
      label_alert: "\u8B66\u62A5",
      label_bug: "\u9519\u8BEF",
      label_fuck: "\u7CDF\u7CD5",
      label_important: "\u91CD\u8981",
      label_shit: "\u7CDF\u7CD5",
      label_air: "\u7A7A\u6C14",
      label_select_all: "\u5168\u9009",
      label_select_more: "\u9009\u62E9...",
      label_select: "\u9009\u62E9",
      label_filter: "\u7B5B\u9009",
      label_collapse: "\u6298\u53E0",
      label_attach: "\u9644\u52A0"
    });
  })();

  // ../metroui-lib/source/i18n/zh-TW.js
  (() => {
    Metro.i18n.add("zh-TW", {
      weekStart: 0,
      january: "\u4E00\u6708",
      february: "\u4E8C\u6708",
      march: "\u4E09\u6708",
      april: "\u56DB\u6708",
      may: "\u4E94\u6708",
      june: "\u516D\u6708",
      july: "\u4E03\u6708",
      august: "\u516B\u6708",
      september: "\u4E5D\u6708",
      october: "\u5341\u6708",
      november: "\u5341\u4E00\u6708",
      december: "\u5341\u4E8C\u6708",
      january_short: "1\u6708",
      february_short: "2\u6708",
      march_short: "3\u6708",
      april_short: "4\u6708",
      may_short: "5\u6708",
      june_short: "6\u6708",
      july_short: "7\u6708",
      august_short: "8\u6708",
      september_short: "9\u6708",
      october_short: "10\u6708",
      november_short: "11\u6708",
      december_short: "12\u6708",
      sunday: "\u661F\u671F\u65E5",
      monday: "\u661F\u671F\u4E00",
      tuesday: "\u661F\u671F\u4E8C",
      wednesday: "\u661F\u671F\u4E09",
      thursday: "\u661F\u671F\u56DB",
      friday: "\u661F\u671F\u4E94",
      saturday: "\u661F\u671F\u516D",
      sunday_short: "\u9031\u65E5",
      monday_short: "\u9031\u4E00",
      tuesday_short: "\u9031\u4E8C",
      wednesday_short: "\u9031\u4E09",
      thursday_short: "\u9031\u56DB",
      friday_short: "\u9031\u4E94",
      saturday_short: "\u9031\u516D",
      sunday_short_2: "\u65E5",
      monday_short_2: "\u4E00",
      tuesday_short_2: "\u4E8C",
      wednesday_short_2: "\u4E09",
      thursday_short_2: "\u56DB",
      friday_short_2: "\u4E94",
      saturday_short_2: "\u516D",
      label_ok: "\u78BA\u5B9A",
      label_cancel: "\u53D6\u6D88",
      label_done: "\u5B8C\u6210",
      label_today: "\u4ECA\u5929",
      label_now: "\u73FE\u5728",
      label_clear: "\u6E05\u9664",
      label_help: "\u8AAA\u660E",
      label_yes: "\u662F",
      label_no: "\u5426",
      label_random: "\u96A8\u6A5F",
      label_save: "\u5132\u5B58",
      label_reset: "\u91CD\u8A2D",
      label_submit: "\u63D0\u4EA4",
      label_add_user_color: "\u52A0\u5165\u8272\u7968",
      label_send: "\u50B3\u9001",
      label_accept: "\u63A5\u53D7",
      label_cookies_title: "\u6B64\u7DB2\u7AD9\u4F7F\u7528Cookie",
      label_cookies_text: "\u672C\u7DB2\u7AD9\u4F7F\u7528Cookie\uFF0C\u4EE5\u78BA\u4FDD\u60A8\u5728\u6211\u5011\u7DB2\u7AD9\u4E0A\u7372\u5F97\u6700\u4F73\u9AD4\u9A57\u3002",
      label_choose_file: "\u9078\u64C7\u6A94\u6848",
      label_drop_file: "\u9EDE\u64CA\u6216\u62D6\u653E\u6A94\u6848\u81F3\u6B64",
      label_files_selected: "\u5DF2\u9078\u64C7 {n} \u500B\u6A94\u6848",
      label_days: "\u5929",
      label_hours: "\u5C0F\u6642",
      label_minutes: "\u5206\u9418",
      label_seconds: "\u79D2",
      label_month: "\u6708",
      label_months: "\u6708",
      label_day: "\u65E5",
      label_year: "\u5E74",
      label_years: "\u5E74",
      label_rows_count: "\u986F\u793A\uFF1A",
      label_search: "\u641C\u5C0B\uFF1A",
      label_table_info: "\u986F\u793A\u7B2C $1 \u5230 $2 \u9805\uFF0C\u5171 $3 \u9805",
      label_prev: "\u4E0A\u4E00\u9801",
      label_next: "\u4E0B\u4E00\u9801",
      label_all: "\u5168\u90E8",
      label_inspector: "\u6AA2\u67E5\u5668",
      label_goto_page: "\u524D\u5F80",
      label_enter_page: "\u8F38\u5165\u9801\u78BC...",
      label_empty: "\u6C92\u6709\u8CC7\u6599\u53EF\u986F\u793A",
      label_user_colors: "\u4F7F\u7528\u8005\u984F\u8272",
      label_tiles: "\u78DA\u584A",
      label_list: "\u6E05\u55AE",
      label_load_more: "\u8F09\u5165\u66F4\u591A",
      label_buy: "\u8CFC\u8CB7",
      label_buy_now: "\u7ACB\u5373\u8CFC\u8CB7",
      label_buy_today: "\u4ECA\u65E5\u8CFC\u8CB7",
      label_download: "\u4E0B\u8F09",
      label_search_results: "\u641C\u5C0B\u7D50\u679C",
      label_add: "\u65B0\u589E",
      label_edit: "\u7DE8\u8F2F",
      label_delete: "\u522A\u9664",
      label_new: "\u65B0\u5EFA",
      label_sell: "\u51FA\u552E",
      label_details: "\u8A73\u7D30\u8CC7\u6599",
      label_sorting: "\u6392\u5E8F",
      label_finish: "\u5B8C\u6210",
      label_play: "\u64AD\u653E",
      label_pause: "\u66AB\u505C",
      label_stop: "\u505C\u6B62",
      label_mute: "\u975C\u97F3",
      label_loop: "\u5FAA\u74B0",
      label_on: "\u958B\u555F",
      label_off: "\u95DC\u9589",
      label_rename_tab: "\u91CD\u65B0\u547D\u540D\u5206\u9801",
      label_close_tab: "\u95DC\u9589\u5206\u9801",
      label_close_other_tabs: "\u95DC\u9589\u5176\u4ED6\u5206\u9801",
      label_close_tabs_left: "\u95DC\u9589\u5DE6\u5074\u5206\u9801",
      label_close_tabs_right: "\u95DC\u9589\u53F3\u5074\u5206\u9801",
      label_close_all_tabs: "\u95DC\u9589\u6240\u6709\u5206\u9801",
      label_close_inactive_tabs: "\u95DC\u9589\u975E\u6D3B\u52D5\u5206\u9801",
      label_clear_input: "\u6E05\u9664\u8F38\u5165",
      label_reveal_password: "\u986F\u793A\u5BC6\u78BC",
      label_hide_password: "\u96B1\u85CF\u5BC6\u78BC",
      label_generate_random: "\u7522\u751F\u96A8\u6A5F\u503C",
      label_search_input: "\u641C\u5C0B\u8F38\u5165\u7684\u503C",
      label_note: "\u5099\u8A3B",
      label_tip: "\u63D0\u793A",
      label_info: "\u8CC7\u8A0A",
      label_warning: "\u8B66\u544A",
      label_question: "\u554F\u984C",
      label_error: "\u932F\u8AA4",
      label_success: "\u6210\u529F",
      label_caution: "\u6CE8\u610F",
      label_alert: "\u8B66\u793A",
      label_bug: "\u932F\u8AA4",
      label_fuck: "\u8A72\u6B7B",
      label_important: "\u91CD\u8981",
      label_shit: "\u7CDF\u7CD5",
      label_air: "\u7A7A\u6C23",
      label_select_all: "\u5168\u9078",
      label_select_more: "\u9078\u64C7...",
      label_select: "\u9078\u64C7",
      label_filter: "\u7BE9\u9078",
      label_collapse: "\u6536\u5408",
      label_attach: "\u9644\u52A0"
    });
  })();

  // ../metroui-lib/source/i18n/hi.js
  (() => {
    Metro.i18n.add("hi", {
      weekStart: 0,
      january: "\u091C\u0928\u0935\u0930\u0940",
      february: "\u092B\u0930\u0935\u0930\u0940",
      march: "\u092E\u093E\u0930\u094D\u091A",
      april: "\u0905\u092A\u094D\u0930\u0948\u0932",
      may: "\u092E\u0908",
      june: "\u091C\u0942\u0928",
      july: "\u091C\u0941\u0932\u093E\u0908",
      august: "\u0905\u0917\u0938\u094D\u0924",
      september: "\u0938\u093F\u0924\u0902\u092C\u0930",
      october: "\u0905\u0915\u094D\u091F\u0942\u092C\u0930",
      november: "\u0928\u0935\u0902\u092C\u0930",
      december: "\u0926\u093F\u0938\u0902\u092C\u0930",
      january_short: "\u091C\u0928",
      february_short: "\u092B\u0930",
      march_short: "\u092E\u093E\u0930\u094D\u091A",
      april_short: "\u0905\u092A\u094D\u0930\u0948",
      may_short: "\u092E\u0908",
      june_short: "\u091C\u0942\u0928",
      july_short: "\u091C\u0941\u0932",
      august_short: "\u0905\u0917",
      september_short: "\u0938\u093F\u0924",
      october_short: "\u0905\u0915\u094D\u091F\u0942",
      november_short: "\u0928\u0935",
      december_short: "\u0926\u093F\u0938",
      sunday: "\u0930\u0935\u093F\u0935\u093E\u0930",
      monday: "\u0938\u094B\u092E\u0935\u093E\u0930",
      tuesday: "\u092E\u0902\u0917\u0932\u0935\u093E\u0930",
      wednesday: "\u092C\u0941\u0927\u0935\u093E\u0930",
      thursday: "\u0917\u0941\u0930\u0941\u0935\u093E\u0930",
      friday: "\u0936\u0941\u0915\u094D\u0930\u0935\u093E\u0930",
      saturday: "\u0936\u0928\u093F\u0935\u093E\u0930",
      sunday_short: "\u0930\u0935\u093F",
      monday_short: "\u0938\u094B\u092E",
      tuesday_short: "\u092E\u0902\u0917\u0932",
      wednesday_short: "\u092C\u0941\u0927",
      thursday_short: "\u0917\u0941\u0930\u0941",
      friday_short: "\u0936\u0941\u0915\u094D\u0930",
      saturday_short: "\u0936\u0928\u093F",
      sunday_short_2: "\u0930",
      monday_short_2: "\u0938\u094B",
      tuesday_short_2: "\u092E\u0902",
      wednesday_short_2: "\u092C\u0941",
      thursday_short_2: "\u0917\u0941",
      friday_short_2: "\u0936\u0941",
      saturday_short_2: "\u0936",
      label_ok: "\u0920\u0940\u0915 \u0939\u0948",
      label_cancel: "\u0930\u0926\u094D\u0926 \u0915\u0930\u0947\u0902",
      label_done: "\u0938\u092E\u093E\u092A\u094D\u0924",
      label_today: "\u0906\u091C",
      label_now: "\u0905\u092D\u0940",
      label_clear: "\u0938\u093E\u092B \u0915\u0930\u0947\u0902",
      label_help: "\u092E\u0926\u0926",
      label_yes: "\u0939\u093E\u0901",
      label_no: "\u0928\u0939\u0940\u0902",
      label_random: "\u092F\u093E\u0926\u0943\u091A\u094D\u091B\u093F\u0915",
      label_save: "\u0938\u0939\u0947\u091C\u0947\u0902",
      label_reset: "\u0930\u0940\u0938\u0947\u091F \u0915\u0930\u0947\u0902",
      label_submit: "\u091C\u092E\u093E \u0915\u0930\u0947\u0902",
      label_add_user_color: "\u0930\u0902\u0917\u094B\u0902 \u092E\u0947\u0902 \u091C\u094B\u0921\u093C\u0947\u0902",
      label_send: "\u092D\u0947\u091C\u0947\u0902",
      label_accept: "\u0938\u094D\u0935\u0940\u0915\u093E\u0930 \u0915\u0930\u0947\u0902",
      label_cookies_title: "\u092F\u0939 \u0938\u093E\u0907\u091F \u0915\u0941\u0915\u0940\u091C\u093C \u0915\u093E \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0924\u0940 \u0939\u0948",
      label_cookies_text: "\u092F\u0939 \u0935\u0947\u092C\u0938\u093E\u0907\u091F \u092F\u0939 \u0938\u0941\u0928\u093F\u0936\u094D\u091A\u093F\u0924 \u0915\u0930\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u0915\u0941\u0915\u0940\u091C\u093C \u0915\u093E \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0924\u0940 \u0939\u0948 \u0915\u093F \u0906\u092A\u0915\u094B \u0939\u092E\u093E\u0930\u0940 \u0935\u0947\u092C\u0938\u093E\u0907\u091F \u092A\u0930 \u0938\u092C\u0938\u0947 \u0905\u091A\u094D\u091B\u093E \u0905\u0928\u0941\u092D\u0935 \u092E\u093F\u0932\u0947\u0964",
      label_choose_file: "\u092B\u093C\u093E\u0907\u0932\u0947\u0902 \u091A\u0941\u0928\u0947\u0902",
      label_drop_file: "\u092F\u0939\u093E\u0902 \u0915\u094D\u0932\u093F\u0915 \u0915\u0930\u0947\u0902 \u092F\u093E \u092B\u093C\u093E\u0907\u0932\u0947\u0902 \u091B\u094B\u0921\u093C\u0947\u0902",
      label_files_selected: "{n} \u092B\u093C\u093E\u0907\u0932\u0947\u0902 \u091A\u0941\u0928\u0940 \u0917\u0908\u0902",
      label_days: "\u0926\u093F\u0928",
      label_hours: "\u0918\u0902\u091F\u0947",
      label_minutes: "\u092E\u093F\u0928\u091F",
      label_seconds: "\u0938\u0947\u0915\u0902\u0921",
      label_month: "\u092E\u0939\u0940\u0928\u093E",
      label_months: "\u092E\u0939\u0940\u0928\u0947",
      label_day: "\u0926\u093F\u0928",
      label_year: "\u0938\u093E\u0932",
      label_years: "\u0938\u093E\u0932",
      label_rows_count: "\u0926\u093F\u0916\u093E\u090F\u0902:",
      label_search: "\u0916\u094B\u091C\u0947\u0902:",
      label_table_info: "$1 \u0938\u0947 $2 \u0924\u0915 $3 \u092A\u094D\u0930\u0935\u093F\u0937\u094D\u091F\u093F\u092F\u093E\u0902 \u0926\u093F\u0916\u093E \u0930\u0939\u093E \u0939\u0948",
      label_prev: "\u092A\u093F\u091B\u0932\u093E",
      label_next: "\u0905\u0917\u0932\u093E",
      label_all: "\u0938\u092D\u0940",
      label_inspector: "\u0928\u093F\u0930\u0940\u0915\u094D\u0937\u0915",
      label_goto_page: "\u092A\u0943\u0937\u094D\u0920 \u092A\u0930 \u091C\u093E\u090F\u0902",
      label_enter_page: "\u092A\u0943\u0937\u094D\u0920 \u0926\u0930\u094D\u091C \u0915\u0930\u0947\u0902...",
      label_empty: "\u0926\u093F\u0916\u093E\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F \u0915\u0941\u091B \u0928\u0939\u0940\u0902",
      label_user_colors: "\u0909\u092A\u092F\u094B\u0917\u0915\u0930\u094D\u0924\u093E \u0930\u0902\u0917",
      label_tiles: "\u091F\u093E\u0907\u0932\u094D\u0938",
      label_list: "\u0938\u0942\u091A\u0940",
      label_load_more: "\u0914\u0930 \u0932\u094B\u0921 \u0915\u0930\u0947\u0902",
      label_buy: "\u0916\u0930\u0940\u0926\u0947\u0902",
      label_buy_now: "\u0905\u092D\u0940 \u0916\u0930\u0940\u0926\u0947\u0902",
      label_buy_today: "\u0906\u091C \u0916\u0930\u0940\u0926\u0947\u0902",
      label_download: "\u0921\u093E\u0909\u0928\u0932\u094B\u0921 \u0915\u0930\u0947\u0902",
      label_search_results: "\u0916\u094B\u091C \u092A\u0930\u093F\u0923\u093E\u092E",
      label_add: "\u091C\u094B\u0921\u093C\u0947\u0902",
      label_edit: "\u0938\u0902\u092A\u093E\u0926\u093F\u0924 \u0915\u0930\u0947\u0902",
      label_delete: "\u0939\u091F\u093E\u090F\u0902",
      label_new: "\u0928\u092F\u093E",
      label_sell: "\u092C\u0947\u091A\u0947\u0902",
      label_details: "\u0935\u093F\u0935\u0930\u0923",
      label_sorting: "\u091B\u0902\u091F\u093E\u0908",
      label_finish: "\u0938\u092E\u093E\u092A\u094D\u0924 \u0915\u0930\u0947\u0902",
      label_play: "\u091A\u0932\u093E\u090F\u0902",
      label_pause: "\u0930\u094B\u0915\u0947\u0902",
      label_stop: "\u092C\u0902\u0926 \u0915\u0930\u0947\u0902",
      label_mute: "\u092E\u094D\u092F\u0942\u091F \u0915\u0930\u0947\u0902",
      label_loop: "\u0926\u094B\u0939\u0930\u093E\u090F\u0902",
      label_on: "\u091A\u093E\u0932\u0942",
      label_off: "\u092C\u0902\u0926",
      label_rename_tab: "\u091F\u0948\u092C \u0915\u093E \u0928\u093E\u092E \u092C\u0926\u0932\u0947\u0902",
      label_close_tab: "\u091F\u0948\u092C \u092C\u0902\u0926 \u0915\u0930\u0947\u0902",
      label_close_other_tabs: "\u0905\u0928\u094D\u092F \u091F\u0948\u092C \u092C\u0902\u0926 \u0915\u0930\u0947\u0902",
      label_close_tabs_left: "\u092C\u093E\u090F\u0902 \u091F\u0948\u092C \u092C\u0902\u0926 \u0915\u0930\u0947\u0902",
      label_close_tabs_right: "\u0926\u093E\u090F\u0902 \u091F\u0948\u092C \u092C\u0902\u0926 \u0915\u0930\u0947\u0902",
      label_close_all_tabs: "\u0938\u092D\u0940 \u091F\u0948\u092C \u092C\u0902\u0926 \u0915\u0930\u0947\u0902",
      label_close_inactive_tabs: "\u0928\u093F\u0937\u094D\u0915\u094D\u0930\u093F\u092F \u091F\u0948\u092C \u092C\u0902\u0926 \u0915\u0930\u0947\u0902",
      label_clear_input: "\u0907\u0928\u092A\u0941\u091F \u0938\u093E\u092B \u0915\u0930\u0947\u0902",
      label_reveal_password: "\u092A\u093E\u0938\u0935\u0930\u094D\u0921 \u0926\u093F\u0916\u093E\u090F\u0902",
      label_hide_password: "\u092A\u093E\u0938\u0935\u0930\u094D\u0921 \u091B\u093F\u092A\u093E\u090F\u0902",
      label_generate_random: "\u092F\u093E\u0926\u0943\u091A\u094D\u091B\u093F\u0915 \u092E\u093E\u0928 \u0909\u0924\u094D\u092A\u0928\u094D\u0928 \u0915\u0930\u0947\u0902",
      label_search_input: "\u0926\u0930\u094D\u091C \u0915\u093F\u090F \u0917\u090F \u092E\u093E\u0928 \u0915\u094B \u0916\u094B\u091C\u0947\u0902",
      label_note: "\u0928\u094B\u091F",
      label_tip: "\u0938\u0941\u091D\u093E\u0935",
      label_info: "\u091C\u093E\u0928\u0915\u093E\u0930\u0940",
      label_warning: "\u091A\u0947\u0924\u093E\u0935\u0928\u0940",
      label_question: "\u092A\u094D\u0930\u0936\u094D\u0928",
      label_error: "\u0924\u094D\u0930\u0941\u091F\u093F",
      label_success: "\u0938\u092B\u0932\u0924\u093E",
      label_caution: "\u0938\u093E\u0935\u0927\u093E\u0928\u0940",
      label_alert: "\u091A\u0947\u0924\u093E\u0935\u0928\u0940",
      label_bug: "\u092C\u0917",
      label_fuck: "\u0927\u0924\u094D\u0924",
      label_important: "\u092E\u0939\u0924\u094D\u0935\u092A\u0942\u0930\u094D\u0923",
      label_shit: "\u092C\u0915\u0935\u093E\u0938",
      label_air: "\u0939\u0935\u093E",
      label_select_all: "\u0938\u092D\u0940 \u0915\u093E \u091A\u092F\u0928 \u0915\u0930\u0947\u0902",
      label_select_more: "\u091A\u0941\u0928\u0947\u0902...",
      label_select: "\u091A\u0941\u0928\u0947\u0902",
      label_filter: "\u092B\u093C\u093F\u0932\u094D\u091F\u0930",
      label_collapse: "\u0938\u0902\u0915\u0941\u091A\u093F\u0924 \u0915\u0930\u0947\u0902",
      label_attach: "\u0938\u0902\u0932\u0917\u094D\u0928 \u0915\u0930\u0928\u093E"
    });
  })();

  // ../metroui-lib/source/i18n/pl.js
  (() => {
    Metro.i18n.add("pl", {
      weekStart: 1,
      january: "Stycze\u0144",
      february: "Luty",
      march: "Marzec",
      april: "Kwiecie\u0144",
      may: "Maj",
      june: "Czerwiec",
      july: "Lipiec",
      august: "Sierpie\u0144",
      september: "Wrzesie\u0144",
      october: "Pa\u017Adziernik",
      november: "Listopad",
      december: "Grudzie\u0144",
      january_short: "Sty",
      february_short: "Lut",
      march_short: "Mar",
      april_short: "Kwi",
      may_short: "Maj",
      june_short: "Cze",
      july_short: "Lip",
      august_short: "Sie",
      september_short: "Wrz",
      october_short: "Pa\u017A",
      november_short: "Lis",
      december_short: "Gru",
      sunday: "Niedziela",
      monday: "Poniedzia\u0142ek",
      tuesday: "Wtorek",
      wednesday: "\u015Aroda",
      thursday: "Czwartek",
      friday: "Pi\u0105tek",
      saturday: "Sobota",
      sunday_short: "Nd",
      monday_short: "Pn",
      tuesday_short: "Wt",
      wednesday_short: "\u015Ar",
      thursday_short: "Czw",
      friday_short: "Pt",
      saturday_short: "Sob",
      sunday_short_2: "N",
      monday_short_2: "P",
      tuesday_short_2: "W",
      wednesday_short_2: "\u015A",
      thursday_short_2: "C",
      friday_short_2: "P",
      saturday_short_2: "S",
      label_ok: "OK",
      label_cancel: "Anuluj",
      label_done: "Gotowe",
      label_today: "Dzisiaj",
      label_now: "Teraz",
      label_clear: "Wyczy\u015B\u0107",
      label_help: "Pomoc",
      label_yes: "Tak",
      label_no: "Nie",
      label_random: "Losowy",
      label_save: "Zapisz",
      label_reset: "Resetuj",
      label_submit: "Wy\u015Blij",
      label_add_user_color: "Dodaj do kolor\xF3w",
      label_send: "Wy\u015Blij",
      label_accept: "Akceptuj",
      label_cookies_title: "Ta strona u\u017Cywa plik\xF3w cookie",
      label_cookies_text: "Ta strona u\u017Cywa plik\xF3w cookie, aby zapewni\u0107 najlepsze do\u015Bwiadczenie na naszej stronie.",
      label_choose_file: "Wybierz plik(i)",
      label_drop_file: "Kliknij lub upu\u015B\u0107 plik(i) tutaj",
      label_files_selected: "Wybrano {n} plik(\xF3w)",
      label_days: "dni",
      label_hours: "godziny",
      label_minutes: "minuty",
      label_seconds: "sekundy",
      label_month: "miesi\u0105c",
      label_months: "miesi\u0105ce",
      label_day: "dzie\u0144",
      label_year: "rok",
      label_years: "lata",
      label_rows_count: "Poka\u017C:",
      label_search: "Szukaj:",
      label_table_info: "Wy\u015Bwietlanie od $1 do $2 z $3 wpis\xF3w",
      label_prev: "Poprzedni",
      label_next: "Nast\u0119pny",
      label_all: "Wszystko",
      label_inspector: "Inspektor",
      label_goto_page: "Id\u017A do",
      label_enter_page: "Wpisz stron\u0119...",
      label_empty: "Brak danych do wy\u015Bwietlenia",
      label_user_colors: "Kolory u\u017Cytkownika",
      label_tiles: "Kafelki",
      label_list: "Lista",
      label_load_more: "Za\u0142aduj wi\u0119cej",
      label_buy: "Kup",
      label_buy_now: "Kup teraz",
      label_buy_today: "Kup dzisiaj",
      label_download: "Pobierz",
      label_search_results: "Wyniki wyszukiwania",
      label_add: "Dodaj",
      label_edit: "Edytuj",
      label_delete: "Usu\u0144",
      label_new: "Nowy",
      label_sell: "Sprzedaj",
      label_details: "Szczeg\xF3\u0142y",
      label_sorting: "Sortowanie",
      label_finish: "Zako\u0144cz",
      label_play: "Odtw\xF3rz",
      label_pause: "Pauza",
      label_stop: "Zatrzymaj",
      label_mute: "Wycisz",
      label_loop: "Zap\u0119tl",
      label_on: "w\u0142\u0105",
      label_off: "wy\u0142",
      label_rename_tab: "Zmie\u0144 nazw\u0119 karty",
      label_close_tab: "Zamknij kart\u0119",
      label_close_other_tabs: "Zamknij inne karty",
      label_close_tabs_left: "Zamknij karty po lewej",
      label_close_tabs_right: "Zamknij karty po prawej",
      label_close_all_tabs: "Zamknij wszystkie karty",
      label_close_inactive_tabs: "Zamknij nieaktywne karty",
      label_clear_input: "Wyczy\u015B\u0107 pole",
      label_reveal_password: "Poka\u017C has\u0142o",
      label_hide_password: "Ukryj has\u0142o",
      label_generate_random: "Wygeneruj losow\u0105 warto\u015B\u0107",
      label_search_input: "Szukaj wprowadzonej warto\u015Bci",
      label_note: "Notatka",
      label_tip: "Wskaz\xF3wka",
      label_info: "Informacja",
      label_warning: "Ostrze\u017Cenie",
      label_question: "Pytanie",
      label_error: "B\u0142\u0105d",
      label_success: "Sukces",
      label_caution: "Uwaga",
      label_alert: "Alarm",
      label_bug: "B\u0142\u0105d",
      label_fuck: "Cholera",
      label_important: "Wa\u017Cne",
      label_shit: "Kurka",
      label_air: "Powietrze",
      label_select_all: "Zaznacz wszystko",
      label_select_more: "Wybierz...",
      label_select: "Wybierz",
      label_filter: "Filtruj",
      label_collapse: "Zwi\u0144",
      label_attach: "Przytwierdza\u0107"
    });
  })();

  // ../metroui-lib/source/extensions/array.js
  (() => {
    "use strict";
    if (typeof Array.prototype.shuffle !== "function") {
      Array.prototype.shuffle = function() {
        let currentIndex = this.length;
        let temporaryValue;
        let randomIndex;
        while (0 !== currentIndex) {
          randomIndex = Math.floor(Math.random() * currentIndex);
          currentIndex -= 1;
          temporaryValue = this[currentIndex];
          this[currentIndex] = this[randomIndex];
          this[randomIndex] = temporaryValue;
        }
        return this;
      };
    }
    if (typeof Array.prototype.clone !== "function") {
      Array.prototype.clone = function() {
        return this.slice(0);
      };
    }
    if (typeof Array.prototype.unique !== "function") {
      Array.prototype.unique = function() {
        const a2 = this.concat();
        for (let i3 = 0; i3 < a2.length; ++i3) {
          for (let j5 = i3 + 1; j5 < a2.length; ++j5) {
            if (a2[i3] === a2[j5]) a2.splice(j5--, 1);
          }
        }
        return a2;
      };
    }
    if (typeof Array.prototype.pack !== "function") {
      Array.prototype.pack = function() {
        return this.filter((value) => {
          return value !== void 0 && value !== null && `${value}`.trim() !== "";
        });
      };
    }
  })();

  // ../metroui-lib/source/extensions/number.js
  (() => {
    Number.prototype.format = function(n3, x5 = 3, s2 = ",", c5 = ".") {
      const re3 = `\\d(?=(\\d{${x5 || 3}})+${n3 > 0 ? "\\D" : "$"})`;
      const num = this.toFixed(Math.max(0, ~~n3));
      return (c5 ? num.replace(".", c5) : num).replace(new RegExp(re3, "g"), `$&${s2 || ","}`);
    };
  })();

  // ../metroui-lib/source/extensions/string.js
  (() => {
    "use strict";
    String.prototype.toArray = function(delimiter = ",", type = "string", format = "", locale = "en", pack = false) {
      const a2 = `${this}`.split(delimiter).map((s2) => {
        let result;
        switch (type) {
          case "int":
          case "integer":
            result = isNaN(s2) ? s2.trim() : Number.parseInt(s2);
            break;
          case "number":
          case "float":
            result = isNaN(s2) ? s2 : Number.parseFloat(s2);
            break;
          case "date":
            result = !format ? datetime(s2) : Datetime.from(s2, format, locale);
            break;
          case "boolean": {
            switch (s2) {
              case true:
              case "true":
              case 1:
              case "1":
              case "on":
              case "yes":
              case "+":
                result = true;
                break;
              default:
                result = false;
            }
            break;
          }
          default:
            result = s2.trim();
        }
        return result;
      });
      return pack ? a2.pack() : a2;
    };
  })();

  // ../metroui-lib/source/common-js/md5.js
  ((Metro2) => {
    "use strict";
    Metro2.md5 = (string) => {
      function RotateLeft(lValue, iShiftBits) {
        return lValue << iShiftBits | lValue >>> 32 - iShiftBits;
      }
      function AddUnsigned(lX, lY) {
        let lX8;
        let lY8;
        let lResult;
        lX8 = lX & 2147483648;
        lY8 = lY & 2147483648;
        const lX4 = lX & 1073741824;
        const lY4 = lY & 1073741824;
        lResult = (lX & 1073741823) + (lY & 1073741823);
        if (lX4 & lY4) {
          return lResult ^ 2147483648 ^ lX8 ^ lY8;
        }
        if (lX4 | lY4) {
          if (lResult & 1073741824) {
            return lResult ^ 3221225472 ^ lX8 ^ lY8;
          }
          return lResult ^ 1073741824 ^ lX8 ^ lY8;
        }
        return lResult ^ lX8 ^ lY8;
      }
      function F5(x6, y4, z5) {
        return x6 & y4 | ~x6 & z5;
      }
      function G6(x6, y4, z5) {
        return x6 & z5 | y4 & ~z5;
      }
      function H5(x6, y4, z5) {
        return x6 ^ y4 ^ z5;
      }
      function I5(x6, y4, z5) {
        return y4 ^ (x6 | ~z5);
      }
      function FF(a3, b6, c6, d5, x6, s2, ac) {
        const _a = AddUnsigned(a3, AddUnsigned(AddUnsigned(F5(b6, c6, d5), x6), ac));
        return AddUnsigned(RotateLeft(_a, s2), b6);
      }
      function GG(a3, b6, c6, d5, x6, s2, ac) {
        const _a = AddUnsigned(a3, AddUnsigned(AddUnsigned(G6(b6, c6, d5), x6), ac));
        return AddUnsigned(RotateLeft(_a, s2), b6);
      }
      function HH(a3, b6, c6, d5, x6, s2, ac) {
        const _a = AddUnsigned(a3, AddUnsigned(AddUnsigned(H5(b6, c6, d5), x6), ac));
        return AddUnsigned(RotateLeft(_a, s2), b6);
      }
      function II(a3, b6, c6, d5, x6, s2, ac) {
        const _a = AddUnsigned(a3, AddUnsigned(AddUnsigned(I5(b6, c6, d5), x6), ac));
        return AddUnsigned(RotateLeft(_a, s2), b6);
      }
      function ConvertToWordArray(string2) {
        let lWordCount;
        const lMessageLength = string2.length;
        const lNumberOfWords_temp1 = lMessageLength + 8;
        const lNumberOfWords_temp2 = (lNumberOfWords_temp1 - lNumberOfWords_temp1 % 64) / 64;
        const lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
        const lWordArray = Array(lNumberOfWords - 1);
        let lBytePosition = 0;
        let lByteCount = 0;
        while (lByteCount < lMessageLength) {
          lWordCount = (lByteCount - lByteCount % 4) / 4;
          lBytePosition = lByteCount % 4 * 8;
          lWordArray[lWordCount] = lWordArray[lWordCount] | string2.charCodeAt(lByteCount) << lBytePosition;
          lByteCount++;
        }
        lWordCount = (lByteCount - lByteCount % 4) / 4;
        lBytePosition = lByteCount % 4 * 8;
        lWordArray[lWordCount] = lWordArray[lWordCount] | 128 << lBytePosition;
        lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
        lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
        return lWordArray;
      }
      function WordToHex(lValue) {
        let WordToHexValue = "";
        let WordToHexValue_temp = "";
        let lByte;
        let lCount;
        for (lCount = 0; lCount <= 3; lCount++) {
          lByte = lValue >>> lCount * 8 & 255;
          WordToHexValue_temp = `0${lByte.toString(16)}`;
          WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);
        }
        return WordToHexValue;
      }
      function Utf8Encode(string2) {
        const _string2 = string2.replace(/\r\n/g, "\n");
        let utftext = "";
        for (let n3 = 0; n3 < _string2.length; n3++) {
          const c6 = _string2.charCodeAt(n3);
          if (c6 < 128) {
            utftext += String.fromCharCode(c6);
          } else if (c6 > 127 && c6 < 2048) {
            utftext += String.fromCharCode(c6 >> 6 | 192);
            utftext += String.fromCharCode(c6 & 63 | 128);
          } else {
            utftext += String.fromCharCode(c6 >> 12 | 224);
            utftext += String.fromCharCode(c6 >> 6 & 63 | 128);
            utftext += String.fromCharCode(c6 & 63 | 128);
          }
        }
        return utftext;
      }
      let x5 = [];
      let k5;
      let AA;
      let BB;
      let CC;
      let DD;
      let a2;
      let b5;
      let c5;
      let d4;
      const S11 = 7;
      const S12 = 12;
      const S13 = 17;
      const S14 = 22;
      const S21 = 5;
      const S22 = 9;
      const S23 = 14;
      const S24 = 20;
      const S31 = 4;
      const S32 = 11;
      const S33 = 16;
      const S34 = 23;
      const S41 = 6;
      const S42 = 10;
      const S43 = 15;
      const S44 = 21;
      const _string = Utf8Encode(string);
      x5 = ConvertToWordArray(_string);
      a2 = 1732584193;
      b5 = 4023233417;
      c5 = 2562383102;
      d4 = 271733878;
      for (k5 = 0; k5 < x5.length; k5 += 16) {
        AA = a2;
        BB = b5;
        CC = c5;
        DD = d4;
        a2 = FF(a2, b5, c5, d4, x5[k5], S11, 3614090360);
        d4 = FF(d4, a2, b5, c5, x5[k5 + 1], S12, 3905402710);
        c5 = FF(c5, d4, a2, b5, x5[k5 + 2], S13, 606105819);
        b5 = FF(b5, c5, d4, a2, x5[k5 + 3], S14, 3250441966);
        a2 = FF(a2, b5, c5, d4, x5[k5 + 4], S11, 4118548399);
        d4 = FF(d4, a2, b5, c5, x5[k5 + 5], S12, 1200080426);
        c5 = FF(c5, d4, a2, b5, x5[k5 + 6], S13, 2821735955);
        b5 = FF(b5, c5, d4, a2, x5[k5 + 7], S14, 4249261313);
        a2 = FF(a2, b5, c5, d4, x5[k5 + 8], S11, 1770035416);
        d4 = FF(d4, a2, b5, c5, x5[k5 + 9], S12, 2336552879);
        c5 = FF(c5, d4, a2, b5, x5[k5 + 10], S13, 4294925233);
        b5 = FF(b5, c5, d4, a2, x5[k5 + 11], S14, 2304563134);
        a2 = FF(a2, b5, c5, d4, x5[k5 + 12], S11, 1804603682);
        d4 = FF(d4, a2, b5, c5, x5[k5 + 13], S12, 4254626195);
        c5 = FF(c5, d4, a2, b5, x5[k5 + 14], S13, 2792965006);
        b5 = FF(b5, c5, d4, a2, x5[k5 + 15], S14, 1236535329);
        a2 = GG(a2, b5, c5, d4, x5[k5 + 1], S21, 4129170786);
        d4 = GG(d4, a2, b5, c5, x5[k5 + 6], S22, 3225465664);
        c5 = GG(c5, d4, a2, b5, x5[k5 + 11], S23, 643717713);
        b5 = GG(b5, c5, d4, a2, x5[k5], S24, 3921069994);
        a2 = GG(a2, b5, c5, d4, x5[k5 + 5], S21, 3593408605);
        d4 = GG(d4, a2, b5, c5, x5[k5 + 10], S22, 38016083);
        c5 = GG(c5, d4, a2, b5, x5[k5 + 15], S23, 3634488961);
        b5 = GG(b5, c5, d4, a2, x5[k5 + 4], S24, 3889429448);
        a2 = GG(a2, b5, c5, d4, x5[k5 + 9], S21, 568446438);
        d4 = GG(d4, a2, b5, c5, x5[k5 + 14], S22, 3275163606);
        c5 = GG(c5, d4, a2, b5, x5[k5 + 3], S23, 4107603335);
        b5 = GG(b5, c5, d4, a2, x5[k5 + 8], S24, 1163531501);
        a2 = GG(a2, b5, c5, d4, x5[k5 + 13], S21, 2850285829);
        d4 = GG(d4, a2, b5, c5, x5[k5 + 2], S22, 4243563512);
        c5 = GG(c5, d4, a2, b5, x5[k5 + 7], S23, 1735328473);
        b5 = GG(b5, c5, d4, a2, x5[k5 + 12], S24, 2368359562);
        a2 = HH(a2, b5, c5, d4, x5[k5 + 5], S31, 4294588738);
        d4 = HH(d4, a2, b5, c5, x5[k5 + 8], S32, 2272392833);
        c5 = HH(c5, d4, a2, b5, x5[k5 + 11], S33, 1839030562);
        b5 = HH(b5, c5, d4, a2, x5[k5 + 14], S34, 4259657740);
        a2 = HH(a2, b5, c5, d4, x5[k5 + 1], S31, 2763975236);
        d4 = HH(d4, a2, b5, c5, x5[k5 + 4], S32, 1272893353);
        c5 = HH(c5, d4, a2, b5, x5[k5 + 7], S33, 4139469664);
        b5 = HH(b5, c5, d4, a2, x5[k5 + 10], S34, 3200236656);
        a2 = HH(a2, b5, c5, d4, x5[k5 + 13], S31, 681279174);
        d4 = HH(d4, a2, b5, c5, x5[k5], S32, 3936430074);
        c5 = HH(c5, d4, a2, b5, x5[k5 + 3], S33, 3572445317);
        b5 = HH(b5, c5, d4, a2, x5[k5 + 6], S34, 76029189);
        a2 = HH(a2, b5, c5, d4, x5[k5 + 9], S31, 3654602809);
        d4 = HH(d4, a2, b5, c5, x5[k5 + 12], S32, 3873151461);
        c5 = HH(c5, d4, a2, b5, x5[k5 + 15], S33, 530742520);
        b5 = HH(b5, c5, d4, a2, x5[k5 + 2], S34, 3299628645);
        a2 = II(a2, b5, c5, d4, x5[k5], S41, 4096336452);
        d4 = II(d4, a2, b5, c5, x5[k5 + 7], S42, 1126891415);
        c5 = II(c5, d4, a2, b5, x5[k5 + 14], S43, 2878612391);
        b5 = II(b5, c5, d4, a2, x5[k5 + 5], S44, 4237533241);
        a2 = II(a2, b5, c5, d4, x5[k5 + 12], S41, 1700485571);
        d4 = II(d4, a2, b5, c5, x5[k5 + 3], S42, 2399980690);
        c5 = II(c5, d4, a2, b5, x5[k5 + 10], S43, 4293915773);
        b5 = II(b5, c5, d4, a2, x5[k5 + 1], S44, 2240044497);
        a2 = II(a2, b5, c5, d4, x5[k5 + 8], S41, 1873313359);
        d4 = II(d4, a2, b5, c5, x5[k5 + 15], S42, 4264355552);
        c5 = II(c5, d4, a2, b5, x5[k5 + 6], S43, 2734768916);
        b5 = II(b5, c5, d4, a2, x5[k5 + 13], S44, 1309151649);
        a2 = II(a2, b5, c5, d4, x5[k5 + 4], S41, 4149444226);
        d4 = II(d4, a2, b5, c5, x5[k5 + 11], S42, 3174756917);
        c5 = II(c5, d4, a2, b5, x5[k5 + 2], S43, 718787259);
        b5 = II(b5, c5, d4, a2, x5[k5 + 9], S44, 3951481745);
        a2 = AddUnsigned(a2, AA);
        b5 = AddUnsigned(b5, BB);
        c5 = AddUnsigned(c5, CC);
        d4 = AddUnsigned(d4, DD);
      }
      const temp = WordToHex(a2) + WordToHex(b5) + WordToHex(c5) + WordToHex(d4);
      return temp.toLowerCase();
    };
  })(Metro);

  // ../metroui-lib/source/common-js/utilities.js
  ((Metro2, $7) => {
    "use strict";
    Metro2.utils = {
      // Deprecated, use Hooks.useId()
      elementId: (prefix) => `${prefix}-${(/* @__PURE__ */ new Date()).getTime()}${$7.random(1, 1e3)}`,
      secondsToTime: (s2) => {
        const days = Math.floor(s2 % 31536e3 / 86400);
        const hours = Math.floor(s2 % 31536e3 % 86400 / 3600);
        const minutes = Math.floor(s2 % 31536e3 % 86400 % 3600 / 60);
        const seconds = Math.round(s2 % 31536e3 % 86400 % 3600 % 60);
        return {
          d: days,
          h: hours,
          m: minutes,
          s: seconds
        };
      },
      secondsToFormattedString: (time) => {
        const sec_num = Number.parseInt(time, 10);
        const hours = Math.floor(sec_num / 3600);
        const minutes = Math.floor((sec_num - hours * 3600) / 60);
        const seconds = sec_num - hours * 3600 - minutes * 60;
        return [Str.lpad(hours, "0", 2), Str.lpad(minutes, "0", 2), Str.lpad(seconds, "0", 2)].join(":");
      },
      func: (f5) => new Function("a", f5),
      exec: function(f5, args, context) {
        let result;
        if (f5 === void 0 || f5 === null) {
          return false;
        }
        let func = this.isFunc(f5);
        if (func === false) {
          func = this.func(f5);
        }
        try {
          result = func.apply(context, args);
        } catch (err) {
          result = null;
          if (globalThis.METRO_THROWS === true) {
            throw err;
          }
        }
        return result;
      },
      embedUrl: (val) => {
        let url = val;
        if (url.indexOf("youtu.be") !== -1) {
          url = `https://www.youtube.com/embed/${val.split("/").pop()}`;
        }
        return `<div class='embed-container'><iframe src='${url}'></iframe></div>`;
      },
      isVisible: function(element2) {
        const el = $7(element2)[0];
        return this.getStyleOne(el, "display") !== "none" && this.getStyleOne(el, "visibility") !== "hidden" && el.offsetParent !== null;
      },
      isUrl: (val) => /^(\.\/|\.\.\/|ftp|http|https):\/\/(\w+:?\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@\-/]))?/.test(val),
      isTag: (val) => /^<\/?[\w\s="/.':;#-/?]+>/gi.test(val),
      isEmbedObject: (val) => {
        const embed = ["iframe", "object", "embed", "video"];
        let result = false;
        $7.each(embed, function() {
          if (typeof val === "string" && val.toLowerCase() === this) {
            result = true;
          } else if (val.nodeType !== void 0 && val.tagName.toLowerCase() === this) {
            result = true;
          }
        });
        return result;
      },
      isVideoUrl: (val) => /youtu\.be|youtube|twitch|vimeo/gi.test(val),
      isDate: function(val, format, locale = "en-US") {
        let result;
        if (this.isDateObject(val)) {
          return true;
        }
        try {
          result = format ? Datetime.from(val, format, locale) : datetime(val);
          return Datetime.isDatetime(result);
        } catch (e2) {
          return false;
        }
      },
      isDateObject: (v5) => typeof v5 === "object" && v5.getMonth !== void 0,
      isInt: (n3) => !isNaN(n3) && +n3 % 1 === 0,
      isFloat: (n3) => !isNaN(n3) && +n3 % 1 !== 0 || /^\d*\.\d+$/.test(n3),
      isFunc: function(f5) {
        return this.isType(f5, "function");
      },
      isObject: function(o2) {
        return this.isType(o2, "object");
      },
      isObject2: (o2) => typeof o2 === "object" && !Array.isArray(o2),
      isType: function(o2, t = "undefined") {
        if (!this.isValue(o2)) {
          return false;
        }
        if (typeof o2 === t) {
          return o2;
        }
        if (`${t}`.toLowerCase() === "tag" && this.isTag(o2)) {
          return o2;
        }
        if (`${t}`.toLowerCase() === "url" && this.isUrl(o2)) {
          return o2;
        }
        if (`${t}`.toLowerCase() === "array" && Array.isArray(o2)) {
          return o2;
        }
        if (t !== "string" && this.isTag(o2) || this.isUrl(o2)) {
          return false;
        }
        if (typeof window[o2] === t) {
          return window[o2];
        }
        if (typeof o2 === "string" && o2.indexOf(".") === -1) {
          return false;
        }
        if (typeof o2 === "string" && /[/\s([]+/gm.test(o2)) {
          return false;
        }
        if (typeof o2 === "number" && t.toLowerCase() !== "number") {
          return false;
        }
        const ns = o2.split(".");
        let i3;
        let context = window;
        for (i3 = 0; i3 < ns.length; i3++) {
          context = context[ns[i3]];
        }
        return typeof context === t ? context : false;
      },
      $: () => globalThis.useJQuery ? globalThis.jQuery : Dom,
      isMetroObject: (el, type) => {
        const $el = $7(el);
        const el_obj = Metro2.getPlugin(el, type);
        if ($el.length === 0) {
          console.warn(`${type} ${el} not found!`);
          return false;
        }
        if (el_obj === void 0) {
          console.warn(
            `Element not contain role ${type}! Please add attribute data-role="${type}" to element ${el}`
          );
          return false;
        }
        return true;
      },
      isJQuery: (el) => typeof globalThis.jQuery !== "undefined" && el instanceof globalThis.jQuery,
      isDom: (el) => typeof Dom !== "undefined" && el instanceof Dom,
      isQ: function(el) {
        return this.isJQuery(el) || this.isDom(el);
      },
      isOutsider: function(element2) {
        const el = $7(element2);
        const clone = el.clone();
        clone.removeAttr("data-role").css({
          visibility: "hidden",
          position: "absolute",
          display: "block"
        });
        el.parent().append(clone);
        const inViewport = this.inViewport(clone[0]);
        clone.remove();
        return !inViewport;
      },
      inViewport: function(el) {
        const rect = this.rect(el);
        return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (globalThis.innerHeight || document.documentElement.clientHeight) && rect.right <= (globalThis.innerWidth || document.documentElement.clientWidth);
      },
      viewportOutByWidth: function(el) {
        const rect = this.rect(el);
        const w6 = globalThis.innerWidth || document.documentElement.clientWidth;
        return rect.right > w6;
      },
      viewportOutByHeight: function(el) {
        const rect = this.rect(el);
        const h3 = globalThis.innerHeight || document.documentElement.clientHeight;
        return rect.bottom > h3;
      },
      viewportOut: function(el) {
        return this.viewportOutByWidth(el) || this.viewportOutByHeight(el);
      },
      rect: (el) => el.getBoundingClientRect(),
      getCursorPosition: function(el, e2) {
        const a2 = this.rect(el);
        return {
          x: this.pageXY(e2).x - a2.left - globalThis.scrollX,
          y: this.pageXY(e2).y - a2.top - globalThis.scrollY
        };
      },
      getCursorPositionX: function(el, e2) {
        return this.getCursorPosition(el, e2).x;
      },
      getCursorPositionY: function(el, e2) {
        return this.getCursorPosition(el, e2).y;
      },
      objectLength: (obj) => Object.keys(obj).length,
      percent: (total, part, round_value) => {
        if (total === 0) {
          return 0;
        }
        const result = part * 100 / total;
        return round_value === true ? Math.round(result) : Math.round(result * 100) / 100;
      },
      objectShift: (obj) => {
        let min = 0;
        $7.each(obj, (i3) => {
          if (min === 0) {
            min = i3;
          } else {
            if (min > i3) {
              min = i3;
            }
          }
        });
        delete obj[min];
        return obj;
      },
      objectDelete: (obj, key) => {
        if (key in obj) delete obj[key];
      },
      arrayDeleteByMultipleKeys: (arr, keys) => {
        for (const ind of keys) {
          delete arr[ind];
        }
        return arr.filter((item) => item !== void 0);
      },
      arrayDelete: (arr, val) => {
        const i3 = arr.indexOf(val);
        if (i3 > -1) arr.splice(i3, 1);
      },
      arrayDeleteByKey: (arr, key) => {
        arr.splice(key, 1);
      },
      nvl: (data, other) => data === void 0 || data === null ? other : data,
      objectClone: (obj) => {
        const copy = {};
        for (const key in obj) {
          if ($7.hasProp(obj, key)) {
            copy[key] = obj[key];
          }
        }
        return copy;
      },
      github: async function(repo, callback) {
        const res = await fetch(`https://api.github.com/repos/${repo}`);
        if (!res.ok) return;
        const data = await res.json();
        this.exec(callback, [data]);
      },
      pageHeight: () => {
        const body = document.body;
        const html = document.documentElement;
        return Math.max(
          body.scrollHeight,
          body.offsetHeight,
          html.clientHeight,
          html.scrollHeight,
          html.offsetHeight
        );
      },
      cleanPreCode: (selector) => {
        const els = Array.prototype.slice.call(document.querySelectorAll(selector), 0);
        for (const el of els) {
          const txt = el.textContent.replace(/^[\r\n]+/, "").replace(/\s+$/g, "");
          if (/^\S/gm.test(txt)) {
            el.textContent = txt;
            continue;
          }
          let mat;
          let str2 = "";
          const re3 = /^[\t ]+/gm;
          let len;
          let min = 1e3;
          while (mat = re3.exec(txt)) {
            len = mat[0].length;
            if (len < min) {
              min = len;
              str2 = mat[0];
            }
          }
          if (min === 1e3) continue;
          el.textContent = txt.replace(new RegExp(`^${str2}`, "gm"), "").trim();
        }
      },
      coords: (element2) => {
        const el = $7(element2)[0];
        const box = el.getBoundingClientRect();
        return {
          top: box.top + globalThis.pageYOffset,
          left: box.left + globalThis.pageXOffset
        };
      },
      /**
       * @param {TouchEvent|Event|MouseEvent} e
       * @param t where: client, screen, or page
       * @param s source: touches or changedTouches
       */
      positionXY: function(e2, t, s2) {
        switch (t) {
          case "client":
            return this.clientXY(e2, s2);
          case "screen":
            return this.screenXY(e2, s2);
          case "page":
            return this.pageXY(e2, s2);
          default:
            return { x: 0, y: 0 };
        }
      },
      /**
       *
       * @param {TouchEvent|Event|MouseEvent} e
       * @param t source: touches or changedTouches
       * @returns {{x: (*), y: (*)}}
       */
      clientXY: (e2, t = "touches") => ({
        x: e2[t] ? e2[t][0].clientX : e2.clientX,
        y: e2[t] ? e2[t][0].clientY : e2.clientY
      }),
      /**
       *
       * @param {TouchEvent|Event|MouseEvent} e
       * @param t source: touches or changedTouches
       * @returns {{x: (*), y: (*)}}
       */
      screenXY: (e2, t = "touches") => ({
        x: e2[t] ? e2[t][0].screenX : e2.screenX,
        y: e2[t] ? e2[t][0].screenY : e2.screenY
      }),
      /**
       *
       * @param {TouchEvent|Event|MouseEvent} e
       * @param t source: touches or changedTouches
       * @returns {{x: (*), y: (*)}}
       */
      pageXY: (e2, t = "touches") => ({
        x: e2[t] ? e2[t][0].pageX : e2.pageX,
        y: e2[t] ? e2[t][0].pageY : e2.pageY
      }),
      isRightMouse: (e2) => "which" in e2 ? e2.which === 3 : "button" in e2 ? e2.button === 2 : void 0,
      hiddenElementSize: (el, includeMargin = false) => {
        const clone = $7(el).clone(true);
        clone.removeAttr("data-role").css({
          visibility: "hidden",
          position: "absolute",
          display: "block"
        });
        $7("body").append(clone);
        const width = clone.outerWidth(includeMargin);
        const height = clone.outerHeight(includeMargin);
        clone.remove();
        return {
          width,
          height
        };
      },
      getStyle: (element2) => {
        const el = $7(element2)[0];
        return globalThis.getComputedStyle(el);
      },
      getStyleOne: function(el, property) {
        return this.getStyle(el).getPropertyValue(property);
      },
      getInlineStyles: (element2) => {
        let i3;
        let l2;
        const styles = {};
        const el = $7(element2)[0];
        for (i3 = 0, l2 = el.style.length; i3 < l2; i3++) {
          const s2 = el.style[i3];
          styles[s2] = el.style[s2];
        }
        return styles;
      },
      encodeURI: (str2) => encodeURI(str2).replace(/%5B/g, "[").replace(/%5D/g, "]"),
      updateURIParameter: (uri, key, value) => {
        const re3 = new RegExp(`([?&])${key}=.*?(&|$)`, "i");
        const separator = uri.indexOf("?") !== -1 ? "&" : "?";
        if (uri.match(re3)) {
          return uri.replace(re3, `$1${key}=${value}$2`);
        }
        return `${uri + separator + key}=${value}`;
      },
      getURIParameter: (url = globalThis.location.href, name2 = "") => {
        const _name = name2.replace(/[[\]]/g, "\\$&");
        const regex = new RegExp(`[?&]${_name}(=([^&#]*)|&|#|$)`);
        const results = regex.exec(url);
        if (!results) return null;
        if (!results[2]) return "";
        return decodeURIComponent(results[2].replace(/\+/g, " "));
      },
      getLocales: () => Object.keys(Metro2.locales),
      addLocale: (locale) => {
        Metro2.locales = $7.extend({}, Metro2.locales, locale);
      },
      aspectRatioH: (width, a2) => {
        if (a2 === "16/9") return width * 9 / 16;
        if (a2 === "21/9") return width * 9 / 21;
        if (a2 === "4/3") return width * 3 / 4;
      },
      aspectRatioW: (height, a2) => {
        if (a2 === "16/9") return height * 16 / 9;
        if (a2 === "21/9") return height * 21 / 9;
        if (a2 === "4/3") return height * 4 / 3;
      },
      valueInObject: (obj, value) => Object.values(obj).indexOf(value) > -1,
      keyInObject: (obj, key) => Object.keys(obj).indexOf(key) > -1,
      inObject: (obj, key, val) => obj[key] !== void 0 && obj[key] === val,
      newCssSheet: (media) => {
        const style = document.createElement("style");
        if (media !== void 0) {
          style.setAttribute("media", media);
        }
        style.appendChild(document.createTextNode(""));
        document.head.appendChild(style);
        return style.sheet;
      },
      addCssRule: (sheet, selector, rules, index) => {
        sheet.insertRule(`${selector}{${rules}}`, index);
      },
      media: (query) => globalThis.matchMedia(query).matches,
      mediaModes: () => globalThis.METRO_MEDIA,
      mediaExist: (media) => globalThis.METRO_MEDIA.indexOf(media) > -1,
      inMedia: (media) => globalThis.METRO_MEDIA.indexOf(media) > -1 && globalThis.METRO_MEDIA.indexOf(media) === globalThis.METRO_MEDIA.length - 1,
      isValue: (val) => val !== void 0 && val !== null && val !== "",
      isNull: (val) => val === void 0 || val === null,
      isNegative: (val) => Number.parseFloat(val) < 0,
      isPositive: (val) => Number.parseFloat(val) > 0,
      isZero: (val) => Number.parseFloat(val.toFixed(2)) === 0,
      between: (val, bottom, top, equals) => equals === true ? val >= bottom && val <= top : val > bottom && val < top,
      parseMoney: (val) => Number(Number.parseFloat(val.replace(/[^0-9-.]/g, ""))),
      parseCard: (val) => val.replace(/[^0-9]/g, ""),
      parsePhone: (val) => (void 0).parseCard(val),
      parseNumber: (val, thousand, decimal) => val.replace(new RegExp(`\\${thousand}`, "g"), "").replace(new RegExp(`\\${decimal}`, "g"), "."),
      nearest: (val, precision, down) => {
        let _val = val / precision;
        _val = Math[down === true ? "floor" : "ceil"](_val) * precision;
        return _val;
      },
      bool: (value) => {
        let result;
        switch (value) {
          case true:
          case "true":
          case 1:
          case "1":
          case "on":
          case "yes":
          case "+":
            result = true;
            break;
          default:
            result = false;
        }
        return result;
      },
      decCount: (v5) => v5 % 1 === 0 ? 0 : v5.toString().split(".")[1].length,
      classNames: (...args) => {
        const classes = [];
        for (const a2 of args) {
          if (!a2) continue;
          if (typeof a2 === "string") {
            classes.push(a2);
          } else if (Metro2.utils.isObject(a2)) {
            for (const k5 in a2) {
              if (a2[k5]) {
                classes.push(k5);
              }
            }
          } else {
            Metro2.utils.nothing();
          }
        }
        return classes.join(" ");
      },
      join: (...values) => {
        const sep = values.pop();
        const classes = [];
        for (const a2 of values) {
          if (!a2) continue;
          classes.push(Metro2.utils.isObject(a2) ? Object.values(a2)[0] : a2);
        }
        return classes.join(sep);
      },
      copy2clipboard: (v5, cb) => {
        navigator.clipboard.writeText(v5).then(() => {
          Metro2.utils.exec(cb, [v5]);
        });
      },
      getCssVar: (v5) => {
        const root = document.documentElement;
        const style = getComputedStyle(root);
        return style.getPropertyValue(v5);
      },
      scrollTo: (element2, options) => {
        const elem = typeof element2 === "string" ? $7(element2)[0] : element2;
        elem.scrollIntoView({
          ...options,
          behavior: "smooth",
          block: "start"
        });
      },
      getInnerSize: (element2) => {
        const el = $7(element2)[0];
        if (!el) return { width: 0, height: 0 };
        const style = getComputedStyle(el);
        const width = el.clientWidth - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight);
        const height = el.clientHeight - parseFloat(style.paddingTop) - parseFloat(style.paddingBottom);
        return { width, height };
      },
      clamp: (val, min, max) => {
        if (max > 0) return Math.min(Math.max(val, min), max);
        return Math.max(val, min);
      }
    };
  })(Metro, Dom);

  // ../metroui-lib/source/components/carousel/animations.js
  ((Metro2, $7) => {
    "use strict";
    const AnimationDefaultConfig = {
      duration: 300,
      ease: "linear"
    };
    Metro2.Effects = {
      switchIn: (el) => {
        $7(el).hide().css({
          left: 0,
          top: 0
        }).show();
      },
      switchOut: (el) => {
        $7(el).hide();
      },
      switch: function(current, next) {
        this.switchOut(current);
        this.switchIn(next);
      },
      slideUpIn: (el, o2) => {
        const $el = $7(el);
        const h3 = $el.parent().outerHeight(true);
        const op = $7.extend({}, AnimationDefaultConfig, o2);
        $el.css({
          top: h3,
          left: 0,
          zIndex: 2
        }).animate({
          draw: {
            top: 0,
            opacity: 1
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      slideUpOut: (el, o2) => {
        const $el = $7(el);
        const h3 = $el.parent().outerHeight(true);
        const op = $7.extend({}, AnimationDefaultConfig, o2);
        $el.css({
          zIndex: 1
        }).animate({
          draw: {
            top: -h3,
            opacity: 0
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      slideUp: function(current, next, o2) {
        this.slideUpOut(current, o2);
        this.slideUpIn(next, o2);
      },
      slideDownIn: (el, o2) => {
        const $el = $7(el);
        const h3 = $el.parent().outerHeight(true);
        const op = $7.extend({}, AnimationDefaultConfig, o2);
        $el.css({
          left: 0,
          top: -h3,
          zIndex: 2
        }).animate({
          draw: {
            top: 0,
            opacity: 1
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      slideDownOut: (el, o2) => {
        const $el = $7(el);
        const h3 = $el.parent().outerHeight(true);
        const op = $7.extend({}, AnimationDefaultConfig, o2);
        $el.css({
          zIndex: 1
        }).animate({
          draw: {
            top: h3,
            opacity: 0
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      slideDown: function(current, next, o2) {
        this.slideDownOut(current, o2);
        this.slideDownIn(next, o2);
      },
      slideLeftIn: (el, o2) => {
        const $el = $7(el);
        const w6 = $el.parent().outerWidth(true);
        const op = $7.extend({}, AnimationDefaultConfig, o2);
        $el.css({
          left: w6,
          zIndex: 2
        }).animate({
          draw: {
            left: 0,
            opacity: 1
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      slideLeftOut: (el, o2) => {
        const $el = $7(el);
        const w6 = $el.parent().outerWidth(true);
        const op = $7.extend({}, AnimationDefaultConfig, o2);
        $el.css({
          zIndex: 1
        }).animate({
          draw: {
            left: -w6,
            opacity: 0
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      slideLeft: function(current, next, o2) {
        this.slideLeftOut(current, o2);
        this.slideLeftIn(next, o2);
      },
      slideRightIn: (el, o2) => {
        const $el = $7(el);
        const w6 = $el.parent().outerWidth(true);
        const op = $7.extend({}, AnimationDefaultConfig, o2);
        $el.css({
          left: -w6,
          zIndex: 2
        }).animate({
          draw: {
            left: 0,
            opacity: 1
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      slideRightOut: (el, o2) => {
        const $el = $7(el);
        const w6 = $el.parent().outerWidth(true);
        const op = $7.extend({}, AnimationDefaultConfig, o2);
        $el.css({
          zIndex: 1
        }).animate({
          draw: {
            left: w6,
            opacity: 0
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      slideRight: function(current, next, o2) {
        this.slideRightOut(current, o2);
        this.slideRightIn(next, o2);
      },
      fadeIn: (el, o2) => {
        const op = $7.extend({}, AnimationDefaultConfig, o2);
        const $el = $7(el);
        $el.css({
          top: 0,
          left: 0,
          opacity: 0
        }).animate({
          draw: {
            opacity: 1
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      fadeOut: (el, o2) => {
        const op = $7.extend({}, AnimationDefaultConfig, o2);
        const $el = $7(el);
        $el.animate({
          draw: {
            opacity: 0
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      fade: function(current, next, o2) {
        this.fadeOut(current, o2);
        this.fadeIn(next, o2);
      },
      zoomIn: (el, o2) => {
        const op = $7.extend({}, AnimationDefaultConfig, o2);
        const $el = $7(el);
        $el.css({
          top: 0,
          left: 0,
          opacity: 0,
          transform: "scale(3)",
          zIndex: 2
        }).animate({
          draw: {
            scale: 1,
            opacity: 1
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      zoomOut: (el, o2) => {
        const op = $7.extend({}, AnimationDefaultConfig, o2);
        const $el = $7(el);
        $el.css({
          zIndex: 1
        }).animate({
          draw: {
            scale: 3,
            opacity: 0
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      zoom: function(current, next, o2) {
        this.zoomOut(current, o2);
        this.zoomIn(next, o2);
      },
      swirlIn: (el, o2) => {
        const op = $7.extend({}, AnimationDefaultConfig, o2);
        const $el = $7(el);
        $el.css({
          top: 0,
          left: 0,
          opacity: 0,
          transform: "scale(3) rotate(180deg)",
          zIndex: 2
        }).animate({
          draw: {
            scale: 1,
            rotate: 0,
            opacity: 1
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      swirlOut: (el, o2) => {
        const op = $7.extend({}, AnimationDefaultConfig, o2);
        const $el = $7(el);
        $el.css({
          zIndex: 1
        }).animate({
          draw: {
            scale: 3,
            rotate: "180deg",
            opacity: 0
          },
          dur: op.duration,
          ease: op.ease
        });
      },
      swirl: function(current, next, o2) {
        this.swirlOut(current, o2);
        this.swirlIn(next, o2);
      }
    };
  })(Metro, Dom);

  // ../metroui-lib/source/components/accordion/accordion.js
  ((Metro2, $7) => {
    "use strict";
    let AccordionDefaultConfig = {
      accordionDeferred: 0,
      showMarker: true,
      material: false,
      duration: 100,
      oneFrame: true,
      showActive: true,
      clsFrame: "",
      clsHeading: "",
      clsContent: "",
      clsAccordion: "",
      clsActiveFrame: "",
      clsActiveFrameHeading: "",
      clsActiveFrameContent: "",
      onFrameOpen: Metro2.noop,
      onFrameBeforeOpen: Metro2.noop_true,
      onFrameClose: Metro2.noop,
      onFrameBeforeClose: Metro2.noop_true,
      onAccordionCreate: Metro2.noop
    };
    Metro2.accordionSetup = (options) => {
      AccordionDefaultConfig = $7.extend({}, AccordionDefaultConfig, options);
    };
    if (typeof globalThis.metroAccordionSetup !== "undefined") {
      Metro2.accordionSetup(globalThis.metroAccordionSetup);
    }
    Metro2.Component("accordion", {
      init: function(options, elem) {
        this._super(elem, options, AccordionDefaultConfig);
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("accordionCreate", {
          element: element2
        });
      },
      _createStructure: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const frames = element2.children(".frame");
        const active = element2.children(".frame.active");
        let frame_to_open;
        if (!element2.id()) {
          element2.id(Hooks.useId("accordion"));
        }
        element2.addClass("accordion").addClass(o2.clsAccordion);
        frames.addClass(o2.clsFrame).each(function() {
          const el = $7(this);
          const heading = el.children(".heading");
          const content = el.children(".content");
          const headingId = Hooks.useId("accordion-heading");
          const contentId = Hooks.useId("accordion-content");
          heading.attr({
            id: headingId,
            role: "button",
            "aria-expanded": el.hasClass("active") ? "true" : "false",
            "aria-controls": contentId,
            tabindex: "0"
          });
          content.attr({
            id: contentId,
            role: "region",
            "aria-labelledby": headingId
          });
          heading.addClass(o2.clsHeading);
          content.addClass(o2.clsContent);
        });
        if (o2.showMarker === true) {
          element2.addClass("marker-on");
        }
        if (o2.material === true) {
          element2.addClass("material");
        }
        if (active.length === 0) {
          frame_to_open = frames[0];
        } else {
          frame_to_open = active[0];
        }
        this._hideAll();
        if (o2.showActive === true) {
          if (o2.oneFrame === true) {
            this._openFrame(frame_to_open);
          } else {
            $7.each(active, function() {
              that._openFrame(this);
            });
          }
        }
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const active = element2.children(".frame.active");
        element2.on("keydown", ".heading", function(e2) {
          const heading = $7(this);
          const frame = heading.parent();
          if (heading.closest(".accordion")[0] !== element2[0]) {
            return false;
          }
          if (e2.keyCode === 13 || e2.keyCode === 32) {
            e2.preventDefault();
            if (frame.hasClass("active")) {
              if (!(active.length === 1 && o2.oneFrame)) {
                that._closeFrame(frame);
              }
            } else {
              that._openFrame(frame);
            }
          }
          if (e2.keyCode === 38 || e2.keyCode === 40) {
            e2.preventDefault();
            const frames = element2.children(".frame");
            const currentIndex = frames.index(frame);
            let nextIndex;
            if (e2.keyCode === 38) {
              nextIndex = (currentIndex - 1 + frames.length) % frames.length;
            } else {
              nextIndex = (currentIndex + 1) % frames.length;
            }
            frames.eq(nextIndex).children(".heading").focus();
          }
        });
        element2.on(Metro2.events.click, ".heading", function() {
          const heading = $7(this);
          const frame = heading.parent();
          if (heading.closest(".accordion")[0] !== element2[0]) {
            return false;
          }
          if (frame.hasClass("active")) {
            if (active.length === 1 && o2.oneFrame) {
            } else {
              that._closeFrame(frame);
            }
          } else {
            that._openFrame(frame);
          }
        });
      },
      _openFrame: function(f5) {
        const element2 = this.element;
        const o2 = this.options;
        const frame = $7(f5);
        if (Metro2.utils.exec(o2.onFrameBeforeOpen, [frame[0]], element2[0]) === false) {
          return false;
        }
        if (o2.oneFrame === true) {
          this._closeAll(frame[0]);
        }
        frame.addClass("active").addClass(o2.clsActiveFrame);
        frame.children(".heading").addClass(o2.clsActiveFrameHeading);
        frame.children(".content").addClass(o2.clsActiveFrameContent).slideDown(o2.duration);
        this._fireEvent("frameOpen", {
          frame: frame[0]
        });
      },
      _closeFrame: function(f5) {
        const element2 = this.element;
        const o2 = this.options;
        const frame = $7(f5);
        if (!frame.hasClass("active")) {
          return;
        }
        if (Metro2.utils.exec(o2.onFrameBeforeClose, [frame[0]], element2[0]) === false) {
          return;
        }
        frame.removeClass("active").removeClass(o2.clsActiveFrame);
        frame.children(".heading").removeClass(o2.clsActiveFrameHeading);
        frame.children(".content").removeClass(o2.clsActiveFrameContent).slideUp(o2.duration);
        this._fireEvent("frameClose", {
          frame: frame[0]
        });
      },
      _closeAll: function(skip) {
        const that = this;
        const element2 = this.element;
        const frames = element2.children(".frame");
        $7.each(frames, function() {
          if (skip === this) return;
          that._closeFrame(this);
        });
      },
      _hideAll: function() {
        const element2 = this.element;
        const frames = element2.children(".frame");
        $7.each(frames, function() {
          $7(this).children(".content").hide();
        });
      },
      _openAll: function() {
        const that = this;
        const element2 = this.element;
        const frames = element2.children(".frame");
        $7.each(frames, function() {
          that._openFrame(this);
        });
      },
      open: function(i3) {
        const frame = this.element.children(".frame").eq(i3);
        this._openFrame(frame);
      },
      close: function(i3) {
        const frame = this.element.children(".frame").eq(i3);
        this._closeFrame(frame);
      },
      toggle: function(i3) {
        const frame = this.element.children(".frame").eq(i3);
        if (frame.hasClass("active")) {
          this._closeFrame(frame);
        } else {
          this._openFrame(frame);
        }
      },
      getActive: function() {
        const element2 = this.element;
        const frames = element2.children(".frame");
        const active = [];
        frames.each(function(index) {
          if ($7(this).hasClass("active")) {
            active.push(index);
          }
        });
        return active;
      },
      changeAttribute: (attr, newVal) => {
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, ".heading");
        return element2;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/action-button/action-button.js
  ((Metro2, $7) => {
    "use strict";
    let ActionButtonDefaultConfig = {
      onClick: Metro2.noop,
      onActionClick: Metro2.noop,
      onActionButtonCreate: Metro2.noop
    };
    Metro2.actionButtonSetup = (options) => {
      ActionButtonDefaultConfig = $7.extend({}, ActionButtonDefaultConfig, options);
    };
    if (typeof globalThis.metroActionButtonSetup !== "undefined") {
      Metro2.actionButtonSetup(globalThis.metroActionButtonSetup);
    }
    Metro2.Component("action-button", {
      init: function(options, elem) {
        this._super(elem, options, ActionButtonDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("action-button-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const actions = element2.find(".actions li, .actions button");
        element2.addClass("action-button");
        element2.cssVar("num-actions", actions.length);
        if (actions.length > 8) {
          element2.cssVar("action-shift", `${60 + (actions.length - 8) * 6}px`);
        }
        actions.each(function(index) {
          $7(this).cssVar("action-index", index).addClass("sub-action");
        });
        element2.children("button").addClass("main-action");
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        element2.on(Metro2.events.click, ".actions li, .actions button", function(e2) {
          that._fireEvent("action-click", { action: this });
        });
        element2.on(Metro2.events.click, ".main-action", function(e2) {
          e2.preventDefault();
          e2.stopPropagation();
          $7(this).toggleClass("active");
        });
      },
      changeAttribute: (attr, newValue) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
    $7(document).on("click", (e2) => {
      $7("[data-role-actionbutton]").each((i3, el) => {
        $7(el).children("button").removeClass("active");
      });
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/dialog/dialog.js
  ((Metro2, $7) => {
    "use strict";
    let DialogDefaultConfig = {
      dialogDeferred: 0,
      closeButton: false,
      leaveOverlayOnClose: false,
      toTop: false,
      toBottom: false,
      title: "",
      content: "",
      customButtons: null,
      actionsAlign: "right",
      defaultActions: true,
      defaultActionButtons: "ok,cancel,help",
      overlay: true,
      overlayColor: "#000000",
      overlayAlpha: 0.5,
      overlayClickClose: false,
      width: "auto",
      height: "auto",
      closeAction: true,
      clsDialog: "",
      clsTitle: "",
      clsContent: "",
      clsAction: "",
      clsDefaultAction: "",
      clsOverlay: "",
      autoHide: 0,
      removeOnClose: false,
      show: false,
      _runtime: false,
      onOk: Metro2.noop,
      onCancel: Metro2.noop,
      onHelp: Metro2.noop,
      onShow: Metro2.noop,
      onHide: Metro2.noop,
      onOpen: Metro2.noop,
      onClose: Metro2.noop,
      onDialogCreate: Metro2.noop
    };
    Metro2.dialogSetup = (options) => {
      DialogDefaultConfig = $7.extend({}, DialogDefaultConfig, options);
    };
    if (typeof globalThis.metroDialogSetup !== "undefined") {
      Metro2.dialogSetup(globalThis.metroDialogSetup);
    }
    Metro2.Component("dialog", {
      _counter: 0,
      init: function(options, elem) {
        this._super(elem, options, DialogDefaultConfig, {
          interval: null,
          overlay: null,
          id: null
        });
        return this;
      },
      _create: function() {
        this._build();
      },
      _build: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const strings = this.strings;
        const body = $7("body");
        let overlay;
        this.id = Hooks.useId(this.elem);
        element2.addClass("dialog");
        if (o2.title !== "") {
          this.setTitle(o2.title);
        }
        if (o2.content !== "") {
          this.setContent(o2.content);
        }
        if (o2.defaultActions === true || o2.customButtons) {
          let buttons = element2.find(".dialog-actions");
          let button;
          if (buttons.length === 0) {
            buttons = $7("<div>").addClass("dialog-actions").addClass(`text-${o2.actionsAlign}`).appendTo(element2);
          }
          if (o2.defaultActions === true && element2.find(".dialog-actions > *").length === 0) {
            for (const b5 of o2.defaultActionButtons.toArray(",")) {
              button = $7("<button>").addClass(b5 !== "help" ? "js-dialog-close" : "").addClass(o2.clsDefaultAction).html(strings[`label_${b5}`]);
              button.appendTo(buttons);
              if (b5 === "ok") {
                button.on(Metro2.events.click, () => {
                  Metro2.utils.exec(o2.onOk, [element2]);
                });
              }
              if (b5 === "help") {
                button.on(Metro2.events.click, () => {
                  Metro2.utils.exec(o2.onHelp, [element2]);
                });
              }
              if (b5 === "cancel") {
                button.on(Metro2.events.click, () => {
                  Metro2.utils.exec(o2.onCancel, [element2]);
                });
              }
            }
          }
          const customButtons = Metro2.utils.isObject(o2.customButtons);
          if (Array.isArray(customButtons))
            $7.each(customButtons, function() {
              const btn = $7("<button>").addClass("button").addClass(this.cls).html(this.text || this.html || "");
              that._setAttributes(btn, this.attr);
              if (this.onclick) {
                btn.on(Metro2.events.click, (e2) => {
                  if (Metro2.utils.isRightMouse(e2)) return;
                  Metro2.utils.exec(this.onclick, [btn[0], element2[0]]);
                });
              }
              btn.appendTo(buttons);
            });
        }
        if (o2.overlay === true) {
          overlay = this._overlay();
          this.overlay = overlay;
        }
        if (o2.closeAction === true) {
          element2.on(Metro2.events.click, ".js-dialog-close", () => {
            this.close();
          });
        }
        let closer = element2.find("closer");
        if (closer.length === 0) {
          closer = $7("<span>").addClass("closer js-dialog-close");
          closer.appendTo(element2);
        }
        if (o2.closeButton !== true) {
          closer.hide();
        }
        element2.css({
          height: o2.height,
          visibility: "hidden",
          top: "100%"
        });
        if (o2.width !== "auto") {
          element2.css({
            width: o2.width
          });
        }
        element2.addClass(o2.clsDialog);
        element2.find(".dialog-title").addClass(o2.clsTitle);
        element2.find(".dialog-content").addClass(o2.clsContent);
        element2.find(".dialog-actions").addClass(o2.clsAction);
        element2.appendTo(body);
        if (o2.show) {
          this.open();
        }
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            this.setPosition();
          },
          { ns: this.id }
        );
        this._fireEvent("dialog-create", {
          element: element2
        });
      },
      _overlay: function() {
        const o2 = this.options;
        const overlay = $7("<div>");
        overlay.addClass("overlay").addClass(o2.clsOverlay);
        if (o2.overlayColor === "transparent") {
          overlay.addClass("transparent");
        } else {
          overlay.css({
            background: Farbe.Routines.toRGBA(Farbe.Routines.parse(o2.overlayColor), o2.overlayAlpha)
          });
        }
        return overlay;
      },
      hide: function(callback) {
        const element2 = this.element;
        const o2 = this.options;
        let timeout = 0;
        if (o2.onHide !== Metro2.noop) {
          timeout = 500;
          this._fireEvent("hide");
        }
        setTimeout(() => {
          Metro2.utils.exec(callback, null, element2[0]);
          element2.css({
            visibility: "hidden",
            top: "100%"
          });
        }, timeout);
      },
      show: function(callback) {
        const element2 = this.element;
        this.setPosition();
        element2.css({
          visibility: "visible"
        });
        this._fireEvent("show");
        Metro2.utils.exec(callback, null, element2[0]);
      },
      setPosition: function() {
        const element2 = this.element;
        const o2 = this.options;
        let top;
        let bottom;
        if (o2.toTop !== true && o2.toBottom !== true) {
          top = ($7(globalThis).height() - element2.outerHeight()) / 2;
          if (top < 0) {
            top = 0;
          }
          bottom = "auto";
        } else {
          if (o2.toTop === true) {
            top = 0;
            bottom = "auto";
          }
          if (o2.toTop !== true && o2.toBottom === true) {
            bottom = 0;
            top = "auto";
          }
        }
        element2.css({
          top,
          bottom,
          left: ($7(globalThis).width() - element2.outerWidth()) / 2
        });
      },
      setContent: function(c5) {
        const element2 = this.element;
        let content = element2.find(".dialog-content");
        if (content.length === 0) {
          content = $7("<div>").addClass("dialog-content");
          content.appendTo(element2);
        }
        if (Metro2.utils.isQ(c5)) {
          c5.appendTo(content);
        } else {
          if (Metro2.utils.isFunc(c5)) {
            content.html(Metro2.utils.exec(c5));
          } else {
            content.html(c5);
          }
        }
      },
      setTitle: function(t) {
        const element2 = this.element;
        let title = element2.find(".dialog-title");
        if (title.length === 0) {
          title = $7("<div>").addClass("dialog-title");
          title.appendTo(element2);
        }
        title.html(t);
      },
      close: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (!Metro2.utils.bool(o2.leaveOverlayOnClose)) {
          $7("body").find(".overlay").remove();
        }
        this.hide(() => {
          element2.data("open", false);
          this._fireEvent("close");
          if (o2.removeOnClose === true) {
            element2.remove();
          }
        });
      },
      open: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (o2.overlay === true && $7(".overlay").length === 0) {
          this.overlay.appendTo($7("body"));
          if (o2.overlayClickClose === true) {
            this.overlay.on(Metro2.events.click, () => {
              this.close();
            });
          }
        }
        this.show(() => {
          this._fireEvent("open");
          element2.data("open", true);
          if (Number.parseInt(o2.autoHide) > 0) {
            setTimeout(() => {
              this.close();
            }, Number.parseInt(o2.autoHide));
          }
        });
      },
      toggle: function() {
        const element2 = this.element;
        if (element2.data("open")) {
          this.close();
        } else {
          this.open();
        }
      },
      isOpen: function() {
        return this.element.data("open") === true;
      },
      /* eslint-disable-next-line */
      changeAttribute: (attr, val) => {
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, ".js-dialog-close");
        element2.find(".button").off(Metro2.events.click);
        $7(globalThis).off(Metro2.events.resize, { ns: this.id });
        element2.remove();
      }
    });
    Metro2.dialog = {
      isDialog: (el) => Metro2.utils.isMetroObject(el, "dialog"),
      open: function(el, content, title) {
        if (!this.isDialog(el)) {
          return false;
        }
        const dialog = Metro2.getPlugin(el, "dialog");
        if (title) {
          dialog.setTitle(title);
        }
        if (content) {
          dialog.setContent(content);
        }
        dialog.open();
      },
      close: function(el) {
        if (!this.isDialog(el)) {
          return false;
        }
        Metro2.getPlugin($7(el)[0], "dialog").close();
      },
      toggle: function(el) {
        if (!this.isDialog(el)) {
          return false;
        }
        Metro2.getPlugin($7(el)[0], "dialog").toggle();
      },
      isOpen: function(el) {
        if (!this.isDialog(el)) {
          return false;
        }
        Metro2.getPlugin($7(el)[0], "dialog").isOpen();
      },
      remove: function(el) {
        if (!this.isDialog(el)) {
          return false;
        }
        const dialog = Metro2.getPlugin($7(el)[0], "dialog");
        dialog.options.removeOnClose = true;
        dialog.close();
      },
      create: (options) => {
        const dlg = $7("<div>").appendTo($7("body"));
        const dlg_options = $7.extend(
          {},
          {
            show: true,
            closeAction: true,
            removeOnClose: true
          },
          options ? options : {}
        );
        dlg_options._runtime = true;
        return Metro2.makePlugin(dlg, "dialog", dlg_options).element;
      }
    };
  })(Metro, Dom);

  // ../metroui-lib/source/components/activity/activity.js
  ((Metro2, $7) => {
    "use strict";
    let ActivityDefaultConfig = {
      activityDeferred: 0,
      type: "ring",
      style: "",
      size: 64,
      radius: 20,
      onActivityCreate: Metro2.noop
    };
    Metro2.activitySetup = (options) => {
      ActivityDefaultConfig = $7.extend({}, ActivityDefaultConfig, options);
    };
    if (typeof globalThis.metroActivitySetup !== "undefined") {
      Metro2.activitySetup(globalThis.metroActivitySetup);
    }
    Metro2.Component("activity", {
      init: function(options, elem) {
        this._super(elem, options, ActivityDefaultConfig);
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        let i3;
        let wrap;
        element2.html("").addClass(o2.style === "dark" ? "dark-side" : o2.style === "color" ? "color-style" : "").addClass(`activity-${o2.type}`);
        function _metro() {
          for (i3 = 0; i3 < 5; i3++) {
            $7("<div/>").addClass("circle").appendTo(element2);
          }
        }
        function _square() {
          for (i3 = 0; i3 < 4; i3++) {
            $7("<div/>").addClass("square").appendTo(element2);
          }
        }
        function _cycle() {
          $7("<div/>").addClass("cycle").appendTo(element2);
        }
        function _ring() {
          for (i3 = 0; i3 < 5; i3++) {
            wrap = $7("<div/>").addClass("wrap").appendTo(element2);
            $7("<div/>").addClass("circle").appendTo(wrap);
          }
        }
        function _simple() {
          $7(`
                    <svg class="circular">
                        <circle class="path" 
                                cx="${o2.size / 2}" 
                                cy="${o2.size / 2}" 
                                r="${o2.radius}" 
                                fill="none" 
                                stroke-width="2" 
                                stroke-miterlimit="10"
                        />
                    </svg>
                `).appendTo(element2);
        }
        function _atom() {
          for (i3 = 0; i3 < 3; i3++) {
            $7("<span/>").addClass("electron").appendTo(element2);
          }
        }
        function _bars() {
          for (i3 = 0; i3 < 6; i3++) {
            $7("<span/>").addClass("bar").appendTo(element2);
          }
        }
        switch (o2.type) {
          case "metro":
            _metro();
            break;
          case "square":
            _square();
            break;
          case "cycle":
            _cycle();
            break;
          case "simple":
            _simple();
            break;
          case "atom":
            _atom();
            break;
          case "bars":
            _bars();
            break;
          default:
            _ring();
        }
        this._fireEvent("activity-create", {
          element: element2
        });
      },
      changeAttribute: (attributeName) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
    Metro2.activity = {
      open: (options = {}) => {
        const o2 = options;
        const activity = `<div data-role="activity" data-type="${o2.type ? o2.type : "cycle"}" data-style="${o2.style ? o2.style : "color"}"></div>`;
        const text = o2.text ? `<div class="text-center">${o2.text}</div>` : "";
        return Metro2.dialog.create({
          content: activity + text,
          defaultActions: false,
          clsContent: "d-flex flex-column flex-center bg-transparent no-shadow w-auto",
          clsDialog: "no-border no-shadow bg-transparent global-dialog",
          autoHide: o2.autoHide ? o2.autoHide : 0,
          overlayClickClose: o2.overlayClickClose === true,
          overlayColor: o2.overlayColor ? o2.overlayColor : "#000000",
          overlayAlpha: o2.overlayAlpha ? o2.overlayAlpha : 0.5,
          clsOverlay: "global-overlay"
        });
      },
      close: (a2) => {
        Metro2.dialog.close(a2);
      }
    };
  })(Metro, Dom);

  // ../metroui-lib/source/components/adblock/adblock.js
  ((Metro2, $7) => {
    "use strict";
    let AdblockDefaultConfig = {
      adblockDeferred: 0,
      checkInterval: 1e3,
      fireOnce: true,
      checkStop: 10,
      localhost: false,
      onAlert: Metro2.noop,
      onFishingStart: Metro2.noop,
      onFishingDone: Metro2.noop
    };
    Metro2.adblockSetup = (options) => {
      AdblockDefaultConfig = $7.extend({}, AdblockDefaultConfig, options);
    };
    if (typeof globalThis.metroAdblockSetup !== "undefined") {
      Metro2.adblockSetup(globalThis.metroAdblockSetup);
    }
    const Adblock = {
      bite: () => {
        const classes = "adblock-bite adsense google-adsense dblclick advert topad top_ads topAds textads sponsoredtextlink_container show_ads right-banner rekl mpu module-ad mid_ad mediaget horizontal_ad headerAd contentAd brand-link bottombanner bottom_ad_block block_ad bannertop banner-right banner-body b-banner b-article-aside__banner b-advert adwrapper adverts advertisment advertisement:not(body) advertise advert_list adtable adsense adpic adlist adleft adinfo adi adholder adframe addiv ad_text ad_space ad_right ad_links ad_body ad_block ad_Right adTitle adText";
        $7("<div>").addClass(classes.split(" ").shuffle().join(" ")).css({
          position: "fixed",
          height: 1,
          width: 1,
          overflow: "hidden",
          visibility: "visible",
          top: 0,
          left: 0
        }).append($7("<a href='https://dblclick.net'>").html("dblclick.net")).appendTo("body");
        if (Adblock.options.adblockDeferred) {
          setTimeout(() => {
            Adblock.fishing();
          }, Adblock.options.adblockDeferred);
        } else Adblock.fishing();
      },
      fishing: () => {
        const o2 = Adblock.options;
        let checks = typeof o2.fireOnce === "number" ? o2.fireOnce : 0;
        let checkStop = o2.checkStop;
        let interval = false;
        const run = () => {
          const a2 = $7(".adsense.google-adsense.dblclick.advert.adblock-bite");
          const b5 = a2.find("a");
          const done = () => {
            clearInterval(interval);
            Metro2.utils.exec(o2.onFishingDone);
            $7(globalThis).fire("fishing-done");
            a2.remove();
          };
          if (!o2.localhost && $7.localhost) {
            done();
            return;
          }
          if (!a2.length || !b5.length || a2.css("display").indexOf("none") > -1 || b5.css("display").indexOf("none") > -1) {
            Metro2.utils.exec(Adblock.options.onAlert);
            $7(globalThis).fire("adblock-alert");
            if (Adblock.options.fireOnce === true) {
              done();
            } else {
              checks--;
              if (checks === 0) {
                done();
              }
            }
          } else {
            if (checkStop !== false) {
              checkStop--;
              if (checkStop === 0) {
                done();
              }
            }
          }
        };
        Metro2.utils.exec(o2.onFishingStart);
        $7(globalThis).fire("fishing-start");
        interval = setInterval(() => {
          run();
        }, Adblock.options.checkInterval);
        run();
      }
    };
    Metro2.Adblock = Adblock;
    $7(() => {
      Adblock.options = $7.extend({}, AdblockDefaultConfig);
      $7(globalThis).on("metro-initiated", () => {
        Adblock.bite();
      });
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/analog-clock/analog-clock.js
  ((Metro2, $7) => {
    "use strict";
    let AnalogClockDefaultConfig = {
      icon: null,
      showNumbers: false,
      showMoon: true,
      showDay: true,
      showDigitalClock: true,
      timeFormat: 24,
      onAnalogClockCreate: Metro2.noop
    };
    Metro2.analogClockSetup = (options) => {
      AnalogClockDefaultConfig = $7.extend({}, AnalogClockDefaultConfig, options);
    };
    if (typeof globalThis.metroAnalogClockSetup !== "undefined") {
      Metro2.analogClockSetup(globalThis.metroAnalogClockSetup);
    }
    Metro2.Component("analog-clock", {
      init: function(options, elem) {
        this._super(elem, options, AnalogClockDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("analog-clock-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const now = datetime();
        element2.addClass("analog-clock");
        if (o2.showNumbers) {
          element2.addClass("show-numbers");
        }
        for (let i3 = 1; i3 <= 12; i3++) {
          element2.append(`<label class="dash" style="--i: ${i3}"><span>${o2.showNumbers ? i3 : "|"}</span></label>`);
        }
        for (let i3 = 1; i3 <= 90; i3++) {
          if (i3 % 5 === 0) {
            continue;
          }
          element2.append(`<label class="secondary-dash" style="--i2: ${i3}"><span>|</span></label>`);
        }
        element2.append(`
                <div class="hands">
                    <div class="hour"></div>                
                    <div class="minute"></div>                
                    <div class="second"></div>                
                </div>
                  
            `);
        element2.append(`
                <div class="day-month">
                    <div class="day-month-inner">
                        <div class="day">${now.format("DD", this.locale)}</div>
                        <div class="month">${now.format("MMM", this.locale)}</div>                    
                    </div>
                    <div class="week-day">${now.format("dddd", this.locale)}</div>
                </div>
            `);
        if (o2.showDay === false) {
          element2.find(".day-month").hide();
        }
        element2.append(`
                <div class="digital-clock">
                    <div class="dc-hour">${now.format(o2.timeFormat === 24 ? "HH" : "hh", this.locale)}</div>
                    <div class="dc-minute">${now.format("mm", this.locale)}</div>
                    <div class="dc-second">${now.format("ss", this.locale)}</div>
                </div>
            `);
        if (o2.showDigitalClock === false) {
          element2.find(".digital-clock").hide();
        }
        if (o2.icon) {
          element2.append(`<div class="icon">${o2.icon}</div>`);
        }
        if (o2.showMoon === true) {
          element2.append(`<div class="moon"></div>`);
        }
        this._updateTime();
        setInterval(() => {
          element2.toggleClass("tick");
        }, 500);
      },
      _createEvents: () => {
      },
      _updateTime: function() {
        const element2 = this.element;
        const o2 = this.options;
        const secondHand = element2.find(".second");
        const minuteHand = element2.find(".minute");
        const hourHand = element2.find(".hour");
        const secondDig = element2.find(".dc-second");
        const minuteDig = element2.find(".dc-minute");
        const hourDig = element2.find(".dc-hour");
        const dayEl = element2.find(".day");
        const monthEl = element2.find(".month");
        const moonEl = element2.find(".moon");
        const updateTime = () => {
          const date = datetime();
          const sec = date.second() / 60 * 360;
          const min = date.minute() / 60 * 360;
          const hr4 = date.hour12() / 12 * 360 + min / 12;
          const day = date.format("DD", this.locale);
          const month = date.format("MMM", this.locale);
          const moon = date.moon();
          secondHand[0].style.transform = `rotate(${sec}deg)`;
          minuteHand[0].style.transform = `rotate(${min}deg)`;
          hourHand[0].style.transform = `rotate(${hr4}deg)`;
          dayEl.html(day);
          monthEl.html(month);
          moonEl.removeClass("").addClass(`${moon.name}`);
          hourDig[0].innerHTML = date.format(o2.timeFormat === 24 ? "HH" : "hh", this.locale);
          minuteDig[0].innerHTML = date.format("mm", this.locale);
          secondDig[0].innerHTML = date.format("ss", this.locale);
        };
        updateTime();
        setInterval(updateTime, 1e3);
      },
      changeAttribute: (attr, newValue) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/app-bar/app-bar.js
  ((Metro2, $7) => {
    "use strict";
    let AppBarDefaultConfig = {
      appbarDeferred: 0,
      expand: false,
      expandPoint: null,
      duration: 100,
      checkHamburgerColor: false,
      onMenuOpen: Metro2.noop,
      onMenuClose: Metro2.noop,
      onBeforeMenuOpen: Metro2.noop,
      onBeforeMenuClose: Metro2.noop,
      onMenuCollapse: Metro2.noop,
      onMenuExpand: Metro2.noop,
      onAppBarCreate: Metro2.noop
    };
    Metro2.appBarSetup = (options) => {
      AppBarDefaultConfig = $7.extend({}, AppBarDefaultConfig, options);
    };
    if (typeof globalThis.metroAppBarSetup !== "undefined") {
      Metro2.appBarSetup(globalThis.metroAppBarSetup);
    }
    Metro2.Component("app-bar", {
      init: function(options, elem) {
        this._super(elem, options, AppBarDefaultConfig, {
          id: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this.id = element2.attr("id") || Hooks.useId(this.elem);
        this._createStructure();
        this._createEvents();
        this._fireEvent("app-bar-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        let hamburger;
        let menu;
        const elementColor = Metro2.utils.getStyleOne(element2, "background-color");
        element2.addClass("app-bar").attr("role", "navigation");
        hamburger = element2.find(".hamburger");
        if (hamburger.length === 0) {
          hamburger = $7("<button>").attr("type", "button").addClass("hamburger menu-down").attr("aria-label", "Toggle menu").attr("aria-expanded", "false").attr("aria-controls", `app-bar-menu-${this.id}`);
          for (let i3 = 0; i3 < 3; i3++) {
            $7("<span>").addClass("line").appendTo(hamburger);
          }
        }
        element2.prepend(hamburger);
        menu = element2.find(".app-bar-menu");
        if (menu.length > 0) {
          menu.attr("id", `app-bar-menu-${this.id}`);
          menu.attr("role", "menubar");
        }
        if (menu.length === 0) {
          hamburger.css("display", "none");
        } else {
          menu.find("li").attr("role", "menuitem");
          menu.find("li a").attr("tabindex", "0");
          menu.find("li:has(ul)").attr("aria-haspopup", "true");
          menu.find("li ul").attr("role", "menu").attr("aria-hidden", "true");
        }
        if (hamburger.css("display") === "block") {
          menu.hide().addClass("collapsed");
          hamburger.removeClass("hidden");
        } else {
          hamburger.addClass("hidden");
        }
        if (o2.expand === true) {
          element2.addClass("app-bar-expand");
          hamburger.addClass("hidden");
        } else {
          if (Metro2.utils.isValue(o2.expandPoint) && Metro2.utils.mediaExist(o2.expandPoint)) {
            element2.addClass("app-bar-expand");
            hamburger.addClass("hidden");
          }
        }
        if (o2.checkHamburgerColor === true) {
        }
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const menu = element2.find(".app-bar-menu");
        const hamburger = element2.find(".hamburger");
        element2.on(Metro2.events.click, ".hamburger", () => {
          if (menu.length === 0) return;
          const collapsed = menu.hasClass("collapsed");
          if (collapsed) {
            that.open();
          } else {
            that.close();
          }
        });
        hamburger.on("keydown", (e2) => {
          if (e2.keyCode === 13 || e2.keyCode === 32) {
            e2.preventDefault();
            hamburger.trigger("click");
          }
        });
        menu.find("li a").on("keydown", function(e2) {
          if (e2.keyCode === 13 || e2.keyCode === 32) {
            e2.preventDefault();
            $7(this).trigger("click");
          }
          if (e2.keyCode === 27) {
            e2.preventDefault();
            that.close();
            hamburger.focus();
          }
        });
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            if (o2.expand !== true) {
              if (Metro2.utils.isValue(o2.expandPoint) && Metro2.utils.mediaExist(o2.expandPoint)) {
                element2.addClass("app-bar-expand");
                that._fireEvent("menu-expand");
              } else {
                element2.removeClass("app-bar-expand");
                that._fireEvent("menu-collapse");
              }
            }
            if (menu.length === 0) {
              hamburger.addClass("hidden");
              return;
            }
            menu.removeClass("opened").removeClass("collapsed");
            if (hamburger.css("display") !== "block") {
              hamburger.addClass("hidden");
              menu.show();
            } else {
              hamburger.removeClass("hidden");
              if (hamburger.hasClass("active")) {
                menu.removeClass("collapsed").addClass("opened");
              } else {
                menu.addClass("collapsed").removeClass("opened");
              }
            }
          },
          { ns: this.id }
        );
      },
      close: function() {
        const element2 = this.element;
        const o2 = this.options;
        const menu = element2.find(".app-bar-menu");
        const hamburger = element2.find(".hamburger");
        this._fireEvent("before-menu-close", {
          menu: menu[0]
        });
        hamburger.attr("aria-expanded", "false");
        menu.find("ul").attr("aria-hidden", "true");
        menu.slideUp(o2.duration, () => {
          menu.addClass("collapsed").removeClass("opened");
          hamburger.removeClass("active");
          this._fireEvent("menu-close", {
            menu: menu[0]
          });
        });
      },
      open: function() {
        const element2 = this.element;
        const o2 = this.options;
        const menu = element2.find(".app-bar-menu");
        const hamburger = element2.find(".hamburger");
        this._fireEvent("before-menu-open", {
          menu: menu[0]
        });
        hamburger.attr("aria-expanded", "true");
        menu.find("ul").attr("aria-hidden", "false");
        menu.slideDown(o2.duration, () => {
          menu.removeClass("collapsed").addClass("opened");
          hamburger.addClass("active");
          this._fireEvent("menu-open", {
            menu: menu[0]
          });
        });
      },
      changeAttribute: (attr, val) => {
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, ".hamburger");
        $7(globalThis).off(Metro2.events.resize, { ns: this.id });
        element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/audio-button/audio-button.js
  ((Metro2, $7) => {
    "use strict";
    let AudioButtonDefaultConfig = {
      audioVolume: 0.5,
      audioSrc: "",
      onStart: Metro2.noop,
      onEnd: Metro2.noop,
      onProgress: Metro2.noop,
      onAudioButtonCreate: Metro2.noop
    };
    Metro2.audioButtonSetup = (options) => {
      AudioButtonDefaultConfig = $7.extend({}, AudioButtonDefaultConfig, options);
    };
    if (typeof globalThis.metroAudioButtonSetup !== "undefined") {
      Metro2.audioButtonSetup(globalThis.metroAudioButtonSetup);
    }
    Metro2.Component("audio-button", {
      init: function(options, elem) {
        this._super(elem, options, AudioButtonDefaultConfig, {
          audio: null,
          canPlay: null,
          id: null,
          playing: false,
          duration: 0
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this.id = Hooks.useId(this.elem);
        this._createStructure();
        this._createEvents();
        this._fireEvent("audioButtonCreate", {
          element: element2
        });
      },
      _createStructure: function() {
        const o2 = this.options;
        this.audio = new Audio(o2.audioSrc);
        this.audio.volume = o2.audioVolume;
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        const audio = this.audio;
        audio.addEventListener("loadedmetadata", () => {
          this.duration = audio.duration.toFixed(0);
        });
        audio.addEventListener("loadeddata", () => {
          this.canPlay = true;
        });
        audio.addEventListener("ended", () => {
          this.playing = false;
          this._fireEvent("end", {
            src: o2.audioSrc,
            audio
          });
        });
        audio.addEventListener("timeupdate", () => {
          const position = audio.currentTime;
          const percent = Math.round(audio.currentTime * 100 / this.duration);
          this._fireEvent("progress", {
            duration: this.duration,
            position,
            percent
          });
        });
        element2.on(
          Metro2.events.click,
          () => {
            this.play();
          },
          { ns: this.id }
        );
      },
      play: function(cb) {
        const element2 = this.element;
        const o2 = this.options;
        const audio = this.audio;
        if (this.playing) {
          this.stop();
          return;
        }
        element2.addClass("playing");
        if (o2.audioSrc !== "" && this.audio.duration && this.canPlay) {
          this.playing = true;
          this._fireEvent("start", {
            src: o2.audioSrc,
            audio
          });
          audio.pause();
          audio.currentTime = 0;
          audio.play();
          Metro2.utils.exec(cb, [audio], element2[0]);
        }
      },
      stop: function(cb) {
        const element2 = this.element;
        const o2 = this.options;
        const audio = this.audio;
        this.playing = false;
        element2.removeClass("playing");
        audio.pause();
        audio.currentTime = 0;
        this._fireEvent("end", {
          src: o2.audioSrc,
          audio
        });
        Metro2.utils.exec(cb, [audio], element2[0]);
      },
      changeAttribute: function(attributeName) {
        const element2 = this.element;
        const o2 = this.options;
        const audio = this.audio;
        const changeSrc = () => {
          const src = element2.attr("data-audio-src");
          if (src && src.trim() !== "") {
            o2.audioSrc = src;
            audio.src = src;
          }
        };
        const changeVolume = () => {
          const volume = Number.parseFloat(element2.attr("data-audio-volume"));
          if (isNaN(volume)) {
            return;
          }
          o2.audioVolume = volume;
          audio.volume = volume;
        };
        if (attributeName === "data-audio-src") {
          changeSrc();
        }
        if (attributeName === "data-audio-volume") {
          changeVolume();
        }
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, { ns: this.id });
        element2.remove();
      }
    });
    Metro2.playSound = (data) => {
      const src = typeof data === "string" ? data : data.audioSrc;
      const volume = data?.audioVolume ? data.audioVolume : 0.5;
      if (!src) {
        return;
      }
      const audio = new Audio(src);
      audio.volume = Number.parseFloat(volume);
      audio.addEventListener("loadeddata", function() {
        if (data?.onAudioStart) Metro2.utils.exec(data.onAudioStart, [src], this);
        this.play();
      });
      audio.addEventListener("ended", function() {
        if (data?.onAudioEnd) Metro2.utils.exec(data.onAudioEnd, [null], this);
      });
    };
  })(Metro, Dom);

  // ../metroui-lib/source/components/slider/slider.js
  ((Metro2, $7) => {
    "use strict";
    let SliderDefaultConfig = {
      sliderDeferred: 0,
      roundValue: true,
      min: 0,
      max: 100,
      accuracy: 0,
      showMinMax: false,
      minMaxPosition: Metro2.position.TOP,
      value: 0,
      buffer: 0,
      hint: false,
      hintAlways: false,
      hintPosition: Metro2.position.TOP,
      hintMask: "$1",
      vertical: false,
      target: null,
      returnType: "value",
      // value or percent
      size: 0,
      label: null,
      hideButton: false,
      clsSlider: "",
      clsBackside: "",
      clsComplete: "",
      clsBuffer: "",
      clsMarker: "",
      clsHint: "",
      clsMinMax: "",
      clsMin: "",
      clsMax: "",
      onStart: Metro2.noop,
      onStop: Metro2.noop,
      onMove: Metro2.noop,
      onSliderClick: Metro2.noop,
      onChange: Metro2.noop,
      onChangeValue: Metro2.noop,
      onChangeBuffer: Metro2.noop,
      onFocus: Metro2.noop,
      onBlur: Metro2.noop,
      onSliderCreate: Metro2.noop
    };
    Metro2.sliderSetup = (options) => {
      SliderDefaultConfig = $7.extend({}, SliderDefaultConfig, options);
    };
    if (typeof globalThis.metroSliderSetup !== "undefined") {
      Metro2.sliderSetup(globalThis.metroSliderSetup);
    }
    Metro2.Component("slider", {
      init: function(options, elem) {
        this._super(elem, options, SliderDefaultConfig, {
          slider: null,
          value: 0,
          percent: 0,
          pixel: 0,
          buffer: 0,
          keyInterval: false,
          id: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        this.id = element2.attr("id") || Hooks.useId(this.elem);
        this._createSlider();
        this._createEvents();
        this.buff(o2.buffer);
        this.val(o2.value);
        this._fireEvent("slider-create", {
          element: element2
        });
      },
      _createSlider: function() {
        const element2 = this.element;
        const o2 = this.options;
        const backside = $7("<div>").addClass("backside").addClass(o2.clsBackside);
        const complete = $7("<div>").addClass("complete").addClass(o2.clsComplete);
        const buffer = $7("<div>").addClass("buffer").addClass(o2.clsBuffer);
        const marker = $7("<button>").attr("type", "button").addClass("marker").addClass(o2.clsMarker);
        const hint = $7("<div>").addClass("hint").addClass(`${o2.hintPosition}-side`).addClass(o2.clsHint);
        let i3;
        const slider = element2.wrap("<div>").addClass("slider").addClass(element2[0].className).addClass(o2.clsSlider);
        if (o2.size > 0) {
          if (o2.vertical === true) {
            slider.outerHeight(o2.size);
          } else {
            slider.outerWidth(o2.size);
          }
        }
        if (o2.vertical === true) {
          slider.addClass("vertical-slider");
        }
        if (o2.hintAlways === true) {
          hint.css({
            display: "block"
          }).addClass("permanent-hint");
        }
        if (o2.label) {
          const label = $7("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(slider);
          if (element2.id()) {
            label.attr("for", element2.id());
          } else {
            const id = Hooks.useId(element2[0]);
            label.attr("for", id);
            element2.attr("id", id);
          }
        }
        backside.appendTo(slider);
        complete.appendTo(slider);
        buffer.appendTo(slider);
        marker.appendTo(slider);
        hint.appendTo(marker);
        if (o2.hideButton === true) {
          slider.addClass("hidden-button");
        }
        if (o2.showMinMax === true) {
          const min_max_wrapper = $7("<div>").addClass("slider-min-max").addClass(o2.clsMinMax);
          $7("<span>").addClass("slider-text-min").addClass(o2.clsMin).html(o2.min).appendTo(min_max_wrapper);
          $7("<span>").addClass("slider-text-max").addClass(o2.clsMax).html(o2.max).appendTo(min_max_wrapper);
          if (o2.minMaxPosition === Metro2.position.TOP) {
            min_max_wrapper.insertBefore(slider);
          } else {
            min_max_wrapper.insertAfter(slider);
          }
        }
        element2[0].className = "";
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        this.slider = slider;
      },
      _createEvents: function() {
        const slider = this.slider;
        const o2 = this.options;
        const marker = slider.find(".marker");
        const hint = slider.find(".hint");
        marker.on(Metro2.events.startAll, () => {
          if (o2.hint === true && o2.hintAlways !== true) {
            hint.fadeIn(300);
          }
          $7(document).on(
            Metro2.events.moveAll,
            (e2) => {
              if (e2.cancelable) e2.preventDefault();
              this._move(e2);
              this._fireEvent("move", {
                val: this.value,
                percent: this.percent
              });
            },
            { ns: this.id, passive: false }
          );
          $7(document).on(
            Metro2.events.stopAll,
            () => {
              $7(document).off(Metro2.events.moveAll, { ns: this.id });
              $7(document).off(Metro2.events.stopAll, { ns: this.id });
              if (o2.hintAlways !== true) {
                hint.fadeOut(300);
              }
              this._fireEvent("stop", {
                val: this.value,
                percent: this.percent
              });
            },
            { ns: this.id }
          );
          this._fireEvent("start", {
            val: this.value,
            percent: this.percent
          });
        });
        marker.on(Metro2.events.focus, () => {
          this._fireEvent("focus", {
            val: this.value,
            percent: this.percent
          });
        });
        marker.on(Metro2.events.blur, () => {
          this._fireEvent("blur", {
            val: this.value,
            percent: this.percent
          });
        });
        marker.on(Metro2.events.keydown, (e2) => {
          const key = e2.keyCode ? e2.keyCode : e2.which;
          if ([37, 38, 39, 40].indexOf(key) === -1) {
            return;
          }
          const step = o2.accuracy === 0 ? 1 : o2.accuracy;
          if (this.keyInterval) {
            return;
          }
          this.keyInterval = setInterval(() => {
            let val = this.value;
            if (e2.keyCode === 37 || e2.keyCode === 40) {
              if (val - step < o2.min) {
                val = o2.min;
              } else {
                val -= step;
              }
            }
            if (e2.keyCode === 38 || e2.keyCode === 39) {
              if (val + step > o2.max) {
                val = o2.max;
              } else {
                val += step;
              }
            }
            this.value = this._correct(val);
            this.percent = this._convert(this.value, "val2prc");
            this.pixel = this._convert(this.percent, "prc2pix");
            this._redraw();
          }, 100);
          e2.preventDefault();
        });
        marker.on(Metro2.events.keyup, () => {
          clearInterval(this.keyInterval);
          this.keyInterval = false;
        });
        slider.on(Metro2.events.click, (e2) => {
          this._move(e2);
          this._fireEvent("slider-click", {
            val: this.value,
            percent: this.percent
          });
          this._fireEvent("stop", {
            val: this.value,
            percent: this.percent
          });
        });
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            this.val(this.value);
            this.buff(this.buffer);
          },
          { ns: this.id }
        );
      },
      _convert: function(v5, how) {
        const slider = this.slider;
        const o2 = this.options;
        const length = (o2.vertical === true ? slider.outerHeight() : slider.outerWidth()) - slider.find(".marker").outerWidth();
        switch (how) {
          case "pix2prc":
            return v5 * 100 / length;
          case "pix2val":
            return this._convert(v5, "pix2prc") * ((o2.max - o2.min) / 100) + o2.min;
          case "val2prc":
            return (v5 - o2.min) / ((o2.max - o2.min) / 100);
          case "prc2pix":
            return v5 / (100 / length);
          case "val2pix":
            return this._convert(this._convert(v5, "val2prc"), "prc2pix");
        }
        return 0;
      },
      _correct: function(value) {
        let res = value;
        const accuracy = this.options.accuracy;
        const min = this.options.min;
        const max = this.options.max;
        if (accuracy === 0 || isNaN(accuracy)) {
          return res;
        }
        res = Math.round(value / accuracy) * accuracy;
        if (res < min) {
          res = min;
        }
        if (res > max) {
          res = max;
        }
        return res.toFixed(Metro2.utils.decCount(accuracy));
      },
      _move: function(e2) {
        const slider = this.slider;
        const o2 = this.options;
        const offset = slider.offset();
        const marker_size = slider.find(".marker").outerWidth();
        const length = o2.vertical === true ? slider.outerHeight() : slider.outerWidth();
        const cStart = 0;
        const cStop = length - marker_size;
        const cPos = o2.vertical === true ? Metro2.utils.pageXY(e2).y - offset.top : Metro2.utils.pageXY(e2).x - offset.left;
        const cPix = o2.vertical === true ? length - cPos - marker_size / 2 : cPos - marker_size / 2;
        if (cPix < cStart || cPix > cStop) {
          return;
        }
        this.value = this._correct(this._convert(cPix, "pix2val"));
        this.percent = this._convert(this.value, "val2prc");
        this.pixel = this._convert(this.percent, "prc2pix");
        this._redraw();
      },
      _hint: function() {
        const o2 = this.options;
        const slider = this.slider;
        const hint = slider.find(".hint");
        let value = +this.value || 0;
        let percent = +this.percent || 0;
        if (o2.roundValue) {
          value = (Metro2.utils.isValue(value) ? +value : 0).toFixed(Metro2.utils.decCount(o2.accuracy));
          percent = (Metro2.utils.isValue(percent) ? +percent : 0).toFixed(Metro2.utils.decCount(o2.accuracy));
        }
        hint.text(o2.hintMask.replace("$1", value).replace("$2", percent));
      },
      _value: function() {
        const element2 = this.element;
        const o2 = this.options;
        let value = o2.returnType === "value" ? this.value : this.percent;
        let percent = this.percent;
        let buffer = this.buffer;
        if (o2.roundValue) {
          value = (Metro2.utils.isValue(value) ? +value : 0).toFixed(Metro2.utils.decCount(o2.accuracy));
          percent = (Metro2.utils.isValue(percent) ? +percent : 0).toFixed(Metro2.utils.decCount(o2.accuracy));
          buffer = (Metro2.utils.isValue(buffer) ? +buffer : 0).toFixed(Metro2.utils.decCount(o2.accuracy));
        }
        if (element2[0].tagName === "INPUT") {
          element2.val(value);
        }
        if (o2.target !== null) {
          const target = $7(o2.target);
          if (target.length !== 0) {
            $7.each(target, function() {
              const t = $7(this);
              if (this.tagName === "INPUT") {
                t.val(value);
              } else {
                t.text(value);
              }
              t.trigger("change");
            });
          }
        }
        this._fireEvent("change-value", {
          val: value
        });
        this._fireEvent("change", {
          val: value,
          percent,
          buffer
        });
      },
      _marker: function() {
        const slider = this.slider;
        const o2 = this.options;
        const marker = slider.find(".marker");
        const complete = slider.find(".complete");
        const length = o2.vertical === true ? slider.outerHeight() : slider.outerWidth();
        const marker_size = Number.parseInt(Metro2.utils.getStyleOne(marker, "width"));
        const slider_visible = Metro2.utils.isVisible(slider);
        if (slider_visible) {
          marker.css({
            "margin-top": 0,
            "margin-left": 0
          });
        }
        if (o2.vertical === true) {
          if (slider_visible) {
            marker.css("top", length - this.pixel);
          } else {
            marker.css("top", `${100 - this.percent}%`);
            marker.css("margin-top", marker_size / 2);
          }
          complete.css("height", `${this.percent}%`);
        } else {
          if (slider_visible) {
            marker.css("left", this.pixel);
          } else {
            marker.css("left", `${this.percent}%`);
            marker.css("margin-left", this.percent === 0 ? 0 : -1 * marker_size / 2);
          }
          complete.css("width", `${this.percent}%`);
        }
      },
      _redraw: function() {
        this._marker();
        this._value();
        this._hint();
      },
      _buffer: function() {
        const element2 = this.element;
        const o2 = this.options;
        const buffer = this.slider.find(".buffer");
        if (o2.vertical === true) {
          buffer.css("height", `${this.buffer}%`);
        } else {
          buffer.css("width", `${this.buffer}%`);
        }
        this._fireEvent("change-buffer", {
          val: this.buffer
        });
        this._fireEvent("change", {
          val: element2.val(),
          percent: this.percent,
          buffer: this.buffer
        });
      },
      val: function(v5) {
        const o2 = this.options;
        if (v5 === void 0 || isNaN(v5)) {
          return this.value;
        }
        let value = Number.parseFloat(v5);
        if (value < o2.min) {
          value = o2.min;
        }
        if (value > o2.max) {
          value = o2.max;
        }
        this.value = this._correct(value);
        this.percent = this._convert(this.value, "val2prc");
        this.pixel = this._convert(this.percent, "prc2pix");
        this._redraw();
      },
      buff: function(v5) {
        const slider = this.slider;
        const buffer = slider.find(".buffer");
        if (v5 === void 0 || isNaN(v5)) {
          return this.buffer;
        }
        if (buffer.length === 0) {
          return false;
        }
        let value = Number.parseFloat(v5);
        if (value > 100) {
          value = 100;
        }
        if (value < 0) {
          value = 0;
        }
        this.buffer = value;
        this._buffer();
      },
      changeValue: function() {
        const element2 = this.element;
        const o2 = this.options;
        let val = element2.attr("data-value");
        if (val < o2.min) {
          val = o2.min;
        }
        if (val > o2.max) {
          val = o2.max;
        }
        this.val(val);
      },
      changeBuffer: function() {
        const element2 = this.element;
        let val = Number.parseInt(element2.attr("data-buffer"));
        if (val < 0) {
          val = 0;
        }
        if (val > 100) {
          val = 100;
        }
        this.buff(val);
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-value":
            this.changeValue();
            break;
          case "data-buffer":
            this.changeBuffer();
            break;
          case "disabled":
            this.toggleState();
            break;
        }
      },
      destroy: function() {
        const o2 = this.options;
        const slider = this.slider;
        const marker = slider.find(".marker");
        marker.off(Metro2.events.startAll);
        marker.off(Metro2.events.focus);
        marker.off(Metro2.events.blur);
        marker.off(Metro2.events.keydown);
        marker.off(Metro2.events.keyup);
        slider.off(Metro2.events.click);
        $7(globalThis).off(Metro2.events.resize, { ns: this.id });
        if (o2.label) {
          slider.prev("label").remove();
        }
        slider.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/audio-player/audio-player.js
  ((Metro2, $7) => {
    "use strict";
    let AudioPlayerDefaultConfig = {
      audioDeferred: 0,
      playlist: null,
      src: null,
      volume: 0.5,
      loop: false,
      autoplay: false,
      showLoop: true,
      showPlay: true,
      showStop: true,
      showMute: true,
      showFull: true,
      showStream: true,
      showVolume: true,
      showInfo: true,
      showPlaylist: true,
      showNext: true,
      showPrev: true,
      showFirst: true,
      showLast: true,
      showForward: true,
      showBackward: true,
      showShuffle: true,
      showRandom: true,
      loopIcon: "\u2B94",
      stopIcon: "\u23F9",
      playIcon: "\u25B6",
      pauseIcon: "\u23F8",
      muteIcon: "\u{1F507}",
      volumeLowIcon: "\u{1F508}",
      volumeMediumIcon: "\u{1F509}",
      volumeHighIcon: "\u{1F50A}",
      playlistIcon: "\u{1F4C3}",
      nextIcon: "\u2192",
      prevIcon: "\u2190",
      firstIcon: "\u21E4",
      lastIcon: "\u21E5",
      forwardIcon: "\u21C9",
      backwardIcon: "\u21C7",
      shuffleIcon: "\u{1F500}",
      randomIcon: "\u{1F3B2}",
      onPlay: Metro2.noop,
      onPause: Metro2.noop,
      onStop: Metro2.noop,
      onEnd: Metro2.noop,
      onMetadata: Metro2.noop,
      onTime: Metro2.noop,
      onAudioPlayerCreate: Metro2.noop
    };
    Metro2.audioPlayerSetup = (options) => {
      AudioPlayerDefaultConfig = $7.extend({}, AudioPlayerDefaultConfig, options);
    };
    if (typeof globalThis.metroAudioPlayerSetup !== "undefined") {
      Metro2.audioPlayerSetup(globalThis.metroAudioPlayerSetup);
    }
    Metro2.Component("audio-player", {
      init: function(options, elem) {
        this._super(elem, options, AudioPlayerDefaultConfig, {
          player: null,
          audio: elem,
          stream: null,
          volume: null,
          volumeBackup: 0,
          muted: false
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        this._createPlayer();
        this._createEvents();
        if (o2.autoplay === true) {
          this.play();
        }
        this._fireEvent("audio-player-create", {
          element: element2,
          player: this.player
        });
      },
      _createPlayer: function() {
        const element2 = this.element;
        const o2 = this.options;
        const audio = this.audio;
        const player = element2.wrap("<div>").addClass(`media-player audio-player ${element2[0].className}`);
        $7.each(["muted", "autoplay", "controls", "height", "width", "loop", "poster", "preload"], function() {
          element2.removeAttr(this);
        });
        element2.attr("preload", "auto");
        audio.volume = o2.volume;
        if (o2.src !== null) {
          this._setSource(o2.src);
        }
        element2[0].className = "";
        this.player = player;
        this._createControls();
      },
      _setSource: function(src) {
        const element2 = this.element;
        element2.find("source").remove();
        element2.removeAttr("src");
        if (Array.isArray(src)) {
          $7.each(src, function() {
            if (this.src === void 0) return;
            $7("<source>").attr("src", this.src).attr("type", this.type !== void 0 ? this.type : "").appendTo(element2);
          });
        } else {
          element2.attr("src", src);
        }
      },
      _createControls: function() {
        const element2 = this.element;
        const o2 = this.options;
        const audio = this.elem;
        const controls = $7("<div>").addClass("controls").addClass(o2.clsControls).insertAfter(element2);
        const stream = $7("<div>").addClass("stream").appendTo(controls);
        const streamSlider = $7("<input>").addClass("stream-slider ultra-thin cycle-marker").appendTo(stream);
        const volume = $7("<div>").addClass("volume").appendTo(controls);
        const volumeSlider = $7("<input>").addClass("volume-slider ultra-thin cycle-marker").appendTo(volume);
        const infoBox = $7("<div>").addClass("info-box").appendTo(controls);
        if (o2.showInfo !== true) {
          infoBox.hide();
        }
        Metro2.makePlugin(streamSlider, "slider", {
          clsMarker: "bg-dark-cyan",
          clsHint: "bg-cyan fg-white",
          clsComplete: "bg-cyan",
          hint: true,
          hideButton: true,
          onStart: () => {
            if (!audio.paused) audio.pause();
          },
          onStop: (val) => {
            if (audio.seekable.length > 0) {
              audio.currentTime = (this.duration * val / 100).toFixed(0);
            }
            if (audio.paused && audio.currentTime > 0) {
              audio.play();
            }
          }
        });
        this.stream = streamSlider;
        if (o2.showStream !== true) {
          stream.hide();
        }
        Metro2.makePlugin(volumeSlider, "slider", {
          clsMarker: "bg-dark-red",
          clsHint: "bg-cyan fg-white",
          clsComplete: "bg-red",
          hint: true,
          hideButton: true,
          value: o2.volume * 100,
          onChangeValue: (val) => {
            audio.volume = val / 100;
          }
        });
        this.volume = volumeSlider;
        if (o2.showVolume !== true) {
          volume.hide();
        }
        let loop;
        if (o2.showLoop === true) {
          loop = $7("<button>").attr("type", "button").addClass("medium cycle loop").html(o2.loopIcon).appendTo(controls);
          loop.addClass("active");
          element2.attr("loop", "loop");
        }
        if (o2.showPlay === true) {
          $7("<button>").attr("type", "button").addClass("medium cycle play").html(o2.playIcon).appendTo(controls);
        }
        if (o2.showStop === true) {
          $7("<button>").attr("type", "button").addClass("medium cycle stop").html(o2.stopIcon).appendTo(controls);
        }
        if (o2.showMute === true) {
          $7("<button>").attr("type", "button").addClass("medium cycle mute").html(o2.muteIcon).appendTo(controls);
        }
        this._setVolume();
        if (o2.muted) {
          this.volumeBackup = audio.volume;
          Metro2.getPlugin(this.volume, "slider").val(0);
          audio.volume = 0;
        }
        infoBox.html("00:00 / 00:00");
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        const audio = this.elem;
        const player = this.player;
        element2.on("loadstart", () => {
        });
        element2.on("loadedmetadata", () => {
          this.duration = audio.duration.toFixed(0);
          this._setInfo(0, this.duration);
          Metro2.utils.exec(o2.onMetadata, [audio, player], element2[0]);
        });
        element2.on("canplay", () => {
          this._setBuffer();
        });
        element2.on("progress", () => {
          this._setBuffer();
        });
        element2.on("timeupdate", () => {
          const position = Math.round(audio.currentTime * 100 / this.duration);
          this._setInfo(audio.currentTime, this.duration);
          Metro2.getPlugin(this.stream, "slider").val(position);
          Metro2.utils.exec(o2.onTime, [audio.currentTime, this.duration, audio, player], element2[0]);
        });
        element2.on("waiting", () => {
        });
        element2.on("loadeddata", () => {
        });
        element2.on("play", () => {
          player.find(".play").html(o2.pauseIcon);
          Metro2.utils.exec(o2.onPlay, [audio, player], element2[0]);
        });
        element2.on("pause", () => {
          player.find(".play").html(o2.playIcon);
          Metro2.utils.exec(o2.onPause, [audio, player], element2[0]);
        });
        element2.on("stop", () => {
          Metro2.getPlugin(this.stream, "slider").val(0);
          Metro2.utils.exec(o2.onStop, [audio, player], element2[0]);
        });
        element2.on("ended", () => {
          Metro2.getPlugin(this.stream, "slider").val(0);
          Metro2.utils.exec(o2.onEnd, [audio, player], element2[0]);
        });
        element2.on("volumechange", () => {
          this._setVolume();
        });
        player.on(Metro2.events.click, ".play", () => {
          if (audio.paused) {
            this.play();
          } else {
            this.pause();
          }
        });
        player.on(Metro2.events.click, ".stop", () => {
          this.stop();
        });
        player.on(Metro2.events.click, ".mute", () => {
          this._toggleMute();
        });
        player.on(Metro2.events.click, ".loop", () => {
          this._toggleLoop();
        });
      },
      _toggleLoop: function() {
        const loop = this.player.find(".loop");
        if (loop.length === 0) return;
        loop.toggleClass("active");
        if (loop.hasClass("active")) {
          this.element.attr("loop", "loop");
        } else {
          this.element.removeAttr("loop");
        }
      },
      _toggleMute: function() {
        this.muted = !this.muted;
        if (this.muted === false) {
          this.audio.volume = this.volumeBackup;
        } else {
          this.volumeBackup = this.audio.volume;
          this.audio.volume = 0;
        }
        Metro2.getPlugin(this.volume, "slider").val(this.muted === false ? this.volumeBackup * 100 : 0);
      },
      _setInfo: function(a2, b5) {
        this.player.find(".info-box").html(
          `${Metro2.utils.secondsToFormattedString(Math.round(a2))} / ${Metro2.utils.secondsToFormattedString(Math.round(b5))}`
        );
      },
      _setBuffer: function() {
        const buffer = this.audio.buffered.length ? Math.round(Math.floor(this.audio.buffered.end(0)) / Math.floor(this.audio.duration) * 100) : 0;
        Metro2.getPlugin(this.stream, "slider").buff(buffer);
      },
      _setVolume: function() {
        const audio = this.audio;
        const player = this.player;
        const o2 = this.options;
        const volumeButton = player.find(".mute");
        const volume = audio.volume * 100;
        if (volume > 1 && volume < 30) {
          volumeButton.html(o2.volumeLowIcon);
        } else if (volume >= 30 && volume < 60) {
          volumeButton.html(o2.volumeMediumIcon);
        } else if (volume >= 60 && volume <= 100) {
          volumeButton.html(o2.volumeHighIcon);
        } else {
          volumeButton.html(o2.muteIcon);
        }
      },
      play: function(src) {
        if (src !== void 0) {
          this._setSource(src);
        }
        if (this.element.attr("src") === void 0 && this.element.find("source").length === 0) {
          return;
        }
        this.audio.play();
      },
      pause: function() {
        this.audio.pause();
      },
      resume: function() {
        if (this.audio.paused) {
          this.play();
        }
      },
      stop: function() {
        this.audio.pause();
        this.audio.currentTime = 0;
        Metro2.getPlugin(this.stream, "slider").val(0);
      },
      setVolume: function(v5) {
        if (v5 === void 0) {
          return this.audio.volume;
        }
        const volume = v5 > 1 ? v5 / 100 : v5;
        this.audio.volume = v5;
        Metro2.getPlugin(this.volume, "slider").val(volume * 100);
      },
      loop: function() {
        this._toggleLoop();
      },
      mute: function() {
        this._toggleMute();
      },
      changeSource: function() {
        const src = JSON.parse(this.element.attr("data-src"));
        this.play(src);
      },
      changeVolume: function() {
        const volume = this.element.attr("data-volume");
        this.setVolume(volume);
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-src":
            this.changeSource();
            break;
          case "data-volume":
            this.changeVolume();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const player = this.player;
        element2.off("all");
        player.off("all");
        Metro2.getPlugin(this.stream, "slider").destroy();
        Metro2.getPlugin(this.volume, "slider").destroy();
        element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/bar3d/bar3d.js
  ((Metro2, $7) => {
    "use strict";
    let Bar3dDefaultConfig = {
      height: 200,
      barColor: "#22ec1a",
      valueColor: "#191919",
      total: 100,
      value: 60,
      valueSuffix: "",
      animationDuration: 300,
      onBar3dCreate: Metro2.noop
    };
    Metro2.bar3dSetup = (options) => {
      Bar3dDefaultConfig = $7.extend({}, Bar3dDefaultConfig, options);
    };
    if (typeof window.metroBar3dSetup !== "undefined") {
      Metro2.bar3dSetup(window.metroBar3dSetup);
    }
    Metro2.Component("bar3d", {
      init: function(options, elem) {
        this._super(elem, options, Bar3dDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("component-create");
      },
      _drawBar: function() {
        const element2 = this.element;
        const o2 = this.options;
        const displayValue = o2.value + o2.valueSuffix;
        const barValue = 100 - Math.round(100 * o2.value / o2.total);
        element2.find(".growing-bar").attr("data-value", displayValue).css({
          transform: `translateY(${barValue}%)`,
          backgroundColor: o2.barColor
        });
        element2.attr("title", displayValue);
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("bar3d");
        element2.html(`
                <div class="side left-side">
                    <div class="growing-bar" data-value="0" style="transition-duration: ${o2.animationDuration}"></div>
                </div>
                <div class="side right-side">
                    <div class="growing-bar" data-value="0" style="transition-duration: ${o2.animationDuration}"></div>
                </div>
                <div class="side top-side"></div>
                <div class="side bottom-side"></div>
            `);
        if (o2.animationDuration > 0) {
          setTimeout(() => {
            this._drawBar();
          }, 100);
        } else {
          this._drawBar();
        }
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
      },
      changeAttribute: function(attr, newValue) {
        switch (attr) {
          case "data-value": {
            this.options.value = newValue;
            this._drawBar();
            break;
          }
        }
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/bulls/bulls.js
  ((Metro2, $7) => {
    "use strict";
    let BullDefaultConfig = {
      type: "success",
      // success, fail, pending
      size: 16,
      onBullCreate: Metro2.noop,
      onBullChange: Metro2.noop
    };
    Metro2.bullSetup = (options) => {
      BullDefaultConfig = $7.extend({}, BullDefaultConfig, options);
    };
    if (typeof globalThis.metroBullSetup !== "undefined") {
      Metro2.bullSetup(globalThis.metroBullSetup);
    }
    Metro2.Component("bull", {
      init: function(options, elem) {
        this._super(elem, options, BullDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._fireEvent("bull-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        let bull;
        switch (o2.type.toLowerCase()) {
          case "success":
            bull = `<svg width="${o2.size}" height="${o2.size}" aria-label="completed successfully" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path fill="#57ab5a" d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16Zm3.78-9.72a.751.751 0 0 0-.018-1.042.751.751 0 0 0-1.042-.018L6.75 9.19 5.28 7.72a.751.751 0 0 0-1.042.018.751.751 0 0 0-.018 1.042l2 2a.75.75 0 0 0 1.06 0Z"></path></svg>`;
            break;
          case "pending":
            bull = `<svg width="${o2.size}" height="${o2.size}" aria-label="currently running" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" class="ani-spin"><path fill="none" stroke="#DBAB0A" stroke-width="2" d="M3.05 3.05a7 7 0 1 1 9.9 9.9 7 7 0 0 1-9.9-9.9Z" opacity=".5"></path><path fill="#DBAB0A" fill-rule="evenodd" d="M8 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Z" clip-rule="evenodd"></path><path fill="#DBAB0A" d="M14 8a6 6 0 0 0-6-6V0a8 8 0 0 1 8 8h-2Z"></path></svg>`;
            break;
          case "fail":
            bull = `<svg width="${o2.size}" height="${o2.size}" aria-label="failed" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path fill="#e5534b" d="M2.343 13.657A8 8 0 1 1 13.658 2.343 8 8 0 0 1 2.343 13.657ZM6.03 4.97a.751.751 0 0 0-1.042.018.751.751 0 0 0-.018 1.042L6.94 8 4.97 9.97a.749.749 0 0 0 .326 1.275.749.749 0 0 0 .734-.215L8 9.06l1.97 1.97a.749.749 0 0 0 1.275-.326.749.749 0 0 0-.215-.734L9.06 8l1.97-1.97a.749.749 0 0 0-.326-1.275.749.749 0 0 0-.734.215L8 6.94Z"></path></svg>`;
            break;
          case "warning":
            bull = `<svg width="${o2.size}" height="${o2.size}" aria-label="warning" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path fill="#ff4d00" d="M246.312928,5.62892705 C252.927596,9.40873724 258.409564,14.8907053 262.189374,21.5053731 L444.667042,340.84129 C456.358134,361.300701 449.250007,387.363834 428.790595,399.054926 C422.34376,402.738832 415.04715,404.676552 407.622001,404.676552 L42.6666667,404.676552 C19.1025173,404.676552 7.10542736e-15,385.574034 7.10542736e-15,362.009885 C7.10542736e-15,354.584736 1.93772021,347.288125 5.62162594,340.84129 L188.099293,21.5053731 C199.790385,1.04596203 225.853517,-6.06216498 246.312928,5.62892705 Z M224,272 C208.761905,272 197.333333,283.264 197.333333,298.282667 C197.333333,313.984 208.415584,325.248 224,325.248 C239.238095,325.248 250.666667,313.984 250.666667,298.624 C250.666667,283.264 239.238095,272 224,272 Z M245.333333,106.666667 L202.666667,106.666667 L202.666667,234.666667 L245.333333,234.666667 L245.333333,106.666667 Z" id="Combined-Shape"></path></svg>`;
            break;
          case "bulb-on":
            bull = `<svg width="${o2.size}" height="${o2.size}" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path fill="#ffde21" d="M213.333333,85.3333333 C284.025781,85.3333333 341.333333,142.640885 341.333333,213.333333 C341.333333,260.711239 315.5928,302.077122 277.333732,324.208982 L277.333333,405.333333 L256,426.666667 L234.666667,426.666667 C234.666667,438.448741 225.115408,448 213.333333,448 C201.551259,448 192,438.448741 192,426.666667 L192,426.666667 L170.666667,426.666667 L149.333333,405.333333 L149.332954,324.208993 C111.073876,302.077136 85.3333333,260.711248 85.3333333,213.333333 C85.3333333,142.640885 142.640885,85.3333333 213.333333,85.3333333 Z M234.667665,339.563386 C227.72957,340.727434 220.602209,341.333333 213.333333,341.333333 C206.064458,341.333333 198.937097,340.727434 191.999002,339.563386 L192,384 L234.666667,384 L234.667665,339.563386 Z M96.4250122,307.614237 L119.052429,330.241654 L73.7975952,375.496488 L51.1701782,352.869071 L96.4250122,307.614237 Z M330.241654,307.614237 L375.496488,352.869071 L352.869071,375.496488 L307.614237,330.241654 L330.241654,307.614237 Z M426.666667,197.333333 L426.666667,229.333333 L362.666667,229.333333 L362.666667,197.333333 L426.666667,197.333333 Z M64,197.333333 L64,229.333333 L7.10542736e-15,229.333333 L7.10542736e-15,197.333333 L64,197.333333 Z M352.869071,51.1701782 L375.496488,73.7975952 L330.241654,119.052429 L307.614237,96.4250122 L352.869071,51.1701782 Z M73.7975952,51.1701782 L119.052429,96.4250122 L96.4250122,119.052429 L51.1701782,73.7975952 L73.7975952,51.1701782 Z M229.333333,-1.0658141e-14 L229.333333,64 L197.333333,64 L197.333333,-1.0658141e-14 L229.333333,-1.0658141e-14 Z" id="Combined-Shape"></path></svg>`;
            break;
          case "bulb-off":
            bull = `<svg width="${o2.size}" height="${o2.size}" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg>`;
            break;
          case "star":
            bull = `<svg width="${o2.size}" height="${o2.size}" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16Zm.252-12.932a.476.476 0 0 0-.682.195l-1.2 2.432-2.684.39a.477.477 0 0 0-.266.816l1.944 1.892-.46 2.674a.479.479 0 0 0 .694.504L8 10.709l2.4 1.261a.478.478 0 0 0 .694-.504l-.458-2.673L12.578 6.9a.479.479 0 0 0-.265-.815l-2.685-.39-1.2-2.432a.473.473 0 0 0-.176-.195Z"></path></svg>`;
            break;
          case "badge":
            bull = `<svg width="${o2.size}" height="${o2.size}" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M7.22 6.5a.72.72 0 1 1-1.44 0 .72.72 0 0 1 1.44 0Z"></path><path d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16ZM4 5v3.38c.001.397.159.778.44 1.059l3.211 3.213a1.202 1.202 0 0 0 1.698 0l3.303-3.303a1.202 1.202 0 0 0 0-1.698L9.439 4.44A1.5 1.5 0 0 0 8.379 4H5a1 1 0 0 0-1 1Z"></path></svg>`;
            break;
          case "chat":
            bull = `<svg width="${o2.size}" height="${o2.size}" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16ZM4 5v5a1 1 0 0 0 1 1h1v1.5a.5.5 0 0 0 .854.354L8.707 11H11a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1Z"></path></svg>`;
            break;
          case "tree":
            bull = `<svg width="${o2.size}" height="${o2.size}" aria-label="tree" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16ZM6 6.928a1.75 1.75 0 1 0-1 0V7.5A1.5 1.5 0 0 0 6.5 9h1v1.072a1.75 1.75 0 1 0 1 0V9h1A1.5 1.5 0 0 0 11 7.5v-.572a1.75 1.75 0 1 0-1 0V7.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5Z"></path></svg>`;
            break;
          case "dot":
            bull = `<svg width="${o2.size}" height="${o2.size}" aria-label="dot" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M8 9.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Z"></path><path d="M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0ZM1.5 8a6.5 6.5 0 1 0 13 0 6.5 6.5 0 0 0-13 0Z"></path></svg>`;
            break;
          case "checkmark":
            bull = `<svg width="${o2.size}" height="${o2.size}" aria-label="checkmark" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M11.28 6.78a.75.75 0 0 0-1.06-1.06L7.25 8.69 5.78 7.22a.75.75 0 0 0-1.06 1.06l2 2a.75.75 0 0 0 1.06 0l3.5-3.5Z"></path><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0Zm-1.5 0a6.5 6.5 0 1 0-13 0 6.5 6.5 0 0 0 13 0Z"></path></svg>`;
            break;
          case "cancel":
            bull = `<svg width="${o2.size}" height="${o2.size}" aria-label="cancel" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0ZM1.5 8a6.5 6.5 0 1 0 13 0 6.5 6.5 0 0 0-13 0Zm9.78-2.22-5.5 5.5a.749.749 0 0 1-1.275-.326.749.749 0 0 1 .215-.734l5.5-5.5a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042Z"></path></svg>`;
            break;
          case "rocket":
            bull = `<svg width="${o2.size}" height="${o2.size}" aria-label="rocket" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.064 0h.186C15.216 0 16 .784 16 1.75v.186a8.752 8.752 0 0 1-2.564 6.186l-.458.459c-.314.314-.641.616-.979.904v3.207c0 .608-.315 1.172-.833 1.49l-2.774 1.707a.749.749 0 0 1-1.11-.418l-.954-3.102a1.214 1.214 0 0 1-.145-.125L3.754 9.816a1.218 1.218 0 0 1-.124-.145L.528 8.717a.749.749 0 0 1-.418-1.11l1.71-2.774A1.748 1.748 0 0 1 3.31 4h3.204c.288-.338.59-.665.904-.979l.459-.458A8.749 8.749 0 0 1 14.064 0ZM8.938 3.623h-.002l-.458.458c-.76.76-1.437 1.598-2.02 2.5l-1.5 2.317 2.143 2.143 2.317-1.5c.902-.583 1.74-1.26 2.499-2.02l.459-.458a7.25 7.25 0 0 0 2.123-5.127V1.75a.25.25 0 0 0-.25-.25h-.186a7.249 7.249 0 0 0-5.125 2.123ZM3.56 14.56c-.732.732-2.334 1.045-3.005 1.148a.234.234 0 0 1-.201-.064.234.234 0 0 1-.064-.201c.103-.671.416-2.273 1.15-3.003a1.502 1.502 0 1 1 2.12 2.12Zm6.94-3.935c-.088.06-.177.118-.266.175l-2.35 1.521.548 1.783 1.949-1.2a.25.25 0 0 0 .119-.213ZM3.678 8.116 5.2 5.766c.058-.09.117-.178.176-.266H3.309a.25.25 0 0 0-.213.119l-1.2 1.95ZM12 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>`;
            break;
        }
        element2.clear().html(bull);
      },
      setType: function(type = "default") {
        const o2 = this.options;
        if (type === o2.type) {
          return;
        }
        o2.type = type.toLowerCase();
        this._createStructure();
        this._fireEvent("bull-change");
      },
      changeAttribute: function(attr, value) {
        if (attr === "data-type") {
          this._createStructure();
        }
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/button-group/button-group.js
  ((Metro2, $7) => {
    "use strict";
    let ButtonGroupDefaultConfig = {
      buttongroupDeferred: 0,
      target: "button",
      clsActive: "active",
      requiredButton: false,
      mode: Metro2.groupMode.ONE,
      onButtonClick: Metro2.noop,
      onGroupCreate: Metro2.noop
    };
    Metro2.buttonGroupSetup = (options) => {
      ButtonGroupDefaultConfig = $7.extend({}, ButtonGroupDefaultConfig, options);
    };
    if (typeof globalThis.metroButtonGroupSetup !== "undefined") {
      Metro2.buttonGroupSetup(globalThis.metroButtonGroupSetup);
    }
    Metro2.Component("button-group", {
      init: function(options, elem) {
        this._super(elem, options, ButtonGroupDefaultConfig, {
          active: null,
          id: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this.id = Hooks.useId(this.elem);
        this._createStruct();
        this._createEvents();
        this._fireEvent("group-create", {
          element: element2
        });
      },
      _createStruct: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("button-group");
        const buttons = element2.find(o2.target);
        const buttons_active = element2.find(o2.clsActive);
        if (o2.requiredButton === true && buttons_active.length === 0) {
          $7(buttons[0]).addClass(o2.clsActive).addClass("js-active");
        }
        if (o2.mode === Metro2.groupMode.ONE && buttons_active.length > 1) {
          buttons_active.removeClass("js-active").removeClass(o2.clsActive);
          $7(buttons_active[0]).addClass("js-active").addClass(o2.clsActive);
        }
        element2.find(".js-active").each(function() {
          that._fireEvent("button-click", {
            button: this
          });
        });
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        element2.find(o2.target).on(Metro2.events.click, function() {
          const el = $7(this);
          that._fireEvent("button-click", {
            button: this
          });
          if (o2.mode === Metro2.groupMode.ONE && el.hasClass("js-active")) {
            return;
          }
          if (o2.mode === Metro2.groupMode.ONE) {
            element2.find(o2.target).removeClass(o2.clsActive).removeClass("js-active");
            el.addClass("js-active").addClass(o2.clsActive);
          } else {
            el.toggleClass("js-active").toggleClass(o2.clsActive);
          }
        });
      },
      changeAttribute: (attr, val) => {
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.off(Metro2.events.click, o2.targets);
        element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/spinner/spinner.js
  ((Metro2, $7) => {
    "use strict";
    let SpinnerDefaultConfig = {
      spinnerDeferred: 0,
      label: "",
      step: 1,
      plusIcon: "+",
      minusIcon: "-",
      buttonsPosition: "default",
      defaultValue: 0,
      minValue: null,
      maxValue: null,
      fixed: 0,
      repeatThreshold: 2e3,
      hideCursor: false,
      clsSpinner: "",
      clsSpinnerInput: "",
      clsSpinnerButton: "",
      clsSpinnerButtonPlus: "",
      clsSpinnerButtonMinus: "",
      clsLabel: "",
      onBeforeChange: Metro2.noop_true,
      onChange: Metro2.noop,
      onPlusClick: Metro2.noop,
      onMinusClick: Metro2.noop,
      onArrowUp: Metro2.noop,
      onArrowDown: Metro2.noop,
      onButtonClick: Metro2.noop,
      onArrowClick: Metro2.noop,
      onSpinnerCreate: Metro2.noop
    };
    Metro2.spinnerSetup = (options) => {
      SpinnerDefaultConfig = $7.extend({}, SpinnerDefaultConfig, options);
    };
    if (typeof globalThis.metroSpinnerSetup !== "undefined") {
      Metro2.spinnerSetup(globalThis.metroSpinnerSetup);
    }
    Metro2.Component("spinner", {
      init: function(options, elem) {
        this._super(elem, options, SpinnerDefaultConfig, {
          repeat_timer: false
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("spinner-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const spinner = $7("<div>").addClass("spinner").addClass(`buttons-${o2.buttonsPosition}`).addClass(element2[0].className).addClass(o2.clsSpinner);
        const button_plus = $7("<button>").attr("type", "button").addClass("button spinner-button spinner-button-plus").addClass(`${o2.clsSpinnerButton} ${o2.clsSpinnerButtonPlus}`).html(o2.plusIcon);
        const button_minus = $7("<button>").attr("type", "button").addClass("button spinner-button spinner-button-minus").addClass(`${o2.clsSpinnerButton} ${o2.clsSpinnerButtonMinus}`).html(o2.minusIcon);
        const init_value = element2.val().trim();
        if (!Metro2.utils.isValue(init_value)) {
          element2.val(0);
        }
        element2[0].className = "";
        spinner.insertBefore(element2);
        element2.appendTo(spinner).addClass(o2.clsSpinnerInput);
        element2.addClass("metro-input");
        button_plus.appendTo(spinner);
        button_minus.appendTo(spinner);
        if (o2.hideCursor === true) {
          spinner.addClass("hide-cursor");
        }
        if (o2.label) {
          const label = $7("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(spinner);
          if (element2.attr("id")) {
            label.attr("for", element2.attr("id"));
          } else {
            const id = Hooks.useId(element2[0]);
            label.attr("for", id);
            element2.attr("id", id);
          }
          if (element2.attr("dir") === "rtl") {
            label.addClass("rtl");
          }
        }
        if (o2.disabled === true || element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        const spinner = element2.closest(".spinner");
        let repeat_timer;
        const spinnerButtonClick = (plus) => {
          const events = [
            plus ? "plus-click" : "minus-click",
            plus ? "arrow-up" : "arrow-down",
            "button-click",
            "arrow-click"
          ];
          const curr = +element2.val();
          let val = +element2.val();
          const step = +o2.step;
          if (plus) {
            val += step;
          } else {
            val -= step;
          }
          this._setValue(val.toFixed(o2.fixed), true);
          this._fireEvents(events, {
            curr,
            val,
            elementVal: element2.val(),
            button: plus ? "plus" : "minus"
          });
        };
        spinner.on(
          Metro2.events.startAll,
          ".spinner-button",
          function(e2) {
            const plus = $7(this).hasClass("spinner-button-plus");
            repeat_timer = setInterval(() => {
              spinnerButtonClick(plus);
            }, 300);
          },
          { passive: true }
        );
        spinner.on(
          Metro2.events.stopAll,
          ".spinner-button",
          (e2) => {
            clearInterval(repeat_timer);
          },
          { passive: true }
        );
        spinner.on(
          Metro2.events.click,
          ".spinner-button",
          function() {
            const plus = $7(this).hasClass("spinner-button-plus");
            spinnerButtonClick(plus);
          },
          { passive: true }
        );
        spinner.on(Metro2.events.click, (e2) => {
          $7(".focused").removeClass("focused");
          spinner.addClass("focused");
          e2.preventDefault();
          e2.stopPropagation();
        });
      },
      _setValue: function(val = 0, trigger_change = false) {
        const element2 = this.element;
        const o2 = this.options;
        if (Metro2.utils.exec(o2.onBeforeChange, [val], element2[0]) !== true) {
          return;
        }
        let _val = +val;
        if (o2.maxValue !== null && _val > +o2.maxValue) {
          _val = +o2.maxValue;
        }
        if (o2.minValue !== null && _val < +o2.minValue) {
          _val = +o2.minValue;
        }
        element2.val(_val);
        this._fireEvent("change", { val }, false, true);
        if (trigger_change === true) {
          element2.fire("change", {
            val
          });
        }
      },
      val: function(val) {
        const element2 = this.element;
        const o2 = this.options;
        if (!Metro2.utils.isValue(val)) {
          return element2.val();
        }
        this._setValue(val.toFixed(o2.fixed), true);
      },
      toDefault: function() {
        const o2 = this.options;
        const val = Metro2.utils.isValue(o2.defaultValue) ? Number(o2.defaultValue) : 0;
        this._setValue(val.toFixed(o2.fixed), true);
        this._fireEvent("change", {
          val
        });
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      changeAttribute: function(attributeName) {
        const element2 = this.element;
        const changeValue = () => {
          const val = element2.attr("value").trim();
          if (Metro2.utils.isValue(val)) {
            this._setValue(Number(val), false);
          }
        };
        switch (attributeName) {
          case "disabled":
            this.toggleState();
            break;
          case "value":
            changeValue();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        const spinner = element2.closest(".spinner");
        const spinner_buttons = spinner.find(".spinner-button");
        spinner.off(Metro2.events.click);
        spinner_buttons.off(Metro2.events.start);
        spinner_buttons.off(Metro2.events.stop);
        element2.off(Metro2.events.keydown);
        spinner.off(Metro2.events.keyup);
        if (o2.label) {
          spinner.prev("label").remove();
        }
        spinner.remove();
      }
    });
    $7(document).on(Metro2.events.click, () => {
      $7(".spinner").removeClass("focused");
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/calendar/calendar.js
  ((Metro2, $7) => {
    "use strict";
    let CalendarDefaultConfig = {
      weekStart: null,
      static: false,
      readonly: false,
      showGhost: false,
      events: null,
      startContent: "days",
      showTime: false,
      initialTime: null,
      initialHours: null,
      initialMinutes: null,
      labelTimeHours: null,
      labelTimeMinutes: null,
      animationContent: true,
      animationSpeed: 10,
      calendarDeferred: 0,
      dayBorder: false,
      excludeDay: null,
      prevMonthIcon: "\u2BC7",
      nextMonthIcon: "\u2BC8",
      prevYearIcon: "\u2BC7",
      nextYearIcon: "\u2BC8",
      compact: false,
      wide: false,
      widePoint: null,
      pickerMode: false,
      show: null,
      outside: true,
      buttons: "",
      //cancel, today, clear, done
      yearsBefore: 100,
      yearsAfter: 100,
      headerFormat: "dddd, MMM DD",
      showHeader: true,
      showFooter: true,
      showWeekNumber: false,
      isDialog: false,
      ripple: false,
      rippleColor: "#cccccc",
      exclude: null,
      preset: null,
      minDate: null,
      maxDate: null,
      weekDayClick: false,
      weekNumberClick: false,
      multiSelect: false,
      special: null,
      format: METRO_DATE_FORMAT,
      inputFormat: null,
      clsCalendar: "",
      clsCalendarHeader: "",
      clsCalendarContent: "",
      clsCalendarFooter: "",
      clsCalendarMonths: "",
      clsCalendarYears: "",
      clsToday: "",
      clsSelected: "",
      clsExcluded: "",
      clsCancelButton: "",
      clsTodayButton: "",
      clsClearButton: "",
      clsDoneButton: "",
      clsEventCounter: "",
      clsWeekend: "",
      clsCurrentWeek: "",
      clsCalendarTime: "",
      clsTime: "",
      clsTimeHours: "",
      clsTimeMinutes: "",
      clsTimeButton: "",
      clsTimeButtonPlus: "",
      clsTimeButtonMinus: "",
      clsSpecial: "",
      clsEvents: "",
      clsEvent: "",
      onCancel: Metro2.noop,
      onToday: Metro2.noop,
      onClear: Metro2.noop,
      onDone: Metro2.noop,
      onDayClick: Metro2.noop,
      onDrawDay: Metro2.noop,
      onDrawMonth: Metro2.noop,
      onDrawYear: Metro2.noop,
      onWeekDayClick: Metro2.noop,
      onWeekNumberClick: Metro2.noop,
      onMonthChange: Metro2.noop,
      onYearChange: Metro2.noop,
      onTimeChange: Metro2.noop,
      onHoursChange: Metro2.noop,
      onMinutesChange: Metro2.noop,
      onCalendarCreate: Metro2.noop
    };
    Metro2.calendarSetup = (options) => {
      CalendarDefaultConfig = $7.extend({}, CalendarDefaultConfig, options);
    };
    if (typeof globalThis.metroCalendarSetup !== "undefined") {
      Metro2.calendarSetup(globalThis.metroCalendarSetup);
    }
    Metro2.Component("calendar", {
      init: function(options, elem) {
        const time = datetime();
        const now = this._correctDate(datetime());
        this._super(elem, options, CalendarDefaultConfig, {
          today: now,
          show: now,
          current: {
            year: now.year(),
            month: now.month(),
            day: now.day()
          },
          preset: [],
          selected: [],
          exclude: [],
          special: [],
          excludeDay: [],
          events: [],
          min: null,
          max: null,
          minYear: null,
          maxYear: null,
          id: null,
          time: [time.hour(), time.minute()],
          content: "days",
          yearDistance: 11,
          yearGroupStart: now.year()
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        this.id = Hooks.useId(this.elem);
        this.content = o2.startContent;
        this.minYear = this.current.year - this.options.yearsBefore;
        this.maxYear = this.current.year + this.options.yearsAfter;
        element2.html("").addClass(`calendar ${o2.compact === true ? "compact" : ""}`).addClass(o2.clsCalendar);
        if (Metro2.utils.isValue(o2.initialTime)) {
          this.time = o2.initialTime.split(":");
        }
        if (Metro2.utils.isValue(o2.initialHours) && Metro2.utils.between(o2.initialHours, 0, 23, true)) {
          this.time[0] = Number.parseInt(o2.initialHours);
        }
        if (Metro2.utils.isValue(o2.initialMinutes) && Metro2.utils.between(o2.initialMinutes, 0, 59, true)) {
          this.time[1] = Number.parseInt(o2.initialMinutes);
        }
        if (o2.dayBorder === true) {
          element2.addClass("day-border");
        }
        if (Metro2.utils.isValue(o2.excludeDay)) {
          this.excludeDay = `${o2.excludeDay}`.toArray(",", "int");
        }
        if (Metro2.utils.isValue(o2.preset)) {
          this._dates2array(o2.preset, "selected");
        }
        if (Metro2.utils.isValue(o2.exclude)) {
          this._dates2array(o2.exclude, "exclude");
        }
        if (Metro2.utils.isValue(o2.special)) {
          this._dates2array(o2.special, "special");
        }
        if (Metro2.utils.isValue(o2.events)) {
          this._dates2array(o2.events, "events");
        }
        this.min = o2.minDate ? (o2.inputFormat ? Datetime.from(o2.minDate, o2.inputFormat) : datetime(o2.minDate)).align("day") : null;
        this.max = o2.maxDate ? (o2.inputFormat ? Datetime.from(o2.maxDate, o2.inputFormat) : datetime(o2.maxDate)).add(1, "day").align("day") : null;
        if (o2.show) {
          this.show = (!o2.show ? datetime() : o2.inputFormat ? Datetime.from(o2.show, o2.inputFormat) : datetime(o2.show)).align("day");
          this.current = {
            year: this.show.year(),
            month: this.show.month(),
            day: this.show.day()
          };
        }
        this._drawCalendar();
        this._createEvents();
        if (o2.wide === true) {
          element2.addClass("calendar-wide");
        } else {
          if (!Metro2.utils.isNull(o2.widePoint) && Metro2.utils.mediaExist(o2.widePoint)) {
            element2.addClass("calendar-wide");
          }
        }
        if (o2.ripple === true && Metro2.utils.isFunc(element2.ripple) !== false) {
          element2.ripple({
            rippleTarget: ".button, .prev-month, .next-month, .prev-year, .next-year, .day",
            rippleColor: this.options.rippleColor
          });
        }
        const id = element2.id();
        if (id) {
          if (Metro2.storage.getItem(`METRO:CALENDAR:${id}:COLLAPSED`, element2.hasClass("calendar-collapsed"))) {
            element2.addClass("calendar-collapsed");
          }
        }
        this._fireEvent("calendar-create");
      },
      _dates2array: function(val, category) {
        const that = this;
        const o2 = this.options;
        if (Metro2.utils.isNull(val)) {
          return;
        }
        const dates = typeof val === "string" ? val.toArray() : Array.isArray(val) ? val : [];
        $7.each(dates, function() {
          let _d;
          try {
            _d = (o2.inputFormat ? Datetime.from(this, o2.inputFormat) : datetime(this)).format("YYYY-MM-DD");
          } catch (e2) {
            return;
          }
          that[category].push(_d);
        });
      },
      _correctDate: (date) => datetime(date).addDay(1).align("day").addMinute((/* @__PURE__ */ new Date()).getTimezoneOffset()),
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            if (o2.wide !== true) {
              if (!Metro2.utils.isNull(o2.widePoint) && Metro2.utils.mediaExist(o2.widePoint)) {
                element2.addClass("calendar-wide");
              } else {
                element2.removeClass("calendar-wide");
              }
            }
          },
          { ns: this.id }
        );
        element2.on(Metro2.events.click, ".button-collapse", () => {
          const id = element2.id();
          element2.toggleClass("calendar-collapsed");
          if (id) {
            Metro2.storage.setItem(`METRO:CALENDAR:${id}:COLLAPSED`, element2.hasClass("calendar-collapsed"));
          }
        });
        element2.on(Metro2.events.click, ".prev-year-group, .next-year-group", function() {
          if (o2.static) {
            return;
          }
          if ($7(this).hasClass("prev-year-group")) {
            that.yearGroupStart -= that.yearDistance;
          } else {
            that.yearGroupStart += that.yearDistance;
          }
          that._drawContent();
        });
        element2.on(Metro2.events.click, ".prev-month, .next-month, .prev-year, .next-year", function() {
          let new_date;
          const el = $7(this);
          if (o2.static) {
            return;
          }
          if (el.hasClass("prev-month")) {
            new_date = datetime(that.current.year, that.current.month - 1, 1).useLocale(that.locale, true);
            if (new_date.year() < that.minYear) {
              return;
            }
          }
          if (el.hasClass("next-month")) {
            new_date = datetime(that.current.year, that.current.month + 1, 1).useLocale(that.locale, true);
            if (new_date.year() > that.maxYear) {
              return;
            }
          }
          if (el.hasClass("prev-year")) {
            new_date = datetime(that.current.year - 1, that.current.month, 1).useLocale(that.locale, true);
            if (new_date.year() < that.minYear) {
              return;
            }
          }
          if (el.hasClass("next-year")) {
            new_date = datetime(that.current.year + 1, that.current.month, 1).useLocale(that.locale, true);
            if (new_date.year() > that.maxYear) {
              return;
            }
          }
          that.current = {
            year: new_date.year(),
            month: new_date.month(),
            day: new_date.day()
          };
          setTimeout(
            () => {
              that._drawContent();
              if (el.hasClass("prev-month") || el.hasClass("next-month")) {
                that._fireEvent("month-change", {
                  current: that.current
                });
              }
              if (el.hasClass("prev-year") || el.hasClass("next-year")) {
                that._fireEvent("year-change", {
                  current: that.current
                });
              }
            },
            o2.ripple ? 300 : 1
          );
        });
        element2.on(Metro2.events.click, ".button-today", () => {
          that.toDay();
          that._fireEvent("today", {
            today: that.today.val(),
            time: that.time
          });
        });
        element2.on(Metro2.events.click, ".button-clear", () => {
          const date = datetime();
          that.selected = [];
          that.time = [date.hour(), date.minute()];
          that.yearGroupStart = date.year();
          that._drawContent();
          that._fireEvent("clear");
        });
        element2.on(Metro2.events.click, ".button-cancel", () => {
          that._drawContent();
          that._fireEvent("cancel");
        });
        element2.on(Metro2.events.click, ".button-done", () => {
          that._drawContent();
          that._fireEvent("done", {
            selected: that.selected,
            time: that.time
          });
        });
        if (o2.weekDayClick === true) {
          element2.on(Metro2.events.click, ".week-days .week-day", function(e2) {
            let index;
            let days;
            const ii = [];
            if (o2.static || o2.readonly) {
              return;
            }
            const day = $7(this);
            index = day.index();
            for (let i3 = 0; i3 < 7; i3++) {
              ii.push(index);
              index += o2.showWeekNumber ? 8 : 7;
            }
            if (o2.multiSelect === true) {
              days = element2.find(".day").filter((el) => {
                const $el = $7(el);
                return ii.indexOf($el.index()) > -1 && !$el.hasClass("outside disabled excluded");
              });
              $7.each(days, function() {
                const $el = $7(this);
                const day2 = $el.data("day");
                if (that.selected.indexOf(day2) === -1) {
                  that.selected.push(day2);
                  $el.addClass("selected").addClass(o2.clsSelected);
                } else {
                  $el.removeClass("selected").removeClass(o2.clsSelected);
                  Metro2.utils.arrayDelete(that.selected, day2);
                }
              });
            }
            that._fireEvent("week-day-click", {
              selected: that.selected,
              day: day[0]
            });
            e2.preventDefault();
            e2.stopPropagation();
          });
        }
        if (o2.weekNumberClick) {
          element2.on(Metro2.events.click, ".week-number", function(e2) {
            let days;
            const $el = $7(this);
            const wn = $el.text();
            const index = $el.index();
            if (wn === "#") {
              return;
            }
            if (o2.static || o2.readonly) {
              return;
            }
            if (o2.multiSelect === true) {
              days = element2.find(".day").filter((el) => {
                const $el2 = $7(el);
                const elIndex = $el2.index();
                return Metro2.utils.between(elIndex, index, index + 8, false) && !$el2.hasClass("outside disabled excluded");
              });
              $7.each(days, function() {
                const $el2 = $7(this);
                const day = $el2.data("day");
                if (that.selected.indexOf(day) === -1) {
                  that.selected.push(day);
                  $el2.addClass("selected").addClass(o2.clsSelected);
                } else {
                  $el2.removeClass("selected").removeClass(o2.clsSelected);
                  Metro2.utils.arrayDelete(that.selected, day);
                }
              });
            }
            that._fireEvent("week-number-click", {
              selected: that.selected,
              num: wn,
              numElement: $el[0]
            });
            e2.preventDefault();
            e2.stopPropagation();
          });
        }
        element2.on(Metro2.events.click, ".day", function(e2) {
          const day = $7(this);
          let index;
          let date;
          if (o2.static || o2.readonly) {
            return;
          }
          date = day.data("day");
          index = that.selected.indexOf(date);
          if (day.hasClass("outside")) {
            date = datetime(date);
            that.current = {
              year: date.year(),
              month: date.month(),
              day: date.day()
            };
            that._drawContent();
            that._fireEvent("month-change", {
              current: that.current
            });
            return;
          }
          if (!day.hasClass("disabled")) {
            if (o2.pickerMode === true) {
              that.selected = [date];
              that.today = datetime(date);
              that.current.year = that.today.year();
              that.current.month = that.today.month();
              that.current.day = that.today.day();
              that._drawHeader();
              that._drawContent();
            } else {
              if (index === -1) {
                if (o2.multiSelect === false) {
                  element2.find(".day").removeClass("selected").removeClass(o2.clsSelected);
                  that.selected = [];
                }
                that.selected.push(date);
                day.addClass("selected").addClass(o2.clsSelected);
              } else {
                day.removeClass("selected").removeClass(o2.clsSelected);
                Metro2.utils.arrayDelete(that.selected, date);
              }
            }
          }
          that._fireEvent("day-click", {
            selected: that.selected,
            day: day[0],
            time: that.time
          });
          e2.preventDefault();
          e2.stopPropagation();
        });
        element2.on(Metro2.events.click, ".curr-month, .header-day", (e2) => {
          that.content = "months";
          that._drawContent();
          e2.preventDefault();
          e2.stopPropagation();
        });
        element2.on(Metro2.events.click, ".month", function(e2) {
          that.current.month = Number.parseInt($7(this).attr("data-month"));
          that.content = "days";
          that._drawContent();
          that._fireEvent("month-change", {
            current: that.current
          });
          e2.preventDefault();
          e2.stopPropagation();
        });
        element2.on(Metro2.events.click, ".curr-year, .header-year", (e2) => {
          if (that.content === "years") {
            return;
          }
          that.content = "years";
          that._drawContent();
          e2.preventDefault();
          e2.stopPropagation();
        });
        element2.on(Metro2.events.click, ".year", function(e2) {
          that.current.year = Number.parseInt($7(this).attr("data-year"));
          that.yearGroupStart = that.current.year;
          that.content = "months";
          that._drawContent();
          that._fireEvent("year-change", {
            current: that.current
          });
          e2.preventDefault();
          e2.stopPropagation();
        });
      },
      _drawHeader: function() {
        const element2 = this.element;
        const o2 = this.options;
        let header = element2.find(".calendar-header");
        if (header.length === 0) {
          header = $7("<div>").addClass("calendar-header").addClass(o2.clsCalendarHeader).appendTo(element2);
        }
        header.html("");
        $7("<div>").addClass("header-year").html(this.today.year()).appendTo(header);
        $7("<div>").addClass("header-day").html(this.today.format(o2.headerFormat, this.locale)).appendTo(header);
        const headerActions = $7("<div>").addClass("header-actions").appendTo(header);
        $7("<button>").addClass("square small button-collapse").html(`
                <svg aria-hidden="true" class="caret toggle-collapsed" width="16" height="16" viewBox="0 0 24 24">
                    <path d="m14.83 11.29-4.24-4.24a1 1 0 1 0-1.42 1.41L12.71 12l-3.54 3.54a1 1 0 0 0 0 1.41 1 1 0 0 0 .71.29 1 1 0 0 0 .71-.29l4.24-4.24a1.002 1.002 0 0 0 0-1.42Z"></path>
                </svg>
            `).attr("title", this.strings.label_collapse).appendTo(headerActions);
        if (o2.showHeader === false) {
          header.hide();
        }
      },
      _drawFooter: function() {
        const element2 = this.element;
        const o2 = this.options;
        const strings = this.strings;
        let footer = element2.find(".calendar-footer");
        if (!o2.buttons) {
          return;
        }
        if (footer.length === 0) {
          footer = $7("<div>").addClass("calendar-footer").addClass(o2.clsCalendarFooter).appendTo(element2);
        }
        footer.html("");
        $7.each(o2.buttons.toArray(","), function() {
          const button = $7("<button>").attr("type", "button").addClass(`button button-${this} ${o2[`cls${Str.capitalize(this)}Button`]}`).html(strings[`label_${this}`]).appendTo(footer);
          if (this === "cancel" || this === "done") {
            button.addClass("js-dialog-close");
          }
        });
        if (o2.showFooter === false) {
          footer.hide();
        }
      },
      _drawTime: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const strings = this.strings;
        const calendarContent = element2.find(".calendar-content");
        const time = $7("<div>").addClass("calendar-time").addClass(o2.clsCalendarTime).appendTo(calendarContent);
        let inner;
        let hours;
        let minutes;
        let row;
        let h3 = `${this.time[0]}`;
        let m5 = `${this.time[1]}`;
        const onChange = function(val) {
          const value = Number.parseInt(val);
          if ($7(this).attr("data-time-part") === "hours") {
            that.time[0] = value;
            that._fireEvent("hours-change", {
              time: that.time,
              hours: value
            });
          } else {
            that.time[1] = value;
            that._fireEvent("minutes-change", {
              time: that.time,
              minutes: value
            });
          }
          that._fireEvent("time-change", {
            time: that.time
          });
        };
        time.append(inner = $7("<div>").addClass("calendar-time__inner"));
        inner.append(row = $7("<div>").addClass("calendar-time__inner-row"));
        row.append(
          $7("<div>").addClass("calendar-time__inner-cell").append($7("<span>").html(str(strings.label_hours).capitalize()))
        );
        row.append(
          $7("<div>").addClass("calendar-time__inner-cell").append($7("<span>").html(str(strings.label_minutes).capitalize()))
        );
        time.append(inner = $7("<div>").addClass("calendar-time__inner spinners").addClass(o2.clsTime));
        inner.append(
          // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>
          hours = $7(
            `<input type='text' data-cls-spinner-input='${o2.clsTimeHours}' data-time-part='hours' data-buttons-position='right' data-min-value='0' data-max-value='23'>`
          ).addClass("hours").addClass(o2.compact ? "input-small" : "input-normal")
        );
        inner.append(
          // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>
          minutes = $7(
            `<input type='text' data-cls-spinner-input='${o2.clsTimeMinutes}' data-time-part='minutes' data-buttons-position='right' data-min-value='0' data-max-value='59'>`
          ).addClass("minutes").addClass(o2.compact ? "input-small" : "input-normal")
        );
        h3 = Str.lpad(h3, "0", 2);
        m5 = Str.lpad(m5, "0", 2);
        hours.val(h3);
        minutes.val(m5);
        Metro2.makePlugin(inner.find("input[type=text]"), "spinner", {
          onChange,
          clsSpinnerButton: o2.clsTimeButton,
          clsSpinnerButtonPlus: o2.clsTimeButtonPlus,
          clsSpinnerButtonMinus: o2.clsTimeButtonMinus
        });
        if (o2.showTime === false) {
          time.hide();
        }
      },
      _drawContentDays: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const strings = this.strings;
        let content = element2.find(".calendar-content");
        let weekDays;
        const calendar = datetime(this.current.year, this.current.month, this.current.day).useLocale(this.locale, true).calendar(Metro2.utils.isValue(o2.weekStart) ? o2.weekStart : strings.weekStart);
        const showDay = this.show.format("YYYY-MM-DD");
        const now = datetime();
        if (content.length === 0) {
          content = $7("<div>").addClass("calendar-content").addClass(o2.clsCalendarContent).appendTo(element2);
        }
        if (o2.showWeekNumber) {
          content.addClass("-week-numbers");
        }
        content.empty();
        const toolbar = $7("<div>").addClass("calendar-toolbar").appendTo(content);
        $7("<span>").addClass("prev-month").html(o2.prevMonthIcon).appendTo(toolbar);
        $7("<span>").addClass("curr-month").html(Datetime.getLocale(this.locale).months[this.current.month]).appendTo(toolbar);
        $7("<span>").addClass("next-month").html(o2.nextMonthIcon).appendTo(toolbar);
        $7("<span>").addClass("prev-year").html(o2.prevYearIcon).appendTo(toolbar);
        $7("<span>").addClass("curr-year").html(this.current.year).appendTo(toolbar);
        $7("<span>").addClass("next-year").html(o2.nextYearIcon).appendTo(toolbar);
        weekDays = $7("<div>").addClass("week-days").appendTo(content);
        if (o2.showWeekNumber) {
          $7("<span>").addClass("week-number").html("#").appendTo(weekDays);
        }
        $7.each(calendar.weekdays, function() {
          $7("<span>").addClass("week-day").html(this).appendTo(weekDays);
        });
        const calendarDays = $7("<div>").addClass("days").appendTo(content);
        $7.each(calendar.days, function(i3) {
          const day = `${this}`;
          const date = that._correctDate(day);
          const outsideDate = date.month() !== that.current.month;
          if (o2.showWeekNumber && i3 % 7 === 0) {
            $7("<span>").addClass("week-number").html(`<span class="week-number-content">${date.weekNumber(o2.weekStart)}</span>`).appendTo(calendarDays);
          }
          const _day = date.day();
          const _data = date.format("YYYY-MM-DD");
          const cell = $7("<span>").addClass("day").html(`<span class="day-content">${_day}</span>`).appendTo(calendarDays);
          cell.attr("data-day", _data);
          if (day === showDay) {
            cell.addClass("showed");
          }
          if (outsideDate) {
            cell.addClass("outside");
            if (!o2.outside) {
              cell.empty();
            }
          }
          if (day === calendar.today) {
            cell.addClass("today");
          }
          if (o2.showGhost && date.day() === now.day()) {
            cell.addClass("coincidental");
          }
          if (that.special.length) {
            if (that.special.indexOf(day) === -1) {
              cell.addClass("disabled excluded").addClass(o2.clsExcluded);
            } else {
              cell.addClass(o2.clsSpecial);
            }
          } else {
            if (that.selected.includes(day)) {
              cell.addClass("selected").addClass(o2.clsSelected);
            }
            if (that.exclude.includes(day)) {
              cell.addClass("disabled excluded").addClass(o2.clsExcluded);
            }
            if (that.min && date.older(that.min)) {
              cell.addClass("disabled excluded").addClass(o2.clsExcluded);
            }
            if (that.max && date.younger(that.max)) {
              cell.addClass("disabled excluded").addClass(o2.clsExcluded);
            }
          }
          if (calendar.weekends.indexOf(day) !== -1) {
            cell.addClass(o2.clsWeekend);
          }
          if (calendar.week.indexOf(day) !== -1) {
            cell.addClass(o2.clsCurrentWeek);
          }
          if (that.events.length) {
            const events = $7("<div>").addClass("events").addClass(o2.clsEvents).appendTo(cell);
            $7.each(that.events, function() {
              if (this === day) {
                const event = $7("<div>").addClass("event").addClass(o2.clsEvent).appendTo(events);
                if (!o2.clsEvent) {
                  event.css({
                    backgroundColor: Farbe.Routines.randomColor()
                  });
                }
              }
            });
          }
          if (o2.animationContent) {
            cell.addClass("to-animate");
          }
          that._fireEvent("draw-day", {
            date: date.val(),
            day: date.day(),
            month: date.month(),
            year: date.year(),
            cell: cell[0]
          });
        });
        this._drawTime();
        this._animateContent(".day");
      },
      _drawContentMonths: function() {
        const element2 = this.element;
        const elem = this.elem;
        const o2 = this.options;
        const locale = this.locale;
        let content = element2.find(".calendar-content");
        let months;
        let month;
        const yearToday = datetime().year();
        const monthToday = datetime().month();
        if (content.length === 0) {
          content = $7("<div>").addClass("calendar-content").addClass(o2.clsCalendarContent).appendTo(element2);
        }
        content.clear();
        const toolbar = $7("<div>").addClass("calendar-toolbar").appendTo(content);
        $7("<span>").addClass("prev-year").html(o2.prevYearIcon).appendTo(toolbar);
        $7("<span>").addClass("curr-year").html(this.current.year).appendTo(toolbar);
        $7("<span>").addClass("next-year").html(o2.nextYearIcon).appendTo(toolbar);
        content.append(months = $7("<div>").addClass("months"));
        let index = 0;
        for (const m5 of Datetime.getLocale(locale).months) {
          months.append(
            // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>
            month = $7("<div>").attr("data-month", index).addClass("month").addClass(index === monthToday && this.current.year === yearToday ? "today" : "").html(m5)
          );
          if (o2.animationContent) {
            month.addClass("to-animate");
          }
          this._fireEvent("draw-month", {
            month: index,
            year: this.current.year,
            cell: month[0]
          });
          index++;
        }
        Metro2.i18n.updateUI(elem, locale);
        this._animateContent(".months .month");
      },
      _drawContentYears: function() {
        const element2 = this.element;
        const o2 = this.options;
        let content = element2.find(".calendar-content");
        let years;
        let year;
        if (content.length === 0) {
          content = $7("<div>").addClass("calendar-content").addClass(o2.clsCalendarContent).appendTo(element2);
        }
        content.clear();
        const toolbar = $7("<div>").addClass("calendar-toolbar").appendTo(content);
        $7("<span>").addClass("prev-year-group").html(o2.prevYearIcon).appendTo(toolbar);
        $7("<span>").addClass("curr-year").html(`${this.yearGroupStart} - ${this.yearGroupStart + this.yearDistance}`).appendTo(toolbar);
        $7("<span>").addClass("next-year-group").html(o2.nextYearIcon).appendTo(toolbar);
        content.append(years = $7("<div>").addClass("years"));
        for (let i3 = this.yearGroupStart; i3 <= this.yearGroupStart + this.yearDistance; i3++) {
          years.append(
            // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>
            year = $7("<div>").attr("data-year", i3).addClass("year").addClass(i3 === this.current.year ? "today" : "").html(i3)
          );
          if (o2.animationContent) {
            year.addClass("to-animate");
          }
          if (i3 < o2.minYear || i3 > o2.maxYear) {
            year.addClass("disabled");
          }
          this._fireEvent("draw-year", {
            year: i3,
            cell: year[0]
          });
        }
        this._animateContent(".years .year");
      },
      _drawContent: function() {
        switch (this.content) {
          case "years":
            this._drawContentYears();
            break;
          case "months":
            this._drawContentMonths();
            break;
          default:
            this._drawContentDays();
        }
        Metro2.i18n.updateUI(this.elem, this.locale);
      },
      _drawCalendar: function() {
        const element2 = this.elem;
        setTimeout(() => {
          this.element.html("");
          this._drawHeader();
          this._drawContent();
          this._drawFooter();
          Metro2.i18n.updateUI(element2, this.locale);
        }, 0);
      },
      _animateContent: function(target, cls = "to-animate") {
        const element2 = this.element;
        const o2 = this.options;
        const content = element2.find(".calendar-content");
        content.find(target).each(function(k5) {
          const day = $7(this);
          setTimeout(() => {
            day.removeClass(cls);
          }, o2.animationSpeed * k5);
        });
      },
      getTime: function(asString = false) {
        const h3 = Str.lpad(this.time[0], "0", 2);
        const m5 = Str.lpad(this.time[1], "0", 2);
        return asString ? `${h3}:${m5}` : this.time;
      },
      setTime: function(time) {
        if (Array.isArray(time)) {
          this.time = time;
        } else {
          this.time = time.split(":");
        }
        this._drawCalendar();
      },
      getPreset: function() {
        return this.preset;
      },
      getSelected: function() {
        return this.selected;
      },
      getExcluded: function() {
        return this.exclude;
      },
      getToday: function() {
        return this.today;
      },
      getCurrent: function() {
        return this.current;
      },
      clearSelected: function() {
        this.selected = [];
        this._drawContent();
      },
      toDay: function() {
        const time = datetime();
        this.today = datetime().align("day");
        this.current = {
          year: this.today.year(),
          month: this.today.month(),
          day: this.today.day()
        };
        this.time = [time.hour(), time.minute()];
        this.yearGroupStart = this.today.year();
        this.content = "days";
        this._drawHeader();
        this._drawContent();
      },
      setExclude: function(exclude) {
        const element2 = this.element;
        const o2 = this.options;
        if (Metro2.utils.isNull(exclude) && Metro2.utils.isNull(element2.attr("data-exclude"))) {
          return;
        }
        o2.exclude = exclude ? exclude : element2.attr("data-exclude");
        this._dates2array(o2.exclude, "exclude");
        this._drawContent();
      },
      setPreset: function(preset) {
        const element2 = this.element;
        const o2 = this.options;
        if (Metro2.utils.isNull(preset) && Metro2.utils.isNull(element2.attr("data-preset"))) {
          return;
        }
        o2.preset = preset ? preset : element2.attr("data-preset");
        this._dates2array(o2.preset, "selected");
        this._drawContent();
      },
      setSpecial: function(special) {
        const element2 = this.element;
        const o2 = this.options;
        if (Metro2.utils.isNull(special) && Metro2.utils.isNull(element2.attr("data-special"))) {
          return;
        }
        o2.special = special ? special : element2.attr("data-special");
        this._dates2array(o2.exclude, "special");
        this._drawContent();
      },
      showDate: function(date) {
        return this.setShow(date);
      },
      setShow: function(show) {
        const element2 = this.element;
        const o2 = this.options;
        const attr = element2.attr("data-show");
        if (!show && !attr) {
          return;
        }
        o2.show = show ? show : attr;
        if (!o2.show) {
          this.show = datetime();
        } else {
          if (typeof o2.show === "string" && o2.inputFormat) {
            this.show = Datetime.from(o2.show, o2.inputFormat);
          } else {
            this.show = datetime(o2.show);
          }
        }
        this.show = this.show.align("day");
        this.current = {
          year: this.show.year(),
          month: this.show.month(),
          day: this.show.day()
        };
        this._drawContent();
      },
      setMinDate: function(date) {
        const element2 = this.element;
        const o2 = this.options;
        const attr = element2.attr("data-min-date");
        if (!date && !attr) {
          return;
        }
        o2.minDate = date ? date : attr;
        this.min = o2.minDate ? (o2.inputFormat ? Datetime.from(o2.minDate, o2.inputFormat) : datetime(o2.minDate)).align("day") : null;
        this._drawContent();
      },
      setMaxDate: function(date) {
        const element2 = this.element;
        const o2 = this.options;
        const attr = element2.attr("data-max-date");
        o2.maxDate = date ? date : attr;
        this.max = o2.maxDate ? (o2.inputFormat ? Datetime.from(o2.maxDate, o2.inputFormat) : datetime(o2.maxDate)).align("day") : null;
        this._drawContent();
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-exclude":
            this.setExclude();
            break;
          case "data-preset":
            this.setPreset();
            break;
          case "data-special":
            this.setSpecial();
            break;
          case "data-show":
            this.setShow();
            break;
          case "data-min-date":
            this.setMinDate();
            break;
          case "data-max-date":
            this.setMaxDate();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.off(Metro2.events.click, ".prev-month, .next-month, .prev-year, .next-year");
        element2.off(Metro2.events.click, ".button.today");
        element2.off(Metro2.events.click, ".button.clear");
        element2.off(Metro2.events.click, ".button.cancel");
        element2.off(Metro2.events.click, ".button.done");
        element2.off(Metro2.events.click, ".week-days .day");
        element2.off(Metro2.events.click, ".days-row .day");
        element2.off(Metro2.events.click, ".curr-month");
        element2.off(Metro2.events.click, ".calendar-months li");
        element2.off(Metro2.events.click, ".curr-year");
        element2.off(Metro2.events.click, ".calendar-years li");
        element2.off(Metro2.events.click);
        if (o2.ripple === true) {
          element2.data("ripple").destroy();
        }
        $7(globalThis).off(Metro2.events.resize, { ns: this.id });
        element2.remove();
      }
    });
    $7(document).on(Metro2.events.click, () => {
      $7(".calendar .calendar-years").each(function() {
        $7(this).removeClass("open");
      });
      $7(".calendar .calendar-months").each(function() {
        $7(this).removeClass("open");
      });
    });
    Metro2.defaults.Calendar = CalendarDefaultConfig;
  })(Metro, Dom);

  // ../metroui-lib/source/components/calendarpicker/calendarpicker.js
  ((Metro2, $7) => {
    "use strict";
    let CalendarPickerDefaultConfig = {
      label: "",
      value: "",
      calendarPickerDeferred: 0,
      nullValue: true,
      useNow: false,
      prepend: "",
      dialogMode: false,
      dialogPoint: 640,
      dialogOverlay: true,
      overlayColor: "#000000",
      overlayAlpha: 0.5,
      size: "100%",
      format: METRO_DATE_FORMAT,
      inputFormat: null,
      clearButton: false,
      calendarButtonIcon: "\u{1F4C5}",
      clearButtonIcon: "\u2716",
      prevMonthIcon: "\u2BC7",
      nextMonthIcon: "\u2BC8",
      prevYearIcon: "\u2BC7",
      nextYearIcon: "\u2BC8",
      copyInlineStyles: false,
      openMode: "auto",
      wide: false,
      widePoint: 640,
      showTime: false,
      outside: true,
      weekStart: 0,
      events: [],
      initialTime: null,
      initialHours: null,
      initialMinutes: null,
      headerFormat: "dddd, MMM DD",
      showWeekNumber: false,
      ripple: false,
      rippleColor: "#000000",
      special: [],
      exclude: [],
      minDate: null,
      maxDate: null,
      yearsBefore: 100,
      yearsAfter: 100,
      clsCalendar: "",
      clsCalendarHeader: "",
      clsCalendarContent: "",
      clsCalendarMonths: "",
      clsCalendarYears: "",
      clsCalendarTime: "",
      clsTime: "",
      clsTimeHours: "",
      clsTimeMinutes: "",
      clsTimeButton: "",
      clsTimeButtonPlus: "",
      clsTimeButtonMinus: "",
      clsToday: "",
      clsSelected: "",
      clsExcluded: "",
      clsOverlay: "",
      clsPicker: "",
      clsInput: "",
      clsPrepend: "",
      clsLabel: "",
      onDayClick: Metro2.noop,
      onCalendarPickerCreate: Metro2.noop,
      onCalendarShow: Metro2.noop,
      onCalendarHide: Metro2.noop,
      onChange: Metro2.noop,
      onPickerChange: Metro2.noop,
      onMonthChange: Metro2.noop,
      onYearChange: Metro2.noop
    };
    Metro2.calendarPickerSetup = (options) => {
      CalendarPickerDefaultConfig = $7.extend({}, CalendarPickerDefaultConfig, options);
    };
    if (typeof globalThis.metroCalendarPickerSetup !== "undefined") {
      Metro2.calendarPickerSetup(globalThis.metroCalendarPickerSetup);
    }
    Metro2.Component("calendar-picker", {
      init: function(options, elem) {
        const time = datetime();
        this._super(elem, options, $7.extend({}, Metro2.defaults.Calendar, {}, CalendarPickerDefaultConfig), {
          value: null,
          value_date: null,
          calendar: null,
          overlay: null,
          id: null,
          time: [time.hour(), time.minute()]
        });
        return this;
      },
      _create: function() {
        this.id = Hooks.useId(this.element);
        this._createStructure();
        this._createEvents();
        this._fireEvent("calendar-picker-create", {
          element: this.element
        });
      },
      _correctTime: (time) => {
        const h3 = Str.lpad(time[0], "0", 2);
        const m5 = Str.lpad(time[1], "0", 2);
        return `${h3}:${m5}`;
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const locale = this.locale;
        const container = $7("<div>").addClass(`input ${element2[0].className} calendar-picker`);
        const buttons = $7("<div>").addClass("button-group");
        let clearButton;
        const cal = $7("<div>");
        let curr;
        let _curr;
        let initHours;
        let initMinutes;
        let elementValue;
        const body = $7("body");
        element2.attr("type", "text");
        element2.attr("autocomplete", "off");
        element2.attr("readonly", true);
        if (Metro2.utils.isValue(o2.initialTime)) {
          this.time = o2.initialTime.trim().split(":");
        }
        if (Metro2.utils.isValue(o2.initialHours)) {
          this.time[0] = Number.parseInt(o2.initialHours);
        }
        if (Metro2.utils.isValue(o2.initialMinutes)) {
          this.time[1] = Number.parseInt(o2.initialMinutes);
        }
        curr = `${o2.value}`.trim() !== "" ? o2.value : element2.val().trim();
        const preset = curr ? curr : "";
        if (!Metro2.utils.isValue(curr)) {
          if (o2.useNow) {
            this.value = datetime().addDay(1).align("day").addMinute((/* @__PURE__ */ new Date()).getTimezoneOffset());
            this.time = [this.value.hour(), this.value.minute()];
          }
        } else {
          _curr = curr.split(" ");
          this.value = !o2.inputFormat ? datetime(_curr[0]) : Datetime.from(_curr[0], o2.inputFormat, locale);
          if (_curr[1]) {
            this.time = _curr[1].trim().split(":");
          }
        }
        elementValue = !curr && o2.nullValue === true ? "" : datetime(this.value).format(o2.format, locale);
        if (o2.showTime && this.time && elementValue) {
          elementValue += ` ${this._correctTime(this.time)}`;
        }
        element2.val(elementValue);
        container.insertBefore(element2);
        element2.appendTo(container);
        buttons.appendTo(container);
        cal.appendTo(o2.dialogMode ? body : container);
        if (this.time?.length) {
          initHours = this.time[0];
          if (typeof this.time[1] !== "undefined") initMinutes = this.time[1];
        }
        const initTime = o2.initialTime;
        if (o2.initialHours) {
          initHours = o2.initialHours;
        }
        if (o2.initialHours) {
          initMinutes = o2.initialMinutes;
        }
        Metro2.makePlugin(cal, "calendar", {
          showTime: o2.showTime,
          initialTime: initTime,
          initialHours: initHours,
          initialMinutes: initMinutes,
          clsCalendarTime: o2.clsCalendarTime,
          clsTime: o2.clsTime,
          clsTimeHours: o2.clsTimeHours,
          clsTimeMinutes: o2.clsTimeMinutes,
          clsTimeButton: o2.clsTimeButton,
          clsTimeButtonPlus: o2.clsTimeButtonPlus,
          clsTimeButtonMinus: o2.clsTimeButtonMinus,
          wide: o2.wide,
          widePoint: o2.widePoint,
          format: o2.format,
          inputFormat: o2.inputFormat,
          pickerMode: true,
          show: preset,
          preset,
          weekStart: o2.weekStart,
          outside: o2.outside,
          buttons: false,
          headerFormat: o2.headerFormat,
          prevMonthIcon: o2.prevMonthIcon,
          nextMonthIcon: o2.nextMonthIcon,
          prevYearIcon: o2.prevYearIcon,
          nextYearIcon: o2.nextYearIcon,
          clsCalendar: [o2.clsCalendar, "calendar-for-picker", o2.dialogMode ? "dialog-mode" : ""].join(" "),
          clsCalendarHeader: o2.clsCalendarHeader,
          clsCalendarContent: o2.clsCalendarContent,
          clsCalendarFooter: "d-none",
          clsCalendarMonths: o2.clsCalendarMonths,
          clsCalendarYears: o2.clsCalendarYears,
          clsToday: o2.clsToday,
          clsSelected: o2.clsSelected,
          clsExcluded: o2.clsExcluded,
          ripple: o2.ripple,
          rippleColor: o2.rippleColor,
          exclude: o2.exclude,
          minDate: o2.minDate,
          maxDate: o2.maxDate,
          yearsBefore: o2.yearsBefore,
          yearsAfter: o2.yearsAfter,
          special: o2.special,
          events: o2.events,
          showHeader: false,
          showFooter: false,
          multiSelect: false,
          showWeekNumber: o2.showWeekNumber,
          onDayClick: (sel, day, time, el) => {
            const date = datetime(sel[0]).addDay(1).align("day").addMinute((/* @__PURE__ */ new Date()).getTimezoneOffset());
            let elementValue2;
            this._removeOverlay();
            this.value = date;
            this.time = time;
            elementValue2 = date.format(o2.format, locale);
            if (o2.showTime) {
              elementValue2 += ` ${this._correctTime(time)}`;
            }
            element2.val(elementValue2);
            element2.trigger("change");
            cal.removeClass("open open-up");
            cal.hide();
            this._fireEvent("change", {
              val: this.value.val(),
              time: this.time
            });
            this._fireEvent("day-click", {
              sel,
              day,
              time,
              el
            });
            this._fireEvent("picker-change", {
              val: this.value.val(),
              time: this.time
            });
          },
          onTimeChange: (time) => {
            let elementValue2;
            this.time = time;
            if (!this.value) {
              this.value = datetime();
            }
            elementValue2 = this.value.format(o2.format, this.locale);
            if (o2.showTime) {
              elementValue2 += ` ${this._correctTime(time)}`;
            }
            element2.val(elementValue2);
            this._fireEvent("change", {
              val: this.value.val(),
              time: this.time
            });
            this._fireEvent("picker-change", {
              val: this.value.val(),
              time: this.time
            });
          },
          onMonthChange: o2.onMonthChange,
          onYearChange: o2.onYearChange
        });
        this.calendar = cal;
        if (o2.clearButton === true) {
          clearButton = $7("<button>").addClass("button input-clear-button").attr("tabindex", -1).attr("type", "button").html(o2.clearButtonIcon);
          clearButton.appendTo(buttons);
        }
        const calendarButton = $7("<button>").addClass("button input-calendar-button").attr("tabindex", -1).attr("type", "button").html(o2.calendarButtonIcon);
        calendarButton.appendTo(buttons);
        if (o2.prepend !== "") {
          const prepend = $7("<div>").html(o2.prepend);
          prepend.addClass("prepend").addClass(o2.clsPrepend).appendTo(container);
        }
        if (element2.attr("dir") === "rtl") {
          container.addClass("rtl");
        }
        if (String(o2.size).indexOf("%") > -1) {
          container.css({
            width: o2.size
          });
        } else {
          container.css({
            width: `${Number.parseInt(o2.size)}px`
          });
        }
        element2[0].className = "";
        if (o2.copyInlineStyles === true) {
          $7.each(Metro2.utils.getInlineStyles(element2), (key, value) => {
            container.css(key, value);
          });
        }
        container.addClass(o2.clsPicker);
        element2.addClass(o2.clsInput);
        if (o2.dialogOverlay === true) {
          this.overlay = this._overlay();
        }
        if (o2.dialogMode === true) {
          container.addClass("dialog-mode");
        } else {
          if (Metro2.utils.media(`(max-width: ${o2.dialogPoint}px)`)) {
            container.addClass("dialog-mode");
            this.calendar.addClass("dialog-mode");
          }
        }
        if (o2.label) {
          const label = $7("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(container);
          if (element2.attr("id")) {
            label.attr("for", element2.attr("id"));
          } else {
            const id = Hooks.useId(element2[0]);
            label.attr("for", id);
            element2.attr("id", id);
          }
          if (element2.attr("dir") === "rtl") {
            label.addClass("rtl");
          }
        }
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.parent();
        const clear = container.find(".input-clear-button");
        const cal = this.calendar;
        const cal_plugin = Metro2.getPlugin(cal[0], "calendar");
        const calendar = this.calendar;
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            if (o2.dialogMode !== true) {
              if (Metro2.utils.media(`(max-width: ${o2.dialogPoint}px)`)) {
                container.addClass("dialog-mode");
                calendar.appendTo("body").addClass("dialog-mode");
              } else {
                container.removeClass("dialog-mode");
                calendar.appendTo(container).removeClass("dialog-mode");
              }
            }
          },
          { ns: this.id }
        );
        if (clear.length > 0)
          clear.on(Metro2.events.click, (e2) => {
            element2.val("").trigger("change").blur();
            this.value = null;
            e2.preventDefault();
            e2.stopPropagation();
          });
        container.on(Metro2.events.click, "button, input", (e2) => {
          const value = this.value ? this.value : datetime().addDay(1).align("day").addMinute((/* @__PURE__ */ new Date()).getTimezoneOffset());
          const presetValue = value.format("YYYY/MM/DD");
          value.align("day");
          if (cal.hasClass("open") === false && cal.hasClass("open-up") === false) {
            $7(".calendar-picker .calendar").removeClass("open open-up").hide();
            cal_plugin.setPreset([presetValue]);
            cal_plugin.setShow(value);
            if (container.hasClass("dialog-mode")) {
              this.overlay.appendTo($7("body"));
            }
            cal.addClass("open");
            if (o2.openMode === "auto") {
              if (!Metro2.utils.inViewport(cal[0])) {
                cal.addClass("open-up");
              }
              if (!Metro2.utils.inViewport(cal[0])) {
                cal.removeClass("open-up");
              }
            } else {
              if (o2.openMode === "up") {
                cal.addClass("open-up");
              }
            }
            this._fireEvent("calendar-show", {
              calendar: cal
            });
          } else {
            this._removeOverlay();
            cal.removeClass("open open-up");
            this._fireEvent("calendar-hide", {
              calendar: cal
            });
          }
          e2.preventDefault();
          e2.stopPropagation();
        });
        element2.on(Metro2.events.blur, () => {
          container.removeClass("focused");
        });
        element2.on(Metro2.events.focus, () => {
          container.addClass("focused");
        });
        element2.on(Metro2.events.change, () => {
          Metro2.utils.exec(o2.onChange, [this.value.val()], element2[0]);
        });
        container.on(Metro2.events.click, (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
        });
      },
      _overlay: function() {
        const o2 = this.options;
        const overlay = $7("<div>");
        overlay.addClass("overlay for-calendar-picker").addClass(o2.clsOverlay);
        if (o2.overlayColor === "transparent") {
          overlay.addClass("transparent");
        } else {
          overlay.css({
            background: Farbe.Routines.toRGBA(o2.overlayColor, o2.overlayAlpha)
          });
        }
        return overlay;
      },
      _removeOverlay: () => {
        $7("body").find(".overlay.for-calendar-picker").remove();
      },
      clear: function() {
        this.value = datetime();
        this.time = [datetime().hour(), datetime().minute()];
        this.element.val("");
      },
      // val: function (v, f) {
      val: function(...args) {
        const element2 = this.element;
        const o2 = this.options;
        let elementValue;
        if (args.length === 0) {
          return {
            date: this.value.val(),
            time: this.time
          };
        }
        const [v5, f5] = args;
        if (v5 === "") {
          return this.clear();
        }
        if (f5) {
          o2.inputFormat = f5;
        }
        const _curr = v5.split(" ");
        this.value = !o2.inputFormat ? datetime(_curr[0]) : Datetime.from(_curr[0], o2.inputFormat, this.locale);
        if (_curr[1]) {
          this.time = _curr[1].trim().split(":");
        }
        this.value.align("day");
        Metro2.getPlugin(this.calendar, "calendar").setTime(this.time);
        elementValue = this.value.format(o2.format);
        if (o2.showTime && this.time && elementValue) {
          elementValue += ` ${this._correctTime(this.time)}`;
        }
        element2.val(elementValue);
        element2.trigger("change");
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      getTime: function(asString = false) {
        const h3 = Str.lpad(this.time[0], "0", 2);
        const m5 = Str.lpad(this.time[1], "0", 2);
        return asString ? `${h3}:${m5}` : this.time;
      },
      changeAttribute: function(attributeName, newValue) {
        const cal = Metro2.getPlugin(this.calendar[0], "calendar");
        switch (attributeName) {
          case "value":
            this.val(newValue);
            break;
          case "disabled":
            this.toggleState();
            break;
          case "data-special":
            cal.setSpecial(newValue);
            break;
          case "data-exclude":
            cal.setExclude(newValue);
            break;
          case "data-min-date":
            cal.setMinDate(newValue);
            break;
          case "data-max-date":
            cal.setMaxDate(newValue);
            break;
          case "data-value":
            this.val(newValue);
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.parent();
        const clear = container.find(".input-clear-button");
        $7(globalThis).off(Metro2.events.resize, { ns: this.id });
        clear.off(Metro2.events.click);
        container.off(Metro2.events.click, "button, input");
        element2.off(Metro2.events.blur);
        element2.off(Metro2.events.focus);
        element2.off(Metro2.events.change);
        Metro2.getPlugin(this.calendar, "calendar").destroy();
        if (o2.label) {
          container.prev("label").remove();
        }
        container.remove();
      }
    });
    $7(document).on(Metro2.events.click, ".overlay.for-calendar-picker", function() {
      $7(this).remove();
      $7(".calendar-for-picker.open").removeClass("open open-up");
    });
    $7(document).on(Metro2.events.click, () => {
      $7(".calendar-picker .calendar").removeClass("open open-up");
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/carousel/carousel.js
  ((Metro2, $7) => {
    "use strict";
    const effects = ["slide", "slide-v", "fade", "switch", "zoom", "swirl"];
    let CarouselDefaultConfig = {
      carouselDeferred: 0,
      autoStart: false,
      width: "100%",
      height: "16/9",
      // 3/4, 21/9
      effect: effects[0],
      effectFunc: "linear",
      direction: "left",
      //left, right
      duration: 300,
      period: 5e3,
      stopOnMouse: true,
      controls: true,
      controlsOnMouse: false,
      controlsOutside: false,
      controlPrev: "&larr;",
      controlNext: "&rarr;",
      bullets: true,
      bulletsStyle: "square",
      // square, circle, rect, diamond
      bulletsSize: "default",
      // default, mini, small, large
      bulletsPosition: "default",
      // default, left, right
      clsCarousel: "",
      clsSlides: "",
      clsSlide: "",
      clsControls: "",
      clsControlNext: "",
      clsControlPrev: "",
      clsBullets: "",
      clsBullet: "",
      clsBulletOn: "",
      clsThumbOn: "",
      onStop: Metro2.noop,
      onStart: Metro2.noop,
      onPlay: Metro2.noop,
      onSlideClick: Metro2.noop,
      onBulletClick: Metro2.noop,
      onThumbClick: Metro2.noop,
      onMouseEnter: Metro2.noop,
      onMouseLeave: Metro2.noop,
      onNextClick: Metro2.noop,
      onPrevClick: Metro2.noop,
      onSlideShow: Metro2.noop,
      onSlideHide: Metro2.noop,
      onCarouselCreate: Metro2.noop
    };
    Metro2.carouselSetup = (options) => {
      CarouselDefaultConfig = $7.extend({}, CarouselDefaultConfig, options);
    };
    if (typeof globalThis.metroCarouselSetup !== "undefined") {
      Metro2.carouselSetup(globalThis.metroCarouselSetup);
    }
    Metro2.Component("carousel", {
      init: function(options, elem) {
        this._super(elem, options, CarouselDefaultConfig, {
          height: 0,
          width: 0,
          slides: [],
          current: null,
          currentIndex: null,
          dir: "left",
          interval: false,
          isAnimate: false,
          id: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        const slides = element2.find(".slide");
        let slides_container = element2.find(".slides");
        this.id = Hooks.useId(this.elem);
        this.dir = this.options.direction;
        element2.addClass("carousel").addClass(o2.clsCarousel);
        element2.css({
          maxWidth: o2.width
        });
        if (o2.controlsOutside === true) {
          element2.addClass("controls-outside");
        }
        if (slides_container.length === 0) {
          slides_container = $7("<div>").addClass("slides").appendTo(element2);
          slides.appendTo(slides_container);
        }
        slides.addClass(o2.clsSlides);
        if (slides.length > 0) {
          this._createSlides();
          this._createControls();
          this._createBullets();
          this._createEvents();
          this._resize();
          if (o2.controlsOnMouse === true) {
            element2.find("[class*=carousel-switch]").fadeOut(0);
            element2.find(".carousel-bullets").fadeOut(0);
          }
          if (o2.autoStart === true) {
            this._start();
          } else {
            this._fireEvent("slide-show", {
              current: this.slides[this.currentIndex][0],
              prev: void 0
            });
          }
        }
        this._fireEvent("carousel-create", {
          element: element2
        });
      },
      _start: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        let period = o2.period;
        const current = this.slides[this.currentIndex];
        if (current.data("period") !== void 0) {
          period = current.data("period");
        }
        if (this.slides.length <= 1) {
          return;
        }
        if (this.interval === false)
          this.interval = setTimeout(function run() {
            const t = o2.direction === "left" ? "next" : "prior";
            that._slideTo(t, true);
          }, period);
        this._fireEvent("start", {
          element: element2
        });
      },
      _stop: function() {
        clearInterval(this.interval);
        this.interval = false;
      },
      _resize: function() {
        const element2 = this.element;
        const o2 = this.options;
        const width = element2.outerWidth();
        let height;
        let medias = [];
        if (["16/9", "21/9", "4/3"].indexOf(o2.height) > -1) {
          height = Metro2.utils.aspectRatioH(width, o2.height);
        } else {
          if (String(o2.height).includes("@")) {
            medias = o2.height.substring(1).toArray("|");
            $7.each(medias, function() {
              const [rule, h3] = this.toArray(",");
              if (matchMedia(rule).matches) {
                if (["16/9", "21/9", "4/3"].includes(h3)) {
                  height = Metro2.utils.aspectRatioH(width, h3);
                } else {
                  if (h3.includes("%")) {
                    const ph = Metro2.utils.rect(element2.parent()[0]).height;
                    height = Math.floor(Number.parseInt(h3) * ph / 100);
                  } else {
                    height = Number.parseInt(h3);
                  }
                }
              }
            });
          } else {
            if (String(o2.height).includes("%")) {
              const ph = Metro2.utils.rect(element2.parent()[0]).height;
              height = Math.floor(Number.parseInt(o2.height) * ph / 100);
            } else {
              height = Number.parseInt(o2.height);
            }
          }
        }
        element2.css({
          height
        });
      },
      _createSlides: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const slides = element2.find(".slide");
        $7.each(slides, function(i3) {
          const slide = $7(this);
          if (slide.data("cover") !== void 0) {
            slide.css({
              backgroundImage: `url(${slide.data("cover")})`
            });
          }
          if (i3 !== 0) {
            switch (o2.effect) {
              case "switch":
              case "slide":
                slide.css("left", "100%");
                break;
              case "slide-v":
                slide.css("top", "100%");
                break;
              case "fade":
              case "zoom":
              case "swirl":
                slide.css("opacity", "0");
                break;
            }
          } else {
            slide.addClass("active-slide");
          }
          slide.addClass(o2.clsSlide);
          that.slides.push(slide);
        });
        this.currentIndex = 0;
        this.current = this.slides[this.currentIndex];
      },
      _createControls: function() {
        const element2 = this.element;
        const o2 = this.options;
        let next;
        let prev;
        if (o2.controls === false) {
          return;
        }
        next = $7("<span>").addClass("carousel-switch-next").addClass(o2.clsControls).addClass(o2.clsControlNext);
        prev = $7("<span>").addClass("carousel-switch-prev").addClass(o2.clsControls).addClass(o2.clsControlPrev);
        if (o2.controlNext) {
          next.html(o2.controlNext);
        }
        if (o2.controlPrev) {
          prev.html(o2.controlPrev);
        }
        next.appendTo(element2);
        prev.appendTo(element2);
      },
      _createBullets: function() {
        const element2 = this.element;
        const o2 = this.options;
        let bullets;
        let i3;
        if (o2.bullets === false) {
          return;
        }
        bullets = $7("<div>").addClass("carousel-bullets").addClass(`${o2.bulletsSize}-size`).addClass(`bullet-style-${o2.bulletsStyle}`).addClass(o2.clsBullets);
        if (o2.bulletsPosition === "default" || o2.bulletsPosition === "center") {
          bullets.addClass("flex-justify-center");
        } else if (o2.bulletsPosition === "left") {
          bullets.addClass("flex-justify-start");
        } else {
          bullets.addClass("flex-justify-end");
        }
        for (i3 = 0; i3 < this.slides.length; i3++) {
          const bullet = $7("<span>").addClass("carousel-bullet").addClass(o2.clsBullet).data("slide", i3);
          if (i3 === 0) {
            bullet.addClass("bullet-on").addClass(o2.clsBulletOn);
          }
          bullet.appendTo(bullets);
        }
        bullets.appendTo(element2);
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        element2.on(Metro2.events.click, ".carousel-bullet", function() {
          const bullet = $7(this);
          if (that.isAnimate === false) {
            that._slideToSlide(bullet.data("slide"));
            that._fireEvent("bullet-click", {
              bullet
            });
          }
        });
        element2.on(Metro2.events.click, ".carousel-switch-next", function() {
          if (that.isAnimate === false) {
            that._slideTo("next", false);
            that._fireEvent("next-click", {
              button: this
            });
          }
        });
        element2.on(Metro2.events.click, ".carousel-switch-prev", function() {
          if (that.isAnimate === false) {
            that._slideTo("prev", false);
            that._fireEvent("prev-click", {
              button: this
            });
          }
        });
        if (o2.stopOnMouse === true && o2.autoStart === true) {
          element2.on(Metro2.events.enter, () => {
            that._stop();
            that._fireEvent(
              "mouse-enter",
              {
                element: element2
              },
              false,
              true
            );
          });
          element2.on(Metro2.events.leave, () => {
            that._start();
            that._fireEvent(
              "mouse-leave",
              {
                element: element2
              },
              false,
              true
            );
          });
        }
        if (o2.controlsOnMouse === true) {
          element2.on(Metro2.events.enter, () => {
            element2.find("[class*=carousel-switch]").fadeIn();
            element2.find(".carousel-bullets").fadeIn();
          });
          element2.on(Metro2.events.leave, () => {
            element2.find("[class*=carousel-switch]").fadeOut();
            element2.find(".carousel-bullets").fadeOut();
          });
        }
        element2.on(Metro2.events.click, ".slide", function() {
          const slide = $7(this);
          that._fireEvent("slide-click", {
            slide
          });
        });
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            that._resize();
          },
          { ns: this.id }
        );
      },
      _slideToSlide: function(index) {
        const element2 = this.element;
        const o2 = this.options;
        if (this.slides[index] === void 0) {
          return;
        }
        if (this.currentIndex === index) {
          return;
        }
        const to2 = index > this.currentIndex ? "next" : "prev";
        const current = this.slides[this.currentIndex];
        const next = this.slides[index];
        this.currentIndex = index;
        this._effect(current, next, o2.effect, to2);
        element2.find(".carousel-bullet").removeClass("bullet-on").removeClass(o2.clsBulletOn);
        element2.find(`.carousel-bullet:nth-child(${this.currentIndex + 1})`).addClass("bullet-on").addClass(o2.clsBulletOn);
      },
      _slideTo: function(to2 = "next", interval = false) {
        const element2 = this.element;
        const o2 = this.options;
        const current = this.slides[this.currentIndex];
        if (to2 === "next") {
          this.currentIndex++;
          if (this.currentIndex >= this.slides.length) {
            this.currentIndex = 0;
          }
        } else {
          this.currentIndex--;
          if (this.currentIndex < 0) {
            this.currentIndex = this.slides.length - 1;
          }
        }
        const next = this.slides[this.currentIndex];
        this._effect(current, next, o2.effect, to2, interval);
        element2.find(".carousel-bullet").removeClass("bullet-on").removeClass(o2.clsBulletOn);
        element2.find(`.carousel-bullet:nth-child(${this.currentIndex + 1})`).addClass("bullet-on").addClass(o2.clsBulletOn);
      },
      _effect: function(current, next, effect, to2, interval) {
        const that = this;
        const o2 = this.options;
        let duration = o2.duration;
        let func;
        let effectFunc = o2.effectFunc;
        let period = o2.period;
        const run = (f5, c5, n3, o3) => {
          Metro2.Effects[f5](c5[0], n3[0], o3);
        };
        if (next.data("duration") !== void 0) {
          duration = next.data("duration");
        }
        if (next.data("effectFunc") !== void 0) {
          effectFunc = next.data("effectFunc");
        }
        if (effect === "switch") {
          duration = 0;
        }
        current.stop(true);
        next.stop(true);
        this.isAnimate = true;
        setTimeout(() => {
          that.isAnimate = false;
        }, duration + 100);
        if (effect === "slide") {
          func = to2 === "next" ? "slideLeft" : "slideRight";
        } else if (effect === "slide-v") {
          func = to2 === "next" ? "slideUp" : "slideDown";
        } else {
          func = effect;
        }
        if (!effects.includes(effect)) {
          func = "switch";
        }
        run(func, current, next, { duration, ease: effectFunc });
        current.removeClass("active-slide");
        next.addClass("active-slide");
        setTimeout(() => {
          that._fireEvent("slide-show", {
            current: next[0],
            prev: current[0]
          });
        }, duration);
        setTimeout(() => {
          that._fireEvent("slide-hide", {
            current: current[0],
            next: next[0]
          });
        }, duration);
        if (interval === true) {
          if (next.data("period") !== void 0) {
            period = next.data("period");
          }
          this.interval = setTimeout(function run2() {
            const t = o2.direction === "left" ? "next" : "prior";
            that._slideTo(t, true);
          }, period);
        }
      },
      toSlide: function(index) {
        this._slideToSlide(index);
      },
      next: function() {
        this._slideTo("next");
      },
      prev: function() {
        this._slideTo("prev");
      },
      stop: function() {
        clearInterval(this.interval);
        this._fireEvent("stop");
      },
      play: function() {
        this._start();
        this._fireEvent("play");
      },
      setEffect: function(effect) {
        const element2 = this.element;
        const o2 = this.options;
        const slides = element2.find(".slide");
        if (!effects.includes(effect)) return;
        o2.effect = effect;
        slides.removeStyleProperty("transform").css({
          top: 0,
          left: 0
        });
      },
      changeAttribute: function(attributeName, newValue) {
        if (attributeName === "data-effect") {
          this.setEffect(newValue);
        }
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.off(Metro2.events.click, ".carousel-bullet");
        element2.off(Metro2.events.click, ".carousel-switch-next");
        element2.off(Metro2.events.click, ".carousel-switch-prev");
        if (o2.stopOnMouse === true && o2.autoStart === true) {
          element2.off(Metro2.events.enter);
          element2.off(Metro2.events.leave);
        }
        if (o2.controlsOnMouse === true) {
          element2.off(Metro2.events.enter);
          element2.off(Metro2.events.leave);
        }
        element2.off(Metro2.events.click, ".slide");
        $7(globalThis).off(Metro2.events.resize, { ns: this.id });
        return element2;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/catalog-menu/catalog-menu.js
  ((Metro2, $7) => {
    "use strict";
    let CatalogMenuDefaultConfig = {
      toggle: null,
      // Selector for toggle element
      onCatalogCreate: Metro2.noop
    };
    Metro2.catalogMenuSetup = (options) => {
      CatalogMenuDefaultConfig = $7.extend({}, CatalogMenuDefaultConfig, options);
    };
    if (typeof window.metroCatalogMenuSetup !== "undefined") {
      Metro2.catalogMenuSetup(window.metroCatalogMenuSetup);
    }
    Metro2.Component("catalog-menu", {
      init: function(options, elem) {
        this._super(elem, options, CatalogMenuDefaultConfig, {
          // define instance vars here
          toggle: null
        });
        return this;
      },
      _create: function() {
        this._calcResize();
        this._createStructure();
        this._createEvents();
        this._fireEvent("catalog-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (o2.toggle) {
          this.toggle = $7(o2.toggle);
          if (this.toggle.length === 0) {
            this.toggle = null;
          }
        }
        element2.addClass("catalog-menu");
      },
      _createEvents: function() {
        const element2 = this.element;
        if (this.toggle) {
          this.toggle.on("click", () => {
            element2.toggleClass("menu-active");
          });
        }
        $7("window").on("resize.catalog-menu", () => {
          this._calcResize();
        });
      },
      _calcResize: function() {
        const element2 = this.element;
        const { width } = Metro2.utils.getInnerSize(element2.parent());
        element2.cssVar("catalog-content-width", width + "px");
      },
      changeAttribute: (attr, val) => {
      },
      destroy: function() {
        $7("window").off("resize.catalog-menu");
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/charms/charms.js
  ((Metro2, $7) => {
    "use strict";
    let CharmsDefaultConfig = {
      charmsDeferred: 0,
      position: "right",
      opacity: 1,
      clsCharms: "",
      onCharmCreate: Metro2.noop,
      onOpen: Metro2.noop,
      onClose: Metro2.noop,
      onToggle: Metro2.noop
    };
    Metro2.charmsSetup = (options) => {
      CharmsDefaultConfig = $7.extend({}, CharmsDefaultConfig, options);
    };
    if (typeof globalThis.metroCharmsSetup !== "undefined") {
      Metro2.charmsSetup(globalThis.metroCharmsSetup);
    }
    Metro2.Component("charms", {
      init: function(options, elem) {
        this._super(elem, options, CharmsDefaultConfig, {
          origin: {
            background: ""
          }
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("charm-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("charms").addClass(`${o2.position}-side`).addClass(o2.clsCharms);
        this.origin.background = element2.css("background-color");
        element2.css({
          backgroundColor: Farbe.Routines.toRGBA(Metro2.utils.getStyleOne(element2, "background-color"), o2.opacity)
        });
      },
      _createEvents: () => {
      },
      open: function() {
        const element2 = this.element;
        element2.addClass("open");
        this._fireEvent("open");
      },
      close: function() {
        const element2 = this.element;
        element2.removeClass("open");
        this._fireEvent("close");
      },
      toggle: function() {
        const element2 = this.element;
        if (element2.hasClass("open") === true) {
          this.close();
        } else {
          this.open();
        }
        this._fireEvent("toggle");
      },
      opacity: function(v5) {
        const element2 = this.element;
        const o2 = this.options;
        if (v5 === void 0) {
          return o2.opacity;
        }
        const opacity = Math.abs(Number.parseFloat(v5));
        if (opacity < 0 || opacity > 1) {
          return;
        }
        o2.opacity = opacity;
        element2.css({
          backgroundColor: Farbe.Routines.toRGBA(Metro2.utils.getStyleOne(element2, "background-color"), opacity)
        });
      },
      changeOpacity: function() {
        const element2 = this.element;
        this.opacity(element2.attr("data-opacity"));
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-opacity":
            this.changeOpacity();
            break;
        }
      },
      destroy: function() {
        return this.element;
      }
    });
    Metro2.charms = {
      check: (el) => {
        if (Metro2.utils.isMetroObject(el, "charms") === false) {
          console.warn("Element is not a charms component");
          return false;
        }
        return true;
      },
      isOpen: function(el) {
        if (this.check(el) === false) return;
        return $7(el).hasClass("open");
      },
      open: function(el) {
        if (this.check(el) === false) return;
        Metro2.getPlugin(el, "charms").open();
      },
      close: function(el) {
        if (this.check(el) === false) return;
        Metro2.getPlugin(el, "charms").close();
      },
      toggle: function(el) {
        if (this.check(el) === false) return;
        Metro2.getPlugin(el, "charms").toggle();
      },
      closeAll: () => {
        $7("[data-role*=charms]").each(function() {
          Metro2.getPlugin(this, "charms").close();
        });
      },
      opacity: function(el, opacity) {
        if (this.check(el) === false) return;
        Metro2.getPlugin(el, "charms").opacity(opacity);
      }
    };
  })(Metro, Dom);

  // ../metroui-lib/source/components/textarea/textarea.js
  ((Metro2, $7) => {
    "use strict";
    let TextareaDefaultConfig = {
      label: "",
      textareaDeferred: 0,
      charsCounter: null,
      charsCounterTemplate: "$1",
      defaultValue: "",
      prepend: "",
      append: "",
      clearButton: true,
      clearButtonIcon: "\u2716",
      btnSize: "default",
      autoSize: true,
      maxHeight: 0,
      initialHeight: 100,
      clsPrepend: "",
      clsAppend: "",
      clsComponent: "",
      clsTextarea: "",
      clsLabel: "",
      onChange: Metro2.noop,
      onTextareaCreate: Metro2.noop
    };
    Metro2.textareaSetup = (options) => {
      TextareaDefaultConfig = $7.extend({}, TextareaDefaultConfig, options);
    };
    if (typeof globalThis.metroTextareaSetup !== "undefined") {
      Metro2.textareaSetup(globalThis.metroTextareaSetup);
    }
    Metro2.Component("textarea", {
      init: function(options, elem) {
        this._super(elem, options, TextareaDefaultConfig);
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("textarea-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const elem = this.elem;
        const o2 = this.options;
        let clearButton;
        const fakeTextarea = $7("<textarea>").addClass("fake-textarea");
        if (!element2.id()) {
          element2.attr("id", Hooks.useId(element2[0]));
        }
        const container = element2.wrap("<div>").addClass(`textarea ${element2[0].className}`);
        container.attr("id", Hooks.useId(container[0]));
        fakeTextarea.appendTo(container);
        if (o2.clearButton !== false && !element2[0].readOnly) {
          clearButton = $7("<button>").addClass(`button square input-clear-button`).attr("tabindex", -1).attr("type", "button").html(o2.clearButtonIcon);
          clearButton.appendTo(container);
        }
        if (element2.attr("dir") === "rtl") {
          container.addClass("rtl").attr("dir", "rtl");
        }
        if (o2.prepend !== "") {
          const prepend = $7("<div>").html(o2.prepend);
          prepend.addClass("prepend").addClass(o2.clsPrepend).appendTo(container);
        }
        if (o2.append !== "") {
          const append = $7("<div>").html(o2.append);
          append.addClass("append").addClass(o2.clsAppend).appendTo(container);
          clearButton.css({
            right: append.outerWidth() + 4
          });
        }
        elem.className = "";
        if (Metro2.utils.isValue(o2.defaultValue) && element2.val().trim() === "") {
          element2.val(o2.defaultValue);
        }
        container.addClass(o2.clsComponent);
        element2.addClass(o2.clsTextarea);
        this._addLabel(o2.label, container, {
          className: o2.clsLabel,
          id: element2.attr("id"),
          dir: element2.attr("dir")
        });
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        fakeTextarea.val(element2.val());
        container.find("textarea").css({
          minHeight: o2.initialHeight + "px"
        });
        if (o2.autoSize === true) {
          container.addClass("autosize no-scroll-vertical");
          setTimeout(() => {
            this.resize();
          }, 100);
        }
        this.component = container;
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const textarea = element2.closest(".textarea");
        const fakeTextarea = textarea.find(".fake-textarea");
        const chars_counter = $7(o2.charsCounter);
        textarea.on(Metro2.events.click, ".input-clear-button", (e2) => {
          element2.val(Metro2.utils.isValue(o2.defaultValue) ? o2.defaultValue : "").trigger("change").trigger("keyup").focus();
          e2.preventDefault();
          e2.stopPropagation();
        });
        if (o2.autoSize) {
          element2.on(`${Metro2.events.inputchange} ${Metro2.events.keyup}`, function() {
            fakeTextarea.val(this.value);
            that.resize();
          });
        }
        element2.on(Metro2.events.blur, () => {
          textarea.removeClass("focused");
        });
        element2.on(Metro2.events.focus, () => {
          textarea.addClass("focused");
        });
        element2.on(Metro2.events.keyup, () => {
          if (Metro2.utils.isValue(o2.charsCounter) && chars_counter.length > 0) {
            if (chars_counter[0].tagName === "INPUT") {
              chars_counter.val(that.length());
            } else {
              chars_counter.html(o2.charsCounterTemplate.replace("$1", that.length()));
            }
          }
          that._fireEvent("change", {
            val: element2.val(),
            length: that.length()
          });
        });
      },
      resize: function() {
        const element2 = this.element;
        const o2 = this.options;
        const textarea = element2.closest(".textarea");
        const fakeTextarea = textarea.find(".fake-textarea");
        const currentHeight = fakeTextarea[0].scrollHeight;
        if (o2.maxHeight && currentHeight >= o2.maxHeight) {
          textarea.removeClass("no-scroll-vertical");
          return;
        }
        if (o2.maxHeight && currentHeight < o2.maxHeight) {
          textarea.addClass("no-scroll-vertical");
        }
        fakeTextarea[0].style.cssText = "height:auto;";
        fakeTextarea[0].style.cssText = `height:${fakeTextarea[0].scrollHeight}px; min-height:${o2.initialHeight}px;`;
        element2[0].style.cssText = `height:${fakeTextarea[0].scrollHeight}px; min-height:${o2.initialHeight}px;`;
      },
      clear: function() {
        this.element.val("").trigger("change").trigger("keyup").focus();
      },
      toDefault: function() {
        this.element.val(Metro2.utils.isValue(this.options.defaultValue) ? this.options.defaultValue : "").trigger("change").trigger("keyup").focus();
      },
      length: function() {
        const characters = this.elem.value.split("");
        return characters.length;
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "disabled":
            this.toggleState();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        const textarea = element2.closest(".textarea");
        textarea.off(Metro2.events.click, ".input-clear-button");
        if (o2.autoSize) {
          element2.off(`${Metro2.events.inputchange} ${Metro2.events.keyup}`);
        }
        element2.off(Metro2.events.blur);
        element2.off(Metro2.events.focus);
        element2.off(Metro2.events.keyup);
        if (o2.label) {
          this.component.prev("label").remove();
        }
        this.component.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/chat/emoji.js
  var emojiMap = {
    "o/": "\u{1F44B}",
    "</3": "\u{1F494}",
    "<3": "\u{1F497}",
    "8-D": "\u{1F601}",
    "8D": "\u{1F601}",
    ":-D": "\u{1F601}",
    ":-3": "\u{1F601}",
    ":3": "\u{1F601}",
    ":D": "\u{1F601}",
    "B^D": "\u{1F601}",
    "X-D": "\u{1F601}",
    XD: "\u{1F601}",
    "x-D": "\u{1F601}",
    xD: "\u{1F601}",
    ":')": "\u{1F602}",
    ":'-)": "\u{1F602}",
    ":-))": "\u{1F603}",
    "8)": "\u{1F604}",
    ":)": "\u{1F60A}",
    ":-)": "\u{1F604}",
    ":]": "\u{1F604}",
    ":^)": "\u{1F604}",
    ":c)": "\u{1F604}",
    ":o)": "\u{1F604}",
    ":}": "\u{1F604}",
    ":\u3063)": "\u{1F604}",
    "0:)": "\u{1F607}",
    "0:-)": "\u{1F607}",
    "0:-3": "\u{1F607}",
    "0:3": "\u{1F607}",
    "0;^)": "\u{1F607}",
    "O:-)": "\u{1F607}",
    "3:)": "\u{1F608}",
    "3:-)": "\u{1F608}",
    "}:)": "\u{1F608}",
    "}:-)": "\u{1F608}",
    "*)": "\u{1F609}",
    "*-)": "\u{1F609}",
    ":-,": "\u{1F609}",
    ";)": "\u{1F609}",
    ";-)": "\u{1F609}",
    ";-]": "\u{1F609}",
    ";D": "\u{1F609}",
    ";]": "\u{1F609}",
    ";^)": "\u{1F609}",
    ":-|": "\u{1F610}",
    ":|": "\u{1F610}",
    ":(": "\u{1F61E}",
    ":-(": "\u{1F612}",
    ":-<": "\u{1F612}",
    ":-[": "\u{1F612}",
    ":-c": "\u{1F612}",
    ":<": "\u{1F612}",
    ":[": "\u{1F612}",
    ":c": "\u{1F612}",
    ":{": "\u{1F612}",
    ":\u3063C": "\u{1F612}",
    "%)": "\u{1F616}",
    "%-)": "\u{1F616}",
    ":-P": "\u{1F61C}",
    ":-b": "\u{1F61C}",
    ":-p": "\u{1F61C}",
    ":-\xDE": "\u{1F61C}",
    ":-\xFE": "\u{1F61C}",
    ":P": "\u{1F61C}",
    ":b": "\u{1F61C}",
    ":p": "\u{1F61C}",
    ":\xDE": "\u{1F61C}",
    ":\xFE": "\u{1F61C}",
    ";(": "\u{1F61C}",
    "X-P": "\u{1F61C}",
    XP: "\u{1F61C}",
    "d:": "\u{1F61C}",
    "x-p": "\u{1F61C}",
    xp: "\u{1F61C}",
    ":-||": "\u{1F620}",
    ":@": "\u{1F620}",
    ":-.": "\u{1F621}",
    ":-/": "\u{1F621}",
    ":/": "\u{1F610}",
    ":L": "\u{1F621}",
    ":S": "\u{1F621}",
    ":\\": "\u{1F621}",
    ":'(": "\u{1F622}",
    ":'-(": "\u{1F622}",
    "^5": "\u{1F624}",
    "^<_<": "\u{1F624}",
    "o/\\o": "\u{1F624}",
    "|-O": "\u{1F62B}",
    "|;-)": "\u{1F62B}",
    ":###..": "\u{1F630}",
    ":#": "\u{1F605}",
    ":-###..": "\u{1F630}",
    "D-':": "\u{1F631}",
    D8: "\u{1F631}",
    "D:": "\u{1F631}",
    "D:<": "\u{1F631}",
    "D;": "\u{1F631}",
    DX: "\u{1F631}",
    "v.v": "\u{1F631}",
    "8-0": "\u{1F632}",
    ":-O": "\u{1F632}",
    ":-o": "\u{1F632}",
    ":O": "\u{1F632}",
    ":o": "\u{1F632}",
    "O-O": "\u{1F632}",
    O_O: "\u{1F632}",
    O_o: "\u{1F632}",
    "o-o": "\u{1F632}",
    o_O: "\u{1F632}",
    o_o: "\u{1F632}",
    ":$": "\u{1F633}",
    "#-)": "\u{1F635}",
    ":&": "\u{1F636}",
    ":-#": "\u{1F636}",
    ":-&": "\u{1F636}",
    ":-X": "\u{1F636}",
    ":X": "\u{1F636}",
    ":-J": "\u{1F63C}",
    ":*": "\u{1F618}",
    ":^*": "\u{1F63D}",
    \u0CA0_\u0CA0: "\u{1F645}",
    "*\\0/*": "\u{1F646}",
    "\\o/": "\u{1F646}",
    ":>": "\u{1F604}",
    ">.<": "\u{1F621}",
    ">:(": "\u{1F620}",
    ">:)": "\u{1F608}",
    ">:-)": "\u{1F608}",
    ">:/": "\u{1F621}",
    ">:O": "\u{1F632}",
    ">:P": "\u{1F61C}",
    ">:[": "\u{1F612}",
    ">:\\": "\u{1F621}",
    ">;)": "\u{1F608}",
    ">_>^": "\u{1F624}",
    "^^": "\u{1F60A}",
    ":sweat:": "\u{1F605}",
    ":smile:": "\u{1F604}",
    ":laughing:": "\u{1F606}",
    ":blush:": "\u{1F60A}",
    ":smiley:": "\u{1F603}",
    ":relaxed:": "\u263A\uFE0F",
    ":smirk:": "\u{1F60F}",
    ":heart_eyes:": "\u{1F60D}",
    ":kissing_heart:": "\u{1F618}",
    ":kissing_closed_eyes:": "\u{1F61A}",
    ":flushed:": "\u{1F633}",
    ":relieved:": "\u{1F60C}",
    ":satisfied:": "\u{1F606}",
    ":grin:": "\u{1F601}",
    ":wink:": "\u{1F609}",
    ":stuck_out_tongue_winking_eye:": "\u{1F61C}",
    ":stuck_out_tongue_closed_eyes:": "\u{1F61D}",
    ":grinning:": "\u{1F600}",
    ":kissing:": "\u{1F617}",
    ":kissing_smiling_eyes:": "\u{1F619}",
    ":stuck_out_tongue:": "\u{1F61B}",
    ":sleeping:": "\u{1F634}",
    ":worried:": "\u{1F61F}",
    ":frowning:": "\u{1F626}",
    ":anguished:": "\u{1F627}",
    ":open_mouth:": "\u{1F62E}",
    ":grimacing:": "\u{1F62C}",
    ":confused:": "\u{1F615}",
    ":hushed:": "\u{1F62F}",
    ":expressionless:": "\u{1F611}",
    ":unamused:": "\u{1F612}",
    ":sweat_smile:": "\u{1F605}",
    ":disappointed_relieved:": "\u{1F625}",
    ":weary:": "\u{1F629}",
    ":pensive:": "\u{1F614}",
    ":disappointed:": "\u{1F61E}",
    ":confounded:": "\u{1F616}",
    ":fearful:": "\u{1F628}",
    ":cold_sweat:": "\u{1F630}",
    ":persevere:": "\u{1F623}",
    ":cry:": "\u{1F622}",
    ":sob:": "\u{1F62D}",
    ":joy:": "\u{1F602}",
    ":astonished:": "\u{1F632}",
    ":scream:": "\u{1F631}",
    ":tired_face:": "\u{1F62B}",
    ":angry:": "\u{1F620}",
    ":rage:": "\u{1F621}",
    ":triumph:": "\u{1F624}",
    ":sleepy:": "\u{1F62A}",
    ":yum:": "\u{1F60B}",
    ":mask:": "\u{1F637}",
    ":sunglasses:": "\u{1F60E}",
    ":dizzy_face:": "\u{1F635}",
    ":imp:": "\u{1F47F}",
    ":smiling_imp:": "\u{1F608}",
    ":neutral_face:": "\u{1F610}",
    ":no_mouth:": "\u{1F636}",
    ":innocent:": "\u{1F607}",
    ":alien:": "\u{1F47D}",
    ":yellow_heart:": "\u{1F49B}",
    ":blue_heart:": "\u{1F499}",
    ":purple_heart:": "\u{1F49C}",
    ":heart:": "\u2764\uFE0F",
    ":green_heart:": "\u{1F49A}",
    ":broken_heart:": "\u{1F494}",
    ":heartbeat:": "\u{1F493}",
    ":heartpulse:": "\u{1F497}",
    ":two_hearts:": "\u{1F495}",
    ":revolving_hearts:": "\u{1F49E}",
    ":cupid:": "\u{1F498}",
    ":sparkling_heart:": "\u{1F496}",
    ":sparkles:": "\u2728",
    ":star:": "\u2B50",
    ":star2:": "\u{1F31F}",
    ":dizzy:": "\u{1F4AB}",
    ":boom:": "\u{1F4A5}",
    ":collision:": "\u{1F4A5}",
    ":anger:": "\u{1F4A2}",
    ":exclamation:": "\u2757",
    ":question:": "\u2753",
    ":grey_exclamation:": "\u2755",
    ":grey_question:": "\u2754",
    ":zzz:": "\u{1F4A4}",
    ":dash:": "\u{1F4A8}",
    ":sweat_drops:": "\u{1F4A6}",
    ":notes:": "\u{1F3B6}",
    ":musical_note:": "\u{1F3B5}",
    ":fire:": "\u{1F525}",
    ":hankey:": "\u{1F4A9}",
    ":poop:": "\u{1F4A9}",
    ":shit:": "\u{1F4A9}",
    ":+1:": "\u{1F44D}",
    ":thumbsup:": "\u{1F44D}",
    ":-1:": "\u{1F44E}",
    ":thumbsdown:": "\u{1F44E}",
    ":ok_hand:": "\u{1F44C}",
    ":punch:": "\u{1F44A}",
    ":facepunch:": "\u{1F44A}",
    ":fist:": "\u270A",
    ":v:": "\u270C\uFE0F",
    ":wave:": "\u{1F44B}",
    ":hand:": "\u270B",
    ":raised_hand:": "\u270B",
    ":open_hands:": "\u{1F450}",
    ":point_up:": "\u261D\uFE0F",
    ":point_down:": "\u{1F447}",
    ":point_left:": "\u{1F448}",
    ":point_right:": "\u{1F449}",
    ":raised_hands:": "\u{1F64C}",
    ":pray:": "\u{1F64F}",
    ":point_up_2:": "\u{1F446}",
    ":clap:": "\u{1F44F}",
    ":muscle:": "\u{1F4AA}",
    ":metal:": "\u{1F918}",
    ":fu:": "\u{1F595}",
    ":walking:": "\u{1F6B6}",
    ":runner:": "\u{1F3C3}",
    ":running:": "\u{1F3C3}",
    ":couple:": "\u{1F46B}",
    ":family:": "\u{1F46A}",
    ":two_men_holding_hands:": "\u{1F46C}",
    ":two_women_holding_hands:": "\u{1F46D}",
    ":dancer:": "\u{1F483}",
    ":dancers:": "\u{1F46F}",
    ":no_good:": "\u{1F645}",
    ":information_desk_person:": "\u{1F481}",
    ":raising_hand:": "\u{1F64B}",
    ":bride_with_veil:": "\u{1F470}",
    ":bow:": "\u{1F647}",
    ":couplekiss:": "\u{1F48F}",
    ":couple_with_heart:": "\u{1F491}",
    ":massage:": "\u{1F486}",
    ":haircut:": "\u{1F487}",
    ":nail_care:": "\u{1F485}",
    ":boy:": "\u{1F466}",
    ":girl:": "\u{1F467}",
    ":woman:": "\u{1F469}",
    ":man:": "\u{1F468}",
    ":baby:": "\u{1F476}",
    ":older_woman:": "\u{1F475}",
    ":older_man:": "\u{1F474}",
    ":man_with_gua_pi_mao:": "\u{1F472}",
    ":construction_worker:": "\u{1F477}",
    ":cop:": "\u{1F46E}",
    ":angel:": "\u{1F47C}",
    ":princess:": "\u{1F478}",
    ":smiley_cat:": "\u{1F63A}",
    ":smile_cat:": "\u{1F638}",
    ":heart_eyes_cat:": "\u{1F63B}",
    ":kissing_cat:": "\u{1F63D}",
    ":smirk_cat:": "\u{1F63C}",
    ":scream_cat:": "\u{1F640}",
    ":crying_cat_face:": "\u{1F63F}",
    ":joy_cat:": "\u{1F639}",
    ":pouting_cat:": "\u{1F63E}",
    ":japanese_ogre:": "\u{1F479}",
    ":japanese_goblin:": "\u{1F47A}",
    ":see_no_evil:": "\u{1F648}",
    ":hear_no_evil:": "\u{1F649}",
    ":speak_no_evil:": "\u{1F64A}",
    ":skull:": "\u{1F480}",
    ":feet:": "\u{1F43E}",
    ":lips:": "\u{1F444}",
    ":kiss:": "\u{1F48B}",
    ":droplet:": "\u{1F4A7}",
    ":ear:": "\u{1F442}",
    ":eyes:": "\u{1F440}",
    ":nose:": "\u{1F443}",
    ":tongue:": "\u{1F445}",
    ":love_letter:": "\u{1F48C}",
    ":bust_in_silhouette:": "\u{1F464}",
    ":busts_in_silhouette:": "\u{1F465}",
    ":speech_balloon:": "\u{1F4AC}",
    ":thought_balloon:": "\u{1F4AD}",
    ":sunny:": "\u2600\uFE0F",
    ":umbrella:": "\u2614",
    ":cloud:": "\u2601\uFE0F",
    ":snowflake:": "\u2744\uFE0F",
    ":snowman:": "\u26C4",
    ":zap:": "\u26A1",
    ":cyclone:": "\u{1F300}",
    ":foggy:": "\u{1F301}",
    ":ocean:": "\u{1F30A}",
    ":cat:": "\u{1F431}",
    ":dog:": "\u{1F436}",
    ":mouse:": "\u{1F42D}",
    ":hamster:": "\u{1F439}",
    ":rabbit:": "\u{1F430}",
    ":wolf:": "\u{1F43A}",
    ":frog:": "\u{1F438}",
    ":tiger:": "\u{1F42F}",
    ":koala:": "\u{1F428}",
    ":bear:": "\u{1F43B}",
    ":pig:": "\u{1F437}",
    ":pig_nose:": "\u{1F43D}",
    ":cow:": "\u{1F42E}",
    ":boar:": "\u{1F417}",
    ":monkey_face:": "\u{1F435}",
    ":monkey:": "\u{1F412}",
    ":horse:": "\u{1F434}",
    ":racehorse:": "\u{1F40E}",
    ":camel:": "\u{1F42B}",
    ":sheep:": "\u{1F411}",
    ":elephant:": "\u{1F418}",
    ":panda_face:": "\u{1F43C}",
    ":snake:": "\u{1F40D}",
    ":bird:": "\u{1F426}",
    ":baby_chick:": "\u{1F424}",
    ":hatched_chick:": "\u{1F425}",
    ":hatching_chick:": "\u{1F423}",
    ":chicken:": "\u{1F414}",
    ":penguin:": "\u{1F427}",
    ":turtle:": "\u{1F422}",
    ":bug:": "\u{1F41B}",
    ":honeybee:": "\u{1F41D}",
    ":ant:": "\u{1F41C}",
    ":beetle:": "\u{1F41E}",
    ":snail:": "\u{1F40C}",
    ":octopus:": "\u{1F419}",
    ":tropical_fish:": "\u{1F420}",
    ":fish:": "\u{1F41F}",
    ":whale:": "\u{1F433}",
    ":whale2:": "\u{1F40B}",
    ":dolphin:": "\u{1F42C}",
    ":cow2:": "\u{1F404}",
    ":ram:": "\u{1F40F}",
    ":rat:": "\u{1F400}",
    ":water_buffalo:": "\u{1F403}",
    ":tiger2:": "\u{1F405}",
    ":rabbit2:": "\u{1F407}",
    ":dragon:": "\u{1F409}",
    ":goat:": "\u{1F410}",
    ":rooster:": "\u{1F413}",
    ":dog2:": "\u{1F415}",
    ":pig2:": "\u{1F416}",
    ":mouse2:": "\u{1F401}",
    ":ox:": "\u{1F402}",
    ":dragon_face:": "\u{1F432}",
    ":blowfish:": "\u{1F421}",
    ":crocodile:": "\u{1F40A}",
    ":dromedary_camel:": "\u{1F42A}",
    ":leopard:": "\u{1F406}",
    ":cat2:": "\u{1F408}",
    ":poodle:": "\u{1F429}",
    ":paw_prints:": "\u{1F43E}",
    ":bouquet:": "\u{1F490}",
    ":cherry_blossom:": "\u{1F338}",
    ":tulip:": "\u{1F337}",
    ":four_leaf_clover:": "\u{1F340}",
    ":rose:": "\u{1F339}",
    ":sunflower:": "\u{1F33B}",
    ":hibiscus:": "\u{1F33A}",
    ":maple_leaf:": "\u{1F341}",
    ":leaves:": "\u{1F343}",
    ":fallen_leaf:": "\u{1F342}",
    ":herb:": "\u{1F33F}",
    ":mushroom:": "\u{1F344}",
    ":cactus:": "\u{1F335}",
    ":palm_tree:": "\u{1F334}",
    ":evergreen_tree:": "\u{1F332}",
    ":deciduous_tree:": "\u{1F333}",
    ":chestnut:": "\u{1F330}",
    ":seedling:": "\u{1F331}",
    ":blossom:": "\u{1F33C}",
    ":ear_of_rice:": "\u{1F33E}",
    ":shell:": "\u{1F41A}",
    ":globe_with_meridians:": "\u{1F310}",
    ":sun_with_face:": "\u{1F31E}",
    ":full_moon_with_face:": "\u{1F31D}",
    ":new_moon_with_face:": "\u{1F31A}",
    ":new_moon:": "\u{1F311}",
    ":waxing_crescent_moon:": "\u{1F312}",
    ":first_quarter_moon:": "\u{1F313}",
    ":waxing_gibbous_moon:": "\u{1F314}",
    ":full_moon:": "\u{1F315}",
    ":waning_gibbous_moon:": "\u{1F316}",
    ":last_quarter_moon:": "\u{1F317}",
    ":waning_crescent_moon:": "\u{1F318}",
    ":last_quarter_moon_with_face:": "\u{1F31C}",
    ":first_quarter_moon_with_face:": "\u{1F31B}",
    ":moon:": "\u{1F314}",
    ":earth_africa:": "\u{1F30D}",
    ":earth_americas:": "\u{1F30E}",
    ":earth_asia:": "\u{1F30F}",
    ":volcano:": "\u{1F30B}",
    ":milky_way:": "\u{1F30C}",
    ":partly_sunny:": "\u26C5",
    ":bamboo:": "\u{1F38D}",
    ":gift_heart:": "\u{1F49D}",
    ":dolls:": "\u{1F38E}",
    ":school_satchel:": "\u{1F392}",
    ":mortar_board:": "\u{1F393}",
    ":flags:": "\u{1F38F}",
    ":fireworks:": "\u{1F386}",
    ":sparkler:": "\u{1F387}",
    ":wind_chime:": "\u{1F390}",
    ":rice_scene:": "\u{1F391}",
    ":jack_o_lantern:": "\u{1F383}",
    ":ghost:": "\u{1F47B}",
    ":santa:": "\u{1F385}",
    ":christmas_tree:": "\u{1F384}",
    ":gift:": "\u{1F381}",
    ":bell:": "\u{1F514}",
    ":no_bell:": "\u{1F515}",
    ":tanabata_tree:": "\u{1F38B}",
    ":tada:": "\u{1F389}",
    ":confetti_ball:": "\u{1F38A}",
    ":balloon:": "\u{1F388}",
    ":crystal_ball:": "\u{1F52E}",
    ":cd:": "\u{1F4BF}",
    ":dvd:": "\u{1F4C0}",
    ":floppy_disk:": "\u{1F4BE}",
    ":camera:": "\u{1F4F7}",
    ":video_camera:": "\u{1F4F9}",
    ":movie_camera:": "\u{1F3A5}",
    ":computer:": "\u{1F4BB}",
    ":tv:": "\u{1F4FA}",
    ":iphone:": "\u{1F4F1}",
    ":phone:": "\u260E\uFE0F",
    ":telephone:": "\u260E\uFE0F",
    ":telephone_receiver:": "\u{1F4DE}",
    ":pager:": "\u{1F4DF}",
    ":fax:": "\u{1F4E0}",
    ":minidisc:": "\u{1F4BD}",
    ":vhs:": "\u{1F4FC}",
    ":sound:": "\u{1F509}",
    ":speaker:": "\u{1F508}",
    ":mute:": "\u{1F507}",
    ":loudspeaker:": "\u{1F4E2}",
    ":mega:": "\u{1F4E3}",
    ":hourglass:": "\u231B",
    ":hourglass_flowing_sand:": "\u23F3",
    ":alarm_clock:": "\u23F0",
    ":watch:": "\u231A",
    ":radio:": "\u{1F4FB}",
    ":satellite:": "\u{1F4E1}",
    ":loop:": "\u27BF",
    ":mag:": "\u{1F50D}",
    ":mag_right:": "\u{1F50E}",
    ":unlock:": "\u{1F513}",
    ":lock:": "\u{1F512}",
    ":lock_with_ink_pen:": "\u{1F50F}",
    ":closed_lock_with_key:": "\u{1F510}",
    ":key:": "\u{1F511}",
    ":bulb:": "\u{1F4A1}",
    ":flashlight:": "\u{1F526}",
    ":high_brightness:": "\u{1F506}",
    ":low_brightness:": "\u{1F505}",
    ":electric_plug:": "\u{1F50C}",
    ":battery:": "\u{1F50B}",
    ":calling:": "\u{1F4F2}",
    ":email:": "\u2709\uFE0F",
    ":mailbox:": "\u{1F4EB}",
    ":postbox:": "\u{1F4EE}",
    ":bath:": "\u{1F6C0}",
    ":bathtub:": "\u{1F6C1}",
    ":shower:": "\u{1F6BF}",
    ":toilet:": "\u{1F6BD}",
    ":wrench:": "\u{1F527}",
    ":nut_and_bolt:": "\u{1F529}",
    ":hammer:": "\u{1F528}",
    ":seat:": "\u{1F4BA}",
    ":moneybag:": "\u{1F4B0}",
    ":yen:": "\u{1F4B4}",
    ":dollar:": "\u{1F4B5}",
    ":pound:": "\u{1F4B7}",
    ":euro:": "\u{1F4B6}",
    ":credit_card:": "\u{1F4B3}",
    ":money_with_wings:": "\u{1F4B8}",
    ":e-mail:": "\u{1F4E7}",
    ":inbox_tray:": "\u{1F4E5}",
    ":outbox_tray:": "\u{1F4E4}",
    ":envelope:": "\u2709\uFE0F",
    ":incoming_envelope:": "\u{1F4E8}",
    ":postal_horn:": "\u{1F4EF}",
    ":mailbox_closed:": "\u{1F4EA}",
    ":mailbox_with_mail:": "\u{1F4EC}",
    ":mailbox_with_no_mail:": "\u{1F4ED}",
    ":package:": "\u{1F4E6}",
    ":door:": "\u{1F6AA}",
    ":smoking:": "\u{1F6AC}",
    ":bomb:": "\u{1F4A3}",
    ":gun:": "\u{1F52B}",
    ":hocho:": "\u{1F52A}",
    ":pill:": "\u{1F48A}",
    ":syringe:": "\u{1F489}",
    ":page_facing_up:": "\u{1F4C4}",
    ":page_with_curl:": "\u{1F4C3}",
    ":bookmark_tabs:": "\u{1F4D1}",
    ":bar_chart:": "\u{1F4CA}",
    ":chart_with_upwards_trend:": "\u{1F4C8}",
    ":chart_with_downwards_trend:": "\u{1F4C9}",
    ":scroll:": "\u{1F4DC}",
    ":clipboard:": "\u{1F4CB}",
    ":calendar:": "\u{1F4C6}",
    ":date:": "\u{1F4C5}",
    ":card_index:": "\u{1F4C7}",
    ":file_folder:": "\u{1F4C1}",
    ":open_file_folder:": "\u{1F4C2}",
    ":scissors:": "\u2702\uFE0F",
    ":pushpin:": "\u{1F4CC}",
    ":paperclip:": "\u{1F4CE}",
    ":black_nib:": "\u2712\uFE0F",
    ":pencil2:": "\u270F\uFE0F",
    ":straight_ruler:": "\u{1F4CF}",
    ":triangular_ruler:": "\u{1F4D0}",
    ":closed_book:": "\u{1F4D5}",
    ":green_book:": "\u{1F4D7}",
    ":blue_book:": "\u{1F4D8}",
    ":orange_book:": "\u{1F4D9}",
    ":notebook:": "\u{1F4D3}",
    ":notebook_with_decorative_cover:": "\u{1F4D4}",
    ":ledger:": "\u{1F4D2}",
    ":books:": "\u{1F4DA}",
    ":bookmark:": "\u{1F516}",
    ":name_badge:": "\u{1F4DB}",
    ":microscope:": "\u{1F52C}",
    ":telescope:": "\u{1F52D}",
    ":newspaper:": "\u{1F4F0}",
    ":football:": "\u{1F3C8}",
    ":basketball:": "\u{1F3C0}",
    ":soccer:": "\u26BD",
    ":baseball:": "\u26BE",
    ":tennis:": "\u{1F3BE}",
    ":8ball:": "\u{1F3B1}",
    ":rugby_football:": "\u{1F3C9}",
    ":bowling:": "\u{1F3B3}",
    ":golf:": "\u26F3",
    ":mountain_bicyclist:": "\u{1F6B5}",
    ":bicyclist:": "\u{1F6B4}",
    ":horse_racing:": "\u{1F3C7}",
    ":snowboarder:": "\u{1F3C2}",
    ":swimmer:": "\u{1F3CA}",
    ":surfer:": "\u{1F3C4}",
    ":ski:": "\u{1F3BF}",
    ":spades:": "\u2660\uFE0F",
    ":hearts:": "\u2665\uFE0F",
    ":clubs:": "\u2663\uFE0F",
    ":diamonds:": "\u2666\uFE0F",
    ":gem:": "\u{1F48E}",
    ":ring:": "\u{1F48D}",
    ":trophy:": "\u{1F3C6}",
    ":musical_score:": "\u{1F3BC}",
    ":musical_keyboard:": "\u{1F3B9}",
    ":violin:": "\u{1F3BB}",
    ":space_invader:": "\u{1F47E}",
    ":video_game:": "\u{1F3AE}",
    ":black_joker:": "\u{1F0CF}",
    ":flower_playing_cards:": "\u{1F3B4}",
    ":game_die:": "\u{1F3B2}",
    ":dart:": "\u{1F3AF}",
    ":mahjong:": "\u{1F004}",
    ":clapper:": "\u{1F3AC}",
    ":memo:": "\u{1F4DD}",
    ":pencil:": "\u{1F4DD}",
    ":book:": "\u{1F4D6}",
    ":art:": "\u{1F3A8}",
    ":microphone:": "\u{1F3A4}",
    ":headphones:": "\u{1F3A7}",
    ":trumpet:": "\u{1F3BA}",
    ":saxophone:": "\u{1F3B7}",
    ":guitar:": "\u{1F3B8}",
    ":shoe:": "\u{1F45E}",
    ":sandal:": "\u{1F461}",
    ":high_heel:": "\u{1F460}",
    ":lipstick:": "\u{1F484}",
    ":boot:": "\u{1F462}",
    ":shirt:": "\u{1F455}",
    ":tshirt:": "\u{1F455}",
    ":necktie:": "\u{1F454}",
    ":womans_clothes:": "\u{1F45A}",
    ":dress:": "\u{1F457}",
    ":running_shirt_with_sash:": "\u{1F3BD}",
    ":jeans:": "\u{1F456}",
    ":kimono:": "\u{1F458}",
    ":bikini:": "\u{1F459}",
    ":ribbon:": "\u{1F380}",
    ":tophat:": "\u{1F3A9}",
    ":crown:": "\u{1F451}",
    ":womans_hat:": "\u{1F452}",
    ":mans_shoe:": "\u{1F45E}",
    ":closed_umbrella:": "\u{1F302}",
    ":briefcase:": "\u{1F4BC}",
    ":handbag:": "\u{1F45C}",
    ":pouch:": "\u{1F45D}",
    ":purse:": "\u{1F45B}",
    ":eyeglasses:": "\u{1F453}",
    ":fishing_pole_and_fish:": "\u{1F3A3}",
    ":coffee:": "\u2615",
    ":tea:": "\u{1F375}",
    ":sake:": "\u{1F376}",
    ":baby_bottle:": "\u{1F37C}",
    ":beer:": "\u{1F37A}",
    ":beers:": "\u{1F37B}",
    ":cocktail:": "\u{1F378}",
    ":tropical_drink:": "\u{1F379}",
    ":wine_glass:": "\u{1F377}",
    ":fork_and_knife:": "\u{1F374}",
    ":pizza:": "\u{1F355}",
    ":hamburger:": "\u{1F354}",
    ":fries:": "\u{1F35F}",
    ":poultry_leg:": "\u{1F357}",
    ":meat_on_bone:": "\u{1F356}",
    ":spaghetti:": "\u{1F35D}",
    ":curry:": "\u{1F35B}",
    ":fried_shrimp:": "\u{1F364}",
    ":bento:": "\u{1F371}",
    ":sushi:": "\u{1F363}",
    ":fish_cake:": "\u{1F365}",
    ":rice_ball:": "\u{1F359}",
    ":rice_cracker:": "\u{1F358}",
    ":rice:": "\u{1F35A}",
    ":ramen:": "\u{1F35C}",
    ":stew:": "\u{1F372}",
    ":oden:": "\u{1F362}",
    ":dango:": "\u{1F361}",
    ":egg:": "\u{1F95A}",
    ":bread:": "\u{1F35E}",
    ":doughnut:": "\u{1F369}",
    ":custard:": "\u{1F36E}",
    ":icecream:": "\u{1F366}",
    ":ice_cream:": "\u{1F368}",
    ":shaved_ice:": "\u{1F367}",
    ":birthday:": "\u{1F382}",
    ":cake:": "\u{1F370}",
    ":cookie:": "\u{1F36A}",
    ":chocolate_bar:": "\u{1F36B}",
    ":candy:": "\u{1F36C}",
    ":lollipop:": "\u{1F36D}",
    ":honey_pot:": "\u{1F36F}",
    ":apple:": "\u{1F34E}",
    ":green_apple:": "\u{1F34F}",
    ":tangerine:": "\u{1F34A}",
    ":lemon:": "\u{1F34B}",
    ":cherries:": "\u{1F352}",
    ":grapes:": "\u{1F347}",
    ":watermelon:": "\u{1F349}",
    ":strawberry:": "\u{1F353}",
    ":peach:": "\u{1F351}",
    ":melon:": "\u{1F348}",
    ":banana:": "\u{1F34C}",
    ":pear:": "\u{1F350}",
    ":pineapple:": "\u{1F34D}",
    ":sweet_potato:": "\u{1F360}",
    ":eggplant:": "\u{1F346}",
    ":tomato:": "\u{1F345}",
    ":corn:": "\u{1F33D}",
    ":house:": "\u{1F3E0}",
    ":house_with_garden:": "\u{1F3E1}",
    ":school:": "\u{1F3EB}",
    ":office:": "\u{1F3E2}",
    ":post_office:": "\u{1F3E3}",
    ":hospital:": "\u{1F3E5}",
    ":bank:": "\u{1F3E6}",
    ":convenience_store:": "\u{1F3EA}",
    ":love_hotel:": "\u{1F3E9}",
    ":hotel:": "\u{1F3E8}",
    ":wedding:": "\u{1F492}",
    ":church:": "\u26EA",
    ":department_store:": "\u{1F3EC}",
    ":european_post_office:": "\u{1F3E4}",
    ":city_sunrise:": "\u{1F307}",
    ":city_sunset:": "\u{1F306}",
    ":japanese_castle:": "\u{1F3EF}",
    ":european_castle:": "\u{1F3F0}",
    ":tent:": "\u26FA",
    ":factory:": "\u{1F3ED}",
    ":tokyo_tower:": "\u{1F5FC}",
    ":japan:": "\u{1F5FE}",
    ":mount_fuji:": "\u{1F5FB}",
    ":sunrise_over_mountains:": "\u{1F304}",
    ":sunrise:": "\u{1F305}",
    ":stars:": "\u{1F320}",
    ":statue_of_liberty:": "\u{1F5FD}",
    ":bridge_at_night:": "\u{1F309}",
    ":carousel_horse:": "\u{1F3A0}",
    ":rainbow:": "\u{1F308}",
    ":ferris_wheel:": "\u{1F3A1}",
    ":fountain:": "\u26F2",
    ":roller_coaster:": "\u{1F3A2}",
    ":ship:": "\u{1F6A2}",
    ":speedboat:": "\u{1F6A4}",
    ":boat:": "\u26F5",
    ":sailboat:": "\u26F5",
    ":rowboat:": "\u{1F6A3}",
    ":anchor:": "\u2693",
    ":rocket:": "\u{1F680}",
    ":airplane:": "\u2708\uFE0F",
    ":helicopter:": "\u{1F681}",
    ":steam_locomotive:": "\u{1F682}",
    ":tram:": "\u{1F68A}",
    ":mountain_railway:": "\u{1F69E}",
    ":bike:": "\u{1F6B2}",
    ":aerial_tramway:": "\u{1F6A1}",
    ":suspension_railway:": "\u{1F69F}",
    ":mountain_cableway:": "\u{1F6A0}",
    ":tractor:": "\u{1F69C}",
    ":blue_car:": "\u{1F699}",
    ":oncoming_automobile:": "\u{1F698}",
    ":car:": "\u{1F697}",
    ":red_car:": "\u{1F697}",
    ":taxi:": "\u{1F695}",
    ":oncoming_taxi:": "\u{1F696}",
    ":articulated_lorry:": "\u{1F69B}",
    ":bus:": "\u{1F68C}",
    ":oncoming_bus:": "\u{1F68D}",
    ":rotating_light:": "\u{1F6A8}",
    ":police_car:": "\u{1F693}",
    ":oncoming_police_car:": "\u{1F694}",
    ":fire_engine:": "\u{1F692}",
    ":ambulance:": "\u{1F691}",
    ":minibus:": "\u{1F690}",
    ":truck:": "\u{1F69A}",
    ":train:": "\u{1F68B}",
    ":station:": "\u{1F689}",
    ":train2:": "\u{1F686}",
    ":bullettrain_front:": "\u{1F685}",
    ":bullettrain_side:": "\u{1F684}",
    ":light_rail:": "\u{1F688}",
    ":monorail:": "\u{1F69D}",
    ":railway_car:": "\u{1F683}",
    ":trolleybus:": "\u{1F68E}",
    ":ticket:": "\u{1F3AB}",
    ":fuelpump:": "\u26FD",
    ":vertical_traffic_light:": "\u{1F6A6}",
    ":traffic_light:": "\u{1F6A5}",
    ":warning:": "\u26A0\uFE0F",
    ":construction:": "\u{1F6A7}",
    ":beginner:": "\u{1F530}",
    ":atm:": "\u{1F3E7}",
    ":slot_machine:": "\u{1F3B0}",
    ":busstop:": "\u{1F68F}",
    ":barber:": "\u{1F488}",
    ":hotsprings:": "\u2668\uFE0F",
    ":checkered_flag:": "\u{1F3C1}",
    ":crossed_flags:": "\u{1F38C}",
    ":izakaya_lantern:": "\u{1F3EE}",
    ":moyai:": "\u{1F5FF}",
    ":circus_tent:": "\u{1F3AA}",
    ":performing_arts:": "\u{1F3AD}",
    ":round_pushpin:": "\u{1F4CD}",
    ":triangular_flag_on_post:": "\u{1F6A9}",
    ":jp:": "\u{1F1EF}\u{1F1F5}",
    ":kr:": "\u{1F1F0}\u{1F1F7}",
    ":cn:": "\u{1F1E8}\u{1F1F3}",
    ":us:": "\u{1F1FA}\u{1F1F8}",
    ":fr:": "\u{1F1EB}\u{1F1F7}",
    ":es:": "\u{1F1EA}\u{1F1F8}",
    ":it:": "\u{1F1EE}\u{1F1F9}",
    ":ru:": "\u{1F1F7}\u{1F1FA}",
    ":gb:": "\u{1F1EC}\u{1F1E7}",
    ":uk:": "\u{1F1EC}\u{1F1E7}",
    ":de:": "\u{1F1E9}\u{1F1EA}",
    ":one:": "1\uFE0F\u20E3",
    ":two:": "2\uFE0F\u20E3",
    ":three:": "3\uFE0F\u20E3",
    ":four:": "4\uFE0F\u20E3",
    ":five:": "5\uFE0F\u20E3",
    ":six:": "6\uFE0F\u20E3",
    ":seven:": "7\uFE0F\u20E3",
    ":eight:": "8\uFE0F\u20E3",
    ":nine:": "9\uFE0F\u20E3",
    ":keycap_ten:": "\u{1F51F}",
    ":1234:": "\u{1F522}",
    ":zero:": "0\uFE0F\u20E3",
    ":hash:": "#\uFE0F\u20E3",
    ":symbols:": "\u{1F523}",
    ":arrow_backward:": "\u25C0\uFE0F",
    ":arrow_down:": "\u2B07\uFE0F",
    ":arrow_forward:": "\u25B6\uFE0F",
    ":arrow_left:": "\u2B05\uFE0F",
    ":capital_abcd:": "\u{1F520}",
    ":abcd:": "\u{1F521}",
    ":abc:": "\u{1F524}",
    ":arrow_lower_left:": "\u2199\uFE0F",
    ":arrow_lower_right:": "\u2198\uFE0F",
    ":arrow_right:": "\u27A1\uFE0F",
    ":arrow_up:": "\u2B06\uFE0F",
    ":arrow_upper_left:": "\u2196\uFE0F",
    ":arrow_upper_right:": "\u2197\uFE0F",
    ":arrow_double_down:": "\u23EC",
    ":arrow_double_up:": "\u23EB",
    ":arrow_down_small:": "\u{1F53D}",
    ":arrow_heading_down:": "\u2935\uFE0F",
    ":arrow_heading_up:": "\u2934\uFE0F",
    ":leftwards_arrow_with_hook:": "\u21A9\uFE0F",
    ":arrow_right_hook:": "\u21AA\uFE0F",
    ":left_right_arrow:": "\u2194\uFE0F",
    ":arrow_up_down:": "\u2195\uFE0F",
    ":arrow_up_small:": "\u{1F53C}",
    ":arrows_clockwise:": "\u{1F503}",
    ":arrows_counterclockwise:": "\u{1F504}",
    ":rewind:": "\u23EA",
    ":fast_forward:": "\u23E9",
    ":information_source:": "\u2139\uFE0F",
    ":ok:": "\u{1F197}",
    ":twisted_rightwards_arrows:": "\u{1F500}",
    ":repeat:": "\u{1F501}",
    ":repeat_one:": "\u{1F502}",
    ":new:": "\u{1F195}",
    ":top:": "\u{1F51D}",
    ":up:": "\u{1F199}",
    ":cool:": "\u{1F192}",
    ":free:": "\u{1F193}",
    ":ng:": "\u{1F196}",
    ":cinema:": "\u{1F3A6}",
    ":koko:": "\u{1F201}",
    ":signal_strength:": "\u{1F4F6}",
    ":u5272:": "\u{1F239}",
    ":u5408:": "\u{1F234}",
    ":u55b6:": "\u{1F23A}",
    ":u6307:": "\u{1F22F}",
    ":u6708:": "\u{1F237}\uFE0F",
    ":u6709:": "\u{1F236}",
    ":u6e80:": "\u{1F235}",
    ":u7121:": "\u{1F21A}",
    ":u7533:": "\u{1F238}",
    ":u7a7a:": "\u{1F233}",
    ":u7981:": "\u{1F232}",
    ":sa:": "\u{1F202}\uFE0F",
    ":restroom:": "\u{1F6BB}",
    ":mens:": "\u{1F6B9}",
    ":womens:": "\u{1F6BA}",
    ":baby_symbol:": "\u{1F6BC}",
    ":no_smoking:": "\u{1F6AD}",
    ":parking:": "\u{1F17F}\uFE0F",
    ":wheelchair:": "\u267F",
    ":metro:": "\u{1F687}",
    ":baggage_claim:": "\u{1F6C4}",
    ":accept:": "\u{1F251}",
    ":wc:": "\u{1F6BE}",
    ":potable_water:": "\u{1F6B0}",
    ":put_litter_in_its_place:": "\u{1F6AE}",
    ":secret:": "\u3299\uFE0F",
    ":congratulations:": "\u3297\uFE0F",
    ":m:": "\u24C2\uFE0F",
    ":passport_control:": "\u{1F6C2}",
    ":left_luggage:": "\u{1F6C5}",
    ":customs:": "\u{1F6C3}",
    ":ideograph_advantage:": "\u{1F250}",
    ":cl:": "\u{1F191}",
    ":sos:": "\u{1F198}",
    ":id:": "\u{1F194}",
    ":no_entry_sign:": "\u{1F6AB}",
    ":underage:": "\u{1F51E}",
    ":no_mobile_phones:": "\u{1F4F5}",
    ":do_not_litter:": "\u{1F6AF}",
    ":non-potable_water:": "\u{1F6B1}",
    ":no_bicycles:": "\u{1F6B3}",
    ":no_pedestrians:": "\u{1F6B7}",
    ":children_crossing:": "\u{1F6B8}",
    ":no_entry:": "\u26D4",
    ":eight_spoked_asterisk:": "\u2733\uFE0F",
    ":sparkle:": "\u2747\uFE0F",
    ":eight_pointed_black_star:": "\u2734\uFE0F",
    ":heart_decoration:": "\u{1F49F}",
    ":vs:": "\u{1F19A}",
    ":vibration_mode:": "\u{1F4F3}",
    ":mobile_phone_off:": "\u{1F4F4}",
    ":chart:": "\u{1F4B9}",
    ":currency_exchange:": "\u{1F4B1}",
    ":aries:": "\u2648",
    ":taurus:": "\u2649",
    ":gemini:": "\u264A",
    ":cancer:": "\u264B",
    ":leo:": "\u264C",
    ":virgo:": "\u264D",
    ":libra:": "\u264E",
    ":scorpius:": "\u264F",
    ":sagittarius:": "\u2650",
    ":capricorn:": "\u2651",
    ":aquarius:": "\u2652",
    ":pisces:": "\u2653",
    ":ophiuchus:": "\u26CE",
    ":six_pointed_star:": "\u{1F52F}",
    ":negative_squared_cross_mark:": "\u274E",
    ":a:": "\u{1F170}\uFE0F",
    ":b:": "\u{1F171}\uFE0F",
    ":ab:": "\u{1F18E}",
    ":o2:": "\u{1F17E}\uFE0F",
    ":diamond_shape_with_a_dot_inside:": "\u{1F4A0}",
    ":recycle:": "\u267B\uFE0F",
    ":end:": "\u{1F51A}",
    ":back:": "\u{1F519}",
    ":on:": "\u{1F51B}",
    ":soon:": "\u{1F51C}",
    ":clock1:": "\u{1F550}",
    ":clock130:": "\u{1F55C}",
    ":clock10:": "\u{1F559}",
    ":clock1030:": "\u{1F565}",
    ":clock11:": "\u{1F55A}",
    ":clock1130:": "\u{1F566}",
    ":clock12:": "\u{1F55B}",
    ":clock1230:": "\u{1F567}",
    ":clock2:": "\u{1F551}",
    ":clock230:": "\u{1F55D}",
    ":clock3:": "\u{1F552}",
    ":clock330:": "\u{1F55E}",
    ":clock4:": "\u{1F553}",
    ":clock430:": "\u{1F55F}",
    ":clock5:": "\u{1F554}",
    ":clock530:": "\u{1F560}",
    ":clock6:": "\u{1F555}",
    ":clock630:": "\u{1F561}",
    ":clock7:": "\u{1F556}",
    ":clock730:": "\u{1F562}",
    ":clock8:": "\u{1F557}",
    ":clock830:": "\u{1F563}",
    ":clock9:": "\u{1F558}",
    ":clock930:": "\u{1F564}",
    ":heavy_dollar_sign:": "\u{1F4B2}",
    ":copyright:": "\xA9\uFE0F",
    ":registered:": "\xAE\uFE0F",
    ":tm:": "\u2122\uFE0F",
    ":x:": "\u274C",
    ":heavy_exclamation_mark:": "\u2757",
    ":bangbang:": "\u203C\uFE0F",
    ":interrobang:": "\u2049\uFE0F",
    ":o:": "\u2B55",
    ":heavy_multiplication_x:": "\u2716\uFE0F",
    ":heavy_plus_sign:": "\u2795",
    ":heavy_minus_sign:": "\u2796",
    ":heavy_division_sign:": "\u2797",
    ":white_flower:": "\u{1F4AE}",
    ":100:": "\u{1F4AF}",
    ":heavy_check_mark:": "\u2714\uFE0F",
    ":ballot_box_with_check:": "\u2611\uFE0F",
    ":radio_button:": "\u{1F518}",
    ":link:": "\u{1F517}",
    ":curly_loop:": "\u27B0",
    ":wavy_dash:": "\u3030\uFE0F",
    ":part_alternation_mark:": "\u303D\uFE0F"
  };

  // ../metroui-lib/source/components/chat/chat.js
  ((Metro2, $7) => {
    "use strict";
    const attachIcon = `
	<?xml version="1.0" encoding="utf-8"?>
	<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
		<path d="M16.617 14.496a1 1 0 0 1 1.414 1.414l-3.182 3.182a7 7 0 1 1-9.9-9.9l5.658-5.656a5 5 0 1 1 7.07 7.07l-5.656 5.658a3 3 0 0 1-4.243-4.243l4.596-4.596a1 1 0 1 1 1.415 1.414l-4.597 4.596a1 1 0 1 0 1.415 1.414l5.656-5.657a3 3 0 1 0-4.242-4.242l-5.657 5.657a5 5 0 1 0 7.071 7.07l3.182-3.181z"/>
	</svg>
	`;
    const sendIcon = `
	<?xml version="1.0" encoding="utf-8"?>
	<svg width="800px" height="800px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
		<g>
			<path fill="none" d="M0 0h24v24H0z"/>
			<path d="M3 13h6v-2H3V1.846a.5.5 0 0 1 .741-.438l18.462 10.154a.5.5 0 0 1 0 .876L3.741 22.592A.5.5 0 0 1 3 22.154V13z"/>
		</g>
	</svg>
	`;
    const smileIcon = `
	<?xml version="1.0" encoding="utf-8"?>
	<svg width="800px" height="800px" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fill="none">
		<path fill-rule="evenodd" clip-rule="evenodd" d="M4.111 2.18a7 7 0 1 1 7.778 11.64A7 7 0 0 1 4.11 2.18zm.556 10.809a6 6 0 1 0 6.666-9.978 6 6 0 0 0-6.666 9.978zM6.5 7a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm5 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM8 11a3 3 0 0 1-2.65-1.58l-.87.48a4 4 0 0 0 7.12-.16l-.9-.43A3 3 0 0 1 8 11z"/>
	</svg>
	`;
    let ChatDefaultConfig = {
      chatDeferred: 0,
      inputTimeFormat: null,
      timeFormat: "D MMM hh:mm A",
      name: "John Doe",
      avatar: "<span>\u{1F466}</span>",
      welcome: null,
      welcomeAvatar: "<span>\u{1F47D}</span>",
      title: null,
      width: "100%",
      height: "auto",
      messages: null,
      readonly: false,
      attachAccept: "*",
      scrollSpeed: 200,
      sendMode: "enter",
      // "button" or "enter" or "control+enter"
      buttons: "attach send",
      useEmoji: true,
      useCode: true,
      useLink: true,
      clsChat: "",
      clsName: "",
      clsTime: "",
      clsInput: "",
      clsSendButton: "",
      clsAttachButton: "",
      clsSmileButton: "",
      clsMessageLeft: "default",
      clsMessageRight: "default",
      onMessage: Metro2.noop,
      onSend: Metro2.noop,
      onSendButtonClick: Metro2.noop,
      onChatCreate: Metro2.noop
    };
    Metro2.chatSetup = (options) => {
      ChatDefaultConfig = $7.extend({}, ChatDefaultConfig, options);
    };
    if (typeof globalThis.metroChatSetup !== "undefined") {
      Metro2.chatSetup(globalThis.metroChatSetup);
    }
    Metro2.Component("chat", {
      init: function(options, elem) {
        this._super(elem, options, ChatDefaultConfig, {
          input: null,
          classes: "primary secondary success alert warning yellow info dark light".split(" "),
          lastMessage: null,
          attach: null,
          file: null,
          locale: null,
          buttons: []
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this.locale = element2.closest("[lang]").attr("lang") || "en";
        this.buttons = this.options.buttons.toArray(" ");
        this._createStructure();
        this._createEvents();
        this._fireEvent("chat-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("chat").addClass(o2.clsChat);
        this.file = $7("<input type='file'>").appendTo(element2);
        this.file.attr("accept", o2.attachAccept);
        this.file.css({
          display: "none"
        });
        element2.css({
          width: o2.width,
          height: o2.height
        });
        if (Metro2.utils.isValue(o2.title)) {
          $7("<div>").addClass("title").html(o2.title).appendTo(element2);
        }
        const messages = $7("<div>").addClass("messages");
        messages.appendTo(element2);
        const messageInput = $7("<div>").addClass("message-input").appendTo(element2);
        const input = $7("<textarea>").attr("placeholder", "Write a message...");
        input.appendTo(messageInput);
        Metro2.makePlugin(input[0], "textarea", {
          clsInput: o2.clsInput,
          initialHeight: 34,
          clearButton: false
        });
        input.addClass("chat-input");
        const buttons = $7("<div>").addClass("buttons").appendTo(messageInput);
        if (this.buttons.includes("attach")) {
          const attachBtn = $7("<span>").addClass(`flat js-chat-attach-button ${o2.clsAttachButton}`).html(attachIcon);
          attachBtn.appendTo(buttons);
        }
        if (this.buttons.includes("send")) {
          const sendBtn = $7("<span>").addClass(`flat js-chat-send-button ${o2.clsSendButton}`).html(sendIcon);
          sendBtn.appendTo(buttons);
        }
        if (o2.welcome) {
          this.add({
            text: o2.welcome,
            time: datetime(),
            position: "left",
            name: "Chat Bot",
            avatar: o2.welcomeAvatar
          });
        }
        if (typeof o2.messages === "string" && o2.messages) {
          o2.messages = Metro2.utils.isObject(o2.messages);
        }
        if (o2.messages && typeof o2.messages === "object" && Metro2.utils.objectLength(o2.messages) > 0) {
          $7.each(o2.messages, function() {
            that.add(this);
          });
        }
        element2.find(".message-input")[o2.readonly ? "addClass" : "removeClass"]("disabled");
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        const input = element2.find("textarea");
        const send = () => {
          const msg = `${input.val()}`;
          if (msg.trim() === "" && !this.attach) {
            return false;
          }
          const m5 = {
            id: Metro2.utils.elementId("chat-message"),
            name: o2.name,
            avatar: o2.avatar,
            text: msg,
            position: "right",
            time: datetime(),
            attach: this.attach ? new File([this.attach], this.attach.name, {
              type: this.attach.type,
              lastModified: this.attach.lastModified
            }) : null
          };
          this.add(m5);
          input.val("").trigger("change");
          this.attach = null;
          this._fireEvent("send", {
            msg: m5
          });
          input.focus();
        };
        element2.on(Metro2.events.click, ".js-chat-send-button", () => {
          send();
        });
        element2.on(Metro2.events.keyup, "textarea", (e2) => {
          if (o2.sendMode === "button") {
            return;
          }
          if (e2.keyCode === Metro2.keyCode.ENTER) {
            if (o2.sendMode === "control+enter" && (e2.ctrlKey || e2.metaKey) || o2.sendMode === "enter" && !e2.shiftKey) {
              send();
            }
          }
        });
        element2.on(Metro2.events.click, ".js-chat-attach-button", () => {
          this.file[0].click();
        });
        this.file.on("change", (e2) => {
          const file = e2.target.files[0];
          if (file) {
            this.attach = file;
            send();
          }
        });
      },
      add: function(msg) {
        const element2 = this.element;
        const o2 = this.options;
        let avatar;
        let text;
        const messages = element2.find(".messages");
        const addLink = (url, attach) => {
          return `<div class="attach-link"><a class="attach" href="${url}" target="_blank" download="${attach.name}">${attach.name} <span class="reduce-2">(Size: ${Math.round(attach.size / 1024 ** 2)} MB)</span></a></div>`;
        };
        const includeAttach = (attach) => {
          if (attach === null) {
            return "";
          }
          const file = URL.createObjectURL(attach);
          let attachHtml = `<div class="message-attach">`;
          if (attach.type.startsWith("image/")) {
            attachHtml += `<img class="attach" src="${file}" alt="${attach.name}">`;
            attachHtml += addLink(file, attach);
          } else if (attach.type.startsWith("video/")) {
            attachHtml += `<video class="attach" controls><source src="${file}" type="${attach.type}"></video>`;
            attachHtml += addLink(file, attach);
          } else if (attach.type.startsWith("audio/")) {
            attachHtml += `<audio class="attach" controls><source src="${file}" type="${attach.type}"></audio>`;
            attachHtml += addLink(file, attach);
          } else {
            attachHtml += addLink(file, attach);
          }
          attachHtml += `</div>`;
          return attachHtml;
        };
        const messageDate = o2.inputTimeFormat ? Datetime.from(msg.time, o2.inputTimeFormat, this.locale) : datetime(msg.time);
        const message = $7("<div>").addClass("message").addClass(msg.position).appendTo(messages);
        const item = $7("<div>").addClass("message-item").appendTo(message);
        if (Metro2.utils.isUrl(msg.avatar) || msg.avatar.includes("data:image")) {
          avatar = $7("<img>").attr("src", msg.avatar).attr("alt", msg.avatar).addClass("message-avatar").appendTo(item);
        } else if (msg.avatar) {
          const _el = $7(msg.avatar);
          if (_el.length) {
            avatar = _el.addClass("message-avatar").appendTo(item);
          } else {
            avatar = $7("<span>").addClass("message-avatar").html(msg.avatar).appendTo(item);
          }
        }
        let _msg = Str.stripTags(msg.text);
        if (o2.useEmoji) {
          const words = _msg.split(" ");
          const newWords = [];
          for (let word of words) {
            if (!word) continue;
            if (word in emojiMap) {
              word = emojiMap[word];
            }
            newWords.push(word);
          }
          _msg = newWords.join(" ");
        }
        if (o2.useCode) {
          _msg = _msg.replace(/```(\w+)?\n?([\s\S]*?)```/g, "<pre><code class='$1'>$2</code></pre>");
          _msg = _msg.replace(/`([^`]+)`/g, "<code>$1</code>");
        }
        if (o2.useLink && _msg.startsWith("http")) {
          _msg = `<a href="${_msg}" target="_blank">${_msg}</a>`;
        }
        text = $7("<div>").addClass("message-text").append(
          $7("<div>").addClass("message-text-inner").html(msg.attach ? includeAttach(msg.attach) : _msg)
        ).appendTo(item);
        const time = $7("<div>").addClass("message-time").addClass(o2.clsTime).text(messageDate.format(o2.timeFormat)).appendTo(text);
        const sender = $7("<div>").addClass("message-sender").addClass(o2.clsName).text(msg.name).appendTo(text);
        if (Metro2.utils.isValue(msg.id)) {
          message.attr("id", msg.id);
        }
        if (msg.position === "left" && Metro2.utils.isValue(o2.clsMessageLeft)) {
          text.addClass(o2.clsMessageLeft);
        }
        if (msg.position === "right" && Metro2.utils.isValue(o2.clsMessageRight)) {
          text.addClass(o2.clsMessageRight);
        }
        if (this.lastMessage && this.lastMessage.position === msg.position) {
          text.addClass("--next");
          avatar.visible(false);
          sender.hide();
        }
        this._fireEvent("message", {
          msg,
          el: {
            message,
            sender,
            time,
            item,
            avatar,
            text
          }
        });
        messages.animate({
          draw: {
            scrollTop: messages[0].scrollHeight
          },
          dur: o2.scrollSpeed
        });
        this.lastMessage = msg;
        return this;
      },
      addMessages: function(messages) {
        const that = this;
        let _messages = messages;
        if (typeof _messages === "string" && _messages) {
          _messages = Metro2.utils.isObject(_messages);
        }
        if (typeof _messages === "object" && Metro2.utils.objectLength(_messages) > 0) {
          $7.each(_messages, function() {
            that.add(this);
          });
        }
        return this;
      },
      delMessage: function(id) {
        const element2 = this.element;
        element2.find(".messages").find(`#${id}`).remove();
        return this;
      },
      updMessage: function(msg) {
        const element2 = this.element;
        const o2 = this.options;
        const msgId = typeof msg === "string" ? msg : msg.id;
        const message = element2.find(".messages").find(`#${msgId}`);
        if (message.length === 0) return this;
        const messageDate = o2.inputTimeFormat ? Datetime.from(msg.time, o2.inputTimeFormat, this.locale) : datetime(msg.time);
        message.find(".message-text-inner").html(msg.text);
        message.find(".message-time").html(messageDate.format(o2.timeFormat));
        return this;
      },
      clear: function() {
        const element2 = this.element;
        const messages = element2.find(".messages");
        messages.html("");
        this.lastMessage = null;
      },
      toggleReadonly: function(readonly) {
        const element2 = this.element;
        const o2 = this.options;
        o2.readonly = typeof readonly === "undefined" ? !o2.readonly : readonly;
        element2.find(".message-input")[o2.readonly ? "addClass" : "removeClass"]("disabled");
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-readonly":
            this.toggleReadonly();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const sendButton = element2.find(".js-chat-send-button");
        const input = element2.find("input[type=text]");
        sendButton.off(Metro2.events.click);
        input.off(Metro2.events.keyup);
        return element2;
      }
    });
    Metro2.defaults.Chat = ChatDefaultConfig;
  })(Metro, Dom);

  // ../metroui-lib/source/components/checkbox/checkbox.js
  ((Metro2, $7) => {
    "use strict";
    globalThis.CHECKBOX_STATE = {
      CHECKED: 1,
      UNCHECKED: -1,
      INDETERMINATE: 0
    };
    let CheckboxDefaultConfig = {
      checkboxDeferred: 0,
      state: CHECKBOX_STATE.UNCHECKED,
      threeState: false,
      prepend: "",
      append: "",
      caption: "",
      clsCheckbox: "",
      clsCaption: "",
      clsPrepend: "",
      clsAppend: "",
      onCheckboxCreate: Metro2.noop
    };
    Metro2.metroCheckboxSetup = (options) => {
      CheckboxDefaultConfig = $7.extend({}, CheckboxDefaultConfig, options);
    };
    if (typeof globalThis.metroCheckboxSetup !== "undefined") {
      Metro2.metroCheckboxSetup(globalThis.metroCheckboxSetup);
    }
    Metro2.Component("checkbox", {
      init: function(options, elem) {
        this._super(elem, options, CheckboxDefaultConfig, {
          origin: {
            className: ""
          },
          state: CHECKBOX_STATE.UNCHECKED
        });
        return this;
      },
      _create: function() {
        const o2 = this.options;
        if (o2.threeState === false && o2.state === 0 || o2.state === "indeterminate") {
          o2.state = CHECKBOX_STATE.UNCHECKED;
        }
        if (o2.state === CHECKBOX_STATE.UNCHECKED || o2.state === "unchecked") {
          this.state = CHECKBOX_STATE.UNCHECKED;
        } else if (o2.state === 0 || o2.state === "indeterminate") {
          this.state = CHECKBOX_STATE.INDETERMINATE;
        } else {
          this.state = CHECKBOX_STATE.CHECKED;
        }
        this._createStructure();
        this._createEvents();
        this._fireEvent("checkbox-create");
      },
      _indeterminate: function(v5 = true) {
        const element2 = this.element;
        element2[0].indeterminate = v5;
        element2.attr("data-indeterminate", v5);
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.wrap("<label>").addClass("checkbox").addClass(o2.clsCheckbox);
        element2.attr("type", "checkbox");
        if (o2.prepend) {
          container.prepend(
            $7("<span>").addClass("caption-prepend").addClass(o2.clsPrepend).addClass(o2.clsCaption).html(o2.prepend)
          );
        }
        if (o2.append || o2.caption) {
          container.append(
            $7("<span>").addClass("caption-append").addClass(o2.clsAppend).addClass(o2.clsCaption).html(o2.append || o2.caption)
          );
        }
        if (element2.attr("readonly") !== void 0) {
          element2.on("click", (e2) => {
            e2.preventDefault();
          });
        }
        if (this.elem.checked && this.state !== CHECKBOX_STATE.INDETERMINATE) {
          this.state = true;
        }
        this._drawState();
      },
      _drawState: function() {
        const elem = this.elem;
        this._indeterminate(false);
        elem.checked = this.state !== CHECKBOX_STATE.UNCHECKED;
        if (this.state === CHECKBOX_STATE.INDETERMINATE) {
          this._indeterminate(true);
        }
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.on("click", () => {
          this.state++;
          if (this.state === 0 && o2.threeState === false) {
            this.state = 1;
          }
          if (this.state === 2) {
            this.state = -1;
          }
          this._drawState();
        });
      },
      check: function() {
        this.setCheckState(CHECKBOX_STATE.CHECKED);
      },
      uncheck: function() {
        this.setCheckState(CHECKBOX_STATE.UNCHECKED);
      },
      indeterminate: function() {
        this.setCheckState(CHECKBOX_STATE.INDETERMINATE);
      },
      setCheckState: function(state2) {
        if (state2 === -1 || state2 === "unchecked") {
          this.state = CHECKBOX_STATE.UNCHECKED;
        } else if (state2 === 0 || state2 === "indeterminate") {
          this.state = CHECKBOX_STATE.INDETERMINATE;
        } else {
          this.state = CHECKBOX_STATE.CHECKED;
        }
        this._drawState();
        return this;
      },
      getCheckState: function(asString = false) {
        if (!asString) {
          return this.state;
        }
        switch (this.state) {
          case -1:
            return "unchecked";
          case 0:
            return "indeterminate";
          case 1:
            return "checked";
        }
      },
      toggle: function() {
        this.state++;
        if (this.state === 2) {
          this.state = -1;
        }
        this._drawState();
      },
      changeAttribute: (attr, newVal) => {
        const changeState = function(val) {
          this.toggle(val);
        };
        switch (attr) {
          case "data-state":
            changeState(newVal);
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        element2.off("click");
        element2.parent().remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/clock/clock.js
  ((Metro2, $7) => {
    "use strict";
    let ClockDefaultConfig = {
      clockDeferred: 0,
      show: "row",
      showTime: true,
      showDate: true,
      dateFormat: "DD.MM.YYYY",
      timeFormat: "HH:mm",
      divider: "&nbsp;&nbsp;",
      twoLines: false,
      onTick: Metro2.noop,
      onSecond: Metro2.noop,
      onClockCreate: Metro2.noop
    };
    Metro2.clockSetup = (options) => {
      ClockDefaultConfig = $7.extend({}, ClockDefaultConfig, options);
    };
    if (typeof globalThis.metroClockSetup !== "undefined") {
      Metro2.clockSetup(globalThis.metroClockSetup);
    }
    Metro2.Component("clock", {
      init: function(options, elem) {
        this._super(elem, options, ClockDefaultConfig, {
          _clockInterval: null,
          locale: "en"
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        const langElement = element2.closest("[lang]");
        if (langElement.length) {
          this.locale = langElement.attr("lang") || "en";
        }
        element2.addClass("clock");
        if (o2.show === "column") {
          element2.addClass("show-column");
        }
        this._fireEvent("clock-create", {
          element: element2
        });
        this._tick();
        this._clockInterval = setInterval(() => {
          this._tick();
        }, 500);
        this._secondInterval = setInterval(() => {
          this._second();
        }, 1e3);
      },
      _second: function() {
        const timestamp = /* @__PURE__ */ new Date();
        this._fireEvent("second", {
          timestamp
        });
      },
      _tick: function() {
        const element2 = this.element;
        const o2 = this.options;
        const timestamp = datetime();
        let result = "";
        const date = timestamp.format(o2.dateFormat, this.locale);
        const time = timestamp.format(o2.timeFormat, this.locale);
        if (o2.showTime) {
          result = `<span class="clock-time">${time}</span>`;
        }
        if (o2.showDate) {
          result += `<span class="clock-date">${date}</span>`;
        }
        element2.html(result);
        this._fireEvent("tick", {
          timestamp
        });
      },
      changeAttribute: function(attr, val) {
        switch (attr) {
          case "data-date-format":
            this.options.dateFormat = val;
            break;
          case "data-time-format":
            this.options.timeFormat = val;
            break;
          case "data-show-date":
            this.options.showDate = JSON.parse(val);
            break;
          case "data-show-time":
            this.options.showTime = JSON.parse(val);
            break;
          case "data-divider":
            this.options.divider = val;
            break;
          case "data-two-lines":
            this.options.twoLines = JSON.parse(val);
            break;
        }
        this._tick();
      },
      destroy: function() {
        clearInterval(this._clockInterval);
        this._clockInterval = null;
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/collapse/collapse.js
  ((Metro2, $7) => {
    "use strict";
    let CollapseDefaultConfig = {
      collapseDeferred: 0,
      collapsed: false,
      toggleElement: false,
      duration: 100,
      onExpand: Metro2.noop,
      onCollapse: Metro2.noop,
      onCollapseCreate: Metro2.noop
    };
    Metro2.collapseSetup = (options) => {
      CollapseDefaultConfig = $7.extend({}, CollapseDefaultConfig, options);
    };
    if (typeof globalThis.metroCollapseSetup !== "undefined") {
      Metro2.collapseSetup(globalThis.metroCollapseSetup);
    }
    Metro2.Component("collapse", {
      init: function(options, elem) {
        this._super(elem, options, CollapseDefaultConfig, {
          toggle: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        const toggle = o2.toggleElement !== false ? $7(o2.toggleElement) : element2.siblings(".collapse-toggle").length > 0 ? element2.siblings(".collapse-toggle") : element2.siblings("a:nth-child(1)");
        if (o2.collapsed === true || element2.attr("collapsed") === true) {
          element2.hide(0);
        }
        toggle.on(Metro2.events.click, (e2) => {
          if (element2.css("display") !== "none" && !element2.hasClass("keep-open")) {
            this._close(element2);
          } else {
            this._open(element2);
          }
          if (["INPUT"].indexOf(e2.target.tagName) === -1) {
            e2.preventDefault();
          }
          e2.stopPropagation();
        });
        this.toggle = toggle;
        this._fireEvent("collapse-create", {
          element: element2
        });
      },
      _close: function(el, immediate) {
        const elem = $7(el);
        const collapsed = elem.data("collapsed");
        if (collapsed) {
          return;
        }
        const dropdown = Metro2.getPlugin(elem[0], "collapse");
        const options = dropdown.options;
        const func = immediate ? "show" : "slideUp";
        const dur = immediate ? 0 : options.duration;
        this.toggle.removeClass("active-toggle");
        elem[func](dur, () => {
          el.trigger("onCollapse", null, el);
          el.data("collapsed", true);
          el.addClass("collapsed");
          dropdown._fireEvent("collapse");
        });
      },
      _open: function(el, immediate) {
        const elem = $7(el);
        const collapsed = elem.data("collapsed");
        if (!collapsed) {
          return;
        }
        const dropdown = Metro2.getPlugin(elem[0], "collapse");
        const options = dropdown.options;
        const func = immediate ? "show" : "slideDown";
        const dur = immediate ? 0 : options.duration;
        this.toggle.addClass("active-toggle");
        elem[func](dur, () => {
          el.trigger("onExpand", null, el);
          el.data("collapsed", false);
          el.removeClass("collapsed");
          dropdown._fireEvent("expand");
        });
      },
      collapse: function(immediate) {
        this._close(this.element, immediate);
      },
      expand: function(immediate) {
        this._open(this.element, immediate);
      },
      close: function(immediate) {
        this._close(this.element, immediate);
      },
      open: function(immediate) {
        this._open(this.element, immediate);
      },
      isCollapsed: function() {
        return this.element.data("collapsed");
      },
      toggleState: function() {
        const element2 = this.element;
        if (element2.attr("collapsed") === true || element2.data("collapsed") === true) {
          this.collapse();
        } else {
          this.expand();
        }
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "collapsed":
          case "data-collapsed":
            this.toggleState();
            break;
        }
      },
      destroy: function() {
        this.toggle.off(Metro2.events.click);
        return this.element;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/dropdown/dropdown.js
  ((Metro2, $7) => {
    "use strict";
    const participants = "[data-role-dropmenu], [data-role-dropdown]";
    const toggleImage = `<svg class="dropdown-caret" aria-hidden="true" width="16" height="16" viewBox="0 0 24 24"><path d="m14.83 11.29-4.24-4.24a1 1 0 1 0-1.42 1.41L12.71 12l-3.54 3.54a1 1 0 0 0 0 1.41 1 1 0 0 0 .71.29 1 1 0 0 0 .71-.29l4.24-4.24a1.002 1.002 0 0 0 0-1.42Z"></path></svg>`;
    let DropdownDefaultConfig = {
      dropdownDeferred: 0,
      dropFilter: null,
      toggleElement: null,
      align: "left",
      noClose: false,
      duration: 50,
      openMode: "auto",
      openFunc: "show",
      closeFunc: "hide",
      height: "auto",
      stayOnClick: false,
      onDrop: Metro2.noop,
      onUp: Metro2.noop,
      onDropdownCreate: Metro2.noop
    };
    Metro2.dropdownSetup = (options) => {
      DropdownDefaultConfig = $7.extend({}, DropdownDefaultConfig, options);
    };
    if (typeof globalThis.metroDropdownSetup !== "undefined") {
      Metro2.dropdownSetup(globalThis.metroDropdownSetup);
    }
    Metro2.Component("dropdown", {
      init: function(options, elem) {
        this._super(elem, options, DropdownDefaultConfig, {
          toggle: null,
          displayOrigin: null,
          isOpen: false,
          level: 0
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("dropdown-create", {
          element: element2
        });
        if (element2.hasClass("open")) {
          element2.removeClass("open");
          setTimeout(() => {
            this.open(true);
          }, 0);
        }
      },
      _toggle: function() {
        const element2 = this.element;
        let toggle = element2.siblings(".menu-toggle, .dropdown-toggle, a");
        if (toggle.length === 0) {
          toggle = element2.prev();
          if (toggle.length === 0) {
            throw new Error("Menu toggle not found");
          }
        }
        return toggle[0];
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const level = element2.parents("[data-role-dropdown]").length;
        let toggle;
        if (o2.openMode === "up") {
          element2.addClass("drop-up");
        }
        toggle = o2.toggleElement ? $7(o2.toggleElement) : $7(this._toggle());
        if (toggle.length) {
          toggle.append(toggleImage);
        }
        this.displayOrigin = Metro2.utils.getStyleOne(element2, "display");
        if (o2.height !== "auto") {
          element2.css({
            height: o2.height,
            "overflow-y": "auto"
          });
        }
        element2.css("display", "none");
        this.toggle = toggle;
        this.level = level;
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        const toggle = this.toggle;
        const parent2 = element2.parent();
        toggle.on(Metro2.events.click, (e2) => {
          $7(".active-container").removeClass("active-container");
          if (element2.css("display") !== "none" && !element2.hasClass("keep-open")) {
            this.close(true, element2);
          } else {
            $7(participants).each((_5, el) => {
              if (!element2.parents("[data-role-dropdown]").is(el) && !$7(el).hasClass("keep-open") && $7(el).css("display") !== "none") {
                if (!Metro2.utils.isValue(o2.dropFilter)) {
                  this.close(true, el);
                } else {
                  if ($7(el).closest(o2.dropFilter).length > 0) {
                    this.close(true, el);
                  }
                }
              }
            });
            if (element2.hasClass("horizontal")) {
              element2.css({
                visibility: "hidden",
                display: "block"
              });
              let children_width = 0;
              $7.each(element2.children("li"), function() {
                children_width += $7(this).outerWidth(true);
              });
              element2.css({
                visibility: "visible",
                display: "none"
              });
              element2.css("width", children_width + 2);
            }
            this.open(false, element2);
            parent2.addClass("active-container");
          }
          e2.preventDefault();
          e2.stopPropagation();
        });
        if (o2.noClose === true) {
          element2.addClass("keep-open").on(Metro2.events.click, (e2) => {
            e2.preventDefault();
            e2.stopPropagation();
          });
        }
        $7(element2).find(".disabled").on(Metro2.events.click, (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
        });
        if (o2.stayOnClick === true) {
          element2.on(Metro2.events.click, (e2) => {
            e2.stopPropagation();
          });
        }
      },
      _close: function(el, immediate) {
        const _el = $7(el);
        const dropdown = Metro2.getPlugin(_el, "dropdown");
        const toggle = dropdown.toggle;
        const options = dropdown.options;
        let func = options.closeFunc;
        toggle.removeClass("active-toggle").removeClass("active-control");
        dropdown.element.parent().removeClass("active-container");
        if (immediate) {
          func = "hide";
        }
        _el[func](immediate ? 0 : options.duration, () => {
          dropdown._fireEvent("close");
          dropdown._fireEvent("up");
          if (options.openMode === "auto") {
            dropdown.element.removeClass("drop-up drop-as-dialog");
          }
        });
        this.isOpen = false;
      },
      _open: function(el, immediate) {
        const dropdown = Metro2.getPlugin(el, "dropdown");
        const options = dropdown.options;
        const func = options.openFunc;
        dropdown.toggle.addClass("active-toggle").addClass("active-control");
        dropdown.element.parent().addClass("active-container");
        dropdown.element[func](immediate ? 0 : options.duration, function() {
          const $el = $7(this);
          const wOut = Metro2.utils.viewportOutByWidth(this);
          const hOut = Metro2.utils.viewportOutByHeight(this);
          if (options.openMode === "auto") {
            if (hOut) {
              $el.addClass("drop-up");
            }
            if (wOut) {
              $el.addClass("place-right");
            }
            if (Metro2.utils.viewportOut(this)) {
              $el.removeClass("drop-up place-right").addClass("drop-as-dialog");
            }
          }
          dropdown._fireEvent("open");
          dropdown._fireEvent("drop");
        });
        this.isOpen = true;
      },
      close: function(immediate, el) {
        this._close(el || this.element, immediate);
      },
      open: function(immediate, el) {
        this._open(el || this.element, immediate);
      },
      toggle: function() {
        if (this.isOpen) this.close();
        else this.open();
      },
      changeAttribute: (attr, val) => {
      },
      destroy: function() {
        this.toggle.off(Metro2.events.click);
      }
    });
    $7(document).on(Metro2.events.click, () => {
      $7(participants).each(function() {
        const el = $7(this);
        if (el.hasClass("keep-open") || el.hasClass("stay-open") || el.hasClass("ignore-document-click")) return;
        const dd = Metro2.getPlugin(el, "dropdown");
        const dm = Metro2.getPlugin(el, "dropmenu");
        if (dd) {
          dd.close();
        }
        if (dm) {
          dm.close();
        }
      });
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/select/select.js
  ((Metro2, $7) => {
    "use strict";
    let SelectDefaultConfig = {
      id: "",
      label: "",
      size: "normal",
      selectDeferred: 0,
      clearButton: false,
      clearButtonIcon: "\u2716",
      usePlaceholder: false,
      placeholder: "",
      addEmptyValue: false,
      emptyValue: "",
      duration: 0,
      prepend: "",
      append: "",
      filterPlaceholder: "",
      filter: false,
      dropHeight: 200,
      dropWidth: null,
      dropFullSize: false,
      openMode: "auto",
      showGroupName: false,
      shortTag: true,
      // tag with name max width 120px
      source: null,
      sourceMethod: "GET",
      sourceType: "json",
      filterSource: null,
      filterThreshold: 500,
      closeOnClear: true,
      clsSelect: "",
      clsSelectInput: "",
      clsPrepend: "",
      clsAppend: "",
      clsOption: "",
      clsOptionActive: "",
      clsOptionGroup: "",
      clsDropList: "",
      clsDropContainer: "",
      clsSelectedItem: "",
      clsSelectedItemAction: "",
      clsLabel: "",
      clsGroupName: "",
      clsFilterInput: "",
      onClear: Metro2.noop,
      onChange: Metro2.noop,
      onUp: Metro2.noop,
      onDrop: Metro2.noop,
      onOptions: Metro2.noop,
      onItemSelect: Metro2.noop,
      onItemDeselect: Metro2.noop,
      onSelectCreate: Metro2.noop,
      onData: (f5) => f5
    };
    Metro2.selectSetup = (options) => {
      SelectDefaultConfig = $7.extend({}, SelectDefaultConfig, options);
    };
    if (typeof globalThis.metroSelectSetup !== "undefined") {
      Metro2.selectSetup(globalThis.metroSelectSetup);
    }
    Metro2.Component("select", {
      init: function(options, elem) {
        this._super(elem, options, SelectDefaultConfig, {
          list: null,
          placeholder: null,
          observer: null,
          origin: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this.origin = element2.clone(true, true);
        this._createSelect();
        this._createEvents();
        this._fireEvent("select-create", {
          element: element2
        });
      },
      _setPlaceholder: function() {
        const element2 = this.element;
        const o2 = this.options;
        const input = element2.siblings(".select-input");
        if (o2.usePlaceholder === true && (!Metro2.utils.isValue(element2.val()) || `${element2.val()}` === `${o2.emptyValue}`)) {
          input.html(o2.placeholder || this.strings.label_select_more);
        }
      },
      _addTag: function(val, data) {
        const element2 = this.element;
        const o2 = this.options;
        let tagSize;
        const container = element2.closest(".select");
        const html = `<span class='title'>${val}</span>`;
        const tag = $7("<div>").addClass("tag").addClass(o2.shortTag ? "short-tag" : "").addClass(o2.clsSelectedItem).html(html).data("option", data);
        $7("<span>").addClass("action unselect-option").addClass(o2.clsSelectedItemAction).html("&times;").appendTo(tag);
        if (container.hasClass("large")) {
          tagSize = "large";
        } else if (container.hasClass("small")) {
          tagSize = "small";
        } else if (container.hasClass("medium")) {
          tagSize = "medium";
        }
        tag.addClass(tagSize);
        return tag;
      },
      _addOption: function(item, parent2, input, multiple, group) {
        const option = $7(item);
        let l2;
        let a2;
        const element2 = this.element;
        const o2 = this.options;
        let html = Metro2.utils.isValue(option.attr("data-template")) ? option.attr("data-template").replace("$1", item.text) : item.text;
        const displayValue = option.attr("data-display");
        l2 = $7("<li>").addClass(o2.clsOption).data("option", item).attr("data-text", item.text).attr("data-value", item.value ? item.value : "");
        a2 = $7("<a>").html(html);
        const optionIcon = option.attr("data-icon");
        if (optionIcon) {
          a2.prepend($7("<span>").addClass("icon").html(optionIcon));
        }
        if (displayValue) {
          l2.attr("data-display", displayValue);
          html = displayValue;
        }
        l2.addClass(item.className);
        l2.data("group", group);
        if (option.is(":disabled")) {
          l2.addClass("disabled");
        }
        if (option.is(":selected")) {
          let g5 = "";
          if (o2.showGroupName && group) {
            g5 = `&nbsp;<span class='selected-item__group-name ${o2.clsGroupName}'>${group}</span>`;
          }
          if (multiple) {
            l2.addClass("d-none");
            input.append(this._addTag(a2.html() + g5, l2));
          } else {
            html = a2.html() + g5;
            element2.val(item.value);
            input.html(html);
            element2.fire("change", {
              val: item.value
            });
            l2.addClass("active");
          }
        }
        l2.append(a2).appendTo(parent2);
      },
      _addOptionGroup: function(item, parent2, input, multiple) {
        const that = this;
        const o2 = this.options;
        const group = $7(item);
        $7("<li>").html(item.label).addClass("group-title").addClass(o2.clsOptionGroup).appendTo(parent2);
        $7.each(group.children(), function() {
          that._addOption(this, parent2, input, multiple, item.label);
        });
      },
      _createOptions: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const select = element2.parent();
        const list = select.find("ul").empty();
        const selected = element2.find("option[selected]").length > 0;
        const multiple = element2[0].multiple;
        const input = element2.siblings(".select-input");
        element2.siblings(".select-input").empty();
        if (o2.addEmptyValue === true) {
          element2.prepend(
            $7(`<option ${!selected ? "selected" : ""} value='${o2.emptyValue}' class='d-none'></option>`)
          );
        }
        $7.each(element2.children(), function() {
          if (this.tagName === "OPTION") {
            that._addOption(this, list, input, multiple, null);
          } else if (this.tagName === "OPTGROUP") {
            that._addOptionGroup(this, list, input, multiple);
          }
        });
        this._fireEvent("options", {
          selected: this.getSelected()
        });
      },
      _createSelect: async function() {
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.wrap("<label>");
        const multiple = element2[0].multiple;
        const select_id = Hooks.useId(container[0]);
        const buttons = $7("<div>").addClass("button-group");
        let drop_container;
        let drop_container_input;
        const checkboxID = Hooks.useId("select-focus-trigger");
        const checkbox = $7("<input type='checkbox'>").addClass("select-focus-trigger").attr("id", checkboxID);
        this.placeholder = $7("<span>").addClass("placeholder").html(o2.placeholder);
        container.attr("id", o2.id ? o2.id : select_id).attr("for", checkboxID);
        container[0].className = Metro2.utils.classNames(
          element2[0].className,
          `input-${o2.size}`,
          "select",
          o2.clsSelect
        );
        const dropdown_toggle = $7("<span>").addClass("dropdown-toggle");
        dropdown_toggle.appendTo(container);
        if (multiple) {
          container.addClass("multiple");
        }
        buttons.appendTo(container);
        checkbox.appendTo(container);
        const input = $7("<div>").addClass("select-input").addClass(o2.clsSelectInput).attr("name", `__${select_id}__`);
        drop_container = $7("<div>").addClass("drop-container").addClass(o2.clsDropContainer);
        if (o2.dropFullSize === false) {
          if (o2.dropWidth) {
            drop_container.css({
              width: +o2.dropWidth
            });
          }
        } else {
          container.addClass("drop-full-size");
        }
        drop_container_input = $7("<div>").appendTo(drop_container);
        const list = $7("<ul>").addClass("option-list").addClass(o2.clsDropList).css({
          "max-height": o2.dropHeight
        });
        const filter_input = $7(
          `<input type='text' data-role='input' data-clear-button-icon="${o2.clearButtonIcon}">`
        ).attr("placeholder", o2.filterPlaceholder || `${this.strings.label_filter}...`).appendTo(drop_container_input);
        filter_input.addClass(o2.clsFilterInput);
        container.append(input);
        container.append(drop_container);
        drop_container.append(drop_container_input);
        if (o2.filter !== true) {
          drop_container_input.hide();
        }
        drop_container.append(list);
        if (o2.source) {
          await this.fetch(o2.source, {
            method: o2.sourceMethod || "GET",
            headers: {
              "Content-Type": `application/${o2.sourceType || "json"}`
            }
          });
        }
        this._createOptions();
        this._setPlaceholder();
        this._createDroppable(drop_container);
        this.list = list;
        if (o2.clearButton === true && !element2[0].readOnly) {
          const clearButton = $7("<button>").addClass("button input-clear-button").addClass(o2.clsClearButton).attr("tabindex", -1).attr("type", "button").html(o2.clearButtonIcon);
          clearButton.appendTo(buttons);
        } else {
          buttons.addClass("d-none");
        }
        if (o2.prepend !== "" && !multiple) {
          const prepend = $7("<div>").html(o2.prepend);
          prepend.addClass("prepend").addClass(o2.clsPrepend).appendTo(container);
        }
        if (o2.append !== "" && !multiple) {
          const append = $7("<div>").html(o2.append);
          append.addClass("append").addClass(o2.clsAppend).appendTo(container);
        }
        if (element2.attr("dir") === "rtl") {
          container.addClass("rtl").attr("dir", "rtl");
        }
        if (o2.label) {
          const label = $7("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(container);
          if (element2.attr("id")) {
            label.attr("for", element2.attr("id"));
          } else {
            label.attr("for", checkboxID);
          }
          if (element2.attr("dir") === "rtl") {
            label.addClass("rtl");
          }
        }
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        this.observer = new MutationObserver(this._updateSelect.bind(this));
        this.observer.observe(element2[0], {
          childList: true,
          subtree: true
        });
      },
      _createDroppable: function(drop_container) {
        const o2 = this.options;
        const filter_input = drop_container.find("input");
        const container = this.element.closest(".select");
        const dropdown_toggle = drop_container.siblings(".dropdown-caret");
        const list = drop_container.find("ul");
        Metro2.makePlugin(drop_container, "dropdown", {
          dropFilter: ".select",
          duration: o2.duration,
          toggleElement: [container],
          openMode: o2.openMode,
          onDrop: () => {
            let target;
            dropdown_toggle.addClass("active-toggle");
            const dropped = $7(".select .drop-container");
            $7.each(dropped, function() {
              const drop = $7(this);
              if (drop.is(drop_container)) {
                return;
              }
              const dataDrop = Metro2.getPlugin(drop, "dropdown");
              if (dataDrop?.close) {
                dataDrop.close();
              }
            });
            filter_input.val("").trigger(Metro2.events.keyup);
            target = list.find("li.active").length > 0 ? $7(list.find("li.active")[0]) : void 0;
            if (target !== void 0) {
              list[0].scrollTop = target.position().top - (list.height() - target.height()) / 2;
            }
            this._fireEvent("drop", {
              list: list[0]
            });
          },
          onUp: () => {
            dropdown_toggle.removeClass("active-toggle");
            this._fireEvent("up", {
              list: list[0]
            });
          }
        });
      },
      _updateSelect: function(mutation) {
        for (const record of mutation) {
          if (record.type === "childList") {
            if (record.addedNodes.length || record.removedNodes.length) {
              this._createOptions();
            }
          }
        }
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.closest(".select");
        const drop_container = container.find(".drop-container");
        const input = element2.siblings(".select-input");
        const filter_input = drop_container.find("input");
        const list = drop_container.find("ul");
        const clearButton = container.find(".input-clear-button");
        const checkbox = container.find(".select-focus-trigger");
        checkbox.on("focus", () => {
          container.addClass("focused");
        });
        checkbox.on("blur", () => {
          container.removeClass("focused");
        });
        clearButton.on(Metro2.events.click, (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
          that.clear();
        });
        element2.on(Metro2.events.change, () => {
          that._setPlaceholder();
        });
        container.on(Metro2.events.click, () => {
          $7(".focused").removeClass("focused");
          container.addClass("focused");
        });
        input.on(Metro2.events.click, () => {
          $7(".focused").removeClass("focused");
          container.addClass("focused");
        });
        list.on(Metro2.events.click, "li", function(e2) {
          if ($7(this).hasClass("group-title")) {
            e2.preventDefault();
            e2.stopPropagation();
            return;
          }
          const leaf = $7(this);
          const displayValue = leaf.attr("data-display");
          const val = leaf.data("value");
          const group = leaf.data("group");
          let html = displayValue ? displayValue : leaf.children("a").html();
          const option = leaf.data("option");
          const options = element2.find("option");
          if (o2.showGroupName && group) {
            html += `&nbsp;<span class='selected-item__group-name ${o2.clsGroupName}'>${group}</span>`;
          }
          if (element2[0].multiple) {
            leaf.addClass("d-none");
            input.append(that._addTag(html, leaf));
          } else {
            list.find("li.active").removeClass("active").removeClass(o2.clsOptionActive);
            leaf.addClass("active").addClass(o2.clsOptionActive);
            input.html(html);
            Metro2.getPlugin(drop_container, "dropdown").close();
          }
          $7.each(options, function() {
            if (this === option) {
              this.selected = true;
            }
          });
          that._fireEvent("item-select", {
            val,
            option,
            leaf: leaf[0]
          });
          const selected = that.getSelected();
          that._fireEvent("change", {
            selected
          });
        });
        input.on("click", ".tag .action", function(e2) {
          const item = $7(this).closest(".tag");
          const leaf = item.data("option");
          const option = leaf.data("option");
          leaf.removeClass("d-none");
          $7.each(element2.find("option"), function() {
            if (this === option) {
              this.selected = false;
            }
          });
          item.remove();
          that._fireEvent("item-deselect", {
            option
          });
          const selected = that.getSelected();
          that._fireEvent("change", {
            selected
          });
          e2.preventDefault();
          e2.stopPropagation();
        });
        const filter_input_change = Hooks.useDebounce(async (e2) => {
          const o3 = this.options;
          const list2 = this.list;
          const filter = e2.target.value.toLowerCase();
          const filterSource = `${o3.filterSource}${filter}`;
          if (o3.filterSource) {
            await this.fetch(
              filterSource,
              {
                method: o3.sourceMethod || "GET",
                headers: {
                  "Content-Type": `application/${o3.sourceType || "json"}`
                }
              },
              true
            );
          } else {
            const li = list2.find("li");
            let i3;
            let a2;
            let t;
            for (i3 = 0; i3 < li.length; i3++) {
              if ($7(li[i3]).hasClass("group-title")) continue;
              a2 = li[i3].getElementsByTagName("a")[0];
              t = a2.innerHTML || a2.innerText;
              if (t.toLowerCase().includes(filter)) {
                li[i3].style.display = "";
              } else {
                li[i3].style.display = "none";
              }
            }
          }
        }, o2.filterThreshold);
        filter_input.on(Metro2.events.keyup, filter_input_change.bind(this));
        filter_input.on(Metro2.events.click, (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
        });
        drop_container.on(Metro2.events.click, (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
        });
      },
      _clearOptions: function() {
        this.element.clear();
        this.list.clear();
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.closest(".select").addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.closest(".select").removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      reset: function() {
        this.observer.disconnect();
        this.element.clear();
        for (const option of this.origin.children()) {
          this.element.append(option.cloneNode(true));
        }
        this._createOptions();
        this.observer.observe(this.elem, {
          childList: true,
          subtree: true
        });
        this._fireEvent("reset");
        return this;
      },
      getSelected: function() {
        const element2 = this.element;
        const result = [];
        element2.find("option").each(function() {
          if (this.selected) result.push(this.value);
        });
        return result;
      },
      val: function(val) {
        const element2 = this.element;
        const o2 = this.options;
        const input = element2.siblings(".select-input");
        const options = element2.find("option");
        const list_items = this.list.find("li");
        const result = [];
        const multiple = !!element2.attr("multiple");
        let option;
        let i3;
        let html = "";
        let list_item;
        let option_value;
        let group;
        if (Metro2.utils.isNull(val)) {
          $7.each(options, function() {
            if (this.selected) result.push(this.value);
          });
          return multiple ? result : result[0];
        }
        $7.each(options, function() {
          this.selected = false;
        });
        list_items.removeClass("active").removeClass("d-none").removeClass(o2.clsOptionActive);
        input.html("");
        const _val = Array.isArray(val) ? val : [val];
        $7.each(_val, (_5, v5) => {
          for (option of options) {
            html = option.getAttribute("data-template") ? option.getAttribute("data-template").replace("$1", option.text) : option.text;
            if (option.getAttribute("data-icon")) {
              html = `<span class='icon'>${option.getAttribute("data-icon")}</span>` + html;
            }
            if (`${option.value}` === `${v5}`) {
              option.selected = true;
              break;
            }
          }
          for (i3 = 0; i3 < list_items.length; i3++) {
            list_item = $7(list_items[i3]);
            group = list_item.data("group");
            option_value = list_item.attr("data-value");
            if (`${option_value}` === `${v5}`) {
              if (o2.showGroupName && group) {
                html += `&nbsp;<span class='selected-item__group-name'>${group}</span>`;
              }
              if (element2[0].multiple) {
                list_item.addClass("d-none");
                input.append(this._addTag(html, list_item));
              } else {
                list_item.addClass("active").addClass(o2.clsOptionActive);
                input.html(html);
              }
              break;
            }
          }
        });
        this._fireEvent("change", {
          selected: this.getSelected()
        });
      },
      options: function(op, selected, delimiter) {
        return this.data(op, selected, delimiter);
      },
      data: function(op, selected, delimiter) {
        const element2 = this.element;
        let option_group;
        let _selected;
        const _delimiter = delimiter || ",";
        if (typeof selected === "string") {
          _selected = selected.toArray(_delimiter).map((v5) => isNaN(v5) ? v5 : +v5);
        } else if (Array.isArray(selected)) {
          _selected = selected.slice().map((v5) => isNaN(v5) ? v5 : +v5);
        } else {
          _selected = [];
        }
        this.observer.disconnect();
        element2.empty();
        if (typeof op === "string") {
          element2.html(op);
        } else if (Metro2.utils.isObject2(op)) {
          $7.each(op, (key, val) => {
            if (Metro2.utils.isObject2(val)) {
              option_group = $7("<optgroup label=''>").attr("label", key).appendTo(element2);
              $7.each(val, (key2, val2) => {
                const op2 = $7("<option>").attr("value", key2).text(val2).appendTo(option_group);
                if (_selected.indexOf(+key2) > -1) {
                  op2.prop("selected", true);
                }
              });
            } else {
              const op2 = $7("<option>").attr("value", key).text(val).appendTo(element2);
              if (_selected.indexOf(key) > -1) {
                op2.prop("selected", true);
              }
            }
          });
        }
        this._createOptions();
        this.observer.observe(element2[0], {
          childList: true,
          subtree: true
        });
        return this;
      },
      addOption: function(val, title, selected) {
        const element2 = this.element;
        const option = $7("<option>").attr("value", val).text(title ? title : val);
        element2.append(option);
        if (selected) {
          if (element2[0].multiple) {
          } else {
            element2.find("option").prop("selected", false);
          }
          option.prop("selected", true);
        }
        return this;
      },
      addOptions: function(values) {
        const that = this;
        if (!values) {
          return this;
        }
        this.observer.disconnect();
        if (Array.isArray(values)) {
          $7.each(values, function() {
            if (Metro2.utils.isObject2(this)) {
              that.addOption(this.val, this.title, this.selected);
            } else {
              that.addOption(this);
            }
          });
        } else if (Metro2.utils.isObject2(values)) {
          $7.each(values, (key, val) => {
            that.addOption(key, val);
          });
        }
        this._createOptions();
        this.observer.observe(element[0], {
          childList: true,
          subtree: true
        });
        return this;
      },
      removeOption: function(val) {
        const element2 = this.element;
        const options = element2.find("option");
        options.each(function() {
          const $el = $7(this);
          if (`${$el.attr("value")}` === `${val}`) {
            $el.remove();
          }
        });
        this._createOptions();
        return this;
      },
      removeOptions: function(values) {
        const element2 = this.element;
        const options = element2.find("option");
        if (!values || !Array.isArray(values)) {
          return this;
        }
        options.each(function() {
          const $el = $7(this);
          const val = $el.attr("value");
          if (values.indexOf(val) > -1) {
            $el.remove();
          }
        });
        this._createOptions();
        return this;
      },
      fetch: async function(source, options, clearOptions = false) {
        const element2 = this.element;
        const o2 = this.options;
        const _options = Object.assign(
          {
            method: "GET",
            headers: {
              "Content-Type": `application/${o2.sourceType}`
            }
          },
          options
        );
        const result = await fetch(source, _options);
        if (result.ok === false) {
          return;
        }
        if (clearOptions) {
          this._clearOptions();
        }
        let data = o2.sourceType === "json" ? await result.json() : await result.text();
        data = Metro2.utils.exec(o2.onData, [data], element2[0]);
        $7.each(data, function() {
          const text = typeof this.text === "undefined" ? this.value : this.text;
          const value = typeof this.value === "undefined" ? this.text : this.value;
          const option = $7("<option>").attr("value", value).html(text);
          if (this.icon) {
            option.attr("data-icon", this.icon);
          }
          if (this.selected) {
            option.prop("selected", true);
          }
          option.appendTo(element2);
        });
      },
      clear: function() {
        const element2 = this.element;
        const o2 = this.options;
        const input = element2.siblings(".select-input");
        const drop = element2.siblings(".drop-container");
        const list = drop.find("ul");
        element2.val(o2.emptyValue);
        if (element2[0].multiple) {
          list.find("li").removeClass("d-none");
          if (o2.closeOnClear) {
            drop.data("dropdown").close();
          }
        }
        input.clear();
        this._setPlaceholder();
        this._fireEvent("clear");
      },
      changeAttribute: function(attributeName) {
        if (attributeName === "disabled") {
          this.toggleState();
        }
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.closest(".select");
        const drop_container = container.find(".drop-container");
        const input = element2.siblings(".select-input");
        const filter_input = drop_container.find("input");
        const list = drop_container.find("ul");
        const clearButton = container.find(".input-clear-button");
        container.off(Metro2.events.click);
        container.off(Metro2.events.click, ".input-clear-button");
        input.off(Metro2.events.click);
        filter_input.off(Metro2.events.blur);
        filter_input.off(Metro2.events.focus);
        list.off(Metro2.events.click, "li");
        filter_input.off(Metro2.events.keyup);
        drop_container.off(Metro2.events.click);
        clearButton.off(Metro2.events.click);
        drop_container.data("dropdown").destroy();
        if (o2.label) {
          container.prev("label").remove();
        }
        container.remove();
      }
    });
    $7(document).on(
      Metro2.events.click,
      () => {
        $7(".select").removeClass("focused");
      },
      { ns: "blur-select-elements" }
    );
  })(Metro, Dom);

  // ../metroui-lib/source/components/input/input.js
  ((Metro2, $7) => {
    "use strict";
    let InputDefaultConfig = {
      inputDeferred: 0,
      label: "",
      autocomplete: null,
      autocompleteUrl: null,
      autocompleteUrlMethod: "GET",
      autocompleteUrlKey: null,
      autocompleteDivider: ",",
      autocompleteListHeight: 200,
      history: false,
      historyPreset: "",
      historyDivider: "|",
      preventSubmit: false,
      defaultValue: "",
      size: "default",
      prepend: "",
      append: "",
      searchButton: false,
      clearButton: true,
      revealButton: true,
      randomButton: false,
      clearButtonIcon: "\u2716",
      revealButtonIcon: "\u{1F440}",
      searchButtonIcon: "\u{1F50D}",
      randomButtonIcon: "\u{1F3B2}",
      customButtons: [],
      searchButtonClick: "submit",
      randomSymbols: "0123456789;abcdefghijklmnopqrstuvwxyz;ABCDEFGHIJKLMNOPQRSTUVWXYZ;<>!?@#$%^&*()_+",
      randomLength: 12,
      prependOptions: "",
      prependOptionsSep: ",",
      appendOptions: "",
      appendOptionsSep: ",",
      badge: null,
      clsComponent: "",
      clsInput: "",
      clsPrepend: "",
      clsAppend: "",
      clsClearButton: "",
      clsRevealButton: "",
      clsCustomButton: "",
      clsSearchButton: "",
      clsRandomButton: "",
      clsLabel: "",
      onAutocompleteSelect: Metro2.noop,
      onHistoryChange: Metro2.noop,
      onHistoryUp: Metro2.noop,
      onHistoryDown: Metro2.noop,
      onClearClick: Metro2.noop,
      onRevealClick: Metro2.noop,
      onSearchButtonClick: Metro2.noop,
      onEnterClick: Metro2.noop,
      onInputCreate: Metro2.noop
    };
    Metro2.inputSetup = (options) => {
      InputDefaultConfig = $7.extend({}, InputDefaultConfig, options);
    };
    if (typeof globalThis.metroInputSetup !== "undefined") {
      Metro2.inputSetup(globalThis.metroInputSetup);
    }
    Metro2.Component("input", {
      init: function(options, elem) {
        this._super(elem, options, InputDefaultConfig, {
          history: [],
          historyIndex: -1,
          autocomplete: [],
          prependOptionsList: null,
          appendOptionsList: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("input-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.wrap("<div>").addClass(`input ${element2[0].className}`);
        let buttons;
        let clearButton;
        let revealButton;
        let searchButton;
        let randomButton;
        if (!element2.id()) {
          element2.attr("id", Hooks.useId(element2[0]));
        }
        if (Metro2.utils.isValue(o2.historyPreset)) {
          $7.each(o2.historyPreset.toArray(o2.historyDivider), function() {
            that.history.push(this);
          });
          that.historyIndex = that.history.length - 1;
        }
        if (element2.attr("type") === void 0) {
          element2.attr("type", "text");
        }
        buttons = $7("<div>").addClass("button-group").appendTo(container);
        if (!Metro2.utils.isValue(element2.val().trim())) {
          element2.val(o2.defaultValue);
        }
        if (o2.clearButton === true && !element2[0].readOnly) {
          clearButton = $7("<button>").addClass("button input-clear-button").addClass(o2.clsClearButton).attr("tabindex", -1).attr("type", "button").html(o2.clearButtonIcon).attr("title", this.strings.label_clear_input);
          clearButton.appendTo(buttons);
        }
        if (element2.attr("type") === "password" && o2.revealButton === true) {
          revealButton = $7("<button>").addClass("button input-reveal-button").addClass(o2.clsRevealButton).attr("tabindex", -1).attr("type", "button").html(o2.revealButtonIcon).attr("title", this.strings.label_reveal_password);
          revealButton.appendTo(buttons);
        }
        if (o2.searchButton === true) {
          searchButton = $7("<button>").addClass("button input-search-button").addClass(o2.clsSearchButton).attr("tabindex", -1).attr("type", o2.searchButtonClick === "submit" ? "submit" : "button").html(o2.searchButtonIcon).attr("title", this.strings.label_search_input);
          searchButton.appendTo(buttons);
        }
        if (o2.randomButton === true) {
          randomButton = $7("<button>").addClass("button input-random-button").addClass(o2.clsRandomButton).attr("tabindex", -1).attr("type", "button").html(o2.randomButtonIcon).attr("title", this.strings.label_generate_random);
          randomButton.appendTo(buttons);
        }
        let opt2;
        let ul;
        if (o2.prepend) {
          $7("<div>").html(o2.prepend).addClass("prepend").addClass(o2.clsPrepend).appendTo(container);
        }
        if (o2.prependOptions) {
          opt2 = $7("<div>").addClass("prepend-options").appendTo(container);
          ul = $7("<select data-role='select'>").addClass("options-list");
          opt2.append(ul);
          for (const item of o2.prependOptions.toArray(o2.prependOptionsSep)) {
            $7("<option>").attr("value", item).html(item).appendTo(ul);
          }
          this.prependOptionsList = ul;
        }
        if (o2.append) {
          $7("<div>").html(o2.append).addClass("append").addClass(o2.clsAppend).appendTo(container);
        }
        if (o2.appendOptions) {
          opt2 = $7("<div>").addClass("append-options").appendTo(container);
          ul = $7("<select data-role='select'>").addClass("options-list");
          opt2.append(ul);
          for (const item of o2.appendOptions.toArray(o2.appendOptionsSep)) {
            $7("<option>").attr("value", item).html(item).appendTo(ul);
          }
          this.appendOptionsList = ul;
        }
        const customButtons = Metro2.utils.isObject(o2.customButtons);
        if (Array.isArray(customButtons)) {
          $7.each(customButtons, function() {
            const btn = $7("<button>");
            btn.addClass("button input-custom-button").addClass(o2.clsCustomButton).addClass(this.cls).attr("tabindex", -1).attr("type", "button").html(this.text || this.html || "");
            that._setAttributes(btn, this.attr);
            if (this.onclick) {
              btn.on("click", (e2) => {
                if (Metro2.utils.isRightMouse(e2)) return;
                Metro2.utils.exec(this.onclick, [btn[0], element2[0]]);
              });
            }
            btn.appendTo(buttons);
          });
        }
        if (Metro2.utils.isValue(element2.attr("data-exclaim"))) {
          container.attr("data-exclaim", element2.attr("data-exclaim"));
        }
        if (element2.attr("dir") === "rtl") {
          container.addClass("rtl").attr("dir", "rtl");
        }
        element2[0].className = "";
        container.addClass(o2.clsComponent);
        element2.addClass(o2.clsInput);
        if (o2.size !== "default") {
          container.css({
            width: o2.size
          });
        }
        if (!Metro2.utils.isNull(o2.autocomplete) || !Metro2.utils.isNull(o2.autocompleteUrl)) {
          $7("<div>").addClass("autocomplete-list").css({
            maxHeight: o2.autocompleteListHeight,
            display: "none"
          }).appendTo(container);
        }
        if (Metro2.utils.isValue(o2.autocomplete)) {
          const autocomplete_obj = Metro2.utils.isObject(o2.autocomplete);
          if (autocomplete_obj !== false) {
            this.autocomplete = autocomplete_obj;
          } else {
            this.autocomplete = o2.autocomplete.toArray(o2.autocompleteDivider);
          }
        }
        if (Metro2.utils.isValue(o2.autocompleteUrl)) {
          fetch(o2.autocompleteUrl, {
            method: o2.autocompleteUrlMethod
          }).then((response) => response.text()).then((data) => {
            let newData = [];
            try {
              newData = JSON.parse(data);
              if (o2.autocompleteUrlKey) {
                newData = newData[o2.autocompleteUrlKey];
              }
            } catch (e2) {
              newData = data.split("\n");
            }
            that.autocomplete = that.autocomplete.concat(newData);
          });
        }
        this._addLabel(o2.label, container, {
          className: o2.clsLabel,
          id: element2.attr("id"),
          dir: element2.attr("dir")
        });
        if (o2.badge) {
          container.append($7("<div>").addClass("badge").html(o2.badge));
        }
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        this.component = container;
      },
      _hideAutocompleteList: function() {
        const element2 = this.element;
        const container = element2.closest(".input");
        const autocompleteList = container.find(".autocomplete-list");
        if (autocompleteList.length > 0) {
          autocompleteList.css({
            display: "none"
          });
        }
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.closest(".input");
        const autocompleteList = container.find(".autocomplete-list");
        container.on(Metro2.events.click, ".input-clear-button", () => {
          const curr = element2.val();
          element2.val(Metro2.utils.isValue(o2.defaultValue) ? o2.defaultValue : "").fire("clear").fire("change").fire("keyup").focus();
          that._hideAutocompleteList();
          that._fireEvent("clear-click", {
            prev: curr
          });
        });
        container.on(Metro2.events.click, ".input-reveal-button", () => {
          if (element2.attr("type") === "password") {
            element2.attr("type", "text");
          } else {
            element2.attr("type", "password");
          }
          that._fireEvent("reveal-click", {
            val: element2.val()
          });
        });
        container.on(Metro2.events.click, ".input-search-button", function() {
          if (o2.searchButtonClick !== "submit") {
            that._fireEvent("search-button-click", {
              val: that.val(),
              button: this
            });
          } else {
            if (this.form) this.form.submit();
          }
        });
        container.on(Metro2.events.click, ".input-random-button", () => {
          const val = that._generateRandomValue();
          element2.val(val).fire("change").fire("keyup").focus();
          that._fireEvent("random-click", {
            val
          });
        });
        element2.on(Metro2.events.keyup, (e2) => {
          if (e2.keyCode === Metro2.keyCode.ESCAPE) {
            that._hideAutocompleteList();
            return;
          }
          if (e2.keyCode === Metro2.keyCode.TAB) {
            that._hideAutocompleteList();
            return;
          }
          const val = element2.val().trim();
          if (o2.history && e2.keyCode === Metro2.keyCode.ENTER && val !== "") {
            element2.val("");
            that.history.push(val);
            that.historyIndex = that.history.length - 1;
            that._fireEvent("history-change", {
              val,
              history: that.history,
              historyIndex: that.historyIndex
            });
            if (o2.preventSubmit === true) {
              e2.preventDefault();
            }
          }
          if (o2.history && e2.keyCode === Metro2.keyCode.UP_ARROW) {
            that.historyIndex--;
            if (that.historyIndex >= 0) {
              element2.val("");
              element2.val(that.history[that.historyIndex]);
              that._fireEvent("history-down", {
                val: element2.val(),
                history: that.history,
                historyIndex: that.historyIndex
              });
            } else {
              that.historyIndex = 0;
            }
            e2.preventDefault();
          }
          if (o2.history && e2.keyCode === Metro2.keyCode.DOWN_ARROW) {
            that.historyIndex++;
            if (that.historyIndex < that.history.length) {
              element2.val("");
              element2.val(that.history[that.historyIndex]);
              that._fireEvent("history-up", {
                val: element2.val(),
                history: that.history,
                historyIndex: that.historyIndex
              });
            } else {
              that.historyIndex = that.history.length - 1;
            }
            e2.preventDefault();
          }
        });
        element2.on(Metro2.events.keydown, (e2) => {
          if (e2.keyCode === Metro2.keyCode.ENTER) {
            that._fireEvent("enter-click", {
              val: element2.val()
            });
          }
        });
        element2.on(Metro2.events.blur, () => {
          container.removeClass("focused");
        });
        element2.on(Metro2.events.focus, () => {
          container.addClass("focused");
        });
        element2.on(Metro2.events.input, function() {
          const val = this.value.toLowerCase();
          that._drawAutocompleteList(val);
        });
        container.on(Metro2.events.click, ".autocomplete-list .item", function() {
          const val = $7(this).attr("data-autocomplete-value");
          element2.val(val);
          that._hideAutocompleteList();
          element2.trigger("change");
          that._fireEvent("autocomplete-select", {
            value: val
          });
        });
      },
      _generateRandomValue: function() {
        const o2 = this.options;
        const groups = o2.randomSymbols.split(";");
        const symbolsPerGroup = Math.round(o2.randomLength / groups.length);
        const val = [];
        for (const g5 of groups) {
          const symbols = g5.split("");
          const len = symbols.length;
          for (let i3 = 0; i3 < symbolsPerGroup; i3++) {
            val.push(symbols[Math.floor(Math.random() * len)]);
          }
        }
        return val.shuffle().join("");
      },
      _drawAutocompleteList: function(val) {
        const that = this;
        const element2 = this.element;
        const container = element2.closest(".input");
        const autocompleteList = container.find(".autocomplete-list");
        if (autocompleteList.length === 0) {
          return;
        }
        autocompleteList.html("");
        const items = this.autocomplete.filter((item) => item.toLowerCase().indexOf(val) > -1);
        autocompleteList.css({
          display: items.length > 0 ? "block" : "none"
        });
        $7.each(items, function() {
          const index = this.toLowerCase().indexOf(val);
          let content;
          const item = $7("<div>").addClass("item").attr("data-autocomplete-value", this);
          if (index === 0) {
            content = `<strong>${this.substring(0, val.length)}</strong>${this.substring(val.length)}`;
          } else {
            content = `${this.substring(0, index)}<strong>${this.substring(index, val.length)}</strong>${this.substring(index + val.length)}`;
          }
          item.html(content).appendTo(autocompleteList);
          that._fireEvent("draw-autocomplete-item", {
            item
          });
        });
      },
      getHistory: function() {
        return this.history;
      },
      getHistoryIndex: function() {
        return this.historyIndex;
      },
      setHistoryIndex: function(val) {
        this.historyIndex = val >= this.history.length ? this.history.length - 1 : val;
      },
      setHistory: function(history2, append) {
        const that = this;
        const o2 = this.options;
        if (!history2) return;
        if (typeof history2 !== "string" && !Array.isArray(history2)) {
          console.error("History must be a string or an array!");
          console.dir(history2);
        }
        const _history = typeof history2 === "string" ? history2.toArray(o2.historyDivider) : history2;
        if (append === true) {
          $7.each(_history, function() {
            that.history.push(this);
          });
        } else {
          this.history = history2;
        }
        this.historyIndex = this.history.length - 1;
      },
      clear: function() {
        this.element.val("");
      },
      toDefault: function() {
        this.element.val(Metro2.utils.isValue(this.options.defaultValue) ? this.options.defaultValue : "");
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      setAutocompleteList: function(l2) {
        const autocomplete_list = Metro2.utils.isObject(l2);
        if (autocomplete_list !== false) {
          this.autocomplete = autocomplete_list;
        } else if (typeof l2 === "string") {
          this.autocomplete = l2.toArray(this.options.autocompleteDivider);
        }
      },
      val: function(v5, splitter = ";") {
        const element2 = this.element;
        const o2 = this.options;
        if (!Metro2.utils.isValue(v5)) {
          let val2 = element2.val();
          if (o2.prependOptions) {
            val2 = this.prependOptionsList.val() + val2;
          }
          if (o2.appendOptions) {
            val2 = val2 + this.appendOptionsList.val();
          }
          return val2;
        }
        const groups = v5.split(splitter);
        let prepend = "";
        let append = "";
        if (o2.prependOptions) {
          prepend = groups.shift();
          Metro2.getPlugin(this.prependOptionsList, "select").val(prepend);
        }
        if (o2.appendOptions) {
          append = groups.pop();
          Metro2.getPlugin(this.appendOptionsList, "select").val(append);
        }
        const val = groups.join("");
        element2.val(val);
      },
      prependOptionsVal: function(v5) {
        if (!this.options.prependOptions) {
          return;
        }
        if (!Metro2.utils.isValue(v5)) {
          this.prependOptionsList.val();
        }
        this.prependOptionsList.val(v5);
      },
      appendOptionsVal: function(v5) {
        if (!this.options.appendOptions) {
          return;
        }
        if (!Metro2.utils.isValue(v5)) {
          return this.appendOptionsList.val();
        }
        this.appendOptionsList.val(v5);
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "disabled":
            this.toggleState();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        const parent2 = element2.parent();
        const clearBtn = parent2.find(".input-clear-button");
        const revealBtn = parent2.find(".input-reveal-button");
        const customBtn = parent2.find(".input-custom-button");
        if (clearBtn.length > 0) {
          clearBtn.off(Metro2.events.click);
        }
        if (revealBtn.length > 0) {
          revealBtn.off(Metro2.events.start);
          revealBtn.off(Metro2.events.stop);
        }
        if (customBtn.length > 0) {
          clearBtn.off(Metro2.events.click);
        }
        element2.off(Metro2.events.blur);
        element2.off(Metro2.events.focus);
        if (o2.label) {
          parent2.prev("label").remove();
        }
        parent2.remove();
      }
    });
    $7(document).on(Metro2.events.click, () => {
      $7(".input .autocomplete-list").hide();
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/radio/radio.js
  ((Metro2, $7) => {
    "use strict";
    let RadioDefaultConfig = {
      radioDeferred: 0,
      prepend: "",
      append: "",
      caption: "",
      clsRadio: "",
      clsCaption: "",
      clsPrepend: "",
      clsAppend: "",
      onRadioCreate: Metro2.noop
    };
    Metro2.metroRadioSetup = (options) => {
      RadioDefaultConfig = $7.extend({}, RadioDefaultConfig, options);
    };
    if (typeof globalThis.metroRadioSetup !== "undefined") {
      Metro2.metroRadioSetup(globalThis.metroRadioSetup);
    }
    Metro2.Component("radio", {
      init: function(options, elem) {
        this._super(elem, options, RadioDefaultConfig, {
          origin: {
            className: ""
          }
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("radio-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.wrap("<label>").addClass("radio").addClass(o2.clsCheckbox);
        element2.attr("type", "radio");
        if (o2.prepend) {
          container.prepend(
            $7("<span>").addClass("caption-prepend").addClass(o2.clsPrepend).addClass(o2.clsCaption).html(o2.prepend)
          );
        }
        if (o2.append || o2.caption) {
          container.append(
            $7("<span>").addClass("caption-append").addClass(o2.clsAppend).addClass(o2.clsCaption).html(o2.append || o2.caption)
          );
        }
        if (element2.attr("readonly")) {
          element2.on("click", (e2) => {
            e2.preventDefault();
          });
        }
        if (this.elem.checked) {
          this.state = true;
        }
        this._drawState();
      },
      _drawState: () => {
      },
      _createEvents: function() {
        const element2 = this.element;
        element2.on("click", () => {
          this._drawState();
        });
      },
      check: function() {
        this.setCheckState(CHECKBOX_STATE.CHECKED);
      },
      uncheck: function() {
        this.setCheckState(CHECKBOX_STATE.UNCHECKED);
      },
      setCheckState: function(state2 = true) {
        this.elem.checked = state2;
        this._drawState();
        return this;
      },
      getCheckState: function(asString = false) {
        const state2 = this.elem.checked;
        if (!asString) {
          return state2;
        }
        switch (this.state) {
          case false:
            return "unchecked";
          case true:
            return "checked";
        }
      },
      toggle: function() {
        this.elem.checked = !this.elem.checked;
        this._drawState();
      },
      changeAttribute: (attr, newVal) => {
      },
      destroy: function() {
        const element2 = this.element;
        element2.off("click");
        element2.parent().remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/color-selector/color-selector.js
  ((Metro2, $7) => {
    "use strict";
    const supportedColorTypes = "hex, rgb, rgba, hsl, hsla, hsv, cmyk";
    let ColorSelectorDefaultConfig = {
      defaultSwatches: "#FFFFFF,#000000,#FFFB0D,#0532FF,#FF9300,#00F91A,#FF2700,#686868,#EE5464,#D27AEE,#5BA8C4,#E64AA9,#1ba1e2,#6a00ff,#bebebe,#f8f8f8",
      userColors: null,
      returnValueType: "hex",
      returnAsString: true,
      showValues: supportedColorTypes,
      showAsString: null,
      showUserColors: true,
      controller: null,
      addUserColorTitle: null,
      userColorsTitle: null,
      hslMode: "percent",
      showAlphaChannel: true,
      inputThreshold: 300,
      initColor: null,
      readonlyInput: false,
      clsSelector: "",
      clsSwatches: "",
      clsSwatch: "",
      clsValue: "",
      clsLabel: "",
      clsInput: "",
      clsUserColorButton: "",
      clsUserColors: "",
      clsUserColorsTitle: "",
      clsUserColor: "",
      onSelectColor: Metro2.noop,
      onColorSelectorCreate: Metro2.noop
    };
    Metro2.colorSelectorSetup = (options) => {
      ColorSelectorDefaultConfig = $7.extend({}, ColorSelectorDefaultConfig, options);
    };
    if (typeof globalThis.metroColorSelectorSetup !== "undefined") {
      Metro2.colorSelectorSetup(globalThis.metroColorSelectorSetup);
    }
    Metro2.Component("color-selector", {
      init: function(options, elem) {
        this._super(elem, options, ColorSelectorDefaultConfig, {
          // define instance vars here
          id: null,
          defaultSwatches: [],
          showValues: [],
          userColors: [],
          showAsString: [],
          hue: 0,
          saturation: 0,
          lightness: 1,
          alpha: 1,
          hsl: null,
          hsla: null,
          hsv: null,
          rgb: null,
          rgba: null,
          cmyk: null,
          hex: null,
          inputInterval: null,
          controller: null
        });
        return this;
      },
      _create: function() {
        const o2 = this.options;
        this.id = Hooks.useId(this.element);
        if (Metro2.utils.isValue(o2.defaultSwatches))
          this.defaultSwatches = o2.defaultSwatches.toArray(",").map((el) => el.toUpperCase());
        if (Metro2.utils.isValue(o2.showValues)) this.showValues = o2.showValues.toArray(",");
        if (Metro2.utils.isValue(o2.userColors))
          this.userColors = o2.userColors.toArray(",").map((el) => el.toUpperCase());
        if (Metro2.utils.isValue(o2.showAsString)) this.showAsString = o2.showAsString.toArray(",");
        this._createStructure();
        this._createEvents();
        this._setColorValues();
        this._fireEvent("color-selector-create");
      },
      _createStructure: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const strings = this.strings;
        let row;
        let map;
        let value;
        let inputs;
        let colorBlock;
        element2.addClass("color-selector").addClass(o2.clsSelector);
        const colorBox = $7("<div>").addClass("color-box");
        element2.append(colorBox);
        row = $7("<div>").addClass("row");
        colorBox.append(row);
        const swatches = $7("<div>").addClass("default-swatches").addClass(o2.clsSwatches);
        row.append(swatches);
        $7.each(this.defaultSwatches, function() {
          swatches.append(
            $7("<button>").attr("data-color", this).attr("type", "button").addClass("swatch").addClass(o2.clsSwatch).css("background-color", this)
          );
        });
        row = $7("<div>").addClass("row");
        colorBox.append(row);
        map = $7("<div>").addClass("color-map");
        row.append(map);
        const shadeCursor = $7("<button>").attr("type", "button").addClass("cursor color-cursor dragging");
        map.append(shadeCursor);
        const shadeCanvas = $7("<canvas>").addClass("color-canvas");
        map.append(shadeCanvas);
        map = $7("<div>").addClass("hue-map");
        row.append(map);
        const hueCursor = $7("<button>").attr("type", "button").addClass("cursor hue-cursor dragging");
        map.append(hueCursor);
        const hueCanvas = $7("<canvas>").addClass("hue-canvas");
        map.append(hueCanvas);
        map = $7("<div>").addClass("alpha-map");
        row.append(map);
        const alphaCursor = $7("<button>").attr("type", "button").addClass("cursor alpha-cursor dragging");
        map.append(alphaCursor);
        const alphaCanvas = $7("<canvas>").addClass("alpha-canvas");
        map.append(alphaCanvas);
        row = $7("<div>").addClass("row color-values-block");
        colorBox.append(row);
        value = $7("<div>").addClass("color-value-hex");
        row.append(value);
        value.append(
          $7("<input type='radio' name='returnType' value='hex' checked>").addClass("check-color-value-hex")
        );
        colorBlock = $7("<div>").addClass("color-block as-string color-hex");
        value.append(colorBlock);
        colorBlock.append($7("<input type='text' data-prepend='HEX:'>").addClass("input-small value-hex"));
        value = $7("<div>").addClass("color-value-rgb");
        row.append(value);
        value.append($7("<input type='radio' name='returnType' value='rgb'>").addClass("check-color-value-rgb"));
        colorBlock = $7("<div>").addClass("color-block color-rgb");
        value.append(colorBlock);
        colorBlock.append($7("<input type='text' data-prepend='R:'>").addClass("input-small value-r"));
        colorBlock.append($7("<input type='text' data-prepend='G:'>").addClass("input-small value-g"));
        colorBlock.append($7("<input type='text' data-prepend='B:'>").addClass("input-small value-b"));
        colorBlock = $7("<div>").addClass("color-block as-string color-rgb");
        value.append(colorBlock);
        colorBlock.append($7("<input type='text' data-prepend='RGB:'>").addClass("input-small value-rgb"));
        if (this.showAsString.indexOf("rgb") > -1) {
          value.find(".value-r,.value-g,.value-b").parent().hide();
        } else {
          value.find(".value-rgb").parent().hide();
        }
        value = $7("<div>").addClass("color-value-rgba");
        row.append(value);
        value.append($7("<input type='radio' name='returnType' value='rgba'>").addClass("check-color-value-rgba"));
        colorBlock = $7("<div>").addClass("color-block color-rgba");
        value.append(colorBlock);
        colorBlock.append($7("<input type='text' data-prepend='R:'>").addClass("input-small value-r"));
        colorBlock.append($7("<input type='text' data-prepend='G:'>").addClass("input-small value-g"));
        colorBlock.append($7("<input type='text' data-prepend='B:'>").addClass("input-small value-b"));
        colorBlock.append($7("<input type='text' data-prepend='A:'>").addClass("input-small value-a"));
        colorBlock = $7("<div>").addClass("color-block as-string color-rgba");
        value.append(colorBlock);
        colorBlock.append($7("<input type='text' data-prepend='RGBA:'>").addClass("input-small value-rgba"));
        if (this.showAsString.indexOf("rgba") > -1) {
          value.find(".value-r,.value-g,.value-b,.value-a").parent().hide();
        } else {
          value.find(".value-rgba").parent().hide();
        }
        value = $7("<div>").addClass("color-value-hsl");
        row.append(value);
        value.append($7("<input type='radio' name='returnType' value='hsl'>").addClass("check-color-value-hsl"));
        colorBlock = $7("<div>").addClass("color-block color-hsl");
        value.append(colorBlock);
        colorBlock.append($7("<input type='text' data-prepend='H:'>").addClass("input-small value-h"));
        colorBlock.append($7("<input type='text' data-prepend='S:'>").addClass("input-small value-s"));
        colorBlock.append($7("<input type='text' data-prepend='L:'>").addClass("input-small value-l"));
        colorBlock = $7("<div>").addClass("color-block as-string color-hsl");
        value.append(colorBlock);
        colorBlock.append($7("<input type='text' data-prepend='HSL:'>").addClass("input-small value-hsl"));
        if (this.showAsString.indexOf("hsl") > -1) {
          value.find(".value-h,.value-s,.value-l").parent().hide();
        } else {
          value.find(".value-hsl").parent().hide();
        }
        value = $7("<div>").addClass("color-value-hsla");
        row.append(value);
        value.append($7("<input type='radio' name='returnType' value='hsla'>").addClass("check-color-value-hsla"));
        colorBlock = $7("<div>").addClass("color-block color-hsla");
        value.append(colorBlock);
        colorBlock.append($7("<input type='text' data-prepend='H:'>").addClass("input-small value-h"));
        colorBlock.append($7("<input type='text' data-prepend='S:'>").addClass("input-small value-s"));
        colorBlock.append($7("<input type='text' data-prepend='L:'>").addClass("input-small value-l"));
        colorBlock.append($7("<input type='text' data-prepend='A:'>").addClass("input-small value-a"));
        colorBlock = $7("<div>").addClass("color-block as-string color-hsla");
        value.append(colorBlock);
        colorBlock.append($7("<input type='text' data-prepend='HSLA:'>").addClass("input-small value-hsla"));
        if (this.showAsString.indexOf("hsla") > -1) {
          value.find(".value-h,.value-s,.value-l,.value-a").parent().hide();
        } else {
          value.find(".value-hsla").parent().hide();
        }
        value = $7("<div>").addClass("color-value-hsv");
        row.append(value);
        value.append($7("<input type='radio' name='returnType' value='hsv'>").addClass("check-color-value-hsl"));
        colorBlock = $7("<div>").addClass("color-block color-hsv");
        value.append(colorBlock);
        colorBlock.append($7("<input type='text' data-prepend='H:'>").addClass("input-small value-h"));
        colorBlock.append($7("<input type='text' data-prepend='S:'>").addClass("input-small value-s"));
        colorBlock.append($7("<input type='text' data-prepend='V:'>").addClass("input-small value-v"));
        colorBlock = $7("<div>").addClass("color-block as-string color-hsv");
        value.append(colorBlock);
        colorBlock.append($7("<input type='text' data-prepend='HSV:'>").addClass("input-small value-hsv"));
        if (this.showAsString.indexOf("hsv") > -1) {
          value.find(".value-h,.value-s,.value-v").parent().hide();
        } else {
          value.find(".value-hsv").parent().hide();
        }
        value = $7("<div>").addClass("color-value-cmyk");
        row.append(value);
        value.append($7("<input type='radio' name='returnType' value='cmyk'>").addClass("check-color-value-cmyk"));
        colorBlock = $7("<div>").addClass("color-block color-cmyk");
        value.append(colorBlock);
        colorBlock.append($7("<input type='text' data-prepend='C:'>").addClass("input-small value-c"));
        colorBlock.append($7("<input type='text' data-prepend='M:'>").addClass("input-small value-m"));
        colorBlock.append($7("<input type='text' data-prepend='Y:'>").addClass("input-small value-y"));
        colorBlock.append($7("<input type='text' data-prepend='K:'>").addClass("input-small value-k"));
        colorBlock = $7("<div>").addClass("color-block as-string color-cmyk");
        value.append(colorBlock);
        colorBlock.append($7("<input type='text' data-prepend='CMYK:'>").addClass("input-small value-cmyk"));
        if (this.showAsString.indexOf("cmyk") > -1) {
          value.find(".value-s,.value-m,.value-y,.value-k").parent().hide();
        } else {
          value.find(".value-cmyk").parent().hide();
        }
        row = $7("<div>").addClass("row user-colors-css-container");
        colorBox.append(row);
        row.append(
          $7("<div>").addClass("user-colors-title").addClass(o2.clsUserColorsTitle).html(o2.userColorsTitle || strings.label_user_colors)
        );
        row.append($7("<div>").addClass("user-colors").addClass(o2.clsUserColors));
        const userColorsActions = $7("<div>").addClass("user-colors-actions");
        row.append(userColorsActions);
        userColorsActions.append(
          $7("<button>").addClass("button add-button").addClass(o2.clsUserColorButton).html(
            `<span class='user-swatch'></span><span>${o2.addUserColorTitle || strings.label_add_user_color}</span>`
          )
        );
        inputs = colorBox.find("input[type=text]");
        Metro2.makePlugin(inputs, "input", {
          clearButton: false,
          clsPrepend: o2.clsLabel,
          clsComponent: o2.clsInput
        });
        inputs.addClass(o2.clsValue);
        if (o2.readonlyInput) {
          inputs.attr("readonly", true);
        }
        const radios = colorBox.find("input[type=radio]").each(function() {
          $7(this).attr("name", `${that.id}-returnType`);
        });
        radios.each(function() {
          if ($7(this).val() === o2.returnValueType) {
            this.checked = true;
          }
        });
        Metro2.makePlugin(radios, "radio");
        $7.each(supportedColorTypes.toArray(","), function() {
          if (that.showValues.indexOf(this) === -1) element2.find(`.color-value-${this}`).hide();
        });
        if (!o2.showUserColors) {
          element2.find(".user-colors-css-container").hide();
        }
        if (!o2.showAlphaChannel) {
          element2.addClass("no-alpha-channel");
          $7.each(["rgba", "hsla"], function() {
            element2.find(`.color-value-${this}`).hide();
          });
        }
        this._fillUserColors();
        this.hueCanvas = hueCanvas;
        this.hueCursor = hueCursor;
        this.shadeCanvas = shadeCanvas;
        this.shadeCursor = shadeCursor;
        this.alphaCanvas = alphaCanvas;
        this.alphaCursor = alphaCursor;
        this._createShadeCanvas();
        this._createHueCanvas();
        this._createAlphaCanvas();
        this._setColorValues();
        this._updateCursorsColor();
        if (o2.initColor && Farbe.Routines.isColor(o2.initColor)) {
          this._colorToPos(typeof o2.initColor === "string" ? Farbe.Routines.parse(o2.initColor) : o2.initColor);
        }
        this.controller = o2.controller ? $7(o2.controller) : null;
      },
      _createShadeCanvas: function(color = "#f00") {
        const canvas = this.shadeCanvas[0];
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        const whiteGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
        whiteGradient.addColorStop(0, "#fff");
        whiteGradient.addColorStop(1, "transparent");
        ctx.fillStyle = whiteGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        const blackGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        blackGradient.addColorStop(0, "transparent");
        blackGradient.addColorStop(1, "#000");
        ctx.fillStyle = blackGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      },
      _createHueCanvas: function() {
        const canvas = this.hueCanvas[0];
        const ctx = canvas.getContext("2d");
        const hueGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        hueGradient.addColorStop(0, "hsl(0,100%,50%)");
        hueGradient.addColorStop(0.17, "hsl(298.8, 100%, 50%)");
        hueGradient.addColorStop(0.33, "hsl(241.2, 100%, 50%)");
        hueGradient.addColorStop(0.5, "hsl(180, 100%, 50%)");
        hueGradient.addColorStop(0.67, "hsl(118.8, 100%, 50%)");
        hueGradient.addColorStop(0.83, "hsl(61.2,100%,50%)");
        hueGradient.addColorStop(1, "hsl(360,100%,50%)");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = hueGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      },
      _createAlphaCanvas: function() {
        const canvas = this.alphaCanvas[0];
        const ctx = canvas.getContext("2d");
        const alphaGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        const startColor = new Farbe.Primitives.HSLA(this.hue, 1, 0.5, 1).toString();
        const endColor = "rgba(0,0,0,0)";
        alphaGradient.addColorStop(0, startColor);
        alphaGradient.addColorStop(1, endColor);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = alphaGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      },
      _updateHueCursor: function(y4) {
        this.hueCursor.css({
          top: y4
        });
      },
      _updateAlphaCursor: function(y4) {
        this.alphaCursor.css({
          top: y4
        });
      },
      _getHueColor: function(pageY) {
        const canvas = this.hueCanvas;
        const offset = canvas.offset();
        const height = canvas.height();
        let y4;
        let hue;
        y4 = pageY - offset.top;
        if (y4 > height) y4 = height;
        if (y4 < 0) y4 = 0;
        const percent = y4 / height;
        hue = 360 - 360 * percent;
        if (hue === 360) hue = 0;
        const color = `hsl(${hue}, 100%, 50%)`;
        this.hue = hue;
        this._createShadeCanvas(color);
        this._createAlphaCanvas();
        this._updateHueCursor(y4);
        this._updateCursorsColor();
        this._setColorValues();
      },
      _getAlphaValue: function(pageY) {
        const canvas = this.alphaCanvas;
        const offset = canvas.offset();
        const height = canvas.height();
        let y4;
        y4 = pageY - offset.top;
        if (y4 > height) y4 = height;
        if (y4 < 0) y4 = 0;
        const percent = 1 - y4 / height;
        this.alpha = percent.toFixed(2);
        this._updateAlphaCursor(y4);
        this._updateCursorsColor();
        this._setColorValues();
      },
      _getShadeColor: function(pageX, pageY) {
        const canvas = this.shadeCanvas;
        const offset = canvas.offset();
        const width = canvas.width();
        const height = canvas.height();
        let x5 = pageX - offset.left;
        let y4 = pageY - offset.top;
        if (x5 > width) x5 = width;
        if (x5 < 0) x5 = 0;
        if (y4 > height) y4 = height;
        if (y4 < 0) y4 = 0.1;
        const xRatio = x5 / width * 100;
        const yRatio = y4 / height * 100;
        const hsvValue = 1 - yRatio / 100;
        const hsvSaturation = xRatio / 100;
        let lightness = hsvValue / 2 * (2 - hsvSaturation);
        let saturation = hsvValue * hsvSaturation / (1 - Math.abs(2 * lightness - 1));
        if (isNaN(lightness)) {
          lightness = 0;
        }
        if (isNaN(saturation)) {
          saturation = 0;
        }
        this.lightness = lightness;
        this.saturation = saturation;
        this._updateShadeCursor(x5, y4);
        this._updateCursorsColor();
        this._setColorValues();
      },
      _updateCursorsColor: function() {
        this.shadeCursor.css({
          backgroundColor: Farbe.Routines.toHEX(
            new Farbe.Primitives.HSL(this.hue, this.saturation, this.lightness)
          )
        });
        this.hueCursor.css({
          backgroundColor: Farbe.Routines.toHEX(new Farbe.Primitives.HSL(this.hue, 1, 0.5))
        });
        this.alphaCursor.css({
          backgroundColor: Farbe.Routines.toRGBA(
            new Farbe.Primitives.HSL(this.hue, 1, 0.5),
            this.alpha
          ).toString()
        });
      },
      _updateShadeCursor: function(x5, y4) {
        this.shadeCursor.css({
          top: y4,
          left: x5
        });
      },
      _colorToPos: function(color) {
        const shadeCanvasRect = this.shadeCanvas[0].getBoundingClientRect();
        const hueCanvasRect = this.hueCanvas[0].getBoundingClientRect();
        const alphaCanvasRect = this.alphaCanvas[0].getBoundingClientRect();
        const hsl = Farbe.Routines.toHSL(color);
        const hsla = Farbe.Routines.toHSLA(color);
        const hsv = Farbe.Routines.toHSV(color);
        const x5 = shadeCanvasRect.width * hsv.s;
        const y4 = shadeCanvasRect.height * (1 - hsv.v);
        const hueY = hueCanvasRect.height - hsl.h / 360 * hueCanvasRect.height;
        const alphaY = (1 - hsla.a) * alphaCanvasRect.height;
        this.hue = hsl.h;
        this.saturation = hsl.s;
        this.lightness = hsl.l;
        this.alpha = hsla.a;
        this._updateHueCursor(hueY);
        this._updateShadeCursor(x5, y4);
        this._updateAlphaCursor(alphaY);
        this._updateCursorsColor();
        this._createShadeCanvas(`hsl(${this.hue}, 100%, 50%)`);
        this._createAlphaCanvas();
        this._setColorValues();
      },
      _setColorValues: function() {
        const element2 = this.element;
        const o2 = this.options;
        const hsl = new Farbe.Primitives.HSL(this.hue, this.saturation, this.lightness);
        const hsla = new Farbe.Primitives.HSLA(this.hue, this.saturation, this.lightness, this.alpha);
        const rgb = Farbe.Routines.toRGB(hsl);
        const rgba = Farbe.Routines.toRGBA(rgb, this.alpha);
        const hsv = Farbe.Routines.toHSV(hsl);
        const cmyk = Farbe.Routines.toCMYK(hsl);
        const hex = Farbe.Routines.toHEX(hsl);
        const controller = this.controller;
        const percent = o2.hslMode === "percent";
        this.hsl = hsl;
        this.hsla = hsla;
        this.hsv = hsv;
        this.rgb = rgb;
        this.rgba = rgba;
        this.hex = hex;
        this.cmyk = cmyk;
        element2.find(".color-value-hex .value-hex input").val(hex);
        element2.find(".color-value-rgb .value-r input").val(rgb.r);
        element2.find(".color-value-rgb .value-g input").val(rgb.g);
        element2.find(".color-value-rgb .value-b input").val(rgb.b);
        element2.find(".color-value-rgb .value-rgb input").val(rgb.toString());
        element2.find(".color-value-rgba .value-r input").val(rgba.r);
        element2.find(".color-value-rgba .value-g input").val(rgba.g);
        element2.find(".color-value-rgba .value-b input").val(rgba.b);
        element2.find(".color-value-rgba .value-a input").val(rgba.a);
        element2.find(".color-value-rgba .value-rgba input").val(rgba.toString());
        element2.find(".color-value-hsl .value-h input").val(hsl.h.toFixed(0));
        element2.find(".color-value-hsl .value-s input").val(percent ? `${Math.round(hsl.s * 100)}%` : hsl.s.toFixed(4));
        element2.find(".color-value-hsl .value-l input").val(percent ? `${Math.round(hsl.l * 100)}%` : hsl.l.toFixed(4));
        element2.find(".color-value-hsl .value-hsl input").val(hsl.toString());
        element2.find(".color-value-hsla .value-h input").val(hsla.h.toFixed(0));
        element2.find(".color-value-hsla .value-s input").val(percent ? `${Math.round(hsla.s * 100)}%` : hsl.s.toFixed(4));
        element2.find(".color-value-hsla .value-l input").val(percent ? `${Math.round(hsla.l * 100)}%` : hsl.l.toFixed(4));
        element2.find(".color-value-hsla .value-a input").val(hsla.a);
        element2.find(".color-value-hsla .value-hsla input").val(hsla.toString());
        element2.find(".color-value-hsv .value-h input").val(hsv.h.toFixed(0));
        element2.find(".color-value-hsv .value-s input").val(percent ? `${Math.round(hsv.s * 100)}%` : hsv.s.toFixed(4));
        element2.find(".color-value-hsv .value-v input").val(percent ? `${Math.round(hsv.v * 100)}%` : hsv.v.toFixed(4));
        element2.find(".color-value-hsv .value-hsv input").val(hsv.toString());
        element2.find(".color-value-cmyk .value-c input").val(cmyk.c.toFixed(0));
        element2.find(".color-value-cmyk .value-m input").val(cmyk.m.toFixed(0));
        element2.find(".color-value-cmyk .value-y input").val(cmyk.y.toFixed(0));
        element2.find(".color-value-cmyk .value-k input").val(cmyk.k.toFixed(0));
        element2.find(".color-value-cmyk .value-cmyk input").val(cmyk.toString());
        element2.find(".user-colors-actions .user-swatch").css({
          backgroundColor: hex
        });
        const value = this.getVal();
        if (controller?.length) {
          controller.val(value);
        }
        this._fireEvent("select-color", {
          color: value,
          primitive: {
            hsl: this.hsl,
            hsla: this.hsla,
            rgb: this.rgb,
            rgba: this.rgba,
            hsv: this.hsv,
            cmyk: this.cmyk,
            hex: this.hex
          }
        });
      },
      _clearInputInterval: function() {
        clearInterval(this.inputInterval);
        this.inputInterval = false;
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const hueMap = element2.find(".hue-map");
        const alphaMap = element2.find(".alpha-map");
        const shadeMap = element2.find(".color-map");
        const controller = this.controller;
        const colorValues = element2.find(".color-values-block input[type=text]");
        let onColorValuesChange = (e2) => {
          const input = $7(e2.target);
          const colorGroup = input.closest(".color-block");
          let colorType;
          let color;
          let parts;
          if (colorGroup.hasClass("color-hex")) {
            colorType = "hex";
          } else if (colorGroup.hasClass("color-rgb")) {
            colorType = "rgb";
          } else if (colorGroup.hasClass("color-rgba")) {
            colorType = "rgba";
          } else if (colorGroup.hasClass("color-hsl")) {
            colorType = "hsl";
          } else if (colorGroup.hasClass("color-hsla")) {
            colorType = "hsla";
          } else if (colorGroup.hasClass("color-hsv")) {
            colorType = "hsv";
          } else if (colorGroup.hasClass("color-cmyk")) {
            colorType = "cmyk";
          }
          if (colorGroup.hasClass("as-string")) {
            color = input.val();
          } else {
            parts = [];
            $7.each(colorGroup.find("input"), function() {
              parts.push(this.value);
            });
            color = `${colorType}(${parts.join(", ")})`;
          }
          if (color && Farbe.Routines.isColor(color)) {
            that.val(color);
          }
        };
        onColorValuesChange = Hooks.useDebounce(onColorValuesChange, o2.inputThreshold);
        colorValues.on(Metro2.events.inputchange, onColorValuesChange);
        if (controller?.length) {
          const onControllerChange = Hooks.useDebounce(() => {
            const val = controller.val();
            if (val && Farbe.Routines.isColor(val)) {
              that.val(val);
            }
          }, o2.inputThreshold);
          controller.on(Metro2.events.inputchange, onControllerChange);
        }
        alphaMap.on(
          Metro2.events.startAll,
          (e2) => {
            if (["hsla", "rgba"].includes(o2.returnValueType) === false) {
            }
            that._getAlphaValue(Metro2.utils.pageXY(e2).y);
            $7(document).on(
              Metro2.events.moveAll,
              (e3) => {
                e3.preventDefault();
                that._getAlphaValue(Metro2.utils.pageXY(e3).y);
              },
              { ns: that.id }
            );
            $7(document).on(
              Metro2.events.stopAll,
              () => {
                $7(document).off(Metro2.events.moveAll, {
                  ns: that.id
                });
                $7(document).off(Metro2.events.stopAll, {
                  ns: that.id
                });
              },
              { ns: that.id }
            );
          },
          { passive: true }
        );
        hueMap.on(
          Metro2.events.startAll,
          (e2) => {
            that._getHueColor(Metro2.utils.pageXY(e2).y);
            $7(document).on(
              Metro2.events.moveAll,
              (e3) => {
                e3.preventDefault();
                that._getHueColor(Metro2.utils.pageXY(e3).y);
              },
              { ns: that.id, passive: false }
            );
            $7(document).on(
              Metro2.events.stopAll,
              () => {
                $7(document).off(Metro2.events.moveAll, {
                  ns: that.id
                });
                $7(document).off(Metro2.events.stopAll, {
                  ns: that.id
                });
              },
              { ns: that.id }
            );
          },
          { passive: true }
        );
        shadeMap.on(
          Metro2.events.startAll,
          (e2) => {
            that._getShadeColor(Metro2.utils.pageXY(e2).x, Metro2.utils.pageXY(e2).y);
            $7(document).on(
              Metro2.events.moveAll,
              (e3) => {
                e3.preventDefault();
                that._getShadeColor(Metro2.utils.pageXY(e3).x, Metro2.utils.pageXY(e3).y);
              },
              { ns: that.id, passive: false }
            );
            $7(document).on(
              Metro2.events.stopAll,
              () => {
                $7(document).off(Metro2.events.moveAll, {
                  ns: that.id
                });
                $7(document).off(Metro2.events.stopAll, {
                  ns: that.id
                });
              },
              { ns: that.id }
            );
          },
          { passive: true }
        );
        element2.on("click", ".swatch", function() {
          that._colorToPos($7(this).attr("data-color"));
        });
        element2.on("click", ".add-button", () => {
          const color = Farbe.Routines.toHEX(
            new Farbe.Primitives.HSL(that.hue, that.saturation, that.lightness)
          ).toUpperCase();
          if (that.userColors.includes(color)) {
            return;
          }
          that.userColors.push(color);
          element2.find(".user-colors").append(
            $7("<button>").attr("data-color", color).attr("type", "button").addClass("swatch user-swatch").css({
              backgroundColor: color
            })
          );
        });
        element2.find("input[type=radio]").on("click", function() {
          o2.returnValueType = $7(this).val();
          that._setColorValues();
        });
      },
      getVal: function() {
        const o2 = this.options;
        let res;
        switch (o2.returnValueType.toLowerCase()) {
          case "rgb":
            res = this.rgb;
            break;
          case "rgba":
            res = this.rgba;
            break;
          case "hsl":
            res = this.hsl;
            break;
          case "hsla":
            res = this.hsla;
            break;
          case "hsv":
            res = this.hsv;
            break;
          case "cmyk":
            res = this.cmyk;
            break;
          default:
            res = this.hex;
        }
        return o2.returnAsString ? res.toString() : res;
      },
      val: function(v5) {
        if (typeof v5 === "undefined") {
          return this.getVal();
        }
        const color = Farbe.Routines.parse(v5);
        this._colorToPos(color);
      },
      user: function(v5) {
        if (!Metro2.utils.isValue(v5)) {
          return this.userColors;
        }
        if (!Array.isArray(v5) && typeof v5 !== "string") {
          return;
        }
        if (typeof v5 === "string") {
          this.userColors = v5.toArray(",").map((el) => el.toUpperCase());
        } else {
          this.userColors = v5.map((el) => el.toUpperCase());
        }
        this._fillUserColors();
      },
      _fillUserColors: function() {
        const colors = this.element.find(".user-colors-css").clear();
        $7.each(this.userColors, function() {
          colors.append(
            $7("<button>").attr("data-color", this).attr("type", "button").addClass("swatch user-swatch").css({
              backgroundColor: this
            })
          );
        });
      },
      changeAttribute: function(attr, newValue) {
        const o2 = this.options;
        if (attr === "data-return-value-type") {
          o2.returnValueType = newValue;
        }
        if (attr === "data-return-as-string") {
          o2.returnValueType = Metro2.utils.bool(newValue);
        }
      },
      destroy: function() {
        this.element.remove();
      }
    });
    Metro2.defaults.ColorSelector = ColorSelectorDefaultConfig;
  })(Metro, Dom);

  // ../metroui-lib/source/components/color-picker/color-picker.js
  ((Metro2, $7) => {
    "use strict";
    let ColorPickerDefaultConfig = {
      defaultSwatches: "#FFFFFF,#000000,#FFFB0D,#0532FF,#FF9300,#00F91A,#FF2700,#686868,#EE5464,#D27AEE,#5BA8C4,#E64AA9,#1ba1e2,#6a00ff,#bebebe,#f8f8f8",
      duration: 100,
      prepend: "",
      append: "",
      label: "",
      clearButton: false,
      clearButtonIcon: "\u2716",
      pickerButtonIcon: "\u{1F3A8}",
      defaultValue: "rgba(0, 0, 0, 0)",
      openMode: "auto",
      resultType: "hex",
      inputThreshold: 500,
      onColorSelected: Metro2.noop,
      onColorPickerCreate: Metro2.noop
    };
    Metro2.colorPickerSetup = (options) => {
      ColorPickerDefaultConfig = $7.extend({}, ColorPickerDefaultConfig, options);
    };
    if (typeof globalThis.metroColorPickerSetup !== "undefined") {
      Metro2.colorPickerSetup(globalThis.metroColorPickerSetup);
    }
    Metro2.Component("color-picker", {
      init: function(options, elem) {
        this._super(
          elem,
          options,
          $7.extend(
            {},
            Metro2.defaults.ColorSelector,
            {
              showUserColors: false,
              showValues: ""
            },
            ColorPickerDefaultConfig
          ),
          {
            value: null,
            picker: null,
            colorSelector: null,
            colorSelectorBox: null,
            colorExample: null,
            inputInterval: null,
            isOpen: false
          }
        );
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        const current = element2.val();
        if (!Metro2.pluginExists("color-selector")) {
          throw new Error("Color selector component required!");
        }
        this.value = Farbe.Routines.isColor(current) ? current : Farbe.Routines.isColor(o2.defaultValue) ? o2.defaultValue : "rgba(0,0,0,0)";
        this._createStructure();
        this._createEvents();
        this._fireEvent("color-picker-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const picker = element2.wrap($7("<div>").addClass("color-picker").addClass(element2[0].className));
        let buttons;
        const colorExample = $7("<div>").addClass("color-example-box").insertBefore(element2);
        buttons = $7("<div>").addClass("buttons").appendTo(picker);
        buttons.append(
          $7("<button>").addClass("button color-picker-button").attr("tabindex", -1).attr("type", "button").html(o2.pickerButtonIcon)
        );
        if (o2.clearButton === true && !element2[0].readOnly) {
          buttons.append(
            $7("<button>").addClass("button input-clear-button").addClass(o2.clsClearButton).attr("tabindex", -1).attr("type", "button").html(o2.clearButtonIcon)
          );
        }
        if (Metro2.utils.isValue(o2.prepend)) {
          picker.prepend($7("<div>").addClass("prepend").addClass(o2.clsPrepend).html(o2.prepend));
        }
        if (Metro2.utils.isValue(o2.append)) {
          picker.append($7("<div>").html(o2.append).addClass("append").addClass(o2.clsAppend));
        }
        const colorSelectorBox = $7("<div>").addClass("color-selector-box").appendTo(picker);
        const colorSelector = $7("<div>").appendTo(colorSelectorBox);
        this.picker = picker;
        this.colorExample = colorExample;
        this.colorSelector = colorSelector;
        this.colorSelectorBox = colorSelectorBox;
        Metro2.makePlugin(colorSelector, "color-selector", {
          defaultSwatches: o2.defaultSwatches,
          returnValueType: o2.resultType,
          returnAsString: true,
          showUserColors: false,
          showValues: "",
          controller: element2,
          showAlphaChannel: true,
          inputThreshold: o2.inputThreshold,
          initColor: this.value,
          readonlyInput: o2.readonlyInput,
          onSelectColor: (color) => {
            this.colorExample.css({
              backgroundColor: color
            });
          },
          onColorSelectorCreate: o2.onColorSelectorCreate
        });
        Metro2.makePlugin(colorSelectorBox, "dropdown", {
          dropFilter: ".color-picker",
          duration: o2.duration,
          toggleElement: [picker],
          checkDropUp: true,
          onDrop: () => {
            Metro2.getPlugin(colorSelector, "color-selector").val(this.value);
          }
        });
        element2[0].className = "";
        if (o2.label) {
          const label = $7("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(picker);
          if (element2.attr("id")) {
            label.attr("for", element2.attr("id"));
          } else {
            const id = Hooks.useId(element2[0]);
            label.attr("for", id);
            element2.attr("id", id);
          }
          if (element2.attr("dir") === "rtl") {
            label.addClass("rtl");
          }
        }
        this._setColor();
      },
      _clearInputInterval: function() {
        clearInterval(this.inputInterval);
        this.inputInterval = false;
      },
      _setColor: function() {
        const colorExample = this.colorExample;
        let color = this.value;
        if (this.value.indexOf("cmyk") !== -1 || this.value.indexOf("hsv") !== -1) {
          color = Farbe.Routines.toHEX(this.value);
        }
        colorExample.css({
          backgroundColor: color
        });
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const picker = this.picker;
        const colorSelector = this.colorSelector;
        const colorSelectorBox = this.colorSelector;
        picker.on(Metro2.events.click, ".input-clear-button", (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
          element2.val(o2.defaultValue).trigger("change");
          Metro2.getPlugin(colorSelector, "color-selector").val(o2.defaultValue);
        });
        element2.on(Metro2.events.inputchange, function() {
          that.value = this.value;
          that._setColor();
        });
        colorSelectorBox.on(Metro2.events.click, (e2) => {
          e2.stopPropagation();
        });
      },
      val: function(v5) {
        if (typeof v5 === "undefined") {
          return this.value;
        }
        if (!Farbe.Routines.isColor(v5)) {
          return;
        }
        this.value = v5;
        this.element.val(v5).trigger("change");
        this._setColor();
      },
      // changeAttribute: function(attr, newValue){
      // },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        const parent2 = element2.parent();
        if (o2.label) {
          parent2.prev("label").remove();
        }
        parent2.remove();
      }
    });
    $7(document).on(Metro2.events.click, () => {
      $7(".color-picker").removeClass("open");
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/context-menu/context-menu.js
  ((Metro2, $7) => {
    Metro2.contextMenu = (items = [], element2 = document) => {
      function buildMenu(items2) {
        const menu = $7("<ul>").addClass("d-menu context-menu").css("display", "none");
        for (const item of items2) {
          if (item.type === "divider") {
            menu.append($7("<li>").addClass("divider"));
          } else {
            const li = $7("<li>").appendTo(menu);
            const an = $7("<a>").appendTo(li);
            if (item.icon) {
              an.append($7("<span>").addClass("icon").html(item.icon));
            }
            an.append($7("<span>").addClass("caption").html(item.text));
            an.href(item.href || "#");
            if (item.onclick) {
              an.on("click", (e2) => {
                Metro2.utils.exec(item.onclick, [e2, item, element2]);
              });
            }
            if (item.attributes) {
              for (const [key, value] of Object.entries(item.attributes)) {
                an.attr(key, value);
              }
            }
            if (item.disabled) {
              an.prop("disabled", true);
            }
            if (item.items) {
              const sub = buildMenu(item.items);
              li.children("a").addClass("dropdown-toggle");
              li.append(sub);
              Metro2.makePlugin(sub, "dropdown", {});
            }
          }
        }
        return menu[0];
      }
      if (typeof element2 === "string") {
        element2 = document.querySelector(element2);
      }
      element2.context_menu = buildMenu(items);
      if (element2.nodeType === 1) {
        element2.append(element2.context_menu);
      } else {
        $7("body").append(element2.context_menu);
      }
      element2.oncontextmenu = function(e2) {
        e2.preventDefault();
        e2.stopPropagation();
        $7(".context-menu").hide();
        $7(this.context_menu).data("context-element", this);
        this.context_menu.style.position = `fixed`;
        this.context_menu.style.left = `${e2.pageX}px`;
        this.context_menu.style.top = `${e2.pageY}px`;
        this.context_menu.style.display = "block";
      };
    };
    $7(document).on("click", () => {
      $7(".context-menu").hide();
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/cookie/cookie.js
  ((Metro2, $7) => {
    "use strict";
    let CookieDefaultConfig = {
      path: "/",
      expires: null,
      maxAge: null,
      domain: null,
      secure: false,
      samesite: null
    };
    Metro2.cookieSetup = (options) => {
      CookieDefaultConfig = $7.extend({}, CookieDefaultConfig, options);
    };
    if (typeof globalThis.metroCookieSetup !== "undefined") {
      Metro2.cookieSetup(globalThis.metroCookieSetup);
    }
    Metro2.cookie = {
      getCookies: () => {
        const a2 = document.cookie.toArray(";");
        const o2 = {};
        $7.each(a2, function() {
          const i3 = this.split("=");
          o2[i3[0]] = i3[1];
        });
        return o2;
      },
      getCookie: (name2) => {
        const cookieName = `${encodeURIComponent(name2)}=`;
        const cookies = document.cookie.toArray(";");
        let i3;
        let cookie;
        for (i3 = 0; i3 < cookies.length; i3++) {
          cookie = cookies[i3];
          while (cookie.charAt(0) === " ") {
            cookie = cookie.substring(1, cookie.length);
          }
          if (cookie.indexOf(cookieName) === 0) {
            return decodeURIComponent(cookie.substring(cookieName.length, cookie.length));
          }
        }
        return null;
      },
      setCookie: (name2, value, options) => {
        let date;
        const cookieName = encodeURIComponent(name2);
        const cookieValue = encodeURIComponent(value);
        let opt2;
        const a2 = [];
        if (options && typeof options !== "object") {
          date = /* @__PURE__ */ new Date();
          date.setTime(date.getTime() + Number.parseInt(options));
          opt2 = $7.extend({}, CookieDefaultConfig, {
            expires: date.toUTCString()
          });
        } else {
          opt2 = $7.extend({}, CookieDefaultConfig, options);
        }
        $7.each(opt2, (key, val) => {
          if (key !== "secure" && val) {
            a2.push(`${Str.dashedName(key)}=${val}`);
          }
          if (key === "secure" && val === true) {
            a2.push("secure");
          }
        });
        document.cookie = `${cookieName}=${cookieValue}; ${a2.join("; ")}`;
      },
      delCookie: function(name2) {
        this.setCookie(name2, false, {
          maxAge: -1
        });
      }
    };
  })(Metro, Dom);

  // ../metroui-lib/source/components/cookie-disclaimer/cookie-disclaimer.js
  ((Metro2, $7) => {
    "use strict";
    const cookieDisclaimerDefaults = {
      name: "cookies_accepted",
      templateUrl: null,
      title: "",
      message: "",
      duration: "30days",
      clsContainer: "",
      clsMessage: "",
      clsButtons: "",
      clsAcceptButton: "",
      clsCancelButton: "",
      onAccept: Metro2.noop,
      onDecline: Metro2.noop
    };
    Metro2.cookieDisclaimer = {
      init: function(options) {
        const cookie = Metro2.cookie;
        this.options = $7.extend({}, cookieDisclaimerDefaults, options);
        this.disclaimer = $7("<div>");
        if (cookie.getCookie(this.options.name)) {
          return;
        }
        this.locale = $7("html").attr("lang") || "en";
        this.strings = $7.extend({}, Metro2.locales.en, Metro2.locales[this.locale]);
        if (this.options.templateUrl) {
          fetch(this.options.templateUrl).then(Metro2.fetch.text).then((data) => {
            this.create(data);
          });
        } else {
          this.create();
        }
      },
      create: function(html) {
        const cookie = Metro2.cookie;
        const o2 = this.options;
        const wrapper = this.disclaimer;
        wrapper.addClass("cookie-disclaimer").addClass(o2.clsContainer);
        if (!html) {
          wrapper.html(
            $7("<div class='disclaimer-message'>").addClass(o2.clsMessage).html(`
                                <div class="disclaimer-title">${o2.title || this.strings.label_cookies_title}</div>
                                <div class="disclaimer-text">${o2.message || this.strings.label_cookies_text}</div>
                            `)
          );
        } else {
          wrapper.append(html);
        }
        const buttons = $7("<div>").addClass("disclaimer-actions").addClass(o2.clsButtons).append(
          $7("<button>").addClass("button cookie-accept-button").addClass(o2.clsAcceptButton).html(this.strings.label_accept)
        ).append(
          $7("<button>").addClass("button cookie-cancel-button").addClass(o2.clsCancelButton).html(this.strings.label_cancel)
        );
        buttons.appendTo(wrapper);
        if (o2.customButtons) {
          $7.each(o2.customButtons, function() {
            const btn = $7("<button>").addClass("button cookie-custom-button").addClass(this.cls).html(this.text);
            btn.on("click", () => {
              Metro2.utils.exec(this.onclick);
            });
            btn.appendTo(buttons);
          });
        }
        wrapper.appendTo($7("body"));
        wrapper.on(Metro2.events.click, ".cookie-accept-button", () => {
          let dur = 0;
          const durations = `${o2.duration}`.toArray(" ");
          $7.each(durations, function() {
            const d4 = `${this}`;
            if (d4.includes("day")) {
              dur += Number.parseInt(d4) * 24 * 60 * 60 * 1e3;
            } else if (d4.includes("hour")) {
              dur += Number.parseInt(d4) * 60 * 60 * 1e3;
            } else if (d4.includes("min")) {
              dur += Number.parseInt(d4) * 60 * 1e3;
            } else if (d4.includes("sec")) {
              dur += Number.parseInt(d4) * 1e3;
            } else {
              dur += Number.parseInt(d4);
            }
          });
          cookie.setCookie(o2.name, true, dur);
          Metro2.utils.exec(o2.onAccept);
          wrapper.remove();
        });
        wrapper.on(Metro2.events.click, ".cookie-cancel-button", () => {
          Metro2.utils.exec(o2.onDecline);
          wrapper.remove();
        });
      }
    };
  })(Metro, Dom);

  // ../metroui-lib/source/components/countdown/countdown.js
  ((Metro2, $7) => {
    "use strict";
    let CountdownDefaultConfig = {
      countdownDeferred: 0,
      stopOnBlur: true,
      animate: "none",
      ease: "linear",
      duration: 600,
      inputFormat: null,
      days: 0,
      hours: 0,
      minutes: 0,
      seconds: 0,
      date: null,
      start: true,
      fontSize: 24,
      clsCountdown: "",
      clsPart: "",
      clsZero: "",
      clsAlarm: "",
      clsDays: "",
      clsHours: "",
      clsMinutes: "",
      clsSeconds: "",
      onAlarm: Metro2.noop,
      onTick: Metro2.noop,
      onZero: Metro2.noop,
      onBlink: Metro2.noop,
      onCountdownCreate: Metro2.noop
    };
    Metro2.countdownSetup = (options) => {
      CountdownDefaultConfig = $7.extend({}, CountdownDefaultConfig, options);
    };
    if (typeof globalThis.metroCountdownSetup !== "undefined") {
      Metro2.countdownSetup(globalThis.metroCountdownSetup);
    }
    Metro2.Component("countdown", {
      init: function(options, elem) {
        this._super(elem, options, CountdownDefaultConfig, {
          breakpoint: (/* @__PURE__ */ new Date()).getTime(),
          blinkInterval: null,
          tickInterval: null,
          zeroDaysFired: false,
          zeroHoursFired: false,
          zeroMinutesFired: false,
          zeroSecondsFired: false,
          fontSize: 0,
          current: {
            d: 0,
            h: 0,
            m: 0,
            s: 0
          },
          inactiveTab: false,
          id: null,
          duration: 600
        });
        return this;
      },
      _create: function() {
        const o2 = this.options;
        this.id = Hooks.useId(this.element);
        this.duration = +o2.duration <= 0 || +o2.duration >= 1e3 ? 1e3 : +o2.duration;
        this._build();
        this._createEvents();
      },
      _setBreakpoint: function() {
        const o2 = this.options;
        const dm = 864e5;
        const hm = 36e5;
        const mm = 6e4;
        const sm = 1e3;
        this.breakpoint = datetime().time();
        if (o2.date) {
          this.breakpoint = (o2.inputFormat ? Datetime.from(o2.date, o2.inputFormat) : datetime(o2.date)).time();
        }
        if (Number.parseInt(o2.days) > 0) {
          this.breakpoint += Number.parseInt(o2.days) * dm;
        }
        if (Number.parseInt(o2.hours) > 0) {
          this.breakpoint += Number.parseInt(o2.hours) * hm;
        }
        if (Number.parseInt(o2.minutes) > 0) {
          this.breakpoint += Number.parseInt(o2.minutes) * mm;
        }
        if (Number.parseInt(o2.seconds) > 0) {
          this.breakpoint += Number.parseInt(o2.seconds) * sm;
        }
      },
      _build: function() {
        const element2 = this.element;
        const o2 = this.options;
        const parts = ["days", "hours", "minutes", "seconds"];
        const dm = 24 * 60 * 60 * 1e3;
        const now = datetime().time();
        const strings = this.strings;
        if (!element2.attr("id")) {
          element2.attr("id", this.id);
        }
        element2.addClass("countdown").addClass(`animate-${o2.animate}`).addClass(o2.clsCountdown);
        element2.css("font-size", o2.fontSize);
        this._setBreakpoint();
        const delta_days = Math.round((this.breakpoint - now) / dm);
        $7.each(parts, function() {
          const part = $7("<div>").addClass(`part ${this}`).addClass(o2.clsPart).attr("data-label", strings[`label_${this}`]).appendTo(element2);
          if (this === "days") {
            part.addClass(o2.clsDays);
          }
          if (this === "hours") {
            part.addClass(o2.clsHours);
          }
          if (this === "minutes") {
            part.addClass(o2.clsMinutes);
          }
          if (this === "seconds") {
            part.addClass(o2.clsSeconds);
          }
          $7("<div>").addClass("digit").appendTo(part);
          $7("<div>").addClass("digit").appendTo(part);
          if (this === "days" && delta_days >= 100) {
            for (let i3 = 0; i3 < Math.floor(delta_days / 100) - 2; i3++) {
              $7("<div>").addClass("digit").appendTo(part);
            }
          }
        });
        const digit = element2.find(".digit");
        digit.append($7("<span class='digit-placeholder'>").html("0"));
        digit.append($7("<span class='digit-value'>").html("0"));
        this._fireEvent("countdown-create", {
          element: element2
        });
        if (o2.start === true) {
          this.start();
        } else {
          this.tick();
        }
        this.fontSize = Number.parseInt(element2.css("font-size"));
      },
      _createEvents: function() {
        $7(document).on(
          "visibilitychange",
          () => {
            if (document.hidden) {
              this.pause();
            } else {
              this.resume();
            }
          },
          { ns: this.id }
        );
      },
      blink: function() {
        const element2 = this.element;
        element2.toggleClass("blink");
        this._fireEvent("blink", {
          time: this.current
        });
      },
      tick: function() {
        const element2 = this.element;
        const o2 = this.options;
        const dm = 24 * 60 * 60;
        const hm = 60 * 60;
        const mm = 60;
        const sm = 1;
        let left;
        const now = datetime().time();
        let d4;
        let h3;
        let m5;
        let s2;
        const days = element2.find(".days");
        const hours = element2.find(".hours");
        const minutes = element2.find(".minutes");
        const seconds = element2.find(".seconds");
        left = Math.floor((this.breakpoint - now) / 1e3);
        if (left <= -1) {
          this.stop();
          element2.addClass(o2.clsAlarm);
          this._fireEvent("alarm", {
            time: now
          });
          return;
        }
        d4 = Math.floor(left / dm);
        left -= d4 * dm;
        if (this.current.d !== d4) {
          this.current.d = d4;
          this.draw("days", d4);
        }
        if (d4 === 0) {
          if (this.zeroDaysFired === false) {
            this.zeroDaysFired = true;
            days.addClass(o2.clsZero);
            this._fireEvent("zero", {
              part: "days",
              value: days
            });
          }
        }
        h3 = Math.floor(left / hm);
        left -= h3 * hm;
        if (this.current.h !== h3) {
          this.current.h = h3;
          this.draw("hours", h3);
        }
        if (d4 === 0 && h3 === 0) {
          if (this.zeroHoursFired === false) {
            this.zeroHoursFired = true;
            hours.addClass(o2.clsZero);
            this._fireEvent("zero", {
              part: "hours",
              value: hours
            });
          }
        }
        m5 = Math.floor(left / mm);
        left -= m5 * mm;
        if (this.current.m !== m5) {
          this.current.m = m5;
          this.draw("minutes", m5);
        }
        if (d4 === 0 && h3 === 0 && m5 === 0) {
          if (this.zeroMinutesFired === false) {
            this.zeroMinutesFired = true;
            minutes.addClass(o2.clsZero);
            this._fireEvent("zero", {
              part: "minutes",
              value: minutes
            });
          }
        }
        s2 = Math.floor(left / sm);
        if (this.current.s !== s2) {
          this.current.s = s2;
          this.draw("seconds", s2);
        }
        if (d4 === 0 && h3 === 0 && m5 === 0 && s2 === 0) {
          if (this.zeroSecondsFired === false) {
            this.zeroSecondsFired = true;
            seconds.addClass(o2.clsZero);
            this._fireEvent("zero", {
              part: "seconds",
              value: seconds
            });
          }
        }
        this._fireEvent("tick", {
          days: d4,
          hours: h3,
          minutes: m5,
          seconds: s2
        });
      },
      draw: function(part, value) {
        const element2 = this.element;
        const o2 = this.options;
        let digits;
        let digits_length;
        let digit_value;
        let digit_current;
        let digit;
        let len;
        let i3;
        const duration = this.duration;
        const fontSize = this.fontSize || Number.parseInt(getComputedStyle(element2[0]).getPropertyValue("font-size"));
        const slideDigit = (digit2, value2) => {
          const height = digit2.height();
          digit2.siblings(".-old-digit").remove();
          const digit_copy = digit2.clone().appendTo(digit2.parent());
          digit_copy.css({
            top: `${-1 * height}px`
          });
          digit2.addClass("-old-digit").animate({
            draw: {
              top: height,
              opacity: 0
            },
            dur: duration,
            ease: o2.ease,
            onDone: function() {
              $7(this).remove();
            }
          });
          digit_copy.html(value2).animate({
            draw: {
              top: 0,
              opacity: [0, 1]
            },
            dur: duration,
            ease: o2.ease
          });
        };
        const fadeDigit = (digit2, value2) => {
          digit2.siblings(".-old-digit").remove();
          const digit_copy = digit2.clone().appendTo(digit2.parent());
          digit_copy.css({
            opacity: 0
          });
          digit2.addClass("-old-digit").animate({
            draw: {
              opacity: 0
            },
            dur: duration / 2,
            ease: o2.ease,
            onDone: function() {
              $7(this).remove();
            }
          });
          digit_copy.html(value2).animate({
            draw: {
              opacity: 1
            },
            dur: duration / 2,
            ease: o2.ease
          });
        };
        const zoomDigit = (digit2, value2) => {
          const height = element2.height();
          const fs = fontSize;
          digit2.siblings(".-old-digit").remove();
          const digit_copy = digit2.clone().appendTo(digit2.parent());
          digit_copy.css({
            top: 0,
            left: 0,
            opacity: 1
          });
          digit2.addClass("-old-digit").animate({
            draw: {
              top: height,
              opacity: 0,
              fontSize: 0
            },
            dur: duration,
            ease: o2.ease,
            onDone: function() {
              $7(this).remove();
            }
          });
          digit_copy.html(value2).animate({
            draw: {
              top: 0,
              opacity: 1,
              fontSize: [0, fs]
            },
            dur: duration,
            ease: o2.ease
          });
        };
        let _value = `${value}`;
        if (_value.length === 1) {
          _value = `0${value}`;
        }
        len = _value.length;
        digits = element2.find(`.${part} .digit:not(.-old-digit)`);
        digits_length = digits.length;
        element2.find(".-old-digit").remove();
        for (i3 = 0; i3 < len; i3++) {
          digit = digits.eq(digits_length - 1).find(".digit-value");
          digit_value = Math.floor(Number.parseInt(value) / 10 ** i3) % 10;
          digit_current = Number.parseInt(digit.text());
          digits_length--;
          if (digit_current === digit_value) {
            continue;
          }
          switch (`${o2.animate}`.toLowerCase()) {
            case "slide":
              slideDigit(digit, digit_value);
              break;
            case "fade":
              fadeDigit(digit, digit_value);
              break;
            case "zoom":
              zoomDigit(digit, digit_value);
              break;
            default:
              digit.html(digit_value);
          }
        }
      },
      start: function() {
        const element2 = this.element;
        if (element2.data("paused") === false) {
          return;
        }
        clearInterval(this.blinkInterval);
        clearInterval(this.tickInterval);
        element2.data("paused", false);
        this._setBreakpoint();
        this.tick();
        this.blinkInterval = setInterval(() => {
          this.blink();
        }, 500);
        this.tickInterval = setInterval(() => {
          this.tick();
        }, 1e3);
      },
      stop: function() {
        const element2 = this.element;
        clearInterval(this.blinkInterval);
        clearInterval(this.tickInterval);
        element2.data("paused", true);
        element2.find(".digit").html("0");
        this.current = {
          d: 0,
          h: 0,
          m: 0,
          s: 0
        };
      },
      pause: function() {
        clearInterval(this.blinkInterval);
        clearInterval(this.tickInterval);
        this.element.data("paused", true);
      },
      resume: function() {
        this.element.data("paused", false);
        this.blinkInterval = setInterval(() => {
          this.blink();
        }, 500);
        this.tickInterval = setInterval(() => {
          this.tick();
        }, 1e3);
      },
      reset: function() {
        const element2 = this.element;
        const o2 = this.options;
        clearInterval(this.blinkInterval);
        clearInterval(this.tickInterval);
        element2.find(".part").removeClass(o2.clsZero);
        const digit = element2.find(".digit").clear();
        digit.append($7("<span class='digit-placeholder'>").html("0"));
        digit.append($7("<span class='digit-value'>").html("0"));
        this._setBreakpoint();
        element2.data("paused", false);
        this.tick();
        this.blinkInterval = setInterval(() => {
          this.blink();
        }, 500);
        this.tickInterval = setInterval(() => {
          this.tick();
        }, 1e3);
      },
      resetWith: function(val) {
        const element2 = this.element;
        const o2 = this.options;
        const keys = ["days", "hours", "minutes", "seconds"];
        this.stop();
        if (typeof val === "string") {
          element2.attr("data-date", val);
          for (const key of keys) {
            o2[key] = 0;
          }
          o2.date = val;
        } else if (typeof val === "object") {
          o2.date = null;
          for (const key of keys) {
            const newVal = val[key] !== void 0 ? val[key] : 0;
            element2.attr(`data-${key}`, newVal);
            o2[key] = newVal;
          }
        }
        this.reset();
      },
      togglePlay: function() {
        if (this.element.attr("data-pause") === true) {
          this.pause();
        } else {
          this.start();
        }
      },
      isPaused: function() {
        return this.element.data("paused");
      },
      getBreakpoint: function(asDate) {
        return asDate === true ? new Date(this.breakpoint) : this.breakpoint;
      },
      getLeft: function() {
        const dm = 24 * 60 * 60 * 1e3;
        const hm = 60 * 60 * 1e3;
        const mm = 60 * 1e3;
        const sm = 1e3;
        const now = (/* @__PURE__ */ new Date()).getTime();
        const left_seconds = Math.floor(this.breakpoint - now);
        return {
          days: Math.round(left_seconds / dm),
          hours: Math.round(left_seconds / hm),
          minutes: Math.round(left_seconds / mm),
          seconds: Math.round(left_seconds / sm)
        };
      },
      changeAttribute: function(attr, newVal) {
        switch (attr) {
          case "data-pause":
            this.togglePlay();
            break;
          case "data-duration":
            this.duration = +newVal <= 0 || +newVal >= 1e3 ? 600 : +newVal;
            break;
        }
      },
      destroy: function() {
        clearInterval(this.blinkInterval);
        clearInterval(this.tickInterval);
        $7(document).off("visibilitychange", { ns: this.id });
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/counter/counter.js
  ((Metro2, $7) => {
    "use strict";
    let CounterDefaultConfig = {
      startOnViewport: false,
      counterDeferred: 0,
      duration: 2e3,
      value: 0,
      from: 0,
      timeout: 0,
      delimiter: ",",
      prefix: "",
      suffix: "",
      size: 16,
      onStart: Metro2.noop,
      onStop: Metro2.noop,
      onTick: Metro2.noop,
      onCounterCreate: Metro2.noop
    };
    Metro2.counterSetup = (options) => {
      CounterDefaultConfig = $7.extend({}, CounterDefaultConfig, options);
    };
    if (typeof globalThis.metroCounterSetup !== "undefined") {
      Metro2.counterSetup(globalThis.metroCounterSetup);
    }
    Metro2.Component("counter", {
      init: function(options, elem) {
        this._super(elem, options, CounterDefaultConfig, {
          numbers: [],
          html: $7(elem).html(),
          started: false,
          id: null
        });
        return this;
      },
      _create: function() {
        this.id = Hooks.useId(this.element);
        this._createStruct();
        this._createEvents();
        this._fireEvent("counter-create");
      },
      _createStruct: function() {
        const element2 = this.element;
        const elem = this.elem;
        const o2 = this.options;
        this.elem.value = 0;
        element2.css("font-size", this.options.size);
      },
      _createEvents: function() {
        const o2 = this.options;
        if (o2.startOnViewport) {
          Hooks.useEvent({
            effect: () => {
              this.start();
            },
            target: this.elem,
            event: Hooks.EVENTS.VIEWPORT
          });
        }
      },
      start: function(val, from) {
        const that = this;
        const elem = this.elem;
        const o2 = this.options;
        if (Metro2.utils.isValue(from)) {
          o2.from = +from;
        }
        if (Metro2.utils.isValue(val)) {
          o2.value = +val;
        }
        this.started = true;
        const _from = o2.from;
        const _to = o2.value;
        this._fireEvent("start");
        $7.animate({
          el: elem,
          draw: {
            value: [_from, _to]
          },
          defer: o2.timeout,
          dur: o2.duration,
          onFrame: function() {
            that._fireEvent("tick", {
              value: this.value
            });
            this.innerHTML = o2.prefix + Number(this.value).format(0, 0, o2.delimiter) + o2.suffix;
          },
          onDone: () => {
            that._fireEvent("stop");
          }
        });
      },
      reset: function() {
        this.started = false;
        this.element.html(this.html);
      },
      changeAttribute: function(attr, val) {
        const o2 = this.options;
        if (attr === "data-value") {
          o2.value = +val;
        }
        if (attr === "data-from") {
          o2.from = +val;
        }
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/cube/cube.js
  ((Metro2, $7) => {
    "use strict";
    let CubeDefaultConfig = {
      cubeDeferred: 0,
      rules: null,
      color: null,
      flashColor: null,
      flashInterval: 1e3,
      numbers: false,
      cells: 4,
      showAxis: false,
      axisStyle: "arrow",
      //line
      cellClick: false,
      autoRestart: 5e3,
      clsCube: "",
      clsCell: "",
      clsSide: "",
      clsSideLeft: "",
      clsSideRight: "",
      clsSideTop: "",
      clsSideLeftCell: "",
      clsSideRightCell: "",
      clsSideTopCell: "",
      clsAxis: "",
      clsAxisX: "",
      clsAxisY: "",
      clsAxisZ: "",
      onTick: Metro2.noop,
      onCubeCreate: Metro2.noop
    };
    Metro2.cubeSetup = (options) => {
      CubeDefaultConfig = $7.extend({}, CubeDefaultConfig, options);
    };
    if (typeof globalThis.metroCubeSetup !== "undefined") {
      Metro2.cubeSetup(globalThis.metroCubeSetup);
    }
    Metro2.cubeDefaultRules = [
      {
        on: { top: [16], left: [4], right: [1] }
      },
      {
        on: { top: [12, 15], left: [3, 8], right: [2, 5] }
      },
      {
        on: { top: [11], left: [7], right: [6] }
      },
      {
        on: { top: [8, 14], left: [2, 12], right: [9, 3] }
      },
      {
        on: { top: [10, 7], left: [6, 11], right: [10, 7] }
      },
      {
        on: { top: [13, 4], left: [1, 16], right: [13, 4] }
      },
      {
        on: { top: [9, 6, 3], left: [5, 10, 15], right: [14, 11, 8] }
      },
      {
        on: { top: [1, 2, 5], left: [9, 13, 14], right: [15, 12, 16] }
      }
    ];
    Metro2.Component("cube", {
      init: function(options, elem) {
        this._super(elem, options, CubeDefaultConfig, {
          id: null,
          rules: null,
          interval: false,
          ruleInterval: false,
          running: false,
          intervals: []
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (o2.rules === null) {
          this.rules = Metro2.cubeDefaultRules;
        } else {
          this._parseRules(o2.rules);
        }
        this._createCube();
        this._createEvents();
        this._fireEvent("cube-create", {
          element: element2
        });
      },
      _parseRules: function(rules) {
        if (rules === void 0 || rules === null) {
          return false;
        }
        if (Metro2.utils.isObject(rules)) {
          this.rules = Metro2.utils.isObject(rules);
          return true;
        }
        try {
          this.rules = JSON.parse(rules);
          return true;
        } catch (err) {
          console.warn(`Unknown or empty rules for cell flashing!
${err.message}`);
          return false;
        }
      },
      _createCube: function() {
        const element2 = this.element;
        const o2 = this.options;
        const sides = ["left", "right", "top"];
        const cells_count = o2.cells ** 2;
        element2.addClass("cube").addClass(o2.clsCube);
        if (!element2.attr("id")) {
          element2.attr("id", Hooks.useId(this.elem));
        }
        this.id = element2.attr("id");
        if (o2.color && Farbe.Routines.isColor(o2.color)) {
          element2.cssVar("--cube-background", o2.color);
        }
        if (o2.flashColor && Farbe.Routines.isColor(o2.flashColor)) {
          element2.cssVar("cube-background-flash", o2.flashColor);
        }
        $7.each(sides, function() {
          let side;
          side = $7("<div>").addClass(`side ${this}-side`).addClass(o2.clsSide).appendTo(element2);
          if (this === "left") {
            side.addClass(o2.clsSideLeft);
          }
          if (this === "right") {
            side.addClass(o2.clsSideRight);
          }
          if (this === "top") {
            side.addClass(o2.clsSideTop);
          }
          for (let i3 = 0; i3 < cells_count; i3++) {
            const cell = $7("<div>").addClass("cube-cell").addClass(`cell-id-${i3 + 1}`).addClass(o2.clsCell);
            cell.data("id", i3 + 1).data("side", this);
            cell.appendTo(side);
            if (o2.numbers === true) {
              cell.html(i3 + 1);
            }
          }
        });
        this._createCssForCellSize();
        const axis = ["x", "y", "z"];
        $7.each(axis, function() {
          const ax = $7("<div>").addClass(`axis ${o2.axisStyle}`).addClass(`axis-${this}`).addClass(o2.clsAxis);
          if (this === "x") ax.addClass(o2.clsAxisX);
          if (this === "y") ax.addClass(o2.clsAxisY);
          if (this === "z") ax.addClass(o2.clsAxisZ);
          ax.appendTo(element2);
        });
        if (o2.showAxis === false) {
          element2.find(".axis").hide();
        }
        this._run();
      },
      _run: function() {
        const element2 = this.element;
        const o2 = this.options;
        let interval = 0;
        clearInterval(this.interval);
        element2.find(".cube-cell").removeClass("light");
        element2.find(".cube-cell").removeClass("light");
        this._start();
        interval = Metro2.utils.isObject(this.rules) ? Metro2.utils.objectLength(this.rules) : 0;
        this.interval = setInterval(() => {
          this._start();
        }, interval * o2.flashInterval);
      },
      _createCssForCellSize: function() {
        const element2 = this.element;
        const o2 = this.options;
        const side = element2.find(".right-side");
        const width = Number.parseInt(Metro2.utils.getStyleOne(side, "width"));
        const gap = Number.parseInt(Metro2.utils.getStyleOne(side, "gap"));
        const cells = +o2.cells;
        const cell_size = Math.floor((width - (cells - 1) * gap - gap * 2) / cells);
        element2.cssVar("cube-size", `${cell_size}px`);
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.on(Metro2.events.click, ".cube-cell", function() {
          if (o2.cellClick === true) {
            $7(this).toggleClass("light");
          }
        });
      },
      _start: function() {
        const element2 = this.element;
        element2.find(".cube-cell").removeClass("light");
        this.running = true;
        $7.each(this.rules, (index, rule) => {
          this._execRule(index, rule);
        });
      },
      _stop: function() {
        this.running = false;
        clearInterval(this.interval);
        $7.each(this.intervals, function() {
          clearInterval(this);
        });
      },
      _tick: function(index, speed) {
        const o2 = this.options;
        const _speed = speed || o2.flashInterval * index;
        const interval = setTimeout(() => {
          Metro2.utils.exec(o2.onTick, [index]);
          this._fireEvent("tick", {
            index
          });
          clearInterval(interval);
          Metro2.utils.arrayDelete(this.intervals, interval);
        }, _speed);
        this.intervals.push(interval);
      },
      _toggle: function(cell, func, time, speed) {
        const _speed = speed || this.options.flashInterval * time;
        const interval = setTimeout(() => {
          cell[func === "on" ? "addClass" : "removeClass"]("light");
          clearInterval(interval);
          Metro2.utils.arrayDelete(this.intervals, interval);
        }, _speed);
        this.intervals.push(interval);
      },
      start: function() {
        this._start();
      },
      stop: function() {
        this._stop();
      },
      toRule: function(index, speed) {
        const element2 = this.element;
        const o2 = this.options;
        const rules = this.rules;
        if (rules === null || rules === void 0 || rules[index] === void 0) {
          return;
        }
        clearInterval(this.ruleInterval);
        this.ruleInterval = false;
        this.stop();
        element2.find(".cube-cell").removeClass("light");
        for (let i3 = 0; i3 <= index; i3++) {
          this._execRule(i3, rules[i3], speed);
        }
        if (Metro2.utils.isInt(o2.autoRestart) && o2.autoRestart > 0) {
          this.ruleInterval = setTimeout(() => {
            this._run();
          }, o2.autoRestart);
        }
      },
      _execRule: function(index, rule, speed) {
        const that = this;
        const element2 = this.element;
        const sides = ["left", "right", "top"];
        this._tick(index, speed);
        $7.each(sides, function() {
          const side_class = `.${this}-side`;
          const cells_on = rule.on?.[this] ? rule.on[this] : false;
          const cells_off = rule.off?.[this] ? rule.off[this] : false;
          if (cells_on !== false)
            $7.each(cells_on, function() {
              const cell = element2.find(`${side_class} .cell-id-${this}`);
              that._toggle(cell, "on", index, speed);
            });
          if (cells_off !== false)
            $7.each(cells_off, function() {
              const cell = element2.find(`${side_class} .cell-id-${this}`);
              that._toggle(cell, "off", index, speed);
            });
        });
      },
      rule: function(r2) {
        if (r2 === void 0) {
          return this.rules;
        }
        if (this._parseRules(r2) !== true) {
          return;
        }
        this.options.rules = r2;
        this.stop();
        this.element.find(".cube-cell").removeClass("light");
        this._run();
      },
      axis: function(show) {
        const func = show ? "show" : "hide";
        this.element.find(".axis")[func]();
      },
      changeRules: function() {
        const element2 = this.element;
        const o2 = this.options;
        const rules = element2.attr("data-rules");
        if (this._parseRules(rules) !== true) {
          return;
        }
        this.stop();
        element2.find(".cube-cell").removeClass("light");
        o2.rules = rules;
        this._run();
      },
      changeAxisVisibility: function() {
        const element2 = this.element;
        const visibility = JSON.parse(element2.attr("data-show-axis")) === true;
        const func = visibility ? "show" : "hide";
        element2.find(".axis")[func]();
      },
      changeAxisStyle: function() {
        const element2 = this.element;
        const style = element2.attr("data-axis-style");
        element2.find(".axis").removeClass("arrow line no-style").addClass(style);
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-rules":
            this.changeRules();
            break;
          case "data-show-axis":
            this.changeAxisVisibility();
            break;
          case "data-axis-style":
            this.changeAxisStyle();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        clearInterval(this.interval);
        this.interval = null;
        element2.off(Metro2.events.click, ".cube-cell");
        return element2;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/custom-checkbox/custom-checkbox.js
  ((Metro2, $7) => {
    "use strict";
    let CustomCheckboxDefaultConfig = {
      customCheckboxDeferred: 0,
      stateOn: "\u2713",
      stateOff: "\u2717",
      captionOn: "",
      captionOff: "",
      captionPosition: "right",
      clsCustomCheckbox: "",
      clsIcon: "",
      clsIconOn: "",
      clsIconOff: "",
      clsCaption: "",
      clsCaptionOn: "",
      clsCaptionOff: "",
      onCustomCheckboxCreate: Metro2.noop
    };
    Metro2.customCheckboxSetup = (options) => {
      CustomCheckboxDefaultConfig = $7.extend({}, CustomCheckboxDefaultConfig, options);
    };
    if (typeof globalThis.metroCustomCheckboxSetup !== "undefined") {
      Metro2.customCheckboxSetup(globalThis.metroCustomCheckboxSetup);
    }
    Metro2.Component("custom-checkbox", {
      init: function(options, elem) {
        this._super(elem, options, CustomCheckboxDefaultConfig);
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.wrap($7("<label>").addClass("custom-checkbox").addClass(o2.clsCustomCheckbox));
        const icon = $7("<span>").addClass("icon").addClass(o2.clsIcon).appendTo(container);
        element2.attr("type", "checkbox");
        if (element2.attr("readonly")) {
          element2.on("click", (e2) => {
            e2.preventDefault();
          });
        }
        if (o2.stateOn) {
          $7("<span>").addClass("state-on").addClass(o2.clsIconOn).html(o2.stateOn).appendTo(icon);
        }
        if (o2.stateOff) {
          $7("<span>").addClass("state-off").addClass(o2.clsIconOff).html(o2.stateOff).appendTo(icon);
        }
        if (o2.captionOn || o2.captionOff) {
          const caption = $7("<span>").addClass("caption").addClass(o2.clsCaption).appendTo(container);
          if (o2.captionOn) {
            $7("<span>").addClass("caption-state-on").addClass(o2.clsCaptionOn).html(o2.captionOn).appendTo(caption);
          }
          if (o2.captionOff) {
            $7("<span>").addClass("caption-state-off").addClass(o2.clsCaptionOff).html(o2.captionOff).appendTo(caption);
          }
        }
        if (o2.captionPosition === "left") {
          container.addClass("caption-left");
        }
        element2[0].className = "";
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        this._fireEvent("customCheckbox-create");
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      toggle: function(v5) {
        const element2 = this.element;
        if (!Metro2.utils.isValue(v5)) {
          element2.prop("checked", !Metro2.utils.bool(element2.prop("checked")));
        } else {
          element2.prop("checked", v5 === 1);
        }
        return this;
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "disabled":
            this.toggleState();
            break;
        }
      },
      destroy: function() {
        return this.element;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/datepicker/datepicker.js
  ((Metro2, $7) => {
    "use strict";
    let DatePickerDefaultConfig = {
      label: "",
      datepickerDeferred: 0,
      gmt: 0,
      format: "YYYY-MM-DD",
      inputFormat: null,
      value: null,
      distance: 3,
      month: true,
      day: true,
      year: true,
      minYear: null,
      maxYear: null,
      defaultYearDistance: 100,
      scrollSpeed: 4,
      openMode: "auto",
      clsPicker: "",
      clsPart: "",
      clsMonth: "",
      clsDay: "",
      clsYear: "",
      clsLabel: "",
      clsButton: "",
      clsOkButton: "",
      clsCancelButton: "",
      okButtonIcon: "\u2713",
      cancelButtonIcon: "\u{10102}",
      onSet: Metro2.noop,
      onOpen: Metro2.noop,
      onClose: Metro2.noop,
      onScroll: Metro2.noop,
      onDatePickerCreate: Metro2.noop
    };
    Metro2.datePickerSetup = (options) => {
      DatePickerDefaultConfig = $7.extend({}, DatePickerDefaultConfig, options);
    };
    if (typeof globalThis.metroDatePickerSetup !== "undefined") {
      Metro2.datePickerSetup(globalThis.metroDatePickerSetup);
    }
    Metro2.Component("date-picker", {
      init: function(options, elem) {
        this._super(elem, options, DatePickerDefaultConfig, {
          picker: null,
          isOpen: false,
          value: datetime(),
          listTimer: {
            day: null,
            month: null,
            year: null
          }
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        const locale = this.locale;
        const date = datetime();
        if (o2.distance < 1) {
          o2.distance = 1;
        }
        if (Metro2.utils.isValue(element2.val())) {
          o2.value = element2.val();
        }
        if (Metro2.utils.isValue(o2.value)) {
          this.value = o2.inputFormat ? Datetime.from(o2.value, o2.inputFormat, locale) : datetime(o2.value);
        }
        if (o2.minYear === null) {
          o2.minYear = date.year() - o2.defaultYearDistance;
        }
        if (o2.maxYear === null) {
          o2.maxYear = date.year() + o2.defaultYearDistance;
        }
        this._createStructure();
        this._createEvents();
        this._set();
        this._fireEvent("datepicker-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const locale = this.locale;
        let picker;
        let month;
        let day;
        let year;
        let i3;
        let j5;
        let dateWrapper;
        let selectBlock;
        picker = element2.wrap("<div>").addClass(`wheel-picker date-picker ${element2[0].className}`).addClass(o2.clsPicker);
        if (!picker.attr("id")) {
          picker.attr("id", Hooks.useId(picker[0]));
        }
        this._addLabel(o2.label, picker, {
          className: o2.clsLabel,
          id: picker.attr("id"),
          dir: element2.attr("dir")
        });
        dateWrapper = $7("<div>").addClass("date-wrapper").appendTo(picker);
        if (o2.month === true) {
          month = $7("<div>").addClass("month").addClass(o2.clsPart).addClass(o2.clsMonth).appendTo(dateWrapper);
        }
        if (o2.day === true) {
          day = $7("<div>").addClass("day").addClass(o2.clsPart).addClass(o2.clsDay).appendTo(dateWrapper);
        }
        if (o2.year === true) {
          year = $7("<div>").addClass("year").addClass(o2.clsPart).addClass(o2.clsYear).appendTo(dateWrapper);
        }
        const selectWrapper = $7("<div>").addClass("select-wrapper").appendTo(picker);
        selectBlock = $7("<div>").addClass("select-block").appendTo(selectWrapper);
        if (o2.month === true) {
          month = $7("<ul>").addClass("sel-month").appendTo(selectBlock);
          for (i3 = 0; i3 < o2.distance; i3++) $7("<li>").html("&nbsp;").data("value", -1).appendTo(month);
          for (i3 = 0; i3 < 12; i3++) {
            const month_name = Datetime.getLocale(locale).months[i3];
            $7("<li>").addClass(`js-month-${i3} js-month-real-${month_name.toLowerCase()}`).html(month_name).data("value", i3).appendTo(month);
          }
          for (i3 = 0; i3 < o2.distance; i3++) $7("<li>").html("&nbsp;").data("value", -1).appendTo(month);
        }
        if (o2.day === true) {
          day = $7("<ul>").addClass("sel-day").appendTo(selectBlock);
          for (i3 = 0; i3 < o2.distance; i3++) $7("<li>").html("&nbsp;").data("value", -1).appendTo(day);
          for (i3 = 0; i3 < 31; i3++) {
            $7("<li>").addClass(`js-day-${i3} js-day-real-${i3 + 1}`).html(i3 + 1).data("value", i3 + 1).appendTo(day);
          }
          for (i3 = 0; i3 < o2.distance; i3++) $7("<li>").html("&nbsp;").data("value", -1).appendTo(day);
        }
        if (o2.year === true) {
          year = $7("<ul>").addClass("sel-year").appendTo(selectBlock);
          for (i3 = 0; i3 < o2.distance; i3++) $7("<li>").html("&nbsp;").data("value", -1).appendTo(year);
          for (i3 = o2.minYear, j5 = 0; i3 <= o2.maxYear; i3++, j5++) {
            $7("<li>").addClass(`js-year-${j5} js-year-real-${i3}`).html(i3).data("value", i3).appendTo(year);
          }
          for (i3 = 0; i3 < o2.distance; i3++) $7("<li>").html("&nbsp;").data("value", -1).appendTo(year);
        }
        selectBlock.height((o2.distance * 2 + 1) * 40);
        const actionBlock = $7("<div>").addClass("action-block").appendTo(selectWrapper);
        $7("<button>").attr("type", "button").addClass("button action-today").addClass(o2.clsButton).addClass(o2.clsTodayButton).html(`<span class="caption">${this.strings.label_today}</span>`).appendTo(actionBlock);
        $7("<button>").attr("type", "button").addClass("button action-ok").addClass(o2.clsButton).addClass(o2.clsOkButton).html(`<span class="icon">${o2.okButtonIcon}</span>`).appendTo(actionBlock);
        $7("<button>").attr("type", "button").addClass("button action-cancel").addClass(o2.clsButton).addClass(o2.clsCancelButton).html(`<span class="icon">${o2.cancelButtonIcon}</span>`).appendTo(actionBlock);
        element2[0].className = "";
        if (element2.prop("disabled")) {
          picker.addClass("disabled");
        }
        this.picker = picker;
      },
      _createEvents: function() {
        const that = this;
        const o2 = this.options;
        const picker = this.picker;
        const ns = picker.attr("id");
        picker.on(Metro2.events.startAll, ".select-block ul", function(e2) {
          if (e2.changedTouches) {
            return;
          }
          let pageY = Metro2.utils.pageXY(e2).y;
          $7(document).on(
            Metro2.events.moveAll,
            (e3) => {
              this.scrollTop -= o2.scrollSpeed * (pageY > Metro2.utils.pageXY(e3).y ? -1 : 1);
              pageY = Metro2.utils.pageXY(e3).y;
            },
            { ns }
          );
          $7(document).on(
            Metro2.events.stopAll,
            () => {
              $7(document).off(Metro2.events.move, { ns });
              $7(document).off(Metro2.events.stop, { ns });
            },
            { ns }
          );
        });
        picker.on(Metro2.events.click, (e2) => {
          if (that.isOpen === false) that.open();
          e2.stopPropagation();
        });
        picker.on(Metro2.events.click, ".action-ok", (e2) => {
          const sm = picker.find(".sel-month li.active");
          const sd = picker.find(".sel-day li.active");
          const sy = picker.find(".sel-year li.active");
          const m5 = sm.length === 0 ? that.value.value.getMonth() : sm.data("value");
          const d4 = sd.length === 0 ? that.value.value.getDate() : sd.data("value");
          const y4 = sy.length === 0 ? that.value.value.getFullYear() : sy.data("value");
          that.value = datetime(y4, m5, d4);
          that._set();
          that.close();
          e2.preventDefault();
          e2.stopPropagation();
        });
        picker.on(Metro2.events.click, ".action-cancel", (e2) => {
          that.close();
          e2.preventDefault();
          e2.stopPropagation();
        });
        const scrollLatency = 150;
        $7.each(["month", "day", "year"], function() {
          const list = picker.find(`.sel-${this}`);
          const scrollFn = Hooks.useDebounce((e2) => {
            that.listTimer[this] = null;
            const target = Math.round(Math.ceil(list.scrollTop()) / 40);
            const targetElement = list.find(`.js-${this}-${target}`);
            const scrollTop = targetElement.position().top - o2.distance * 40;
            list.find(".active").removeClass("active");
            list[0].scrollTop = scrollTop;
            targetElement.addClass("active");
            Metro2.utils.exec(o2.onScroll, [targetElement, list, picker], list[0]);
          }, scrollLatency);
          list.on("scroll", scrollFn);
        });
        picker.on(Metro2.events.click, "ul li", function(e2) {
          const target = $7(this);
          const list = target.closest("ul");
          const scrollTop = target.position().top - o2.distance * 40;
          list.find(".active").removeClass("active");
          $7.animate({
            el: list[0],
            draw: {
              scrollTop
            },
            dur: 300
          });
          list[0].scrollTop = scrollTop;
          target.addClass("active");
          Metro2.utils.exec(o2.onScroll, [target, list, picker], list[0]);
        });
        picker.on(Metro2.events.click, ".action-today", (e2) => {
          const now = datetime();
          const month = now.month();
          const day = now.day();
          const year = now.year();
          picker.find(`.sel-month li.js-month-${month}`).click();
          picker.find(`.sel-day li.js-day-real-${day}`).click();
          picker.find(`.sel-year li.js-year-real-${year}`).click();
          e2.preventDefault();
          e2.stopPropagation();
        });
      },
      _correct: function() {
        const m5 = this.value.month();
        const d4 = this.value.day();
        const y4 = this.value.year();
        this.value = datetime(y4, m5, d4);
      },
      _set: function() {
        const element2 = this.element;
        const o2 = this.options;
        const picker = this.picker;
        const m5 = Datetime.getLocale(this.locale).months[this.value.month()];
        const d4 = this.value.day();
        const y4 = this.value.year();
        if (o2.month === true) {
          picker.find(".month").html(m5);
        }
        if (o2.day === true) {
          picker.find(".day").html(d4);
        }
        if (o2.year === true) {
          picker.find(".year").html(y4);
        }
        element2.val(this.value.format(o2.format, this.locale)).trigger("change");
        this._fireEvent("set", {
          value: this.value.val(),
          elementValue: element2.val(),
          picker
        });
      },
      open: function() {
        const o2 = this.options;
        const picker = this.picker;
        const m5 = this.value.month();
        const d4 = this.value.day() - 1;
        const y4 = this.value.year();
        const select_wrapper = picker.find(".select-wrapper");
        $7.each($7(".date-picker"), function() {
          $7(this).find("input").each(function() {
            Metro2.getPlugin(this, "datepicker").close();
          });
        });
        select_wrapper.show(0);
        picker.find("li").removeClass("active");
        if (o2.openMode === "auto") {
          if (!Metro2.utils.inViewport(select_wrapper[0])) {
            select_wrapper.parent().addClass("drop-up-select");
          }
          if (!Metro2.utils.inViewport(select_wrapper[0])) {
            select_wrapper.parent().removeClass("drop-up-select");
            select_wrapper.parent().addClass("drop-as-dialog");
          }
        } else {
          if (o2.openMode === "dialog") {
            select_wrapper.parent().addClass("drop-as-dialog");
          } else if (o2.openMode === "up") {
            select_wrapper.parent().addClass("drop-up-select");
          }
        }
        if (o2.month === true) {
          const m_list = picker.find(".sel-month");
          m_list.scrollTop(0).animate({
            draw: {
              scrollTop: m_list.find(`li.js-month-${m5}`).addClass("active").position().top - 40 * o2.distance
            },
            dur: 100
          });
        }
        if (o2.day === true) {
          const d_list = picker.find(".sel-day");
          d_list.scrollTop(0).animate({
            draw: {
              scrollTop: d_list.find(`li.js-day-${d4}`).addClass("active").position().top - 40 * o2.distance
            },
            dur: 100
          });
        }
        if (o2.year === true) {
          const y_list = picker.find(".sel-year");
          y_list.scrollTop(0).animate({
            draw: {
              scrollTop: y_list.find(`li.js-year-real-${y4}`).addClass("active").position().top - 40 * o2.distance
            },
            dur: 100
          });
        }
        this.isOpen = true;
        this._fireEvent("open", {
          value: this.value.val(),
          picker
        });
      },
      close: function() {
        const picker = this.picker;
        const o2 = this.options;
        picker.find(".select-wrapper").hide(0);
        if (o2.openMode === "auto") {
          picker.find(".select-wrapper").parent().removeClass("drop-up-select drop-as-dialog");
        }
        this.isOpen = false;
        this._fireEvent("close", {
          value: this.value.val(),
          picker
        });
      },
      val: function(value) {
        const o2 = this.options;
        if (!Metro2.utils.isValue(value)) {
          return this.element.val();
        }
        this.value = o2.inputFormat ? Datetime.from(value, o2.inputFormat, this.locale) : datetime(value);
        this._set();
      },
      date: function(t, f5) {
        if (t === void 0) {
          return this.value.val();
        }
        try {
          this.value = Datetime.from(t, f5, this.locale);
          this._set();
        } catch (e2) {
          return false;
        }
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      changeAttribute: function(attr, newValue) {
        switch (attr) {
          case "disabled":
            this.toggleState();
            break;
          case "data-value":
            this.val(newValue);
            break;
          case "data-format":
            this.options.format = newValue;
            this._set();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const picker = this.picker;
        $7.each(["moth", "day", "year"], function() {
          picker.find(`.sel-${this}`).off("scroll");
        });
        picker.off(Metro2.events.start, ".select-block ul");
        picker.off(Metro2.events.click);
        picker.off(Metro2.events.click, ".action-ok");
        picker.off(Metro2.events.click, ".action-cancel");
        return element2;
      }
    });
    $7(document).on(Metro2.events.click, () => {
      $7.each($7(".date-picker"), function() {
        $7(this).find("input").each(function() {
          Metro2.getPlugin(this, "datepicker").close();
        });
      });
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/directive/directive.js
  ((Metro2, $7) => {
    "use strict";
    const note_icon = `
    <svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M8.75 3.5V2C8.75 1.59 8.41 1.25 8 1.25C7.59 1.25 7.25 1.59 7.25 2V3.56C7.5 3.53 7.73 3.5 8 3.5H8.75Z"/>
        <path d="M16.75 3.56V2C16.75 1.59 16.41 1.25 16 1.25C15.59 1.25 15.25 1.59 15.25 2V3.5H16C16.27 3.5 16.5 3.53 16.75 3.56Z"/>
        <path d="M16.75 3.56V5C16.75 5.41 16.41 5.75 16 5.75C15.59 5.75 15.25 5.41 15.25 5V3.5H8.75V5C8.75 5.41 8.41 5.75 8 5.75C7.59 5.75 7.25 5.41 7.25 5V3.56C4.3 3.83 3 5.73 3 8.5V17C3 20 4.5 22 8 22H16C19.5 22 21 20 21 17V8.5C21 5.73 19.7 3.83 16.75 3.56ZM12 16.75H8C7.59 16.75 7.25 16.41 7.25 16C7.25 15.59 7.59 15.25 8 15.25H12C12.41 15.25 12.75 15.59 12.75 16C12.75 16.41 12.41 16.75 12 16.75ZM16 11.75H8C7.59 11.75 7.25 11.41 7.25 11C7.25 10.59 7.59 10.25 8 10.25H16C16.41 10.25 16.75 10.59 16.75 11C16.75 11.41 16.41 11.75 16 11.75Z"/>
    </svg>
    `;
    const info_icon = `
    <svg width="800px" height="800px" viewBox="-160 0 512 512" xmlns="http://www.w3.org/2000/svg">
        <path d="M20 424.229h20V279.771H20c-11.046 0-20-8.954-20-20V212c0-11.046 8.954-20 20-20h112c11.046 0 20 8.954 20 20v212.229h20c11.046 0 20 8.954 20 20V492c0 11.046-8.954 20-20 20H20c-11.046 0-20-8.954-20-20v-47.771c0-11.046 8.954-20 20-20zM96 0C56.235 0 24 32.235 24 72s32.235 72 72 72 72-32.235 72-72S135.764 0 96 0z"/>
    </svg>
    `;
    const warning_icon = `
    <svg height="800px" width="800px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 294.995 294.995" xml:space="preserve">
        <path d="M291.874,248.279L165.605,26.526c-4.007-7.037-10.776-11.26-18.107-11.26s-14.101,4.202-18.107,11.239L3.121,248.238 c-3.979,6.989-4.164,15.013-0.493,21.326c3.67,6.313,10.663,10.165,18.705,10.165h252.329c8.042,0,15.035-3.852,18.705-10.165 C296.038,263.251,295.854,255.268,291.874,248.279z M146.665,86.229c9.665,0,17.5,7.835,17.5,17.5v63c0,9.665-7.835,17.5-17.5,17.5 c-9.665,0-17.5-7.835-17.5-17.5v-63C129.165,94.064,137,86.229,146.665,86.229z M147.498,204.005c9.665,0,17.5,7.835,17.5,17.5 c0,9.665-7.835,17.5-17.5,17.5c-9.665,0-17.5-7.835-17.5-17.5C129.998,211.84,137.833,204.005,147.498,204.005z"/>
    </svg>
    `;
    const caution_icon = `
    <svg height="800px" width="800px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512"  xml:space="preserve">
        <path class="st0" d="M387.317,0.005H284.666h-57.332h-102.65L0,124.688v102.67v57.294v102.67l124.684,124.674h102.65h57.332
            h102.651L512,387.321v-102.67v-57.294v-102.67L387.317,0.005z M255.45,411.299c-19.082,0-34.53-15.467-34.53-34.549
            c0-19.053,15.447-34.52,34.53-34.52c19.082,0,34.53,15.467,34.53,34.52C289.98,395.832,274.532,411.299,255.45,411.299z
             M283.414,278.692c0,15.448-12.516,27.964-27.964,27.964c-15.458,0-27.964-12.516-27.964-27.964l-6.566-135.368
            c0-19.072,15.447-34.54,34.53-34.54c19.082,0,34.53,15.467,34.53,34.54L283.414,278.692z"/>
    </svg>
    `;
    const tip_icon = `
    <svg height="800px" width="800px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 256 256" xml:space="preserve">
        <path d="M216.2,92.5c-5.2-5.3-13.8-5.4-19-0.1L157.8,134l-0.3,0.3c-25.5,0.1-46.2,16.8-46.2,37.3h-5.8c0-23.6,23.1-42.8,51.6-43.1
            l-0.1-19.4c0,0-0.1-85.4-0.1-85.5c-0.7-5.8-5.6-10.3-11.7-10.3c-6.5,0-11.7,5.3-11.7,11.7c0,0.2,0,72.9,0,72.9l-5.2,0.2l-0.1-81.2
            c0-6.5-5.3-11.7-11.8-11.7s-11.7,5.3-11.7,11.8v81h-5.6l0.1-63.6c0-6.5-5.3-11.7-11.8-11.7S75.7,28,75.7,34.4V98h-5.2l0.1-34.2
            c0-6.5-5.3-11.7-11.8-11.7s-11.7,5.3-11.7,11.8c0,108.4,0,108.4,0,111c0,13.2,6.8,24.4,16.2,28.1v48.4h0.2v0.4l81.2-0.4v-51.1
            c2.5-0.9,5.1-2,7.6-3.3c15.4-7.9,26.1-20.3,29.5-32.5c2.9-4.3,36.8-56.2,36.8-56.2C221.4,103.7,220.6,96.9,216.2,92.5z"/>
    </svg>  
    `;
    const success_icon = `
        <svg width="800px" height="800px" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
          <path d="M24,2A22,22,0,1,0,46,24,21.9,21.9,0,0,0,24,2ZM35.4,18.4l-14,14a1.9,1.9,0,0,1-2.8,0l-5.9-5.9a2.2,2.2,0,0,1-.4-2.7,2,2,0,0,1,3.1-.2L20,28.2,32.6,15.6a2,2,0,0,1,2.8,2.8Z"/>
        </svg>    
    `;
    const icons = {
      note: note_icon,
      info: info_icon,
      warning: warning_icon,
      caution: caution_icon,
      tip: tip_icon,
      success: success_icon
    };
    let DirectiveDefaultConfig = {
      directive: "note",
      showIcon: true,
      title: "default",
      style: 1,
      // default - 1, vue style - 2, 3
      onDirectiveCreate: Metro2.noop
    };
    Metro2.directiveSetup = (options) => {
      DirectiveDefaultConfig = $7.extend({}, DirectiveDefaultConfig, options);
    };
    if (typeof globalThis.metroDirectiveSetup !== "undefined") {
      Metro2.directiveSetup(globalThis.metroDirectiveSetup);
    }
    Metro2.Component("directive", {
      init: function(options, elem) {
        this._super(elem, options, DirectiveDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("directive-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const directive = element2.wrap("<div>").addClass("directive").addClass(`directive-style-${o2.style}`).addClass(`directive-${o2.directive}`);
        const title = $7("<div>").addClass("directive-title").html(
          o2.title === "default" ? this.strings[`label_${o2.directive.toLowerCase()}`].toUpperCase() : o2.title
        );
        if (o2.showIcon) {
          title.prepend($7("<span>").addClass("icon").html(icons[o2.directive]));
        }
        directive.prepend(title);
        this.component = directive;
      },
      _createEvents: () => {
      },
      changeAttribute: (attr, val) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/donut/donut.js
  ((Metro2, $7) => {
    "use strict";
    let DonutDefaultConfig = {
      donutDeferred: 0,
      size: 100,
      hole: 0.8,
      value: 0,
      background: "transparent",
      color: "",
      stroke: "#d1d8e7",
      fill: "#49649f",
      fontSize: 0,
      total: 100,
      cap: "%",
      showText: true,
      showValue: false,
      animate: 0,
      onChange: Metro2.noop,
      onDrawValue: (v5) => v5,
      onDonutCreate: Metro2.noop
    };
    Metro2.donutSetup = (options) => {
      DonutDefaultConfig = $7.extend({}, DonutDefaultConfig, options);
    };
    if (typeof globalThis.metroDonutSetup !== "undefined") {
      Metro2.donutSetup(globalThis.metroDonutSetup);
    }
    Metro2.Component("donut", {
      init: function(options, elem) {
        this._super(elem, options, DonutDefaultConfig, {
          value: 0,
          animation_change_interval: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("donut");
        this._setElementSize();
        this._draw();
        this._addEvents();
        this.val(o2.value);
        this._fireEvent("donut-create", {
          element: element2
        });
      },
      _setElementSize: function() {
        const element2 = this.element;
        const o2 = this.options;
        const width = o2.size;
        element2.css({
          width,
          background: o2.background
        });
        element2.css({
          height: element2.width()
        });
      },
      _draw: function() {
        const element2 = this.element;
        const o2 = this.options;
        let html = "";
        const radius = element2.width() / 2;
        const r2 = radius * (1 - (1 - o2.hole) / 2);
        const width = radius * (1 - o2.hole);
        const transform = `rotate(-90 ${radius},${radius})`;
        const fontSize = o2.fontSize === 0 ? r2 * o2.hole * 0.6 : o2.fontSize;
        html += "<svg>";
        html += `   <circle class='donut-back' r='${r2}px' cx='${radius}px' cy='${radius}px' transform='${transform}' fill='none' stroke='${o2.stroke}' stroke-width='${width}'/>`;
        html += `   <circle class='donut-fill' r='${r2}px' cx='${radius}px' cy='${radius}px' transform='${transform}' fill='none' stroke='${o2.fill}' stroke-width='${width}'/>`;
        if (o2.showText === true)
          html += `   <text class='donut-title' x='${radius}px' y='${radius}px' dy='${fontSize / 3}px' text-anchor='middle' fill='${o2.color !== "" ? o2.color : o2.fill}' font-size='${fontSize}px'></text>`;
        html += "</svg>";
        element2.html(html);
      },
      _addEvents: function() {
        $7(globalThis).on("resize", () => {
          this._setElementSize();
          this._draw();
          this.val(this.value);
        });
      },
      _setValue: function(v5) {
        const element2 = this.element;
        const o2 = this.options;
        const fill = element2.find(".donut-fill");
        const title = element2.find(".donut-title");
        const radius = element2.width() / 2;
        const r2 = radius * (1 - (1 - o2.hole) / 2);
        const circumference = Math.round(2 * Math.PI * r2);
        const title_value = o2.showValue ? v5 : Metro2.utils.percent(o2.total, v5, true);
        const fill_value = Math.round(+v5 * circumference / o2.total);
        let sda = fill.attr("stroke-dasharray");
        if (typeof sda === "undefined") {
          sda = 0;
        } else {
          sda = +sda.split(" ")[0];
        }
        const delta = fill_value - sda;
        fill.animate({
          draw: function(t, p5) {
            $7(this).attr("stroke-dasharray", `${sda + delta * p5} ${circumference}`);
          },
          dur: o2.animate
        });
        title.html(Metro2.utils.exec(o2.onDrawValue, [title_value + o2.cap]));
      },
      val: function(v5) {
        const o2 = this.options;
        if (v5 === void 0) {
          return this.value;
        }
        if (Number.parseInt(v5) < 0 || Number.parseInt(v5) > o2.total) {
          return false;
        }
        this._setValue(v5);
        this.value = v5;
        this._fireEvent("change", {
          value: this.value
        });
      },
      setColor: function(obj) {
        const validKeys = ["background", "fill", "stroke", "color"];
        $7.each(obj, (key, val) => {
          if (validKeys.indexOf(key) !== -1) {
            this.options[key] = val;
          }
        });
        this._draw();
        this.val(this.value);
        return this;
      },
      changeValue: function() {
        this.val(this.element.attr("data-value"));
      },
      changeAttribute: function(attr, val) {
        switch (attr) {
          case "data-value":
            this.changeValue();
            break;
          case "data-background":
            this.setColor({ background: val });
            break;
          case "data-fill":
            this.setColor({ fill: val });
            break;
          case "data-stroke":
            this.setColor({ stroke: val });
            break;
          case "data-color":
            this.setColor({ color: val });
            break;
        }
      },
      destroy: function() {
        return this.element;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/double-select-box/double-select-box.js
  ((Metro2, $7) => {
    "use strict";
    let DoubleSelectBoxDefaultConfig = {
      height: "auto",
      multiSelect: false,
      moveRightIcon: "&rsaquo;",
      moveRightAllIcon: "&raquo;",
      moveLeftIcon: "&lsaquo;",
      moveLeftAllIcon: "&laquo;",
      clsBox: "",
      clsMoveButton: "",
      clsMoveRightButton: "",
      clsMoveRightAllButton: "",
      clsMoveLeftButton: "",
      clsMoveLeftAllButton: "",
      clsListLeft: "",
      clsListRight: "",
      onDoubleSelectBoxCreate: Metro2.noop
    };
    Metro2.doubleSelectBoxSetup = (options) => {
      DoubleSelectBoxDefaultConfig = $7.extend({}, DoubleSelectBoxDefaultConfig, options);
    };
    if (typeof globalThis.metroDoubleSelectBoxSetup !== "undefined") {
      Metro2.doubleSelectBoxSetup(globalThis.metroDoubleSelectBoxSetup);
    }
    Metro2.Component("double-select-box", {
      init: function(options, elem) {
        this._super(elem, options, DoubleSelectBoxDefaultConfig, {
          // define instance vars here
          select1: null,
          select2: null,
          list1: null,
          list2: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        if (element2.children("select").length !== 2) {
          throw new Error("Component DoubleSelectBox required two select elements!");
        }
        this._createStructure();
        this._createEvents();
        this._fireEvent("double-select-box-create");
      },
      _drawList: function() {
        this.list1.clear();
        this.select1.find("option").each((i3, option) => {
          const $op = $7(option);
          const icon = $op.attr("data-icon");
          let html = $op.attr("data-template") ? $op.attr("data-template").replace(/\$1/g, $op.text()) : $op.text();
          if (icon) {
            html = $7("<span>").addClass("icon").append(icon).outerHTML() + html;
          }
          this.list1.append($7("<li>").html(html).attr("data-value", option.value).data("option", option));
        });
        this.list2.clear();
        this.select2.find("option").each((i3, option) => {
          const $op = $7(option);
          const icon = $op.attr("data-icon");
          let html = $op.attr("data-template") ? $op.attr("data-template").replace(/\$1/g, $op.text()) : $op.text();
          if (icon) {
            html = $7("<span>").addClass("icon").append(icon).outerHTML() + html;
          }
          this.list2.append($7("<li>").html(html).attr("data-value", option.value).data("option", option));
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const selects = element2.children("select");
        const select1 = selects.eq(0);
        const select2 = selects.eq(1);
        const controls = $7("<div>").addClass("controls").insertBefore(select2);
        element2.addClass("double-select-box").addClass(o2.clsBox).css({
          height: o2.height
        });
        selects.prop("multiple", true);
        controls.append(
          $7([
            $7("<button>").attr("type", "button").addClass("button square small --move-right").addClass(o2.clsMoveButton).addClass(o2.clsMoveRightButton).html(`<span class="icon">${o2.moveRightIcon}</span>`),
            $7("<button>").attr("type", "button").addClass("button square small --move-right-all").addClass(o2.clsMoveButton).addClass(o2.clsMoveRightAllButton).html(`<span class="icon">${o2.moveRightAllIcon}</span>`),
            $7("<button>").attr("type", "button").addClass("button square small --move-left-all").addClass(o2.clsMoveButton).addClass(o2.clsMoveLeftAllButton).html(`<span class="icon">${o2.moveLeftAllIcon}</span>`),
            $7("<button>").attr("type", "button").addClass("button square small --move-left").addClass(o2.clsMoveButton).addClass(o2.clsMoveLeftButton).html(`<span class="icon">${o2.moveLeftIcon}</span>`)
          ])
        );
        const list1 = $7("<ul>").addClass("--list1").addClass(o2.clsListLeft).insertBefore(select1);
        const list2 = $7("<ul>").addClass("--list2").addClass(o2.clsListRight).insertBefore(select2);
        this.select1 = select1;
        this.select2 = select2;
        this.list1 = list1;
        this.list2 = list2;
        this._drawList();
      },
      _moveItems: (items, targets) => {
        $7.each(items, function() {
          const $item = $7(this);
          const option = $item.data("option");
          $7(option).appendTo(targets[0]);
          $item.removeClass("active").appendTo(targets[1]);
        });
      },
      _move: function(dir, scope) {
        if (scope === "selected") {
          if (dir === "ltr") {
            this._moveItems(this.list1.find("li.active"), [this.select2, this.list2]);
          } else {
            this._moveItems(this.list2.find("li.active"), [this.select1, this.list1]);
          }
        } else {
          if (dir === "ltr") {
            this._moveItems(this.list1.find("li"), [this.select2, this.list2]);
          } else {
            this._moveItems(this.list2.find("li"), [this.select1, this.list1]);
          }
        }
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const items = element2.find("li");
        items.on("click", function() {
          const $el = $7(this);
          if (o2.multiSelect === false) {
            that.list1.find("li").removeClass("active");
            that.list2.find("li").removeClass("active");
          }
          $el.addClass("active");
        });
        items.on("dblclick", function() {
          const $el = $7(this);
          const dir = $el.parent().hasClass("--list1") ? "ltr" : "rtl";
          const scope = "selected";
          that.list1.find("li").removeClass("active");
          that.list2.find("li").removeClass("active");
          $el.addClass("active");
          that._move(dir, scope);
        });
        element2.on("click", "button", function() {
          const btn = $7(this);
          if (btn.hasClass("--move-right")) {
            that._move("ltr", "selected");
          } else if (btn.hasClass("--move-right-all")) {
            that._move("ltr", "all");
          } else if (btn.hasClass("--move-left")) {
            that._move("rtl", "selected");
          } else if (btn.hasClass("--move-left-all")) {
            that._move("rtl", "all");
          } else {
            throw new Error("Pressed unregistered button!");
          }
        });
      },
      changeAttribute: (attr, val) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/double-slider/double-slider.js
  ((Metro2, $7) => {
    "use strict";
    let DoubleSliderDefaultConfig = {
      doubleSliderDeferred: 0,
      roundValue: true,
      min: 0,
      max: 100,
      accuracy: 0,
      showMinMax: false,
      minMaxPosition: Metro2.position.BOTTOM,
      valueMin: null,
      valueMax: null,
      hint: false,
      hintAlways: false,
      hintPositionMin: Metro2.position.TOP,
      hintPositionMax: Metro2.position.TOP,
      hintMaskMin: "$1",
      hintMaskMax: "$1",
      target: null,
      size: 0,
      label: "",
      clsSlider: "",
      clsBackside: "",
      clsComplete: "",
      clsMarker: "",
      clsMarkerMin: "",
      clsMarkerMax: "",
      clsHint: "",
      clsHintMin: "",
      clsHintMax: "",
      clsMinMax: "",
      clsMin: "",
      clsMax: "",
      onStart: Metro2.noop,
      onStop: Metro2.noop,
      onMove: Metro2.noop,
      onChange: Metro2.noop,
      onChangeValue: Metro2.noop,
      onFocus: Metro2.noop,
      onBlur: Metro2.noop,
      onDrawHint: (f5) => f5,
      onDoubleSliderCreate: Metro2.noop
    };
    Metro2.doubleSliderSetup = (options) => {
      DoubleSliderDefaultConfig = $7.extend({}, DoubleSliderDefaultConfig, options);
    };
    if (typeof globalThis.metroDoubleSliderSetup !== "undefined") {
      Metro2.doubleSliderSetup(globalThis.metroDoubleSliderSetup);
    }
    Metro2.Component("double-slider", {
      init: function(options, elem) {
        this._super(elem, options, DoubleSliderDefaultConfig, {
          slider: null,
          valueMin: null,
          valueMax: null,
          keyInterval: false,
          id: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        this.id = Hooks.useId(this.elem);
        this.valueMin = Metro2.utils.isValue(o2.valueMin) ? +o2.valueMin : +o2.min;
        this.valueMax = Metro2.utils.isValue(o2.valueMax) ? +o2.valueMax : +o2.max;
        this._createSlider();
        this._createEvents();
        this.val(this.valueMin, this.valueMax);
        this._fireEvent("double-slider-create", {
          element: element2
        });
      },
      _createSlider: function() {
        const element2 = this.element;
        const o2 = this.options;
        const slider_wrapper = $7("<div>").addClass("slider-wrapper");
        const slider = $7("<div>").addClass("slider").addClass(o2.clsSlider).addClass(this.elem.className);
        const backside = $7("<div>").addClass("backside").addClass(o2.clsBackside);
        const complete = $7("<div>").addClass("complete").addClass(o2.clsComplete);
        const markerMin = $7("<button>").attr("type", "button").addClass("marker marker-min").addClass(o2.clsMarker).addClass(o2.clsMarkerMin);
        const markerMax = $7("<button>").attr("type", "button").addClass("marker marker-max").addClass(o2.clsMarker).addClass(o2.clsMarkerMax);
        const hintMin = $7("<div>").addClass("hint hint-min").addClass(`${o2.hintPositionMin}-side`).addClass(o2.clsHint).addClass(o2.clsHintMin);
        const hintMax = $7("<div>").addClass("hint hint-max").addClass(`${o2.hintPositionMax}-side`).addClass(o2.clsHint).addClass(o2.clsHintMax);
        let i3;
        if (o2.size > 0) {
          slider.outerWidth(o2.size);
        }
        slider.insertBefore(element2);
        element2.appendTo(slider);
        slider_wrapper.insertBefore(slider);
        slider.appendTo(slider_wrapper);
        backside.appendTo(slider);
        complete.appendTo(slider);
        markerMin.appendTo(slider);
        markerMax.appendTo(slider);
        hintMin.appendTo(markerMin);
        hintMax.appendTo(markerMax);
        if (o2.hintAlways === true) {
          $7([hintMin, hintMax]).css({
            display: "block"
          }).addClass("permanent-hint");
        }
        if (o2.showMinMax === true) {
          const min_max_wrapper = $7("<div>").addClass("slider-min-max").addClass(o2.clsMinMax);
          $7("<span>").addClass("slider-text-min").addClass(o2.clsMin).html(`${o2.min}`).appendTo(min_max_wrapper);
          $7("<span>").addClass("slider-text-max").addClass(o2.clsMax).html(`${o2.max}`).appendTo(min_max_wrapper);
          if (o2.minMaxPosition === Metro2.position.TOP) {
            min_max_wrapper.insertBefore(slider);
          } else {
            min_max_wrapper.insertAfter(slider);
          }
        }
        element2[0].className = "";
        if (o2.label) {
          this._addLabel(o2.label, slider_wrapper);
        }
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        this.slider = slider;
      },
      _createEvents: function() {
        const that = this;
        const slider = this.slider;
        const o2 = this.options;
        const marker = slider.find(".marker");
        marker.on(Metro2.events.startAll, function() {
          const _marker = $7(this);
          const hint = _marker.find(".hint");
          _marker.addClass("active");
          if (o2.hint === true && o2.hintAlways !== true) {
            hint.fadeIn(300);
          }
          $7(document).on(
            Metro2.events.moveAll,
            (e2) => {
              that._move(e2);
              that._fireEvent("move", {
                min: that.valueMin,
                max: that.valueMax
              });
            },
            { ns: that.id }
          );
          $7(document).on(
            Metro2.events.stopAll,
            () => {
              slider.find(".marker").removeClass("active");
              $7(document).off(Metro2.events.moveAll, { ns: that.id });
              $7(document).off(Metro2.events.stopAll, { ns: that.id });
              if (o2.hintAlways !== true) {
                hint.fadeOut(300);
              }
              that._fireEvent("stop", {
                min: that.valueMin,
                max: that.valueMax
              });
            },
            { ns: that.id }
          );
          that._fireEvent("start", {
            min: that.valueMin,
            max: that.valueMax
          });
        });
        marker.on(Metro2.events.focus, () => {
          that._fireEvent("focus", {
            min: that.valueMin,
            max: that.valueMax
          });
        });
        marker.on(Metro2.events.blur, () => {
          that._fireEvent("blur", {
            min: that.valueMin,
            max: that.valueMax
          });
        });
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            that.val(that.valueMin, that.valueMax);
          },
          { ns: that.id }
        );
      },
      _convert: function(v5, how) {
        const slider = this.slider;
        const o2 = this.options;
        const length = slider.outerWidth() - slider.find(".marker").outerWidth();
        switch (how) {
          case "pix2prc":
            return v5 * 100 / length;
          case "pix2val":
            return this._convert(v5, "pix2prc") * ((o2.max - o2.min) / 100) + o2.min;
          case "val2prc":
            return (v5 - o2.min) / ((o2.max - o2.min) / 100);
          case "prc2pix":
            return v5 / (100 / length);
          case "val2pix":
            return this._convert(this._convert(v5, "val2prc"), "prc2pix");
        }
        return 0;
      },
      _correct: function(value) {
        let res = value;
        const accuracy = this.options.accuracy;
        const min = this.options.min;
        const max = this.options.max;
        const _dec = (v5) => v5 % 1 === 0 ? 0 : v5.toString().split(".")[1].length;
        if (accuracy === 0 || isNaN(accuracy)) {
          return res;
        }
        res = Math.round(value / accuracy) * accuracy;
        if (res < min) {
          res = min;
        }
        if (res > max) {
          res = max;
        }
        return res.toFixed(_dec(accuracy));
      },
      _move: function(e2) {
        const target = this.slider.find(".marker.active");
        const isMin = target.hasClass("marker-min");
        const slider = this.slider;
        const offset = slider.offset();
        const marker_size = slider.find(".marker").outerWidth();
        const markerMin = slider.find(".marker-min");
        const markerMax = slider.find(".marker-max");
        const length = slider.outerWidth();
        let cStart;
        let cStop;
        const cPix = Metro2.utils.pageXY(e2).x - offset.left - marker_size / 2;
        if (isMin) {
          cStart = 0;
          cStop = Number.parseInt(markerMax.css("left")) - marker_size;
        } else {
          cStart = Number.parseInt(markerMin.css("left")) + marker_size;
          cStop = length - marker_size;
        }
        if (cPix < cStart || cPix > cStop) {
          return;
        }
        this[isMin ? "valueMin" : "valueMax"] = this._correct(this._convert(cPix, "pix2val"));
        this._redraw();
      },
      _hint: function() {
        const that = this;
        const o2 = this.options;
        const slider = this.slider;
        const hint = slider.find(".hint");
        hint.each(function() {
          const _hint = $7(this);
          const isMin = _hint.hasClass("hint-min");
          const _mask = isMin ? o2.hintMaskMin : o2.hintMaskMax;
          const value = +(isMin ? that.valueMin : that.valueMax) || 0;
          _hint.text(
            _mask.replace(
              "$1",
              Metro2.utils.exec(o2.onDrawHint, [value.toFixed(Metro2.utils.decCount(o2.accuracy))])
            )
          );
        });
      },
      _value: function() {
        const element2 = this.element;
        const o2 = this.options;
        let v1 = +this.valueMin || 0;
        let v22 = +this.valueMax || 0;
        let value;
        if (o2.roundValue) {
          v1 = v1.toFixed(Metro2.utils.decCount(o2.accuracy));
          v22 = v22.toFixed(Metro2.utils.decCount(o2.accuracy));
        }
        value = [v1, v22].join(", ");
        if (element2[0].tagName === "INPUT") {
          element2.val(value);
        }
        if (o2.target !== null) {
          const target = $7(o2.target);
          if (target.length !== 0) {
            $7.each(target, function() {
              const t = $7(this);
              if (this.tagName === "INPUT") {
                t.val(value);
              } else {
                t.text(value);
              }
              t.trigger("change");
            });
          }
        }
        this._fireEvent("change-value", {
          val: value
        });
        this._fireEvent("change", {
          val: value
        });
      },
      _marker: function() {
        const slider = this.slider;
        const markerMin = slider.find(".marker-min");
        const markerMax = slider.find(".marker-max");
        const complete = slider.find(".complete");
        const marker_size = Number.parseInt(Metro2.utils.getStyleOne(markerMin, "width"));
        const slider_visible = Metro2.utils.isVisible(slider);
        if (slider_visible) {
          $7([markerMin, markerMax]).css({
            "margin-top": 0,
            "margin-left": 0
          });
        }
        if (slider_visible) {
          markerMin.css("left", this._convert(this.valueMin, "val2pix"));
          markerMax.css("left", this._convert(this.valueMax, "val2pix"));
        } else {
          markerMin.css({
            left: `${this._convert(this.valueMin, "val2prc")}%`,
            "margin-top": this._convert(this.valueMin, "val2prc") === 0 ? 0 : -1 * marker_size / 2
          });
          markerMax.css({
            left: `${this._convert(this.valueMax, "val2prc")}%`,
            "margin-top": this._convert(this.valueMax, "val2prc") === 0 ? 0 : -1 * marker_size / 2
          });
        }
        complete.css({
          left: this._convert(this.valueMin, "val2pix"),
          width: this._convert(this.valueMax, "val2pix") - this._convert(this.valueMin, "val2pix")
        });
      },
      _redraw: function() {
        this._marker();
        this._value();
        this._hint();
      },
      val: function(vMin, vMax) {
        const o2 = this.options;
        if (!Metro2.utils.isValue(vMin) && !Metro2.utils.isValue(vMax)) {
          return [this.valueMin, this.valueMax];
        }
        let min = vMin;
        let max = vMax;
        if (typeof min !== "undefined" && min < o2.min) min = o2.min;
        if (typeof max !== "undefined" && max < o2.min) max = o2.min;
        if (typeof min !== "undefined" && min > o2.max) min = o2.max;
        if (typeof max !== "undefined" && max > o2.max) max = o2.max;
        if (typeof min !== "undefined") this.valueMin = this._correct(min);
        if (typeof max !== "undefined") this.valueMax = this._correct(max);
        this._redraw();
      },
      changeValue: function() {
        const element2 = this.element;
        const valMin = +element2.attr("data-value-min");
        const valMax = +element2.attr("data-value-max");
        this.val(valMin, valMax);
      },
      disable: function() {
        const element2 = this.element;
        element2.data("disabled", true);
        element2.parent().addClass("disabled");
      },
      enable: function() {
        const element2 = this.element;
        element2.data("disabled", false);
        element2.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-value-min":
            this.changeValue();
            break;
          case "data-value-max":
            this.changeValue();
            break;
          case "disabled":
            this.toggleState();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const slider = this.slider;
        const marker = slider.find(".marker");
        marker.off(Metro2.events.startAll);
        marker.off(Metro2.events.focus);
        marker.off(Metro2.events.blur);
        marker.off(Metro2.events.keydown);
        marker.off(Metro2.events.keyup);
        slider.off(Metro2.events.click);
        $7(globalThis).off(Metro2.events.resize, { ns: this.id });
        element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/drag-items/drag-items.js
  ((Metro2, $7) => {
    "use strict";
    let DragItemsDefaultConfig = {
      dragItemsDeferred: 0,
      target: null,
      dragItem: "li",
      dragMarker: ".drag-item-marker",
      drawDragMarker: false,
      clsDragItemAvatar: "",
      clsDragItem: "",
      canDrag: true,
      onDragStartItem: Metro2.noop,
      onDragMoveItem: Metro2.noop,
      onDragDropItem: Metro2.noop,
      onTarget: Metro2.noop,
      onTargetIn: Metro2.noop,
      //TODO
      onTargetOut: Metro2.noop,
      //TODO
      onDragItemsCreate: Metro2.noop
    };
    Metro2.dragItemsSetup = (options) => {
      DragItemsDefaultConfig = $7.extend({}, DragItemsDefaultConfig, options);
    };
    if (typeof globalThis.metroDragItemsSetup !== "undefined") {
      Metro2.dragItemsSetup(globalThis.metroDragItemsSetup);
    }
    Metro2.Component("drag-items", {
      init: function(options, elem) {
        this._super(elem, options, DragItemsDefaultConfig, {
          id: null,
          canDrag: false
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this.id = Hooks.useId(this.elem);
        this._createStructure();
        this._createEvents();
        this._fireEvent("drag-items-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (!element2.id()) {
          element2.id(this.id);
        }
        element2.addClass("drag-items-target");
        if (o2.drawDragMarker === true) {
          element2.find(o2.dragItem).each(function() {
            $7("<span>").addClass("drag-item-marker").appendTo(this);
          });
        }
        o2.canDrag ? this.on() : this.off();
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        const doc = $7.document();
        const body = $7.body();
        let offset;
        const shift = { top: 0, left: 0 };
        let width;
        let height;
        const move = (e2, avatar, dragItem) => {
          const x5 = Metro2.utils.pageXY(e2).x;
          const y4 = Metro2.utils.pageXY(e2).y;
          const _top = y4 - shift.top;
          const _left = x5 - shift.left;
          avatar.css({
            top: _top,
            left: _left
          });
          const target = document.elementsFromPoint(x5, y4).filter((el) => $7(el).hasClass("drag-items-target"));
          if (target.length === 0) {
            return;
          }
          this._fireEvent("target", {
            target
          });
          const sibling = document.elementsFromPoint(x5, y4).filter((el) => {
            const $el = $7(el);
            return $7.matches(el, o2.dragItem) && !$el.hasClass("dragged-item-avatar");
          })[0];
          if (!Metro2.utils.isValue(sibling)) {
            dragItem.appendTo(target);
          } else {
            const $sibling = $7(sibling);
            const $sibling_offset = $sibling.offset();
            const offsetY = y4 - $sibling_offset.top;
            const offsetX = x5 - $sibling_offset.left;
            let side;
            const dim = { w: $sibling.width(), h: $sibling.height() };
            if (offsetX < dim.w / 3 && (offsetY < dim.h / 2 || offsetY > dim.h / 2)) {
              side = "left";
            } else if (offsetX > dim.w * 2 / 3 && (offsetY < dim.h / 2 || offsetY > dim.h / 2)) {
              side = "right";
            } else if (offsetX > dim.w / 3 && offsetX < dim.w * 2 / 3 && offsetY > dim.h / 2) {
              side = "bottom";
            } else {
              side = "top";
            }
            if (!$sibling.hasClass("dragged-item")) {
              if (side === "top" || side === "left") {
                dragItem.insertBefore($sibling);
              } else {
                dragItem.insertAfter($sibling);
              }
            }
          }
        };
        element2.on(Metro2.events.startAll, o2.drawDragMarker ? o2.dragMarker : o2.dragItem, (e_start) => {
          const dragItem = $7(e_start.target).closest(o2.dragItem);
          if (Metro2.utils.isRightMouse(e_start)) {
            return;
          }
          if (this.canDrag !== true) {
            return;
          }
          dragItem.addClass("dragged-item").addClass(o2.clsDragItem);
          const avatar = $7("<div>").addClass("dragged-item-avatar").addClass(o2.clsDragItemAvatar);
          offset = dragItem.offset();
          width = dragItem.width();
          height = dragItem.height();
          shift.top = Metro2.utils.pageXY(e_start).y - offset.top;
          shift.left = Metro2.utils.pageXY(e_start).x - offset.left;
          avatar.css({
            top: offset.top,
            left: offset.left,
            width,
            height
          }).appendTo(body);
          this._fireEvent("drag-start-item", {
            dragItem: dragItem[0],
            avatar: avatar[0]
          });
          doc.on(
            Metro2.events.moveAll,
            (e_move) => {
              move(e_move, avatar, dragItem);
              this._fireEvent("drag-move-item", {
                dragItem: dragItem[0],
                avatar: avatar[0]
              });
              e_move.preventDefault();
            },
            { ns: this.id, passive: false }
          );
          doc.on(
            Metro2.events.stopAll,
            () => {
              this._fireEvent("drag-drop-item", {
                dragItem: dragItem[0],
                avatar: avatar[0]
              });
              dragItem.removeClass("dragged-item").removeClass(o2.clsDragItem);
              avatar.remove();
              doc.off(Metro2.events.moveAll, { ns: this.id });
              doc.off(Metro2.events.stopAll, { ns: this.id });
            },
            { ns: this.id }
          );
          if (o2.drawDragMarker) {
            e_start.preventDefault();
            e_start.stopPropagation();
          }
        });
      },
      on: function() {
        this.canDrag = true;
        this.element.find(".drag-item-marker").show();
      },
      off: function() {
        this.canDrag = false;
        this.element.find(".drag-item-marker").hide();
      },
      toggle: function() {
        this.canDrag = this.canDrag ? this.off() : this.on();
      },
      changeAttribute: function(attributeName) {
        const element2 = this.element;
        const o2 = this.options;
        const changeCanDrag = () => {
          o2.canDtag = JSON.parse(element2.attr("data-can-drag"));
          o2.canDtag ? this.on() : this.off();
        };
        if (attributeName === "data-can-drag") {
          changeCanDrag();
        }
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.off(Metro2.events.startAll, o2.drawDragMarker ? o2.dragMarker : o2.dragItem);
        return element2;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/draggable/draggable.js
  ((Metro2, $7) => {
    "use strict";
    let DraggableDefaultConfig = {
      canDrag: true,
      dragContext: null,
      draggableDeferred: 0,
      dragElement: "self",
      dragArea: "parent",
      timeout: 0,
      boundaryRestriction: true,
      onCanDrag: Metro2.noop_true,
      onDragStart: Metro2.noop,
      onDragStop: Metro2.noop,
      onDragMove: Metro2.noop,
      onDraggableCreate: Metro2.noop
    };
    Metro2.draggableSetup = (options) => {
      DraggableDefaultConfig = $7.extend({}, DraggableDefaultConfig, options);
    };
    if (typeof globalThis.metroDraggableSetup !== "undefined") {
      Metro2.draggableSetup(globalThis.metroDraggableSetup);
    }
    Metro2.Component("draggable", {
      init: function(options, elem) {
        this._super(elem, options, DraggableDefaultConfig, {
          drag: false,
          move: false,
          backup: {
            cursor: "default",
            zIndex: "0"
          },
          dragArea: null,
          dragElement: null,
          id: null
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("draggable-create", {
          element: this.element
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const offset = element2.offset();
        const dragElement = o2.dragElement !== "self" ? element2.find(o2.dragElement) : element2;
        element2.attr("data-can-drag", o2.canDrag);
        this.dragElement = dragElement;
        dragElement[0].ondragstart = () => false;
        element2.css("position", "absolute");
        if (o2.dragArea === "document" || o2.dragArea === "window") {
          o2.dragArea = "body";
        }
        setTimeout(() => {
          this.dragArea = o2.dragArea === "parent" ? element2.parent() : $7(o2.dragArea);
          if (this.dragArea.css("position") === "static") {
            this.dragArea.css("position", "relative");
          }
          if (o2.dragArea !== "parent") {
            element2.appendTo(this.dragArea);
            element2.css({
              top: offset.top,
              left: offset.left
            });
          }
        });
        if (!element2.attr("id")) {
          element2.attr("id", Hooks.useId(this.elem));
        }
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        const position = {
          x: 0,
          y: 0
        };
        this.dragElement.on(Metro2.events.startAll, (e2) => {
          if (o2.canDrag !== true) {
            return;
          }
          const coord = element2.position();
          const shiftX = Metro2.utils.pageXY(e2).x - coord.left;
          const shiftY = Metro2.utils.pageXY(e2).y - coord.top;
          const moveElement = (e3) => {
            let top = Metro2.utils.pageXY(e3).y - shiftY;
            let left = Metro2.utils.pageXY(e3).x - shiftX;
            if (o2.boundaryRestriction) {
              if (top < 0) top = 0;
              if (left < 0) left = 0;
              if (top > this.dragArea.outerHeight() - element2.outerHeight())
                top = this.dragArea.outerHeight() - element2.outerHeight();
              if (left > this.dragArea.outerWidth() - element2.outerWidth())
                left = this.dragArea.outerWidth() - element2.outerWidth();
            }
            position.y = top;
            position.x = left;
            element2.css({
              left,
              top
            });
            this._fireEvent("drag-move", {
              position,
              context: o2.dragContext
            });
          };
          if (element2.data("canDrag") === false || Metro2.utils.exec(o2.onCanDrag, [element2]) !== true) {
            return;
          }
          if (Metro2.isTouchable === false && e2.which !== 1) {
            return;
          }
          this.drag = true;
          element2.addClass("draggable");
          this._fireEvent("drag-start", {
            position,
            context: o2.dragContext
          });
          $7(document).on(Metro2.events.moveAll, moveElement, { ns: this.id, passive: false });
          $7(document).on(
            Metro2.events.stopAll,
            () => {
              element2.removeClass("draggable");
              $7(document).off(Metro2.events.moveAll, { ns: this.id });
              $7(document).off(Metro2.events.stopAll, { ns: this.id });
              this.drag = false;
              this.move = false;
              this._fireEvent("drag-stop", {
                position,
                context: o2.dragContext
              });
            },
            { ns: this.id }
          );
        });
      },
      off: function() {
        this.element.data("canDrag", false);
      },
      on: function() {
        this.element.data("canDrag", true);
      },
      changeAttribute: function(attr, val) {
        const o2 = this.options;
        if (attr === "data-can-drag") {
          o2.canDrag = JSON.parse(val);
        }
      },
      destroy: function() {
        const element2 = this.element;
        this.dragElement.off(Metro2.events.startAll);
        return element2;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/eval/eval.js
  ((Metro2, $7) => {
    "use strict";
    let EvalDefaultConfig = {
      enabled: true,
      logErrors: false,
      delimiterStart: "{{",
      delimiterEnd: "}}",
      context: null,
      // контекст выполнения для передачи переменных
      processChild: true
      // обработка дочерних элементов
    };
    Metro2.evalSetup = (options) => {
      EvalDefaultConfig = $7.extend({}, EvalDefaultConfig, options);
    };
    if (typeof globalThis.metroEvalSetup !== "undefined") {
      Metro2.evalSetup(globalThis.metroEvalSetup);
    }
    Metro2.Component("eval", {
      init: function(options, elem) {
        this._super(elem, options, EvalDefaultConfig, {
          origContent: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this.origContent = element2.html();
        if (this.options.enabled) {
          if (this.options.processChild) {
            this._processNodeAndChildren(element2[0]);
          } else {
            element2.text(this.eval(element2.text()));
          }
        }
      },
      _processNodeAndChildren: function(node) {
        if (node.nodeType === 3) {
          node.textContent = this.eval(node.textContent);
          return;
        }
        for (let i3 = 0; i3 < node.childNodes.length; i3++) {
          this._processNodeAndChildren(node.childNodes[i3]);
        }
      },
      eval: function(str2) {
        const o2 = this.options;
        if (!o2.enabled) return str2;
        const regex = new RegExp(
          `${this._escapeRegExp(o2.delimiterStart || "{{")}(.*?)${this._escapeRegExp(o2.delimiterEnd || "}}")}`,
          "gs"
        );
        return str2.replace(regex, (match, code) => {
          try {
            const fn = new Function(`return ${code}`);
            return fn.call(o2.context);
          } catch (error) {
            if (o2.logErrors) {
              console.error("Metro UI Eval error:", error, "in code:", code);
            }
            return match;
          }
        });
      },
      _escapeRegExp: (string) => string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"),
      reset: function() {
        if (this.origContent) {
          this.element.html(this.origContent);
        }
      },
      destroy: function() {
        this.reset();
        return this._super();
      }
    });
    Metro2.evalText = (text, options) => {
      const tempConfig = $7.extend({}, EvalDefaultConfig, options);
      const instance = { options: tempConfig };
      return Metro2.Component("eval").prototype.eval.call(instance, text);
    };
  })(Metro, Dom);

  // ../metroui-lib/source/components/export/export.js
  ((Metro2, $7) => {
    "use strict";
    const Export = {
      init: function() {
        return this;
      },
      options: {
        csvDelimiter: "	",
        csvNewLine: "\r\n",
        includeHeader: true
      },
      setup: function(options) {
        this.options = $7.extend({}, this.options, options);
        return this;
      },
      base64: (data) => globalThis.btoa(unescape(encodeURIComponent(data))),
      b64toBlob: (b64Data, contentType = "", sliceSize = 512) => {
        const byteCharacters = globalThis.atob(b64Data);
        const byteArrays = [];
        let offset;
        for (offset = 0; offset < byteCharacters.length; offset += sliceSize) {
          const slice = byteCharacters.slice(offset, offset + sliceSize);
          const byteNumbers = new Array(slice.length);
          for (let i3 = 0; i3 < slice.length; i3 = i3 + 1) {
            byteNumbers[i3] = slice.charCodeAt(i3);
          }
          const byteArray = new globalThis.Uint8Array(byteNumbers);
          byteArrays.push(byteArray);
        }
        return new Blob(byteArrays, {
          type: contentType
        });
      },
      tableToCSV: function(table, filename, options) {
        let o2;
        let body;
        let head;
        let data = "";
        let row;
        let cell;
        o2 = $7.extend({}, this.options, options);
        const _table = $7(table)[0];
        if (Metro2.utils.bool(o2.includeHeader)) {
          head = _table.querySelectorAll("thead")[0];
          for (let i3 = 0; i3 < head.rows.length; i3++) {
            row = head.rows[i3];
            for (let j5 = 0; j5 < row.cells.length; j5++) {
              cell = row.cells[j5];
              data += (j5 ? o2.csvDelimiter : "") + cell.textContent.trim();
            }
            data += o2.csvNewLine;
          }
        }
        body = _table.querySelectorAll("tbody")[0];
        for (let i3 = 0; i3 < body.rows.length; i3++) {
          row = body.rows[i3];
          for (let j5 = 0; j5 < row.cells.length; j5++) {
            cell = row.cells[j5];
            data += (j5 ? o2.csvDelimiter : "") + cell.textContent.trim();
          }
          data += o2.csvNewLine;
        }
        if (Metro2.utils.isValue(filename)) {
          return this.createDownload(this.base64(`\uFEFF${data}`), "application/csv", filename);
        }
        return data;
      },
      createDownload: function(data, contentType, filename) {
        const anchor = document.createElement("a");
        anchor.style.display = "none";
        document.body.appendChild(anchor);
        const blob = this.b64toBlob(data, contentType);
        const url = globalThis.URL.createObjectURL(blob);
        anchor.href = url;
        anchor.download = filename || Hooks.useId(anchor);
        anchor.click();
        globalThis.URL.revokeObjectURL(url);
        document.body.removeChild(anchor);
        return true;
      },
      arrayToCsv: function(array, filename, options) {
        let o2;
        let data = "";
        let i3;
        let row;
        o2 = $7.extend({}, this.options, options);
        for (i3 = 0; i3 < array.length; i3++) {
          row = array[i3];
          if (typeof row !== "object") {
            data += row + o2.csvNewLine;
          } else {
            $7.each(row, (key, val) => {
              data += (key ? o2.csvDelimiter : "") + val.toString();
            });
            data += o2.csvNewLine;
          }
        }
        if (Metro2.utils.isValue(filename)) {
          return this.createDownload(this.base64(`\uFEFF${data}`), "application/csv", filename);
        }
        return data;
      }
    };
    Metro2.export = Export.init();
  })(Metro, Dom);

  // ../metroui-lib/source/components/file/file.js
  ((Metro2, $7) => {
    "use strict";
    let FileDefaultConfig = {
      fileDeferred: 0,
      label: "",
      mode: "input",
      buttonTitle: "",
      filesSelectedTitle: "",
      dropTitle: "",
      dropIcon: "\u{1F4E5}",
      clearButtonIcon: "\u2716",
      prepend: "",
      clsComponent: "",
      clsPrepend: "",
      clsButton: "",
      clsCaption: "",
      clsLabel: "",
      onSelect: Metro2.noop,
      onFileCreate: Metro2.noop
    };
    Metro2.fileSetup = (options) => {
      FileDefaultConfig = $7.extend({}, FileDefaultConfig, options);
    };
    if (typeof globalThis.metroFileSetup !== "undefined") {
      Metro2.fileSetup(globalThis.metroFileSetup);
    }
    Metro2.Component("file", {
      init: function(options, elem) {
        this._super(elem, options, FileDefaultConfig);
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("file-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.wrap("<div>").addClass(
          (o2.mode === "input" ? " file " : o2.mode === "button" ? " file-button " : " drop-zone ") + element2[0].className
        ).addClass(o2.clsComponent);
        container.attr("id", Hooks.useId(container[0]));
        const caption = $7("<span>").addClass("caption").addClass(o2.clsCaption);
        const files = $7("<span>").addClass("files").addClass(o2.clsCaption);
        let icon;
        let button;
        if (o2.mode.includes("drop")) {
          icon = $7("<span>").addClass("icon").html(o2.dropIcon).appendTo(container);
          caption.html(o2.dropTitle || this.strings.label_drop_file).insertAfter(icon);
          files.html((o2.filesSelectedTitle || this.strings.label_files_selected).replace("{n}", 0)).insertAfter(caption);
          button = $7("<button>").addClass("button clear-button square").html(o2.clearButtonIcon).appendTo(container);
        } else {
          caption.insertBefore(element2);
          button = $7("<button>").attr("type", "button").addClass("button select-files-button").attr("tabindex", -1).html(o2.buttonTitle || this.strings.label_choose_file);
          button.appendTo(container);
          button.addClass(o2.clsButton);
          if (container.hasClass("input-small")) {
            button.addClass("small");
          }
          if (element2.attr("dir") === "rtl") {
            container.addClass("rtl");
          }
          if (o2.prepend !== "") {
            const prepend = $7("<div>").html(o2.prepend);
            prepend.addClass("prepend").addClass(o2.clsPrepend).appendTo(container);
          }
        }
        element2[0].className = "";
        this._addLabel(o2.label, container, {
          className: o2.clsLabel,
          id: container.attr("id"),
          dir: element2.attr("dir")
        });
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.closest(".file, .drop-zone");
        const caption = element2.siblings(".caption");
        const files = element2.siblings(".files");
        const form = element2.closest("form");
        if (form.length) {
          form.on("reset", () => {
            that.clear();
          });
        }
        container.on(Metro2.events.click, ".select-files-button", () => {
          element2[0].click();
        });
        container.on(Metro2.events.click, ".clear-button", () => {
          that.clear();
        });
        element2.on(Metro2.events.change, function() {
          const file_names = [];
          let entry;
          const _files = Array.from(this.files);
          for (const file of _files) {
            file_names.push(file.name);
          }
          if (o2.mode === "input") {
            entry = file_names.join(", ");
            caption.html(entry);
            caption.attr("title", entry);
          } else {
            files.html(
              (o2.filesSelectedTitle || that.strings.label_files_selected).replace(
                "{n}",
                element2[0].files.length
              )
            );
          }
          that._fireEvent("select", {
            files: this.files
          });
        });
        element2.on(Metro2.events.focus, () => {
          container.addClass("focused");
        });
        element2.on(Metro2.events.blur, () => {
          container.removeClass("focused");
        });
        if (o2.mode !== "input") {
          container.on(Metro2.events.click, () => {
            element2[0].click();
          });
          container.on("drag dragstart dragend dragover dragenter dragleave drop", (e2) => {
            e2.preventDefault();
          });
          container.on("dragenter dragover", () => {
            container.addClass("drop-on");
          });
          container.on("dragleave", () => {
            container.removeClass("drop-on");
          });
          container.on("drop", (e2) => {
            element2[0].files = e2.dataTransfer.files;
            files.html(
              (o2.filesSelectedTitle || that.strings.label_files_selected).replace(
                "{n}",
                element2[0].files.length
              )
            );
            container.removeClass("drop-on");
            element2.trigger("change");
          });
        }
      },
      clear: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (o2.mode === "input") {
          element2.siblings(".caption").html("");
        } else {
          element2.siblings(".files").html((o2.filesSelectedTitle || this.strings.label_files_selected).replace("{n}", 0));
        }
        element2[0].value = "";
        element2.trigger("change");
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      toggleDir: function() {
        if (this.element.attr("dir") === "rtl") {
          this.element.parent().addClass("rtl");
        } else {
          this.element.parent().removeClass("rtl");
        }
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "disabled":
            this.toggleState();
            break;
          case "dir":
            this.toggleDir();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        const parent2 = element2.parent();
        element2.off(Metro2.events.change);
        parent2.off(Metro2.events.click, "button");
        if (o2.label) {
          parent2.prev("label").remove();
        }
        parent2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/gauge/gauge.js
  ((Metro2, $7) => {
    "use strict";
    let GaugeDefaultConfig = {
      min: 0,
      max: 100,
      value: 0,
      size: 0,
      labelMin: "",
      labelMax: "",
      label: "",
      suffix: "",
      values: 10,
      segments: 10,
      startAngle: 235,
      range: 250,
      theme: "",
      onGaugeCreate: Metro2.noop
    };
    Metro2.gaugeSetup = (options) => {
      GaugeDefaultConfig = $7.extend({}, GaugeDefaultConfig, options);
    };
    if (typeof globalThis.metroGaugeSetup !== "undefined") {
      Metro2.gaugeSetup(globalThis.metroGaugeSetup);
    }
    Metro2.Component("gauge", {
      init: function(options, elem) {
        this._super(elem, options, GaugeDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2[0].style.setProperty("--analog-gauge-segments", `${o2.segments}`);
        element2[0].style.setProperty("--analog-gauge-start-angle", `${o2.startAngle}deg`);
        element2[0].style.setProperty("--analog-gauge-range", `${o2.range}deg`);
        this.options.range = Number.parseFloat(
          getComputedStyle(element2[0]).getPropertyValue("--analog-gauge-range")
        );
        this.options.start = Number.parseFloat(
          getComputedStyle(element2[0]).getPropertyValue("--analog-gauge-start-angle")
        );
        this.options.defaultMark = 90;
        this.options.defaultNeedle = 270;
        this.options.minDegree = this.options.start - this.options.defaultNeedle;
        this._createStructure();
        this._createEvents();
        this.update();
        this._fireEvent("gauge-create");
      },
      _generateMarks: function() {
        const o2 = this.options;
        const values = `${o2.values}`.trim();
        if (values === "") return "";
        const t = values.toArray(",");
        let valueArray = [];
        let count;
        if (t.length === 1) {
          valueArray = Array.from(
            { length: +values },
            (_5, i3) => Math.round(o2.min + i3 * (o2.max - o2.min) / (+values - 1 || 1))
          );
          count = Number.parseInt(values);
        } else {
          valueArray = [...t];
          count = t.length;
        }
        const degreeStep = o2.range / (count - 1 || 1);
        return `
                <ul class="value-marks">
                  ${valueArray.map((value, i3) => {
          const degree = o2.start - o2.defaultMark + i3 * degreeStep;
          return `<li style="--_d:${degree}deg" class="mark">${value}</li>`;
        }).join("")}
                </ul>
            `;
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("analog-gauge");
        if (o2.size) {
          element2.css({
            width: o2.size,
            height: o2.size
          });
        }
        element2.html(`
                <div class="gauge"></div>
                ${this._generateMarks()} 
                <div class="needle"></div> 
                <div class="value">${o2.value}</div> 
                <div class="label">${o2.label}</div> 
                <div class="label-min">${o2.labelMin}</div> 
                <div class="label-max">${o2.labelMax}</div> 
            `);
        if (o2.theme) {
          element2.addClass(`theme-${o2.theme}`);
        }
      },
      _createEvents: () => {
      },
      val: function(value) {
        if (typeof value === "undefined") {
          return this.options.value;
        }
        this.options.value = value;
        this.update();
      },
      update: function() {
        const element2 = this.element;
        const elem = this.elem;
        const o2 = this.options;
        const normalizedValue = Math.max(o2.min, Math.min(o2.max, o2.value));
        const valuePercentage = (normalizedValue - o2.min) / (o2.max - o2.min);
        const degree = o2.minDegree + valuePercentage * o2.range;
        elem.style.setProperty("--analog-gauge-value", `${valuePercentage * o2.range}deg`);
        elem.style.setProperty("--_d", `${degree}deg`);
        element2.find(".value").html(o2.value + o2.suffix);
      },
      changeAttribute: (attr, val) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/gradient-box/gradient-box.js
  ((Metro2, $7) => {
    "use strict";
    let GradientBoxDefaultConfig = {
      gradientType: "linear",
      // linear, radial
      gradientShape: "",
      gradientPosition: "",
      gradientSize: "",
      gradientColors: "#000, #fff",
      gradientRepeat: false,
      onGradientBoxCreate: Metro2.noop
    };
    Metro2.gradientBoxSetup = (options) => {
      GradientBoxDefaultConfig = $7.extend({}, GradientBoxDefaultConfig, options);
    };
    if (typeof globalThis.metroGradientBoxSetup !== "undefined") {
      Metro2.gradientBoxSetup(globalThis.metroGradientBoxSetup);
    }
    Metro2.Component("gradient-box", {
      init: function(options, elem) {
        this._super(elem, options, GradientBoxDefaultConfig, {
          // define instance vars here
          colors: [],
          shape: "",
          size: "",
          position: "",
          type: "linear",
          func: "linear-gradient",
          repeat: false
        });
        return this;
      },
      _create: function() {
        const o2 = this.options;
        this.colors = o2.gradientColors.toArray(",");
        this.type = o2.gradientType.toLowerCase();
        this.shape = o2.gradientShape.toLowerCase();
        this.size = o2.gradientSize.toLowerCase();
        this.repeat = o2.gradientRepeat;
        this.func = `${(this.repeat ? "repeating-" : "") + this.type}-gradient`;
        if (this.type === "linear") {
          if (!o2.gradientPosition) {
            this.position = "to bottom";
          } else {
            this.position = isNaN(o2.gradientPosition) === false ? `${o2.gradientPosition}deg` : o2.gradientPosition;
            if (this.position.indexOf("deg") === -1 && this.position.indexOf("to ") === -1) {
              this.position = `to ${this.position}`;
            }
          }
        } else {
          this.position = o2.gradientPosition.toLowerCase();
          if (this.position && this.position.indexOf("at ") === -1) {
            this.position = `at ${this.position}`;
          }
        }
        this._createStructure();
        this._setGradient();
        this._fireEvent("gradient-box-create");
      },
      _createStructure: function() {
        this.element.addClass("gradient-box");
      },
      _setGradient: function() {
        const element2 = this.element;
        const gradientOptions = [];
        if (this.type === "radial" && this.shape) {
          gradientOptions.push(this.shape);
        }
        if (this.type === "radial" && this.size) {
          gradientOptions.push(this.size);
        }
        if (this.position) {
        }
        const gradientRule = `${this.func}(${gradientOptions.length ? `${gradientOptions.join(" ")}, ` : ""}${this.colors.join(", ")})`;
        element2.css({
          background: gradientRule
        });
      },
      changeAttribute: function(attr, newValue) {
        if (attr.indexOf("data-gradient-") === -1) {
          return;
        }
        switch (attr) {
          case "data-gradient-type":
            this.type = newValue;
            this.func = `${newValue.toLowerCase()}-gradient`;
            break;
          case "data-gradient-colors-css":
            this.colors = newValue ? newValue.toArray(",") : ["#fff", "#000"];
            break;
          case "data-gradient-shape":
            this.shape = newValue.toLowerCase();
            break;
          case "data-gradient-size":
            this.size = newValue.toLowerCase();
            break;
          case "data-gradient-position":
            this.position = newValue.toLowerCase();
            break;
          case "data-gradient-repeat":
            this.repeat = Metro2.utils.bool(newValue);
            break;
        }
        this._setGradient();
      },
      destroy: function() {
        return this.element;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/gravatar/gravatar.js
  ((Metro2, $7) => {
    "use strict";
    let GravatarDefaultConfig = {
      gravatarDeferred: 0,
      email: "",
      size: 80,
      default: "mp",
      onGravatarCreate: Metro2.noop
    };
    Metro2.gravatarSetup = (options) => {
      GravatarDefaultConfig = $7.extend({}, GravatarDefaultConfig, options);
    };
    if (typeof globalThis.metroGravatarSetup !== "undefined") {
      Metro2.gravatarSetup(globalThis.metroGravatarSetup);
    }
    Metro2.Component("gravatar", {
      init: function(options, elem) {
        this._super(elem, options, GravatarDefaultConfig);
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this.get();
        this._fireEvent("gravatar-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (element2[0].tagName !== "IMG") {
          element2.html("<img alt='' src='' />");
        }
        element2.addClass("gravatar");
        element2.css({
          height: o2.size + "px",
          width: o2.size + "px"
        });
      },
      getImage: function(email, size, def, is_object) {
        const image = $7("<img>").attr("alt", email);
        image.attr("src", this.getImageSrc(email, size));
        return is_object === true ? image : image[0];
      },
      getImageSrc: (email, size = 80, def = "404") => {
        if (email === void 0 || email.trim() === "") {
          return "";
        }
        return `https://www.gravatar.com/avatar/${Metro2.md5(email.toLowerCase().trim())}?size=${size}&d=${Metro2.utils.encodeURI(def)}`;
      },
      get: function() {
        const element2 = this.element;
        const o2 = this.options;
        const img = element2[0].tagName === "IMG" ? element2 : element2.find("img");
        if (img.length === 0) {
          return;
        }
        img.attr("src", this.getImageSrc(o2.email, o2.size, o2.default));
        return this;
      },
      resize: function(new_size) {
        this.options.size = new_size !== void 0 ? new_size : this.element.attr("data-size");
        this.get();
      },
      email: function(new_email) {
        this.options.email = new_email !== void 0 ? new_email : this.element.attr("data-email");
        this.get();
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-size":
            this.resize();
            break;
          case "data-email":
            this.email();
            break;
        }
      },
      destroy: function() {
        return this.element;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/hint/hint.js
  ((Metro2, $7) => {
    "use strict";
    let HintDefaultConfig = {
      hintDeferred: 0,
      hintHide: 5e3,
      clsHint: "",
      hintText: "",
      hintPosition: Metro2.position.TOP,
      hintOffset: 4,
      onHintShow: Metro2.noop,
      onHintHide: Metro2.noop,
      onHintCreate: Metro2.noop
    };
    Metro2.hintSetup = (options) => {
      HintDefaultConfig = $7.extend({}, HintDefaultConfig, options);
    };
    if (typeof globalThis.metroHintSetup !== "undefined") {
      Metro2.hintSetup(globalThis.metroHintSetup);
    }
    Metro2.Component("hint", {
      init: function(options, elem) {
        this._super(elem, options, HintDefaultConfig, {
          hint: null,
          hint_size: {
            width: 0,
            height: 0
          },
          id: null
        });
        return this;
      },
      _create: function() {
        this.id = Hooks.useId(this.element);
        this._createEvents();
        this._fireEvent("hint-create", {
          element: this.element
        });
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        let over = false;
        element2.on(Metro2.events.enter, () => {
          over = true;
          setTimeout(() => {
            if (!over) return;
            this.createHint();
            if (+o2.hintHide > 0) {
              setTimeout(() => {
                this.removeHint();
              }, o2.hintHide);
            }
          }, o2.hintDeferred);
        });
        element2.on(Metro2.events.leave, () => {
          over = false;
          this.removeHint();
        });
        $7(globalThis).on(
          `${Metro2.events.scroll} ${Metro2.events.resize}`,
          () => {
            if (this.hint !== null) this.setPosition();
          },
          { ns: this.id }
        );
      },
      createHint: function() {
        const elem = this.elem;
        const element2 = this.element;
        const o2 = this.options;
        const hint = $7("<div>").addClass("hint").addClass(o2.clsHint).html(o2.hintText);
        this.hint = hint;
        this.hint_size = Metro2.utils.hiddenElementSize(hint);
        $7(".hint:not(.permanent-hint)").remove();
        if (elem.tagName === "TD" || elem.tagName === "TH") {
          const wrp = $7("<div/>").css("display", "inline-block").html(element2.html());
          element2.html(wrp);
          this.element = wrp;
        }
        this.setPosition();
        hint.appendTo($7("body"));
        this._fireEvent("hint-show", {
          hint: hint[0]
        });
      },
      setPosition: function() {
        const hint = this.hint;
        const hint_size = this.hint_size;
        const o2 = this.options;
        const element2 = this.element;
        if (o2.hintPosition === Metro2.position.BOTTOM) {
          hint.addClass("bottom");
          hint.css({
            top: element2.offset().top - $7(globalThis).scrollTop() + element2.outerHeight() + o2.hintOffset,
            left: element2.offset().left + element2.outerWidth() / 2 - hint_size.width / 2 - $7(globalThis).scrollLeft()
          });
        } else if (o2.hintPosition === Metro2.position.RIGHT) {
          hint.addClass("right");
          hint.css({
            top: element2.offset().top + element2.outerHeight() / 2 - hint_size.height / 2 - $7(globalThis).scrollTop(),
            left: element2.offset().left + element2.outerWidth() - $7(globalThis).scrollLeft() + o2.hintOffset
          });
        } else if (o2.hintPosition === Metro2.position.LEFT) {
          hint.addClass("left");
          hint.css({
            top: element2.offset().top + element2.outerHeight() / 2 - hint_size.height / 2 - $7(globalThis).scrollTop(),
            left: element2.offset().left - hint_size.width - $7(globalThis).scrollLeft() - o2.hintOffset
          });
        } else {
          hint.addClass("top");
          hint.css({
            top: element2.offset().top - $7(globalThis).scrollTop() - hint_size.height - o2.hintOffset,
            left: element2.offset().left - $7(globalThis).scrollLeft() + element2.outerWidth() / 2 - hint_size.width / 2
          });
        }
      },
      removeHint: function() {
        const hint = this.hint;
        const options = this.options;
        const timeout = options.onHintHide === Metro2.noop ? 0 : 300;
        if (hint !== null) {
          this._fireEvent("hint-hide", {
            hint: hint[0]
          });
          setTimeout(() => {
            hint.hide(0, () => {
              hint.remove();
              this.hint = null;
            });
          }, timeout);
        }
      },
      changeText: function() {
        this.options.hintText = this.element.attr("data-hint-text");
      },
      changeAttribute: function(attributeName) {
        if (attributeName === "data-hint-text") {
          this.changeText();
        }
      },
      destroy: function() {
        const element2 = this.element;
        this.removeHint();
        element2.off(`${Metro2.events.enter}-hint`);
        element2.off(`${Metro2.events.leave}-hint`);
        $7(globalThis).off(`${Metro2.events.scroll}-hint`);
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/hotkey/hotkey.js
  ((Metro2, $7) => {
    "use strict";
    if (typeof Metro2.hotkeys === "undefined") {
      Metro2.hotkeys = {};
    }
    const Hotkey = {
      specialKeys: {
        8: "backspace",
        9: "tab",
        13: "return",
        16: "shift",
        17: "ctrl",
        18: "alt",
        19: "pause",
        20: "capslock",
        27: "esc",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down",
        45: "insert",
        46: "del",
        96: "0",
        97: "1",
        98: "2",
        99: "3",
        100: "4",
        101: "5",
        102: "6",
        103: "7",
        104: "8",
        105: "9",
        106: "*",
        107: "+",
        109: "-",
        110: ".",
        111: "/",
        112: "f1",
        113: "f2",
        114: "f3",
        115: "f4",
        116: "f5",
        117: "f6",
        118: "f7",
        119: "f8",
        120: "f9",
        121: "f10",
        122: "f11",
        123: "f12",
        144: "numlock",
        145: "scroll",
        188: ",",
        190: ".",
        191: "/",
        91: "meta",
        // Левая клавиша Win
        92: "meta",
        // Правая клавиша Win
        93: "meta",
        // Контекстное меню
        224: "meta"
        // Meta в Firefox
      },
      shiftNums: {
        "~": "`",
        "!": "1",
        "@": "2",
        "#": "3",
        $: "4",
        "%": "5",
        "^": "6",
        "&": "7",
        "*": "8",
        "(": "9",
        ")": "0",
        _: "-",
        "+": "=",
        ":": ";",
        '"': "'",
        "<": ",",
        ">": ".",
        "?": "/",
        "|": "\\"
      },
      shiftNumsInverse: {
        "`": "~",
        1: "!",
        2: "@",
        3: "#",
        4: "$",
        5: "%",
        6: "^",
        7: "&",
        8: "*",
        9: "(",
        0: ")",
        "-": "_",
        "=": "+",
        ";": ": ",
        "'": '"',
        ",": "<",
        ".": ">",
        "/": "?",
        "\\": "|"
      },
      textAcceptingInputTypes: [
        "text",
        "password",
        "number",
        "email",
        "url",
        "range",
        "date",
        "month",
        "week",
        "time",
        "datetime",
        "datetime-local",
        "search",
        "color",
        "tel"
      ],
      // Змінні для комбінованих хоткеїв
      pendingKey: null,
      pendingTimeout: 1e3,
      pendingTimer: null,
      normalizeKey: (key) => {
        if (key.includes(" ")) {
          const parts2 = key.split(" ");
          return parts2.map(Hotkey.normalizeKey).join(" ");
        }
        if (!key.includes("+")) {
          return key;
        }
        const parts = key.split("+");
        const mainKey = parts.pop();
        const modifiers = parts.filter((mod) => ["alt", "ctrl", "meta", "shift"].includes(mod));
        modifiers.sort((a2, b5) => {
          const order = { alt: 1, ctrl: 2, meta: 3, shift: 4 };
          return order[a2] - order[b5];
        });
        return modifiers.length ? `${modifiers.join("+")}+${mainKey}` : mainKey;
      },
      getKey: (e2) => {
        let key;
        const k5 = e2.keyCode;
        const char = String.fromCharCode(k5).toLowerCase();
        if ([91, 92, 93, 224].includes(k5)) {
          key = "meta";
        } else if (k5 === 18) {
          key = "alt";
        } else if (k5 === 17) {
          key = "ctrl";
        } else if (k5 === 16) {
          key = "shift";
        } else if (e2.shiftKey) {
          key = Hotkey.shiftNums[char] ? Hotkey.shiftNums[char] : char;
        } else {
          key = Hotkey.specialKeys[k5] === void 0 ? char : Hotkey.specialKeys[k5];
        }
        const modifiers = Hotkey.getModifier(e2);
        if (["alt", "ctrl", "meta", "shift"].includes(key) && modifiers.includes(key)) {
          return modifiers.join("+");
        }
        return modifiers.length ? `${modifiers.join("+")}+${key}` : key;
      },
      getModifier: (e2) => {
        const m5 = [];
        if (e2.altKey) {
          m5.push("alt");
        }
        if (e2.ctrlKey) {
          m5.push("ctrl");
        }
        if (e2.metaKey) {
          m5.push("meta");
        }
        if (e2.shiftKey) {
          m5.push("shift");
        }
        return m5;
      },
      // Метод для формування комбінованого хоткея
      createChordKey: (firstPart, secondPart) => {
        return `${firstPart} ${secondPart}`;
      },
      // Метод для перевірки, чи є ключ в Metro.hotkeys як частина комбінованого хоткея
      isPartOfChordKey: (key) => {
        return Object.keys(Metro2.hotkeys).some((hotkey) => hotkey.split(" ")[0] === key);
      },
      // Спільна функція для виконання дії хоткея
      executeHotkeyAction: (hotkeyConfig, e2) => {
        const el = $7(hotkeyConfig[0]);
        const fn = hotkeyConfig[1];
        const href = `${el.attr("href")}`.trim();
        if (e2.repeat && !el.attr("data-repeat")) {
          return false;
        }
        e2.preventDefault();
        if (fn) {
          Metro2.utils.exec(fn);
        } else {
          if (el.is("a") && href && href.length > 0 && href.trim() !== "#") {
            globalThis.location.href = href;
          } else {
            el[0].click();
          }
        }
        return true;
      },
      // Функція для очищення очікування для комбінованого хоткея
      clearPending: () => {
        clearTimeout(Hotkey.pendingTimer);
        Hotkey.pendingKey = null;
      },
      // Функція для встановлення очікування другої частини комбінованого хоткея
      setPending: (key) => {
        Hotkey.pendingKey = key;
        clearTimeout(Hotkey.pendingTimer);
        Hotkey.pendingTimer = setTimeout(Hotkey.clearPending, Hotkey.pendingTimeout);
      }
    };
    function hotkeyHandler(e2) {
      const key = Hotkey.getKey(e2);
      const normalizedKey = Hotkey.normalizeKey(key);
      if (Hotkey.pendingKey !== null) {
        const chordKey = Hotkey.createChordKey(Hotkey.pendingKey, normalizedKey);
        for (const hotkeyName in Metro2.hotkeys) {
          if (Hotkey.normalizeKey(hotkeyName) === chordKey) {
            if (Hotkey.executeHotkeyAction(Metro2.hotkeys[hotkeyName], e2)) {
              Hotkey.clearPending();
              return;
            }
          }
        }
      }
      const isPartOfChord = Object.keys(Metro2.hotkeys).some((hotkey) => {
        const parts = hotkey.split(" ");
        return parts.length > 1 && Hotkey.normalizeKey(parts[0]) === normalizedKey;
      });
      if (isPartOfChord) {
        Hotkey.setPending(normalizedKey);
      }
      for (const hotkeyName in Metro2.hotkeys) {
        if (!hotkeyName.includes(" ") && Hotkey.normalizeKey(hotkeyName) === normalizedKey) {
          Hotkey.executeHotkeyAction(Metro2.hotkeys[hotkeyName], e2);
          return;
        }
      }
    }
    function bindKey(key, fn) {
      const normalizedKey = Hotkey.normalizeKey(key);
      return this.each(function() {
        const el = $7(this);
        const isInputElement = el.is("input, textarea") || el.attr("contenteditable") === "true";
        if (isInputElement) {
          const wrappedHandler = (e2, pressedKey) => {
            Metro2.utils.exec(fn, [e2, pressedKey, key], el[0]);
          };
          el.on(`${Metro2.events.keydown}.hotkey-data-${key}`, (e2) => {
            const pressedKey = Hotkey.getKey(e2);
            const normalizedPressedKey = Hotkey.normalizeKey(pressedKey);
            if (Hotkey.pendingKey !== null) {
              const chordKey = Hotkey.createChordKey(Hotkey.pendingKey, normalizedPressedKey);
              if (normalizedKey === chordKey) {
                Hotkey.clearPending();
                e2.preventDefault();
                wrappedHandler(e2, pressedKey);
                return;
              }
            }
            if (normalizedKey.includes(" ")) {
              const keyParts = normalizedKey.split(" ");
              if (normalizedPressedKey === Hotkey.normalizeKey(keyParts[0])) {
                Hotkey.setPending(normalizedPressedKey);
                return;
              }
            }
            if (normalizedKey === normalizedPressedKey) {
              e2.preventDefault();
              wrappedHandler(e2, pressedKey);
            }
          });
        } else {
          Metro2.hotkeys[key] = [el, fn];
        }
      });
    }
    $7.fn.hotkey = bindKey;
    if (globalThis.METRO_JQUERY && globalThis.jquery_present) {
      globalThis.jQuery.fn.hotkey = bindKey;
    }
    $7(document).on(`${Metro2.events.keydown}.hotkey-data`, hotkeyHandler);
  })(Metro, Dom);

  // ../metroui-lib/source/components/hover-box/hover-box.js
  ((Metro2, $7) => {
    "use strict";
    let HoverBoxDefaultConfig = {
      onHoverBoxCreate: Metro2.noop
    };
    Metro2.hoverBoxSetup = (options) => {
      HoverBoxDefaultConfig = $7.extend({}, HoverBoxDefaultConfig, options);
    };
    if (typeof window.metroHoverBoxSetup !== "undefined") {
      Metro2.hoverBoxSetup(window.metroHoverBoxSetup);
    }
    Metro2.Component("hoverbox", {
      init: function(options, elem) {
        this._super(elem, options, HoverBoxDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("hover-box-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        element2.addClass("hover-box");
        element2.cssVar("size", `${element2.height() / 2}px`);
      },
      _createEvents: function() {
        const element2 = this.element;
        element2.on(Metro2.events.move, (e2) => {
          const rect = element2[0].getBoundingClientRect();
          const x5 = e2.pageX - (rect.left + window.scrollX);
          const y4 = e2.pageY - (rect.top + window.scrollY);
          element2.cssVar("x", `${Math.round(x5)}px`).cssVar("y", `${Math.round(y4)}px`);
        });
      },
      changeAttribute: (attr, newValue) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/html-container/html-container.js
  ((Metro2, $7) => {
    "use strict";
    let HtmlContainerDefaultConfig = {
      htmlContainerDeferred: 0,
      method: "get",
      htmlSource: null,
      requestData: null,
      requestOptions: null,
      insertMode: "default",
      // replace, append, prepend
      onHtmlLoad: Metro2.noop,
      onHtmlLoadFail: Metro2.noop,
      onHtmlLoadDone: Metro2.noop,
      onHtmlContainerCreate: Metro2.noop
    };
    Metro2.htmlContainerSetup = (options) => {
      HtmlContainerDefaultConfig = $7.extend({}, HtmlContainerDefaultConfig, options);
    };
    if (typeof globalThis.metroHtmlContainerSetup !== "undefined") {
      Metro2.htmlContainerSetup(globalThis.metroHtmlContainerSetup);
    }
    Metro2.Component("html-container", {
      init: function(options, elem) {
        this._super(elem, options, HtmlContainerDefaultConfig, {
          data: null,
          opt: {},
          htmlSource: ""
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (typeof o2.requestData === "string") {
          o2.requestData = JSON.parse(o2.requestData);
        }
        if (Metro2.utils.isObject(o2.requestData)) {
          this.data = Metro2.utils.isObject(o2.requestData);
        }
        if (typeof o2.requestOptions === "string") {
          o2.requestOptions = JSON.parse(o2.requestOptions);
        }
        if (Metro2.utils.isObject(o2.requestOptions)) {
          this.opt = Metro2.utils.isObject(o2.requestOptions);
        }
        o2.method = o2.method.toUpperCase();
        if (Metro2.utils.isValue(o2.htmlSource)) {
          this.htmlSource = o2.htmlSource;
          this._load();
        }
        this._fireEvent("html-container-create", {
          element: element2
        });
      },
      _load: function() {
        const element2 = this.element;
        const o2 = this.options;
        const fetchData = {
          method: o2.method
        };
        if (this.data) fetchData.body = this.data;
        if (this.opt) fetchData.headers = this.opt;
        fetch(this.htmlSource, fetchData).then(Metro2.fetch.status).then(Metro2.fetch.text).then((data) => {
          let _data = $7(data);
          if (_data.length === 0) {
            _data = $7("<div>").html(data);
          }
          switch (o2.insertMode.toLowerCase()) {
            case "prepend":
              element2.prepend(_data);
              break;
            case "append":
              element2.append(_data);
              break;
            case "replace":
              _data.insertBefore(element2).script();
              element2.remove();
              break;
            default: {
              element2.html(_data);
            }
          }
          this._fireEvent("html-load", {
            data,
            source: o2.htmlSource,
            requestData: this.data,
            requestOptions: this.opt
          });
        }).catch((error) => {
          this._fireEvent("html-load-fail", {
            error
          });
        });
      },
      load: function(source, data, opt2) {
        if (source) {
          this.htmlSource = source;
        }
        if (data) {
          this.data = Metro2.utils.isObject(data);
        }
        if (opt2) {
          this.opt = Metro2.utils.isObject(opt2);
        }
        this._load();
      },
      changeAttribute: function(attributeName) {
        const element2 = this.element;
        const o2 = this.options;
        const changeHTMLSource = () => {
          const html = element2.attr("data-html-source");
          if (Metro2.utils.isNull(html)) {
            return;
          }
          if (html.trim() === "") {
            element2.html("");
          }
          o2.htmlSource = html;
          this._load();
        };
        const changeInsertMode = () => {
          const attr = element2.attr("data-insert-mode");
          if (Metro2.utils.isValue(attr)) {
            o2.insertMode = attr;
          }
        };
        const changeRequestData = () => {
          const data = element2.attr("data-request-data");
          this.load(o2.htmlSource, data);
        };
        switch (attributeName) {
          case "data-html-source":
            changeHTMLSource();
            break;
          case "data-insert-mode":
            changeInsertMode();
            break;
          case "data-request-data":
            changeRequestData();
            break;
        }
      },
      destroy: () => {
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/image-box/image-box.js
  ((Metro2, $7) => {
    "use strict";
    let ImageBoxDefaultConfig = {
      image: null,
      size: "cover",
      repeat: false,
      color: "transparent",
      attachment: "scroll",
      origin: "border",
      onImageBoxCreate: Metro2.noop
    };
    Metro2.imageBoxSetup = (options) => {
      ImageBoxDefaultConfig = $7.extend({}, ImageBoxDefaultConfig, options);
    };
    if (typeof globalThis.metroImageBoxSetup !== "undefined") {
      Metro2.imageBoxSetup(globalThis.metroImageBoxSetup);
    }
    Metro2.Component("image-box", {
      init: function(options, elem) {
        this._super(elem, options, ImageBoxDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._fireEvent("image-box-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        element2.addClass("image-box");
        this._drawImage();
      },
      _drawImage: function() {
        const element2 = this.element;
        const o2 = this.options;
        const image = new Image();
        let portrait;
        if (!element2.attr("data-original")) element2.attr("data-original", o2.image);
        element2.css({
          backgroundImage: `url(${o2.image})`,
          backgroundSize: o2.size,
          backgroundRepeat: o2.repeat ? "repeat" : "no-repeat",
          backgroundColor: o2.color,
          backgroundAttachment: o2.attachment,
          backgroundOrigin: o2.origin
        });
        image.src = o2.image;
        image.onload = function() {
          portrait = this.height >= this.width;
          element2.removeClass("image-box__portrait image-box__landscape").addClass(`image-box__${portrait ? "portrait" : "landscape"}`);
        };
      },
      changeAttribute: function(attr, newValue) {
        const attrName = attr.replace("data-", "");
        if (["image", "size", "repeat", "color", "attachment", "origin"].indexOf(attrName) > -1) {
          this.options[attrName] = newValue;
          this._drawImage();
        }
      },
      destroy: function() {
        return this.element;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/image-carousel/image-carousel.js
  ((Metro2, $7) => {
    "use strict";
    let ImageCarouselDefaultConfig = {
      thumbnailSize: null,
      animationDuration: 300,
      animationEasing: "linear",
      onSlideChange: Metro2.noop,
      onCarouselCreate: Metro2.noop
    };
    Metro2.imageCarouselSetup = (options) => {
      ImageCarouselDefaultConfig = $7.extend({}, ImageCarouselDefaultConfig, options);
    };
    if (typeof window.metroImageCarouselSetup !== "undefined") {
      Metro2.imageCarouselSetup(window.metroImageCarouselSetup);
    }
    Metro2.Component("image-carousel", {
      init: function(options, elem) {
        this._super(elem, options, ImageCarouselDefaultConfig, {
          // define instance vars here
          scene: null,
          nextButton: null,
          prevButton: null,
          images: [],
          index: 0,
          animation: false
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("image-carousel");
        if (o2.thumbnailSize) {
          element2.cssVar("thumbnail-size", `${o2.thumbnailSize}px`);
        }
        this._createStructure();
        this._createEvents();
        this._fireEvent("carousel-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        this.images = [...element2.children("img").hide()];
        this.scene = $7("<div>").addClass("scene").html("Scene").appendTo(element2);
        this.scene.css({
          height: Metro2.utils.getInnerSize(this.scene).width
        });
        const thumbnails = $7("<div>").addClass("thumbnails").appendTo(element2);
        this.images.forEach((img, index) => {
          const c5 = $7("<div>").addClass(`thumbnail ${index === 0 ? "active" : ""}`).appendTo(thumbnails);
          $7("<img>").attr("src", img.src).attr("alt", img.src).appendTo(c5);
        });
        this.prevButton = $7("<button>").addClass("cycle prev-button").appendTo(this.scene);
        this.nextButton = $7("<button>").addClass("cycle next-button").appendTo(this.scene);
        this.scene.append(this._createSlide(0).addClass("current"));
      },
      _createEvents: function() {
        const that = this;
        this.prevButton.on(Metro2.events.click, (e2) => {
          e2.preventDefault();
          if (this.index > 0) {
            this.index--;
            this.goto(this.index, "prev");
          }
        });
        this.nextButton.on(Metro2.events.click, (e2) => {
          e2.preventDefault();
          if (this.index < this.images.length - 1) {
            this.index++;
            this.goto(this.index, "next");
          }
        });
        this.element.on(Metro2.events.click, ".thumbnail", function(e2) {
          e2.preventDefault();
          const thumbnail = $7(this);
          const index = thumbnail.index();
          if (index !== that.index) {
            that.goto(index, index > that.index ? "next" : "prev");
          }
        });
        $7("window").on(Metro2.events.resize, () => {
          this.scene.css({
            height: Metro2.utils.getInnerSize(this.scene).width
          });
        });
      },
      _createSlide: function(index) {
        if (index < 0 || index >= this.images.length) {
          return;
        }
        const img = this.images[index].cloneNode(true);
        const slide = $7("<div>").addClass("slide").append($7(img).show());
        return slide;
      },
      goto: function(index, direction) {
        if (this.animation) {
          return;
        }
        if (index < 0 || index >= this.images.length) {
          return;
        }
        this.animation = true;
        const width = Metro2.utils.getInnerSize(this.scene).width;
        const currentSlide = this.scene.find(".slide.current");
        const newSlide = this._createSlide(index).css({ left: direction === "next" ? width : -width }).appendTo(this.scene);
        currentSlide.animate({
          draw: {
            left: direction === "next" ? [0, -width] : [0, width]
          },
          dur: this.options.animationDuration,
          ease: this.options.animationEasing,
          onDone: () => {
            currentSlide.remove();
            this.scene.find(".thumbnail.active").removeClass("active");
            this.scene.find(`.thumbnail:nth-child(${index + 1})`).addClass("active");
          }
        });
        newSlide.animate({
          draw: {
            left: direction === "next" ? [width, 0] : [-width, 0]
          },
          dur: this.options.animationDuration,
          ease: this.options.animationEasing,
          onDone: () => {
            newSlide.addClass("current");
            this.element.find(".thumbnail.active").removeClass("active");
            this.element.find(`.thumbnail:nth-child(${index + 1})`).addClass("active");
            this.animation = false;
            this._fireEvent("slide-change", {
              index,
              direction,
              currentSlide,
              newSlide
            });
          }
        });
        this.index = index;
      },
      changeAttribute: function(attr, newValue) {
        const element2 = this.element;
        const o2 = this.options;
        switch (attr) {
          case "data-thumbnail-size":
            o2.thumbnailSize = newValue;
            element2.cssVar("thumbnail-size", `${newValue}px`);
            break;
          case "data-animation-duration":
            o2.animationDuration = parseInt(newValue, 10);
            break;
          case "data-animation-easing":
            o2.animationEasing = newValue;
            break;
          default:
            break;
        }
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/image-compare/image-compare.js
  ((Metro2, $7) => {
    "use strict";
    let ImageCompareDefaultConfig = {
      imageCompareDeferred: 0,
      width: "100%",
      height: "auto",
      onSliderMove: Metro2.noop,
      onImageCompareCreate: Metro2.noop
    };
    Metro2.imageCompareSetup = (options) => {
      ImageCompareDefaultConfig = $7.extend({}, ImageCompareDefaultConfig, options);
    };
    if (typeof globalThis.metroImageCompareSetup !== "undefined") {
      Metro2.imageCompareSetup(globalThis.metroImageCompareSetup);
    }
    Metro2.Component("image-compare", {
      init: function(options, elem) {
        this._super(elem, options, ImageCompareDefaultConfig, {
          id: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this.id = Hooks.useId(this.elem);
        this._createStructure();
        this._createEvents();
        this._fireEvent("image-compare-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        let element_width;
        let element_height;
        if (!Metro2.utils.isValue(element2.attr("id"))) {
          element2.attr("id", this.id);
        }
        element2.addClass("image-compare").css({
          width: o2.width
        });
        element_width = element2.width();
        switch (o2.height) {
          case "16/9":
            element_height = Metro2.utils.aspectRatioH(element_width, o2.height);
            break;
          case "21/9":
            element_height = Metro2.utils.aspectRatioH(element_width, o2.height);
            break;
          case "4/3":
            element_height = Metro2.utils.aspectRatioH(element_width, o2.height);
            break;
          case "auto":
            element_height = Metro2.utils.aspectRatioH(element_width, "16/9");
            break;
          default:
            element_height = o2.height;
        }
        element2.css({
          height: element_height
        });
        const container = $7("<div>").addClass("image-container").appendTo(element2);
        const container_overlay = $7("<div>").addClass("image-container-overlay").appendTo(element2).css({
          width: element_width / 2
        });
        const slider = $7("<div>").addClass("image-slider").appendTo(element2);
        slider.css({
          top: element_height / 2 - slider.height() / 2,
          left: element_width / 2 - slider.width() / 2
        });
        const images = element2.find("img");
        $7.each(images, function(i3) {
          const img = $7("<div>").addClass("image-wrapper");
          img.css({
            width: element_width,
            height: element_height,
            backgroundImage: `url(${this.src})`
          });
          img.appendTo(i3 === 0 ? container : container_overlay);
        });
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        const overlay = element2.find(".image-container-overlay");
        const slider = element2.find(".image-slider");
        slider.on(Metro2.events.startAll, () => {
          const w6 = element2.width();
          $7(document).on(
            Metro2.events.moveAll,
            (e2) => {
              let x5 = Metro2.utils.getCursorPositionX(element2[0], e2);
              if (x5 < 0) x5 = 0;
              if (x5 > w6) x5 = w6;
              overlay.css({
                width: x5
              });
              const left_pos = x5 - slider.width() / 2;
              slider.css({
                left: left_pos
              });
              this._fireEvent("slider-move", {
                x: x5,
                l: left_pos
              });
            },
            { ns: this.id }
          );
          $7(document).on(
            Metro2.events.stopAll,
            () => {
              $7(document).off(Metro2.events.moveAll, { ns: this.id });
              $7(document).off(Metro2.events.stopAll, { ns: this.id });
            },
            { ns: this.id }
          );
        });
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            const element_width = element2.width();
            let element_height;
            if (o2.width !== "100%") {
              return;
            }
            switch (o2.height) {
              case "16/9":
                element_height = Metro2.utils.aspectRatioH(element_width, o2.height);
                break;
              case "21/9":
                element_height = Metro2.utils.aspectRatioH(element_width, o2.height);
                break;
              case "4/3":
                element_height = Metro2.utils.aspectRatioH(element_width, o2.height);
                break;
              case "auto":
                element_height = Metro2.utils.aspectRatioH(element_width, "16/9");
                break;
              default:
                element_height = o2.height;
            }
            element2.css({
              height: element_height
            });
            $7.each(element2.find(".image-wrapper"), function() {
              $7(this).css({
                width: element_width,
                height: element_height
              });
            });
            element2.find(".image-container-overlay").css({
              width: element_width / 2
            });
            slider.css({
              top: element_height / 2 - slider.height() / 2,
              left: element_width / 2 - slider.width() / 2
            });
          },
          { ns: this.id }
        );
      },
      changeAttribute: (attr, val) => {
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.start);
        $7(globalThis).off(Metro2.events.resize, { ns: this.id });
        element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/image-grid/image-grig.js
  ((Metro2, $7) => {
    "use strict";
    let ImageGridDefaultConfig = {
      useBackground: false,
      backgroundSize: "cover",
      backgroundPosition: "top left",
      clsImageGrid: "",
      clsImageGridItem: "",
      clsImageGridImage: "",
      onItemClick: Metro2.noop,
      onDrawItem: Metro2.noop,
      onImageGridCreate: Metro2.noop
    };
    Metro2.imageGridSetup = (options) => {
      ImageGridDefaultConfig = $7.extend({}, ImageGridDefaultConfig, options);
    };
    if (typeof globalThis.metroImageGridSetup !== "undefined") {
      Metro2.imageGridSetup(globalThis.metroImageGridSetup);
    }
    Metro2.Component("image-grid", {
      init: function(options, elem) {
        this._super(elem, options, ImageGridDefaultConfig, {
          // define instance vars here
          items: []
        });
        return this;
      },
      _create: function() {
        this.items = this.element.children("img");
        this._createStructure();
        this._createEvents();
        this._fireEvent("image-grid-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("image-grid").addClass(o2.clsImageGrid);
        this._createItems();
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        element2.on(Metro2.events.click, ".image-grid__item", function() {
          that._fireEvent("item-click", {
            item: this
          });
        });
      },
      _createItems: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const items = this.items;
        element2.clear();
        items.each(function() {
          const el = $7(this);
          const src = this.src;
          const wrapper = $7("<div>").addClass("image-grid__item").addClass(o2.clsImageGridItem).appendTo(element2);
          const img = new Image();
          img.src = src;
          img.onload = function() {
            const port = this.height >= this.width;
            wrapper.addClass(port ? "image-grid__item-portrait" : "image-grid__item-landscape");
            el.addClass(o2.clsImageGridImage).appendTo(wrapper);
            if (o2.useBackground) {
              wrapper.css({
                background: `url(${src})`,
                backgroundRepeat: "no-repeat",
                backgroundSize: o2.backgroundSize,
                backgroundPosition: o2.backgroundPosition
              }).attr("data-original", el.attr("data-original") || src).attr("data-title", el.attr("alt") || el.attr("data-title") || "");
              el.visible(false);
            }
            that._fireEvent("draw-item", {
              item: wrapper[0],
              image: el[0]
            });
          };
        });
      },
      changeAttribute: function(attr, val) {
        const o2 = this.options;
        if (attr === "data-use-background") {
          o2.useBackground = Metro2.utils.bool(val);
          this._createItems();
        }
        if (attr === "data-background-size") {
          o2.backgroundSize = val;
          this._createItems();
        }
        if (attr === "data-background-position") {
          o2.backgroundPosition = val;
          this._createItems();
        }
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/image-magnifier/image-magnifier.js
  ((Metro2, $7) => {
    "use strict";
    let ImageMagnifierDefaultConfig = {
      imageMagnifierDeferred: 0,
      width: "100%",
      height: "auto",
      lensSize: 100,
      lensType: "square",
      // square, circle
      magnifierZoom: 2,
      magnifierMode: "glass",
      // glass, zoom
      magnifierZoomElement: null,
      clsMagnifier: "",
      clsLens: "",
      clsZoom: "",
      onMagnifierMove: Metro2.noop,
      onImageMagnifierCreate: Metro2.noop
    };
    Metro2.imageMagnifierSetup = (options) => {
      ImageMagnifierDefaultConfig = $7.extend({}, ImageMagnifierDefaultConfig, options);
    };
    if (typeof globalThis.metroImageMagnifierSetup !== "undefined") {
      Metro2.imageMagnifierSetup(globalThis.metroImageMagnifierSetup);
    }
    Metro2.Component("image-magnifier", {
      init: function(options, elem) {
        this._super(elem, options, ImageMagnifierDefaultConfig, {
          zoomElement: null,
          id: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this.id = Hooks.useId(this.elem);
        this._createStructure();
        this._createEvents();
        this._fireEvent("image-magnifier-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        let magnifier;
        let element_width;
        let element_height;
        const image = element2.find("img");
        if (image.length === 0) {
          throw new Error("Image not defined");
        }
        if (!Metro2.utils.isValue(element2.attr("id"))) {
          element2.attr("id", this.id);
        }
        element2.addClass("image-magnifier").css({
          width: o2.width
        }).addClass(o2.clsMagnifier);
        element_width = element2.width();
        switch (o2.height) {
          case "16/9":
            element_height = Metro2.utils.aspectRatioH(element_width, o2.height);
            break;
          case "21/9":
            element_height = Metro2.utils.aspectRatioH(element_width, o2.height);
            break;
          case "4/3":
            element_height = Metro2.utils.aspectRatioH(element_width, o2.height);
            break;
          case "auto":
            element_height = Metro2.utils.aspectRatioH(element_width, "16/9");
            break;
          default:
            element_height = o2.height;
        }
        element2.css({
          height: element_height
        });
        const x5 = element_width / 2 - o2.lensSize / 2;
        const y4 = element_height / 2 - o2.lensSize / 2;
        if (o2.magnifierMode === "glass") {
          magnifier = $7("<div>").addClass("image-magnifier-glass").appendTo(element2);
          magnifier.css({
            width: o2.lensSize,
            height: o2.lensSize,
            borderRadius: o2.lensType !== "circle" ? 0 : "50%",
            top: y4,
            left: x5,
            backgroundImage: `url(${image[0].src})`,
            backgroundRepeat: "no-repeat",
            backgroundPosition: `-${x5 * o2.magnifierZoom - o2.lensSize / 4 + 4}px -${y4 * o2.magnifierZoom - o2.lensSize / 4 + 4}px`,
            backgroundSize: `${image[0].width * o2.magnifierZoom}px ${image[0].height * o2.magnifierZoom}px`
          }).addClass(o2.clsLens);
        } else {
          magnifier = $7("<div>").addClass("image-magnifier-glass").appendTo(element2);
          magnifier.css({
            width: o2.lensSize,
            height: o2.lensSize,
            borderRadius: 0,
            borderWidth: 1,
            top: y4,
            left: x5
          }).addClass(o2.clsLens);
          if (!Metro2.utils.isValue(o2.magnifierZoomElement) || $7(o2.magnifierZoomElement).length === 0) {
            this.zoomElement = $7("<div>").insertAfter(element2);
          } else {
            this.zoomElement = $7(o2.magnifierZoomElement);
          }
          const zoom_element_width = magnifier[0].offsetWidth * o2.magnifierZoom;
          const zoom_element_height = magnifier[0].offsetHeight * o2.magnifierZoom;
          const cx = zoom_element_width / o2.lensSize;
          const cy = zoom_element_height / o2.lensSize;
          this.zoomElement.css({
            width: zoom_element_width,
            height: zoom_element_height,
            backgroundImage: `url(${image[0].src})`,
            backgroundRepeat: "no-repeat",
            backgroundPosition: `-${x5 * cx}px -${y4 * cy}px`,
            backgroundSize: `${image[0].width * cx}px ${image[0].height * cy}px`
          }).addClass(o2.clsZoom);
        }
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        const glass = element2.find(".image-magnifier-glass");
        const glass_size = glass[0].offsetWidth / 2;
        const image = element2.find("img")[0];
        const zoomElement = this.zoomElement;
        let cx;
        let cy;
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            const x5 = element2.width() / 2 - o2.lensSize / 2;
            const y4 = element2.height() / 2 - o2.lensSize / 2;
            if (o2.magnifierMode === "glass") {
              glass.css({
                backgroundPosition: `-${x5 * o2.magnifierZoom - o2.lensSize / 4 + 4}px -${y4 * o2.magnifierZoom - o2.lensSize / 4 + 4}px`,
                backgroundSize: `${image.width * o2.magnifierZoom}px ${image.height * o2.magnifierZoom}px`
              });
            }
          },
          { ns: this.id }
        );
        if (o2.magnifierMode !== "glass") {
          cx = zoomElement[0].offsetWidth / glass_size / 2;
          cy = zoomElement[0].offsetHeight / glass_size / 2;
          zoomElement.css({
            backgroundSize: `${image.width * cx}px ${image.height * cy}px`
          });
        }
        const lens_move = (pos) => {
          let x5;
          let y4;
          const magic = 4;
          const zoom = Number.parseInt(o2.magnifierZoom);
          if (o2.magnifierMode === "glass") {
            x5 = pos.x;
            y4 = pos.y;
            if (x5 > image.width - glass_size / zoom) {
              x5 = image.width - glass_size / zoom;
            }
            if (x5 < glass_size / zoom) {
              x5 = glass_size / zoom;
            }
            if (y4 > image.height - glass_size / zoom) {
              y4 = image.height - glass_size / zoom;
            }
            if (y4 < glass_size / zoom) {
              y4 = glass_size / zoom;
            }
            glass.css({
              top: y4 - glass_size,
              left: x5 - glass_size,
              backgroundPosition: `-${x5 * zoom - glass_size + magic}px -${y4 * zoom - glass_size + magic}px`
            });
          } else {
            x5 = pos.x - glass_size;
            y4 = pos.y - glass_size;
            if (x5 > image.width - glass_size * 2) {
              x5 = image.width - glass_size * 2;
            }
            if (x5 < 0) {
              x5 = 0;
            }
            if (y4 > image.height - glass_size * 2) {
              y4 = image.height - glass_size * 2;
            }
            if (y4 < 0) {
              y4 = 0;
            }
            glass.css({
              top: y4,
              left: x5
            });
            zoomElement.css({
              backgroundPosition: `-${x5 * cx}px -${y4 * cy}px`
            });
          }
        };
        element2.on(Metro2.events.move, (e2) => {
          const pos = Metro2.utils.getCursorPosition(image, e2);
          lens_move(pos);
          this._fireEvent("magnifier-move", {
            pos,
            glass: glass[0],
            zoomElement: zoomElement ? zoomElement[0] : void 0
          });
          e2.preventDefault();
        });
        element2.on(Metro2.events.leave, () => {
          const x5 = element2.width() / 2 - o2.lensSize / 2;
          const y4 = element2.height() / 2 - o2.lensSize / 2;
          glass.animate({
            draw: {
              top: y4,
              left: x5
            }
          });
          lens_move({
            x: x5 + o2.lensSize / 2,
            y: y4 + o2.lensSize / 2
          });
        });
      },
      changeAttribute: (attr, val) => {
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.move);
        element2.off(Metro2.events.leave);
        element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/image-placeholder/image-placeholder.js
  ((Metro2, $7) => {
    "use strict";
    let ImagePlaceholderDefaultConfig = {
      size: "100x100",
      width: null,
      height: null,
      color: "#f8f8f8",
      textColor: "#292929",
      font: "12px sans-serif",
      text: "",
      showText: true,
      onImagePlaceholderCreate: Metro2.noop
    };
    Metro2.imagePlaceholderSetup = (options) => {
      ImagePlaceholderDefaultConfig = $7.extend({}, ImagePlaceholderDefaultConfig, options);
    };
    if (typeof globalThis.metroImagePlaceholderSetup !== "undefined") {
      Metro2.imagePlaceholderSetup(globalThis.metroImagePlaceholderSetup);
    }
    Metro2.Component("image-placeholder", {
      init: function(options, elem) {
        this._super(elem, options, ImagePlaceholderDefaultConfig, {
          // define instance vars here
          width: 0,
          height: 0
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("image-placeholder-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const size = o2.size.toArray("x");
        this.width = o2.width ? o2.width : size[0];
        this.height = o2.height ? o2.height : size[1];
        element2.attr("src", this._createPlaceholder());
      },
      _createEvents: () => {
      },
      _createPlaceholder: function() {
        const o2 = this.options;
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        const width = this.width;
        const height = this.height;
        canvas.width = Number.parseInt(width);
        canvas.height = Number.parseInt(height);
        context.clearRect(0, 0, width, height);
        context.fillStyle = o2.color;
        context.fillRect(0, 0, width, height);
        context.fillStyle = o2.textColor;
        context.font = o2.font;
        context.translate(width / 2, height / 2);
        context.textAlign = "center";
        context.textBaseline = "middle";
        if (o2.showText) context.fillText(o2.text ? o2.text : `${width} \xD7 ${height}`, 0, 0);
        return canvas.toDataURL();
      },
      changeAttribute: (attr, val) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/info-box/info-box.js
  ((Metro2, $7) => {
    "use strict";
    let InfoBoxDefaultConfig = {
      infoboxDeferred: 0,
      type: "",
      width: 480,
      height: "auto",
      overlay: true,
      overlayColor: "#000000",
      overlayAlpha: 0.5,
      overlayClickClose: false,
      autoHide: 0,
      removeOnClose: false,
      closeButton: true,
      clsBox: "",
      clsBoxContent: "",
      clsOverlay: "",
      onOpen: Metro2.noop,
      onClose: Metro2.noop,
      onInfoBoxCreate: Metro2.noop
    };
    Metro2.infoBoxSetup = (options) => {
      InfoBoxDefaultConfig = $7.extend({}, InfoBoxDefaultConfig, options);
    };
    if (typeof globalThis.metroInfoBoxSetup !== "undefined") {
      Metro2.infoBoxSetup(globalThis.metroInfoBoxSetup);
    }
    Metro2.Component("info-box", {
      init: function(options, elem) {
        this._super(elem, options, InfoBoxDefaultConfig, {
          overlay: null,
          id: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this.id = Hooks.useId(this.elem);
        this._createStructure();
        this._createEvents();
        this._fireEvent("info-box-create", {
          element: element2
        });
      },
      _overlay: function() {
        const o2 = this.options;
        const overlay = $7("<div>");
        overlay.addClass("overlay").addClass(o2.clsOverlay);
        if (o2.overlayColor === "transparent") {
          overlay.addClass("transparent");
        } else {
          overlay.css({
            background: Farbe.Routines.toRGBA(Farbe.Routines.parse(o2.overlayColor), o2.overlayAlpha)
          });
        }
        return overlay;
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        let closer;
        if (o2.overlay === true) {
          this.overlay = this._overlay();
        }
        element2.addClass("info-box").addClass(o2.type).addClass(o2.clsBox);
        closer = element2.find("closer");
        if (closer.length === 0) {
          closer = $7("<span>").addClass("button square closer");
          closer.appendTo(element2);
        }
        if (o2.closeButton !== true) {
          closer.hide();
        }
        const content = element2.find(".info-box-content");
        if (content.length > 0) {
          content.addClass(o2.clsBoxContent);
        }
        element2.css({
          width: o2.width,
          height: o2.height,
          visibility: "hidden",
          top: "100%",
          left: ($7(globalThis).width() - element2.outerWidth()) / 2
        });
        element2.appendTo($7("body"));
      },
      _createEvents: function() {
        const element2 = this.element;
        element2.on(Metro2.events.click, ".closer", () => {
          this.close();
        });
        element2.on(Metro2.events.click, ".js-dialog-close", () => {
          this.close();
        });
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            this.reposition();
          },
          { ns: this.id }
        );
      },
      _setPosition: function() {
        const element2 = this.element;
        element2.css({
          top: ($7(globalThis).height() - element2.outerHeight()) / 2,
          left: ($7(globalThis).width() - element2.outerWidth()) / 2
        });
      },
      reposition: function() {
        this._setPosition();
      },
      setContent: function(c5) {
        const element2 = this.element;
        const content = element2.find(".info-box-content");
        if (content.length === 0) {
          return;
        }
        content.html(c5);
        this.reposition();
      },
      setType: function(t) {
        const element2 = this.element;
        element2.removeClass("success info alert warning").addClass(t);
      },
      open: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (o2.overlay === true && $7(".overlay").length === 0) {
          this.overlay.appendTo($7("body"));
          if (o2.overlayClickClose === true) {
            this.overlay.on(Metro2.events.click, () => {
              this.close();
            });
          }
        }
        this._setPosition();
        element2.css({
          visibility: "visible"
        });
        this._fireEvent("open");
        element2.data("open", true);
        if (Number.parseInt(o2.autoHide) > 0) {
          setTimeout(() => {
            this.close();
          }, Number.parseInt(o2.autoHide));
        }
      },
      close: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (o2.overlay === true) {
          $7("body").find(".overlay").remove();
        }
        element2.css({
          visibility: "hidden",
          top: "100%"
        });
        this._fireEvent("close");
        element2.data("open", false);
        if (o2.removeOnClose === true) {
          this.destroy();
          element2.remove();
        }
      },
      isOpen: function() {
        return this.element.data("open") === true;
      },
      changeAttribute: (attr, val) => {
      },
      destroy: function() {
        const element2 = this.element;
        element2.off("all");
        $7(globalThis).off(Metro2.events.resize, { ns: this.id });
        element2.remove();
      }
    });
    Metro2.infobox = {
      isInfoBox: (el) => Metro2.utils.isMetroObject(el, "infobox"),
      open: function(el, c5, t) {
        if (!this.isInfoBox(el)) {
          return false;
        }
        const ib = Metro2.getPlugin(el, "infobox");
        if (c5 !== void 0) {
          ib.setContent(c5);
        }
        if (t !== void 0) {
          ib.setType(t);
        }
        ib.open();
      },
      close: function(el) {
        if (!this.isInfoBox(el)) {
          return false;
        }
        const ib = Metro2.getPlugin(el, "infobox");
        ib.close();
      },
      setContent: function(el, c5 = "") {
        if (!this.isInfoBox(el)) {
          return false;
        }
        const ib = Metro2.getPlugin(el, "infobox");
        ib.setContent(c5);
        ib.reposition();
      },
      setType: function(el, t) {
        if (!this.isInfoBox(el)) {
          return false;
        }
        const ib = Metro2.getPlugin(el, "infobox");
        ib.setType(t);
        ib.reposition();
      },
      isOpen: function(el) {
        if (!this.isInfoBox(el)) {
          return false;
        }
        const ib = Metro2.getPlugin(el, "infobox");
        return ib.isOpen();
      },
      create: (c5, t, o2, open) => {
        const $$ = Metro2.utils.$();
        let ib;
        const box_type = t !== void 0 ? t : "";
        const el = $$("<div>").appendTo($$("body"));
        $$("<div>").addClass("info-box-content").appendTo(el);
        const ib_options = $$.extend(
          {},
          {
            removeOnClose: true,
            type: box_type
          },
          o2 !== void 0 ? o2 : {}
        );
        ib_options._runtime = true;
        el.infobox(ib_options);
        ib = Metro2.getPlugin(el, "infobox");
        ib.setContent(c5);
        if (open !== false) {
          ib.open();
        }
        return el;
      }
    };
  })(Metro, Dom);

  // ../metroui-lib/source/components/input-mask/input-mask.js
  ((Metro2, $7) => {
    "use strict";
    let InputMaskDefaultConfig = {
      maskPattern: ".",
      mask: null,
      maskPlaceholder: "_",
      maskEditableStart: 0,
      thresholdInterval: 300,
      onChar: Metro2.noop,
      onInputMaskCreate: Metro2.noop
    };
    Metro2.inputMaskSetup = (options) => {
      InputMaskDefaultConfig = $7.extend({}, InputMaskDefaultConfig, options);
    };
    if (typeof globalThis.metroInputMaskSetup !== "undefined") {
      Metro2.inputMaskSetup(globalThis.metroInputMaskSetup);
    }
    Metro2.Component("input-mask", {
      init: function(options, elem) {
        this._super(elem, options, InputMaskDefaultConfig, {
          // define instance vars here
          pattern: null,
          mask: "",
          maskArray: [],
          placeholder: "",
          length: 0,
          thresholdTimer: null,
          id: null
        });
        return this;
      },
      _create: function() {
        this.id = Hooks.useId(this.elem);
        this._createStructure();
        this._createEvents();
        this._fireEvent("input-mask-create");
      },
      _createStructure: function() {
        const o2 = this.options;
        if (!o2.mask) {
          throw new Error("You must provide a pattern for masked input.");
        }
        this.placeholder = o2.maskPlaceholder.split("");
        this.mask = `${o2.mask}`;
        this.maskArray = this.mask.split("");
        this.pattern = new RegExp(`^${o2.maskPattern}+$`);
        this.length = this.mask.length;
        this._showValue();
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const editableStart = o2.maskEditableStart;
        const id = this.id;
        const checkEditablePosition = (pos) => {
          if (pos < editableStart) {
            setPosition(editableStart);
            return false;
          }
          return true;
        };
        const checkEditableChar = (pos) => pos < that.mask.length && that.placeholder.includes(that.mask.charAt(pos));
        const findNextEditablePosition = (pos) => {
          let i3;
          const a2 = that.maskArray;
          for (i3 = pos; i3 <= a2.length; i3++) {
            if (that.placeholder.includes(a2[i3])) {
              return i3;
            }
          }
          return pos;
        };
        const setPosition = (pos) => {
          that.elem.setSelectionRange(pos, pos);
        };
        const clearThresholdInterval = () => {
          clearInterval(that.thresholdTimer);
          that.thresholdTimer = null;
        };
        element2.on(
          "change",
          function() {
            if (this.value === "") {
              this.value = that.mask;
              setPosition(editableStart);
            }
          },
          { ns: id }
        );
        element2.on(
          "focus click",
          function() {
            checkEditablePosition(this.selectionStart);
            setPosition(findNextEditablePosition(this.selectionStart));
          },
          { ns: id }
        );
        element2.on(
          "keydown",
          function(e2) {
            const pos = this.selectionStart;
            const val = this.value;
            const code = e2.code;
            const key = e2.key;
            if (code === "ArrowRight" || code === "End" || code === "Tab") {
              return true;
            }
            if (pos >= that.length && ["Backspace", "Home", "ArrowLeft", "ArrowUp"].indexOf(code) === -1) {
              e2.preventDefault();
            } else if (code === "Home" || code === "ArrowUp") {
              e2.preventDefault();
              setPosition(editableStart);
            } else if (code === "ArrowLeft") {
              if (pos - 1 < editableStart) {
                e2.preventDefault();
              }
            } else if (code === "Backspace") {
              e2.preventDefault();
              if (pos - 1 >= editableStart) {
                if (checkEditableChar(pos - 1)) {
                  if (!that.placeholder.includes(val.charAt(pos - 1))) {
                    this.value = val.substring(0, pos - 1) + that.mask[pos - 1] + val.substring(pos);
                  }
                }
                setPosition(pos - 1);
              }
            } else if (code === "Space") {
              e2.preventDefault();
              setPosition(pos + 1);
            } else if (!that.pattern.test(key)) {
              e2.preventDefault();
            } else {
              e2.preventDefault();
              if (checkEditableChar(pos)) {
                this.value = val.substring(0, pos) + (o2.onChar === Metro2.noop ? key : Metro2.utils.exec(o2.onChar, [key], this)) + val.substring(pos + 1);
                setPosition(findNextEditablePosition(pos + 1));
              }
            }
          },
          { ns: id }
        );
        element2.on(
          "keyup",
          function() {
            clearThresholdInterval();
            that.thresholdTimer = setInterval(() => {
              clearThresholdInterval();
              setPosition(findNextEditablePosition(this.selectionStart));
            }, o2.thresholdInterval);
          },
          { ns: id }
        );
      },
      _showValue: function() {
        const elem = this.elem;
        const a2 = new Array(this.length);
        let val;
        if (!elem.value) {
          elem.value = this.mask;
        } else {
          val = elem.value;
          $7.each(this.maskArray, (i3, v5) => {
            if (val[i3] !== v5 && !this.pattern.test(val[i3])) {
              a2[i3] = this.mask[i3];
            } else {
              a2[i3] = val[i3];
            }
          });
          this.elem.value = a2.join("");
        }
      },
      destroy: function() {
        const element2 = this.element;
        const id = this.id;
        element2.off("change", { ns: id });
        element2.off("focus", { ns: id });
        element2.off("click", { ns: id });
        element2.off("keydown", { ns: id });
        element2.off("keyup", { ns: id });
        return element2;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/input-material/input-material.js
  ((Metro2, $7) => {
    "use strict";
    let MaterialInputDefaultConfig = {
      materialInputDeferred: 0,
      label: "",
      informer: "",
      icon: "",
      permanentLabel: false,
      searchButton: false,
      clearButton: true,
      revealButton: true,
      clearButtonIcon: "\u2716",
      revealButtonIcon: "\u{1F440}",
      searchButtonIcon: "\u{1F50D}",
      customButtons: [],
      searchButtonClick: "submit",
      clsComponent: "",
      clsInput: "",
      clsLabel: "",
      clsInformer: "",
      clsIcon: "",
      clsLine: "",
      onInputCreate: Metro2.noop
    };
    Metro2.materialInputSetup = (options) => {
      MaterialInputDefaultConfig = $7.extend({}, MaterialInputDefaultConfig, options);
    };
    if (typeof globalThis.metroMaterialInputSetup !== "undefined") {
      Metro2.materialInputSetup(globalThis.metroMaterialInputSetup);
    }
    Metro2.Component("material-input", {
      init: function(options, elem) {
        this._super(elem, options, MaterialInputDefaultConfig, {
          history: [],
          historyIndex: -1
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("input-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        let container;
        let buttons;
        element2[0].className = "";
        element2.attr("autocomplete", "nope");
        if (element2.attr("type") === void 0) {
          element2.attr("type", "text");
        }
        container = element2.wrap("<div>").addClass(`input-material ${element2[0].className}`);
        buttons = $7("<div>").addClass("buttons").appendTo(container);
        if (o2.label) {
          $7("<span>").html(o2.label).addClass("label").addClass(o2.clsLabel).insertAfter(element2);
        }
        if (Metro2.utils.isValue(o2.informer)) {
          $7("<span>").html(o2.informer).addClass("informer").addClass(o2.clsInformer).insertAfter(element2);
        }
        if (Metro2.utils.isValue(o2.icon)) {
          container.addClass("with-icon");
          $7("<span>").html(o2.icon).addClass("icon").addClass(o2.clsIcon).insertAfter(element2);
        }
        if (o2.clearButton === true && !element2[0].readOnly) {
          const clearButton = $7("<button>").addClass("button input-clear-button").addClass(o2.clsClearButton).attr("tabindex", -1).attr("type", "button").html(o2.clearButtonIcon);
          clearButton.appendTo(buttons);
        }
        if (element2.attr("type") === "password" && o2.revealButton === true) {
          const revealButton = $7("<button>").addClass("button input-reveal-button").addClass(o2.clsRevealButton).attr("tabindex", -1).attr("type", "button").html(o2.revealButtonIcon);
          revealButton.appendTo(buttons);
        }
        if (o2.searchButton === true) {
          const searchButton = $7("<button>").addClass("button input-search-button").addClass(o2.clsSearchButton).attr("tabindex", -1).attr("type", o2.searchButtonClick === "submit" ? "submit" : "button").html(o2.searchButtonIcon);
          searchButton.appendTo(buttons);
        }
        const customButtons = Metro2.utils.isObject(o2.customButtons);
        if (Array.isArray(customButtons)) {
          $7.each(customButtons, function() {
            const btn = $7("<button>");
            btn.addClass("button input-custom-button").addClass(o2.clsCustomButton).addClass(this.cls).attr("tabindex", -1).attr("type", "button").html(this.text || this.html || "");
            that._setAttributes(btn, this.attr);
            if (this.onclick)
              btn.on("click", (e2) => {
                if (Metro2.utils.isRightMouse(e2)) return;
                Metro2.utils.exec(this.onclick, [btn[0], element2[0]]);
              });
            btn.appendTo(buttons);
          });
        }
        container.append($7("<hr>").addClass(o2.clsLine));
        if (o2.permanentLabel === true) {
          container.addClass("permanent-label");
        }
        container.addClass(o2.clsComponent);
        element2.addClass(o2.clsInput);
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        this.component = container;
      },
      _createEvents: function() {
        const that = this;
        const o2 = this.options;
        const element2 = this.element;
        this.component.on(Metro2.events.click, ".input-clear-button", () => {
          const curr = element2.val();
          element2.val("").fire("clear").fire("change").fire("keyup").focus();
          that._fireEvent("clear-click", {
            prev: curr
          });
        });
        this.component.on(Metro2.events.click, ".input-reveal-button", () => {
          if (element2.attr("type") === "password") {
            element2.attr("type", "text");
          } else {
            element2.attr("type", "password");
          }
          that._fireEvent("reveal-click", {
            val: element2.val()
          });
        });
        this.component.on(Metro2.events.click, ".input-search-button", function() {
          if (o2.searchButtonClick !== "submit") {
            that._fireEvent("search-button-click", {
              val: element2.val(),
              button: this
            });
          } else {
            if (this.form) this.form.submit();
          }
        });
        element2.on(Metro2.events.keydown, (e2) => {
          if (e2.keyCode === Metro2.keyCode.ENTER) {
            that._fireEvent("enter-click", {
              val: element2.val()
            });
          }
        });
      },
      clear: function() {
        this.element.val("");
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      changeAttribute: function(attributeName) {
        if (attributeName === "disabled") {
          this.toggleState();
        }
      },
      destroy: function() {
        return this.element;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/keypad/keypad.js
  ((Metro2, $7) => {
    "use strict";
    let KeypadDefaultConfig = {
      keypadDeferred: 0,
      label: "",
      keySize: 36,
      keys: "1, 2, 3, 4, 5, 6, 7, 8, 9, 0",
      exceptKeys: "",
      keySeparator: "",
      trimSeparator: false,
      keyDelimiter: ",",
      copyInlineStyles: false,
      target: null,
      keyLength: 0,
      shuffle: false,
      shuffleCount: 3,
      //position: Metro.position.BOTTOM_LEFT, //top-left, top, top-right, right, bottom-right, bottom, bottom-left, left
      // dynamicPosition: false,
      serviceButtons: true,
      showValue: true,
      open: false,
      useElementSizeForKeys: false,
      // sizeAsKeys: false,
      openMode: "auto",
      clsKeypad: "",
      clsInput: "",
      clsKeys: "",
      clsKey: "",
      clsServiceKey: "",
      clsBackspace: "",
      clsClear: "",
      clsLabel: "",
      onChange: Metro2.noop,
      onClear: Metro2.noop,
      onBackspace: Metro2.noop,
      onShuffle: Metro2.noop,
      onKey: Metro2.noop,
      onKeypadCreate: Metro2.noop
    };
    Metro2.keypadSetup = (options) => {
      KeypadDefaultConfig = $7.extend({}, KeypadDefaultConfig, options);
    };
    if (typeof globalThis.metroKeypadSetup !== "undefined") {
      Metro2.keypadSetup(globalThis.metroKeypadSetup);
    }
    Metro2.Component("keypad", {
      init: function(options, elem) {
        this._super(elem, options, KeypadDefaultConfig, {
          value: elem.tagName === "INPUT" ? elem.value : elem.innerText,
          positions: ["top-left", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left"],
          keypad: null,
          keys: [],
          keys_to_work: [],
          exceptKeys: []
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        this.options.position = "bottom-left";
        this.keys = o2.keys.toArray(o2.keyDelimiter);
        this.keys_to_work = this.keys;
        this.exceptKeys = o2.exceptKeys.toArray(o2.keyDelimiter);
        this._createKeypad();
        if (o2.shuffle === true) {
          this.shuffle();
        }
        this._createKeys();
        this._createEvents();
        this._fireEvent("keypad-create", {
          element: element2
        });
      },
      _createKeypad: function() {
        const element2 = this.element;
        const o2 = this.options;
        let keys;
        const keypad = element2.wrap("<div>").addClass("input keypad").addClass(element2[0].className).addClass(o2.clsKeypad);
        if (element2.attr("type") === void 0) {
          element2.attr("type", "text");
        }
        element2.attr("readonly", true);
        keys = $7("<div>").addClass("keys").addClass(o2.clsKeys);
        keys.appendTo(keypad);
        this._setKeysPosition();
        if (o2.open === true) {
          keys.addClass("open keep-open");
        }
        element2[0].className = "";
        if (o2.copyInlineStyles === true) {
          let i3 = 0;
          const l2 = element2[0].style.length;
          for (; i3 < l2; i3++) {
            keypad.css(element2[0].style[i3], element2.css(element2[0].style[i3]));
          }
        }
        element2.addClass(o2.clsInput);
        keypad.addClass(o2.clsKeypad);
        element2.on(Metro2.events.blur, () => {
          keypad.removeClass("focused");
        });
        element2.on(Metro2.events.focus, () => {
          keypad.addClass("focused");
        });
        const buttons = $7("<div>").addClass("button-group").appendTo(keypad);
        const kbdButton = $7("<button>").addClass("button input-kbd-button").addClass(o2.clsKbdButton).attr("tabindex", -1).attr("type", "button").html("\u2328");
        kbdButton.appendTo(buttons);
        if (o2.label) {
          const label = $7("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(keypad);
          if (element2.attr("id")) {
            label.attr("for", element2.attr("id"));
          } else {
            const id = Hooks.useId(element2[0]);
            element2.id(id);
            label.attr("for", id);
          }
          if (element2.attr("dir") === "rtl") {
            label.addClass("rtl");
          }
        }
        if (o2.disabled === true || element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        this.keypad = keypad;
      },
      _setKeysPosition: function() {
        const element2 = this.element;
        const o2 = this.options;
        const keypad = element2.parent();
        const keys = keypad.find(".keys");
        keys.removeClass(this.positions.join(" ")).addClass(o2.position);
      },
      _createKeys: function() {
        const element2 = this.element;
        const o2 = this.options;
        const keypad = element2.parent();
        let key;
        const keys = keypad.find(".keys");
        const factor = Math.round(Math.sqrt(this.keys.length + 2));
        const key_size = o2.keySize;
        let width;
        keys.html("");
        $7.each(this.keys_to_work, function() {
          key = $7("<span>").addClass("key").addClass(o2.clsKey).html(this);
          key.data("key", this);
          key.css({
            width: o2.keySize,
            height: o2.keySize,
            lineHeight: o2.keySize - 4
          }).appendTo(keys);
        });
        if (o2.serviceButtons === true) {
          const service_keys = ["&larr;", "&times;"];
          $7.each(service_keys, function() {
            key = $7("<span>").addClass("key service-key").addClass(o2.clsKey).addClass(o2.clsServiceKey).html(this);
            if (this === "&larr;") {
              key.addClass(o2.clsBackspace);
            }
            if (this === "&times;") {
              key.addClass(o2.clsClear);
            }
            key.data("key", this);
            key.css({
              width: o2.keySize,
              height: o2.keySize,
              lineHeight: o2.keySize - 4
            }).appendTo(keys);
          });
        }
        if (o2.useElementSizeForKeys === true) {
          keys.outerWidth(element2.outerWidth());
        } else {
          width = factor * (key_size + 2) - 6;
          keys.outerWidth(width);
        }
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const keypad = element2.parent();
        const keys = keypad.find(".keys");
        keys.on(Metro2.events.click, ".key", function(e2) {
          const key = $7(this);
          const keyValue = key.data("key");
          let crop;
          if (key.data("key") !== "&larr;" && key.data("key") !== "&times;") {
            if (o2.keyLength > 0 && `${that.value}`.length === o2.keyLength) {
              return false;
            }
            if (that.exceptKeys.indexOf(keyValue) === -1)
              that.value = that.value + (that.value !== "" ? o2.keySeparator : "") + keyValue;
            if (o2.shuffle === true) {
              that.shuffle();
              that._createKeys();
            }
            if (o2.dynamicPosition === true) {
              o2.position = that.positions[$7.random(0, that.positions.length - 1)];
              that._setKeysPosition();
            }
            that._fireEvent("key", {
              key: key.data("key"),
              val: that.value
            });
          } else {
            if (key.data("key") === "&times;") {
              that.value = "";
              that._fireEvent("clear");
            }
            if (key.data("key") === "&larr;") {
              crop = o2.keySeparator && that.value[that.value.length - 1] !== o2.keySeparator ? 2 : 1;
              that.value = that.value.substring(0, that.value.length - crop);
              that._fireEvent("backspace", {
                val: that.value
              });
            }
          }
          if (o2.showValue === true) {
            if (element2[0].tagName === "INPUT") {
              element2.val(that.value);
            } else {
              element2.text(that.value);
            }
          }
          that._fireEvent("change", {
            val: that.val
          });
          e2.preventDefault();
          e2.stopPropagation();
        });
        keypad.on(Metro2.events.click, (e2) => {
          if (o2.open === true) {
            return;
          }
          if (keys.hasClass("open") === true) {
            keys.removeClass("open").removeClass("top-left");
          } else {
            keys.addClass("open");
            if (o2.openMode === "auto") {
              if (Metro2.utils.inViewport(keys[0]) === false) {
                keys.addClass("top-left");
              }
            } else {
              if (o2.openMode === "up") {
                keys.addClass("top-left");
              }
            }
          }
          e2.preventDefault();
          e2.stopPropagation();
        });
        if (o2.target !== null) {
          element2.on(Metro2.events.change, () => {
            const t = $7(o2.target);
            if (t.length === 0) {
              return;
            }
            if (t[0].tagName === "INPUT") {
              t.val(that.value);
            } else {
              t.text(that.value);
            }
          });
        }
      },
      shuffle: function() {
        const o2 = this.options;
        for (let i3 = 0; i3 < o2.shuffleCount; i3++) {
          this.keys_to_work = this.keys_to_work.shuffle();
        }
        this._fireEvent("shuffle", {
          keysToWork: this.keys_to_work,
          keys: this.keys
        });
      },
      shuffleKeys: function(count = 3) {
        for (let i3 = 0; i3 < count; i3++) {
          this.keys_to_work = this.keys_to_work.shuffle();
        }
        this._createKeys();
      },
      val: function(v5) {
        const element2 = this.element;
        const o2 = this.options;
        if (typeof v5 === "undefined") {
          return o2.trimSeparator ? this.value.replace(new RegExp(o2.keySeparator, "g")) : this.value;
        }
        this.value = `${v5}`;
        if (element2[0].tagName === "INPUT") {
          element2.val(v5);
        } else {
          element2.text(v5);
        }
        return this;
      },
      open: function() {
        const element2 = this.element;
        const o2 = this.options;
        const keypad = element2.parent();
        const keys = keypad.find(".keys");
        keys.addClass("open");
        if (o2.openMode === "auto") {
          if (Metro2.utils.inViewport(keys[0]) === false) {
            keys.addClass("top-left");
          }
        } else {
          if (o2.openMode === "up") {
            keys.addClass("top-left");
          }
        }
      },
      close: function() {
        const element2 = this.element;
        const keypad = element2.parent();
        const keys = keypad.find(".keys");
        keys.removeClass("open").removeClass("top-left");
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      setPosition: function(pos) {
        const new_position = pos !== void 0 ? pos : this.element.attr("data-position");
        if (this.positions.indexOf(new_position) === -1) {
          return;
        }
        this.options.position = new_position;
        this._setKeysPosition();
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "disabled":
            this.toggleState();
            break;
          case "data-position":
            this.setPosition();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        const keypad = this.keypad;
        const keys = keypad.find(".keys");
        keypad.off(Metro2.events.click);
        keys.off(Metro2.events.click, ".key");
        element2.off(Metro2.events.change);
        if (o2.label) {
          keypad.prev("label").remove();
        }
        keypad.remove();
      }
    });
    $7(document).on(Metro2.events.click, () => {
      const keypads = $7(".keypad .keys");
      $7.each(keypads, function() {
        if (!$7(this).hasClass("keep-open")) {
          $7(this).removeClass("open");
        }
      });
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/lightbox/lightbox.js
  ((Metro2, $7) => {
    "use strict";
    let LightboxDefaultConfig = {
      loop: true,
      source: "img",
      iconClose: "\u2716",
      iconPrev: "\u{1F850}",
      iconNext: "\u{1F852}",
      clsNext: "",
      clsPrev: "",
      clsClose: "",
      clsImage: "",
      clsImageContainer: "",
      clsImageWrapper: "",
      clsLightbox: "",
      onDrawImage: Metro2.noop,
      onLightboxCreate: Metro2.noop
    };
    Metro2.lightboxSetup = (options) => {
      LightboxDefaultConfig = $7.extend({}, LightboxDefaultConfig, options);
    };
    if (typeof globalThis.metroLightboxSetup !== "undefined") {
      Metro2.lightboxSetup(globalThis.metroLightboxSetup);
    }
    Metro2.Component("lightbox", {
      init: function(options, elem) {
        this._super(elem, options, LightboxDefaultConfig, {
          // define instance vars here
          overlay: null,
          lightbox: null,
          current: null,
          items: []
        });
        return this;
      },
      _create: function() {
        const o2 = this.options;
        if (!o2.source) {
          o2.source = "img";
        }
        this._createStructure();
        this._createEvents();
        this._fireEvent("lightbox-create");
      },
      _createStructure: function() {
        const o2 = this.options;
        let overlay;
        overlay = $7(".lightbox-overlay");
        if (overlay.length === 0) {
          overlay = $7("<div>").addClass("lightbox-overlay").appendTo("body").hide();
        }
        const lightbox = $7("<div>").addClass("lightbox").addClass(o2.clsLightbox).appendTo("body").hide();
        $7("<span>").addClass("lightbox__prev").addClass(o2.clsPrev).html(o2.iconPrev).appendTo(lightbox);
        $7("<span>").addClass("lightbox__next").addClass(o2.clsNext).html(o2.iconNext).appendTo(lightbox);
        $7("<span>").addClass("lightbox__closer").addClass(o2.clsClose).html(o2.iconClose).appendTo(lightbox);
        $7("<div>").addClass("lightbox__image").addClass(o2.clsImageContainer).appendTo(lightbox);
        this.component = lightbox[0];
        this.lightbox = lightbox;
        this.overlay = overlay;
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const lightbox = $7(this.component);
        element2.on(Metro2.events.click, o2.source, function() {
          that.open(this);
        });
        lightbox.on(Metro2.events.click, ".lightbox__closer", () => {
          that.close();
        });
        lightbox.on(Metro2.events.click, ".lightbox__prev", () => {
          that.prev();
        });
        lightbox.on(Metro2.events.click, ".lightbox__next", () => {
          that.next();
        });
      },
      _setupItems: function() {
        const element2 = this.element;
        const o2 = this.options;
        const items = element2.find(o2.source);
        if (items.length === 0) {
          return;
        }
        this.items = items;
      },
      _goto: function(el) {
        const that = this;
        const o2 = this.options;
        const $el = $7(el);
        const img = $7("<img>");
        let src;
        const imageContainer = this.lightbox.find(".lightbox__image");
        imageContainer.find(".lightbox__image-wrapper").remove();
        const imageWrapper = $7("<div>").addClass("lightbox__image-wrapper").addClass(o2.clsImageWrapper).attr("data-title", $el.attr("alt") || $el.attr("data-title") || "").appendTo(imageContainer);
        const activity = $7("<div>").appendTo(imageWrapper);
        Metro2.makePlugin(activity, "activity", {
          type: "cycle",
          style: "color"
        });
        this.current = el;
        if (el.tagName === "IMG" || el.tagName === "DIV") {
          src = $el.attr("data-original") || $el.attr("src");
          img.attr("src", src);
          img[0].onload = function() {
            const port = this.height > this.width;
            img.addClass(port ? "lightbox__image-portrait" : "lightbox__image-landscape").addClass(o2.clsImage);
            img.attr("alt", $el.attr("alt"));
            img.appendTo(imageWrapper);
            activity.remove();
            that._fireEvent("draw-image", {
              image: img[0],
              item: imageWrapper[0]
            });
          };
        }
      },
      _index: function(el) {
        let index = -1;
        this.items.each(function(i3) {
          if (this === el) {
            index = i3;
          }
        });
        return index;
      },
      next: function() {
        let index;
        const current = this.current;
        index = this._index(current);
        if (index + 1 >= this.items.length) {
          if (this.options.loop) {
            index = -1;
          } else {
            return;
          }
        }
        this._goto(this.items[index + 1]);
      },
      prev: function() {
        let index;
        const current = this.current;
        index = this._index(current);
        if (index - 1 < 0) {
          if (this.options.loop) {
            index = this.items.length;
          } else {
            return;
          }
        }
        this._goto(this.items[index - 1]);
      },
      open: function(el) {
        this._setupItems();
        this._goto(el);
        this.overlay.show();
        this.lightbox.show();
        return this;
      },
      close: function() {
        this.overlay.hide();
        this.lightbox.hide();
      },
      changeAttribute: (attr, val) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/resizable/resizable.js
  ((Metro2, $7) => {
    "use strict";
    let ResizableDefaultConfig = {
      resizableDeferred: 0,
      canResize: true,
      resizeElement: ".resize-element",
      minWidth: 0,
      minHeight: 0,
      maxWidth: 0,
      maxHeight: 0,
      preserveRatio: false,
      onResizeStart: Metro2.noop,
      onResizeStop: Metro2.noop,
      onResize: Metro2.noop,
      onResizableCreate: Metro2.noop
    };
    Metro2.resizableSetup = (options) => {
      ResizableDefaultConfig = $7.extend({}, ResizableDefaultConfig, options);
    };
    if (typeof globalThis.metroResizableSetup !== "undefined") {
      Metro2.resizableSetup(globalThis.metroResizableSetup);
    }
    Metro2.Component("resizable", {
      init: function(options, elem) {
        this._super(elem, options, ResizableDefaultConfig, {
          resizer: null,
          id: null
        });
        return this;
      },
      _create: function() {
        this.id = Hooks.useId(this.elem);
        this._createStructure();
        this._createEvents();
        this._fireEvent("resizable-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("resizable-element");
        element2.attr("data-can-resize", o2.canResize);
        if (Metro2.utils.isValue(o2.resizeElement) && element2.find(o2.resizeElement).length > 0) {
          this.resizer = element2.find(o2.resizeElement);
        } else {
          this.resizer = $7("<span>").addClass("resize-element").appendTo(element2);
        }
        element2.data("canResize", o2.canResize);
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        this.resizer.on(Metro2.events.start, (e2) => {
          if (element2.data("canResize") === false) {
            return;
          }
          const startXY = Metro2.utils.pageXY(e2);
          const startWidth = Number.parseInt(element2.outerWidth());
          const startHeight = Number.parseInt(element2.outerHeight());
          const size = { width: startWidth, height: startHeight };
          element2.addClass("stop-pointer");
          this._fireEvent("resize-start", {
            size
          });
          $7(document).on(
            Metro2.events.move,
            (e3) => {
              const moveXY = Metro2.utils.pageXY(e3);
              const size2 = {
                width: startWidth + moveXY.x - startXY.x,
                height: startHeight + moveXY.y - startXY.y
              };
              if (o2.maxWidth > 0 && size2.width > o2.maxWidth) {
                return true;
              }
              if (o2.minWidth > 0 && size2.width < o2.minWidth) {
                return true;
              }
              if (o2.maxHeight > 0 && size2.height > o2.maxHeight) {
                return true;
              }
              if (o2.minHeight > 0 && size2.height < o2.minHeight) {
                return true;
              }
              element2.css(size2);
              this._fireEvent("resize", {
                size: size2
              });
            },
            { ns: this.id }
          );
          $7(document).on(
            Metro2.events.stop,
            () => {
              element2.removeClass("stop-pointer");
              $7(document).off(Metro2.events.move, { ns: this.id });
              $7(document).off(Metro2.events.stop, { ns: this.id });
              const size2 = {
                width: Number.parseInt(element2.outerWidth()),
                height: Number.parseInt(element2.outerHeight())
              };
              this._fireEvent("resize-stop", {
                size: size2
              });
            },
            { ns: this.id }
          );
          e2.preventDefault();
          e2.stopPropagation();
        });
      },
      off: function() {
        this.element.data("canResize", false);
      },
      on: function() {
        this.element.data("canResize", true);
      },
      changeAttribute: function(attributeName) {
        const element2 = this.element;
        const o2 = this.options;
        const canResize = () => {
          o2.canResize = JSON.parse(element2.attr("data-can-resize")) === true;
          if (o2.canResize) {
            this.on();
          } else {
            this.off();
          }
        };
        switch (attributeName) {
          case "data-can-resize":
            canResize();
            break;
        }
      },
      destroy: function() {
        this.resizer.off(Metro2.events.start);
        return this.element;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/linked-block/linked-block.js
  ((Metro2, $7) => {
    "use strict";
    const dragIcon = `
    <svg width="800px" height="800px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="can-drag-icon" style="z-index: 100">
        <path d="M16.1924 5.65683C16.5829 5.2663 16.5829 4.63314 16.1924 4.24261L13.364 1.41419C12.5829 0.633139 11.3166 0.633137 10.5355 1.41419L7.70711 4.24261C7.31658 4.63314 7.31658 5.2663 7.70711 5.65683C8.09763 6.04735 8.73079 6.04735 9.12132 5.65683L11 3.77812V11.0503H3.72784L5.60655 9.17157C5.99707 8.78104 5.99707 8.14788 5.60655 7.75735C5.21602 7.36683 4.58286 7.36683 4.19234 7.75735L1.36391 10.5858C0.582863 11.3668 0.582859 12.6332 1.36391 13.4142L4.19234 16.2426C4.58286 16.6332 5.21603 16.6332 5.60655 16.2426C5.99707 15.8521 5.99707 15.219 5.60655 14.8284L3.8284 13.0503H11V20.2219L9.12132 18.3432C8.73079 17.9526 8.09763 17.9526 7.7071 18.3432C7.31658 18.7337 7.31658 19.3669 7.7071 19.7574L10.5355 22.5858C11.3166 23.3669 12.5829 23.3669 13.364 22.5858L16.1924 19.7574C16.5829 19.3669 16.5829 18.7337 16.1924 18.3432C15.8019 17.9526 15.1687 17.9526 14.7782 18.3432L13 20.1213V13.0503H20.071L18.2929 14.8284C17.9024 15.219 17.9024 15.8521 18.2929 16.2426C18.6834 16.6332 19.3166 16.6332 19.7071 16.2426L22.5355 13.4142C23.3166 12.6332 23.3166 11.3668 22.5355 10.5858L19.7071 7.75735C19.3166 7.36683 18.6834 7.36683 18.2929 7.75735C17.9024 8.14788 17.9024 8.78104 18.2929 9.17157L20.1716 11.0503H13V3.87867L14.7782 5.65683C15.1687 6.04735 15.8019 6.04735 16.1924 5.65683Z" fill="var(--linked-block-border-color)"/>
    </svg>
    `;
    let globalConnectionState = {
      isConnecting: false,
      sourceBlock: null,
      sourcePoint: null,
      tempConnector: null,
      mouseFollower: null
    };
    let LinkedBlockDefaultConfig = {
      width: null,
      height: null,
      minWidth: 0,
      minHeight: 0,
      maxWidth: null,
      maxHeight: null,
      content: "",
      showAddButtons: true,
      addButtons: "north east south west",
      resizeHotkey: null,
      dragHotkey: null,
      connectionType: "curve",
      // line, curve, step
      connectionStyle: "solid",
      // solid, dashed, dotted
      connectionAnimate: false,
      connectionAnimationSpeed: 500,
      // швидкість анімації (1-5)
      connectionAnimationDirection: "forward",
      // forward, reverse
      onePoint: false,
      canDrag: true,
      canResize: true,
      showPoints: true,
      showDragIcon: true,
      position: "absolute",
      top: 0,
      left: 0,
      onAddPoint: Metro2.noop,
      onRemovePoint: Metro2.noop,
      onStartConnection: Metro2.noop,
      onCancelConnection: Metro2.noop,
      onConnect: Metro2.noop,
      onDisconnect: Metro2.noop,
      onDragStart: Metro2.noop,
      onDragMove: Metro2.noop,
      onDragEnd: Metro2.noop,
      onLinkedBlockCreate: Metro2.noop
    };
    Metro2.linkedBlockSetup = (options) => {
      LinkedBlockDefaultConfig = $7.extend({}, LinkedBlockDefaultConfig, options);
    };
    if (typeof window.metroLinkedBlockSetup !== "undefined") {
      Metro2.linkedBlockSetup(window.metroLinkedBlockSetup);
    }
    Metro2.Component("linked-block", {
      init: function(options, elem) {
        this._super(elem, options, LinkedBlockDefaultConfig, {
          pointCount: 0,
          connections: /* @__PURE__ */ new Map(),
          hoverButtons: []
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this.html = element2.html();
        element2.clear();
        this._createStructure();
        this._createEvents();
        this._setupDraggable();
        this._setupResizable();
        Metro2.utils.exec(this.options.onLinkedBlockCreate, [element2]);
        this._fireEvent("linked-block-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (!element2.attr("id")) {
          element2.attr("id", `linked-block-${Hooks.useId(element2[0])}`);
        }
        element2.addClass("linked-block");
        if (o2.onePoint) {
          element2.addClass("one-point");
        }
        if (o2.showPoints === false) {
          element2.addClass("no-points");
        }
        if (o2.showDragIcon === false) {
          element2.addClass("no-drag-icon");
        }
        element2.css("position", o2.position);
        if (o2.width) element2.css("width", o2.width);
        if (o2.height) element2.css("height", o2.height);
        if (o2.minWidth) element2.css("min-width", o2.minWidth);
        if (o2.minHeight) element2.css("min-height", o2.minHeight);
        if (o2.maxWidth) element2.css("max-width", o2.maxWidth);
        if (o2.maxHeight) element2.css("max-height", o2.maxHeight);
        if (o2.top) element2.css("top", o2.top);
        if (o2.left) element2.css("left", o2.left);
        const _content = element2.innerHTML;
        let contentContainer = element2.find(".linked-block-content");
        if (contentContainer.length === 0) {
          contentContainer = $7("<div>").addClass("linked-block-content");
          element2.append(contentContainer);
        }
        contentContainer.html(this.html || o2.content);
        this._createSides();
        if (o2.showAddButtons) {
          this._createAddButtons();
        }
      },
      _createSides: function() {
        const element2 = this.element;
        const sides = [
          { name: "north-side", position: "top" },
          { name: "east-side", position: "right" },
          { name: "south-side", position: "bottom" },
          { name: "west-side", position: "left" }
        ];
        sides.forEach((side) => {
          const sideElement = $7("<div>").addClass(`side ${side.name}`).attr("data-side", side.position);
          element2.append(sideElement);
        });
      },
      _createAddButtons: function() {
        const element2 = this.element;
        const o2 = this.options;
        const sides = o2.addButtons.toArray(" ");
        sides.forEach((side) => {
          const button = $7("<button>").addClass(`add-point-btn add-point-${side}`).attr("type", "button").attr("data-side", side).text("+");
          element2.append(button);
          this.hoverButtons.push(button);
        });
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        const self = this;
        if (o2.showAddButtons) {
          element2.on("mouseenter.linked-block", () => {
            self.hoverButtons.forEach((btn) => btn.show());
            self._fireEvent("hover", { element: element2 });
          });
          element2.on("mouseleave.linked-block", () => {
            if (!self.isConnecting) {
              self.hoverButtons.forEach((btn) => btn.hide());
            }
            self._fireEvent("leave", { element: element2 });
          });
          element2.on("click.linked-block", ".add-point-btn", function(e2) {
            e2.preventDefault();
            e2.stopPropagation();
            const side = $7(this).attr("data-side");
            if (globalConnectionState.isConnecting) {
              self._completeConnection($7(this), side);
            } else {
              self._startConnection($7(this), side);
            }
            self._updateConnections();
          });
        }
        element2.on("click.linked-block", (e2) => {
          $7(".linked-block").removeClass("active-block");
          element2.toggleClass("active-block");
          e2.stopPropagation();
        });
        if (o2.resizeHotkey) {
          $7("body").hotkey(o2.resizeHotkey, () => {
            const activeBlock = $7(".linked-block.active-block");
            const canResize = activeBlock.attr("data-can-resize") ? JSON.parse(activeBlock.attr("data-can-resize")) : o2.canResize;
            activeBlock.attr("data-can-resize", !canResize);
          });
        }
        if (o2.dragHotkey) {
          $7("body").hotkey(o2.dragHotkey, () => {
            const activeBlock = $7(".linked-block.active-block");
            const canDrag = activeBlock.attr("data-can-drag") ? JSON.parse(activeBlock.attr("data-can-drag")) : o2.canDrag;
            activeBlock.attr("data-can-drag", !canDrag);
          });
        }
      },
      _setupDraggable: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (o2.position !== "absolute" && o2.position !== "fixed") {
          return;
        }
        element2.append(dragIcon);
        Metro2.makePlugin(element2, "draggable", {
          canDrag: o2.canDrag,
          onDragStart: () => {
            const { top, left } = element2.rect();
            Metro2.utils.exec(o2.onDragStart, [{ top, left }, element2]);
          },
          onDragMove: () => {
            this.hoverButtons.forEach((btn) => btn.hide());
            this._updateConnections();
            const { top, left } = element2.rect();
            Metro2.utils.exec(o2.onDragMove, [{ top, left }, element2]);
          },
          onDragStop: () => {
            this.hoverButtons.forEach((btn) => btn.show());
            this._updateConnections();
            const { top, left } = element2.rect();
            Metro2.utils.exec(o2.onDragEnd, [{ top, left }, element2]);
          }
        });
      },
      _setupResizable: function() {
        const element2 = this.element;
        const o2 = this.options;
        Metro2.makePlugin(element2, "resizable", {
          canResize: o2.canResize,
          minWidth: o2.minWidth,
          minHeight: o2.minHeight,
          maxWidth: o2.maxWidth,
          maxHeight: o2.maxHeight,
          onResize: () => {
            const { width, height } = element2.rect();
            this._updateConnections();
            Metro2.utils.exec(o2.onResize, [{ width, height }, element2]);
          }
        });
      },
      _updateConnections: function() {
        this.connections.forEach((connection) => {
          if (connection.connector?.update) {
            connection.connector.update();
          }
        });
      },
      _generatePointId: function(side) {
        const element2 = this.element;
        const blockId = element2.attr("id");
        return `${blockId}_${side}_${this.pointCount++}`;
      },
      _startConnection: function(button, side) {
        Metro2.utils.exec(this.options.onStartConnection, [button, side]);
        this._fireEvent("start-connection", {
          element: this.element,
          button,
          side
        });
        const newPoint = this.addPoint(side);
        const newPointRect = newPoint.rect();
        const tempPoint = this._createTempPoint();
        tempPoint.css({
          top: newPointRect.y,
          left: newPointRect.x
        });
        tempPoint.addClass("temp-point");
        globalConnectionState.isConnecting = true;
        globalConnectionState.sourceBlock = this;
        globalConnectionState.sourcePoint = newPoint;
        const tempId = `temp-connector-${Date.now()}`;
        try {
          globalConnectionState.tempConnector = Metro2.connector.create(
            newPoint,
            // передаємо DOM елемент
            tempPoint,
            // передаємо DOM елемент
            {
              type: "line",
              container: this.element.parent(),
              id: tempId,
              autoUpdate: false
            }
          );
        } catch (error) {
          console.error("Error creating temp connector:", error);
          this._cancelConnection();
          return;
        }
        globalConnectionState.mouseFollower = $7("<div>").addClass("temp-connection-point").css({
          position: "absolute",
          width: "1px",
          height: "1px",
          pointerEvents: "none",
          zIndex: 1e3
        }).appendTo(this.element.parent());
        button.addClass("connecting");
      },
      _updateMouseFollower: function(clientX, clientY) {
        if (!globalConnectionState.mouseFollower || !globalConnectionState.tempConnector) {
          return;
        }
        const container = this.element.parent();
        if (typeof container === "undefined") {
          return;
        }
        const containerOffset = container.offset();
        const x5 = clientX - containerOffset.left;
        const y4 = clientY - containerOffset.top;
        globalConnectionState.mouseFollower.css({
          left: x5,
          top: y4
        });
        const tempPoint = $7(globalConnectionState.tempConnector.options.pointB);
        tempPoint.css({
          left: x5,
          top: y4
        });
        try {
          globalConnectionState.tempConnector.update();
        } catch (error) {
          console.error("Error updating temp connector:", error);
        }
      },
      _completeConnection: function(targetButton, targetSide) {
        const o2 = this.options;
        const targetBlock = targetButton.closest(".linked-block");
        const targetBlockInstance = Metro2.getPlugin(targetBlock[0], "linked-block");
        if (!targetBlockInstance || targetBlock[0] === globalConnectionState.sourceBlock.element[0]) {
          this._cancelConnection();
          return;
        }
        const targetPoint = targetBlockInstance.addPoint(targetSide);
        if (globalConnectionState.tempConnector) {
          globalConnectionState.tempConnector.destroy();
        }
        const connectionId = `connection-${Date.now()}`;
        const connector = Metro2.connector.create(globalConnectionState.sourcePoint[0], targetPoint[0], {
          type: o2.connectionType,
          lineStyle: o2.connectionStyle,
          container: globalConnectionState.sourceBlock.element.parent(),
          id: connectionId,
          autoUpdate: true,
          animated: o2.connectionAnimate,
          animationSpeed: o2.connectionAnimationSpeed,
          animationDirection: o2.connectionAnimationDirection
        });
        const connectionData = {
          connector,
          sourceBlock: this.element[0],
          targetBlock: targetBlock[0],
          sourcePoint: globalConnectionState.sourcePoint,
          targetPoint
        };
        this.connections.set(connectionId, connectionData);
        targetBlockInstance.connections.set(connectionId, connectionData);
        Metro2.utils.exec(o2.onConnect, [
          connectionId,
          this.element[0],
          targetBlock[0],
          globalConnectionState.sourcePoint,
          targetPoint,
          connector
        ]);
        this._fireEvent("connect", { connectionId, ...connectionData });
        this._resetConnectionState();
      },
      _cancelConnection: function() {
        Metro2.utils.exec(this.options.onCancelConnection);
        this._fireEvent("cancel-connection", {
          element: this.element
        });
        if (globalConnectionState.sourcePoint) {
          $7(globalConnectionState.sourcePoint).remove();
        }
        if (globalConnectionState.tempConnector) {
          globalConnectionState.tempConnector.destroy();
        }
        this._resetConnectionState();
      },
      _resetConnectionState: () => {
        if (globalConnectionState.mouseFollower) {
          globalConnectionState.mouseFollower.remove();
        }
        globalConnectionState = {
          isConnecting: false,
          sourceBlock: null,
          sourcePoint: null,
          tempConnector: null,
          mouseFollower: null
        };
        $7(".add-point-btn").removeClass("connecting connection-target").hide();
        $7(".linked-block").each(function() {
          const blockInstance = Metro2.getPlugin(this, "linked-block");
          if (blockInstance && $7(this).is(":hover")) {
            blockInstance.hoverButtons.forEach((btn) => btn.show());
          }
        });
      },
      _createTempPoint: function() {
        const container = this.element.parent();
        return $7("<div>").addClass("temp-point").css({
          position: "absolute",
          width: "1px",
          height: "1px",
          left: "0px",
          top: "0px",
          zIndex: -1
        }).appendTo(container);
      },
      // Перевірка, чи точка вже задіяна у будь-якому з'єднанні цього блоку
      _isPointBusy: function(pointEl) {
        const pid = $7(pointEl).attr("id");
        let busy = false;
        this.connections.forEach((connection) => {
          if (connection.sourcePoint?.attr("id") === pid || connection.targetPoint?.attr("id") === pid) {
            busy = true;
          }
        });
        return busy;
      },
      // Повертає першу вільну точку на стороні або null
      _findFreePoint: function(side) {
        const pts = this.getPoints(side);
        for (let i3 = 0; i3 < pts.length; i3++) {
          const p5 = $7(pts[i3]);
          if (!this._isPointBusy(p5)) return p5;
        }
        return null;
      },
      // Повертає першу вільну точку на будь-якій стороні (DOM-порядок сторін)
      _findAnyFreePoint: function() {
        const pts = this.getPoints();
        for (let i3 = 0; i3 < pts.length; i3++) {
          const p5 = $7(pts[i3]);
          if (!this._isPointBusy(p5)) return p5;
        }
        return null;
      },
      // Повертає вільну точку на стороні або створює нову
      _getOrCreatePoint: function(side) {
        return this._findFreePoint(side) || this.addPoint(side);
      },
      // Публічні методи
      addPoint: function(side) {
        const element2 = this.element;
        const o2 = this.options;
        const validSides = ["north", "east", "south", "west"];
        if (validSides.indexOf(side) === -1) {
          console.warn("LinkedBlock: the wrong side. Use: north, east, south, west");
          return null;
        }
        const pointId = this._generatePointId(side);
        const point = $7("<div>").addClass("link-point").attr("id", pointId).attr("data-side", side);
        const sideElement = element2.find(`.${side}-side`);
        sideElement.append(point);
        Metro2.utils.exec(o2.onAddPoint, [point[0], side, pointId, element2[0]], element2[0]);
        this._fireEvent("add-point", {
          element: element2,
          point,
          side,
          pointId
        });
        return point;
      },
      removePoint: function(pointId) {
        const element2 = this.element;
        const o2 = this.options;
        const point = element2.find(`#${pointId}`);
        if (point.length === 0) {
          return false;
        }
        this.disconnectPoint(pointId);
        const side = point.attr("data-side");
        Metro2.utils.exec(o2.onRemovePoint, [point[0], side, pointId, element2[0]], element2[0]);
        point.remove();
        this._fireEvent("remove-point", {
          element: element2,
          pointId,
          side
        });
        return true;
      },
      getPoints: function(side = null) {
        const element2 = this.element;
        if (side) {
          return element2.find(`.${side}-side .link-point`);
        }
        return element2.find(".link-point");
      },
      connect: function(targetBlock, options = {}) {
        const element2 = this.element;
        const o2 = this.options;
        const target = targetBlock.element ? targetBlock.element : $7(targetBlock);
        if (target.length === 0) {
          console.warn("LinkedBlock: target block not found");
          return null;
        }
        const targetInst = Metro2.getPlugin(target[0], "linked-block");
        if (!targetInst) {
          console.warn("LinkedBlock: target block hasn't role linked-block");
          return null;
        }
        if (options.sourcePoint && options.targetPoint) {
          const sourcePoint2 = $7(options.sourcePoint);
          const targetPoint2 = $7(options.targetPoint);
          if (Metro2.connector?.create) {
            const connector = Metro2.connector.create(sourcePoint2, targetPoint2, {
              type: options.type || "curve",
              container: options.container || element2.parent()
            });
            const connectionId = `${element2.attr("id")}-${target.attr("id")}-${Date.now()}`;
            this.connections.set(connectionId, {
              target,
              sourcePoint: sourcePoint2,
              targetPoint: targetPoint2,
              connector,
              options
            });
            targetInst.connections.set(connectionId, {
              target: element2,
              sourcePoint: sourcePoint2,
              targetPoint: targetPoint2,
              connector,
              options
            });
            Metro2.utils.exec(
              o2.onConnect,
              [target[0], sourcePoint2[0], targetPoint2[0], connector.element[0]],
              element2[0]
            );
            this._fireEvent("connect", {
              element: element2[0],
              target: target[0],
              sourcePoint: sourcePoint2[0],
              targetPoint: targetPoint2[0],
              connector: connector.element[0],
              connectionId
            });
            this._updateConnections();
            return {
              id: connectionId,
              connector: connector.element[0],
              sourcePoint: sourcePoint2[0],
              targetPoint: targetPoint2[0]
            };
          }
          this._updateConnections();
          return null;
        }
        const freeSrc = this._findAnyFreePoint();
        const freeTgt = targetInst._findAnyFreePoint();
        if (freeSrc && freeTgt) {
          if (Metro2.connector?.create) {
            const connector = Metro2.connector.create(freeSrc, freeTgt, {
              type: options.type || "curve",
              container: options.container || element2.parent()
            });
            const connectionId = `${element2.attr("id")}-${target.attr("id")}-${Date.now()}`;
            this.connections.set(connectionId, {
              target,
              sourcePoint: freeSrc,
              targetPoint: freeTgt,
              connector,
              options
            });
            targetInst.connections.set(connectionId, {
              target: element2,
              sourcePoint: freeSrc,
              targetPoint: freeTgt,
              connector,
              options
            });
            Metro2.utils.exec(
              o2.onConnect,
              [target[0], freeSrc[0], freeTgt[0], connector.element[0]],
              element2[0]
            );
            this._fireEvent("connect", {
              element: element2[0],
              target: target[0],
              sourcePoint: freeSrc[0],
              targetPoint: freeTgt[0],
              connector: connector.element[0],
              connectionId
            });
            this._updateConnections();
            return {
              id: connectionId,
              connector: connector.element[0],
              sourcePoint: freeSrc[0],
              targetPoint: freeTgt[0]
            };
          }
          this._updateConnections();
          return null;
        }
        const srcRect = element2.rect();
        const tgtRect = target.rect();
        let sourceSide = null;
        let targetSide = null;
        if (srcRect.top + srcRect.height < tgtRect.top) {
          sourceSide = "north";
          targetSide = "south";
        } else if (tgtRect.top + tgtRect.height < srcRect.top) {
          sourceSide = "south";
          targetSide = "north";
        } else if (srcRect.left < tgtRect.left) {
          sourceSide = "east";
          targetSide = "west";
        } else if (tgtRect.left < srcRect.left) {
          sourceSide = "west";
          targetSide = "east";
        }
        const sourcePoint = options.sourcePoint ? $7(options.sourcePoint) : this._getOrCreatePoint(sourceSide);
        const targetPoint = options.targetPoint ? $7(options.targetPoint) : targetInst._getOrCreatePoint(targetSide);
        if (Metro2.connector?.create) {
          const connector = Metro2.connector.create(sourcePoint, targetPoint, {
            type: options.type || "curve",
            container: options.container || element2.parent()
          });
          const connectionId = `${element2.attr("id")}-${target.attr("id")}-${Date.now()}`;
          this.connections.set(connectionId, {
            target,
            sourcePoint,
            targetPoint,
            connector,
            options
          });
          targetInst.connections.set(connectionId, {
            target: element2,
            sourcePoint,
            targetPoint,
            connector,
            options
          });
          Metro2.utils.exec(
            o2.onConnect,
            [target[0], sourcePoint[0], targetPoint[0], connector.element[0]],
            element2[0]
          );
          this._fireEvent("connect", {
            element: element2[0],
            target: target[0],
            sourcePoint: sourcePoint[0],
            targetPoint: targetPoint[0],
            connector: connector.element[0],
            connectionId
          });
          this._updateConnections();
          return {
            id: connectionId,
            connector: connector.element[0],
            sourcePoint: sourcePoint[0],
            targetPoint: targetPoint[0]
          };
        }
        this._updateConnections();
        return null;
      },
      disconnect: function(connectionId) {
        const connection = this.connections.get(connectionId);
        if (!connection) {
          return false;
        }
        if (connection.connector?.destroy) {
          connection.connector.destroy();
        }
        this.connections.delete(connectionId);
        Metro2.utils.exec(this.options.onDisconnect, [connectionId]);
        this._fireEvent("disconnect", {
          connectionId
        });
        return true;
      },
      disconnectPoint: function(pointId) {
        const connectionsToRemove = [];
        this.connections.forEach((connection, id) => {
          if (connection.sourcePoint.attr("id") === pointId || connection.targetPoint.attr("id") === pointId) {
            connectionsToRemove.push(id);
          }
        });
        connectionsToRemove.forEach((id) => this.disconnect(id));
        return connectionsToRemove.length;
      },
      disconnectAll: function() {
        const connectionIds = Array.from(this.connections.keys());
        connectionIds.forEach((id) => this.disconnect(id));
        return connectionIds.length;
      },
      setContent: function(content) {
        const element2 = this.element;
        const contentContainer = element2.find(".linked-block-content");
        contentContainer.html(content);
        this.options.content = content;
      },
      getContent: function() {
        const element2 = this.element;
        const contentContainer = element2.find(".linked-block-content");
        return contentContainer.length ? contentContainer.html() : "";
      },
      getConnections: function() {
        return Array.from(this.connections.values());
      },
      update: function() {
        this._updateConnections();
      },
      changeAttribute: function(attr, val) {
        const o2 = this.options;
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        this.disconnectAll();
        element2.off("mouseenter.linked-block");
        element2.off("mouseleave.linked-block");
        element2.off("click.linked-block");
        element2.remove();
        this._fireEvent("linked-block-destroy");
      }
    });
    Metro2.linkedBlock = {
      create: (options = {}) => {
        const config = $7.extend({}, LinkedBlockDefaultConfig, options);
        const element2 = $7("<div>");
        if (config.id) {
          element2.id(config.id);
        }
        if (config.container) {
          $7(config.container).append(element2);
        } else {
          $7("body").append(element2);
        }
        return Metro2.makePlugin(element2, "linked-block", config);
      },
      destroy: (element2) => {
        const inst = element2.element ? element2 : Metro2.getPlugin(element2, "linked-block");
        if (inst) {
          inst.destroy();
        }
      },
      destroyAll: () => {
        $7(".linked-block").each(function() {
          const inst = Metro2.getPlugin(this, "linked-block");
          if (inst) {
            inst.destroy();
          }
        });
      },
      connect: (source, target, options = {}) => {
        const sourceInst = source.element ? source : Metro2.getPlugin(source, "linked-block");
        if (sourceInst) {
          return sourceInst.connect(target, options);
        }
        return null;
      },
      disconnect: (element2, connectionId) => {
        const inst = element2.element ? element2 : Metro2.getPlugin(element2, "linked-block");
        if (inst) {
          return inst.disconnect(connectionId);
        }
        return null;
      }
    };
    $7(document).on("click.linked-block-global", (e2) => {
      $7(".linked-block").removeClass("active-block");
      if (globalConnectionState.isConnecting && !$7(e2.target).hasClass("add-point-btn") && globalConnectionState.sourceBlock && typeof globalConnectionState.sourceBlock._cancelConnection === "function") {
        globalConnectionState.sourceBlock._cancelConnection();
      }
    });
    $7(document).on("mousemove.linked-block-global", (e2) => {
      if (globalConnectionState.isConnecting && globalConnectionState.mouseFollower && globalConnectionState.sourceBlock && typeof globalConnectionState.sourceBlock._updateMouseFollower === "function") {
        globalConnectionState.sourceBlock._updateMouseFollower(e2.clientX, e2.clientY);
      }
    });
    $7(document).on("mouseenter.linked-block-connection", ".add-point-btn", (e2) => {
      if (globalConnectionState.isConnecting && globalConnectionState.sourceBlock && $7(e2.target).closest(".linked-block")[0] !== globalConnectionState.sourceBlock.element[0]) {
        $7(e2.target).addClass("connection-target");
      }
    });
    $7(document).on("mouseleave.linked-block-connection", ".add-point-btn", (e2) => {
      if (globalConnectionState.isConnecting) {
        $7(e2.target).removeClass("connection-target");
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/linked-block/linked-connector.js
  ((Metro2, $7) => {
    "use strict";
    const deleteIcon = `<?xml version="1.0" encoding="utf-8"?><svg fill="var(--linked-block-line-color)" width="800px" height="800px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M5.755,20.283,4,8H20L18.245,20.283A2,2,0,0,1,16.265,22H7.735A2,2,0,0,1,5.755,20.283ZM21,4H16V3a1,1,0,0,0-1-1H9A1,1,0,0,0,8,3V4H3A1,1,0,0,0,3,6H21a1,1,0,0,0,0-2Z"/></svg>`;
    let ConnectorDefaultConfig = {
      pointA: null,
      pointB: null,
      type: "curve",
      // line, curve, step
      container: null,
      // контейнер для SVG
      autoUpdate: true,
      // автоматичне оновлення при переміщенні блоків
      id: null,
      // унікальний ID для з'єднання
      deleteButton: false,
      arrow: "none",
      // none, end, start, both
      lineStyle: "solid",
      // solid, dashed, dotted
      animated: false,
      // анімація потоку даних
      animationSpeed: 500,
      // швидкість анімації (1-5)
      animationDirection: "forward",
      // forward, reverse
      onConnectorCreate: Metro2.noop,
      onConnectorUpdate: Metro2.noop,
      onConnectorDestroy: Metro2.noop
    };
    Metro2.connectorSetup = (options) => {
      ConnectorDefaultConfig = $7.extend({}, ConnectorDefaultConfig, options);
    };
    if (typeof window.metroConnectorSetup !== "undefined") {
      Metro2.connectorSetup(window.metroConnectorSetup);
    }
    Metro2.Component("connector", {
      init: function(options, elem) {
        this._super(elem, options, ConnectorDefaultConfig, {
          connections: /* @__PURE__ */ new Map(),
          svgElement: null,
          observers: /* @__PURE__ */ new Map(),
          deleteButton: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        this._createStructure();
        this._createConnection();
        this._createEvents();
        this._fireEvent("connector-create", {
          element: element2,
          options: o2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (!o2.container) {
          o2.container = element2.parent();
        }
        if (!o2.id) {
          o2.id = `connector-${Hooks.useId(element2[0])}`;
        }
        element2.id(o2.id);
      },
      _createConnection: function() {
        const o2 = this.options;
        if (!o2.pointA || !o2.pointB) {
          console.warn("Connector: PointA and PointB are required to create connection");
          return;
        }
        const sharedSvg = this._getOrCreateSharedSVG(o2.container);
        this.svgElement = sharedSvg;
        const shape = this._createShape(o2.id, o2.type, sharedSvg);
        const deleteBtn = this._createDeleteButton(sharedSvg, o2.id);
        this._applyArrows(shape, sharedSvg);
        this._applyLineStyle(shape, o2.lineStyle);
        if (o2.animated) {
          this._applyAnimation(shape, o2.animationSpeed, o2.animationDirection);
        }
        this.connections.set(o2.id, {
          pointA: o2.pointA,
          pointB: o2.pointB,
          type: o2.type,
          svg: sharedSvg,
          shape,
          deleteBtn
        });
        this.update();
      },
      _createEvents: function() {
        const o2 = this.options;
        if (o2.autoUpdate) {
          this._setupAutoUpdate();
        }
        $7(document).on("click", ".cl-curve, .cl-line", (e2) => {
          this._selectPath(e2.target);
          e2.stopPropagation();
        });
        $7(document).on("click", () => {
          $7(".cl-line, .cl-curve").removeClass("selected-path");
          $7(`.connector-delete`).hide();
        });
      },
      _applyAnimation: (shape, speed = 2, direction = "forward") => {
        const animationClass = direction === "reverse" ? "data-flow-reverse" : "data-flow";
        let speedClass;
        if (speed <= 500) {
          speedClass = "speed-1";
        } else if (speed > 500 && speed <= 1e3) {
          speedClass = "speed-2";
        } else if (speed > 1e3 && speed <= 3e3) {
          speedClass = "speed-3";
        } else if (speed > 3e3 && speed <= 5e3) {
          speedClass = "speed-4";
        } else {
          speedClass = "speed-5";
        }
        shape.addClass(`${animationClass} ${speedClass}`);
        const dashLength = 6;
        const gapLength = 4;
        const totalLength = dashLength + gapLength;
        shape.attr("stroke-dasharray", `${dashLength} ${gapLength}`);
        const animationDuration = speed;
        const animationName = `data-flow-${shape.attr("data-conn-id")}`;
        const keyframes = direction === "reverse" ? `@keyframes ${animationName} { 0% { stroke-dashoffset: 0; } 100% { stroke-dashoffset: ${totalLength}px; } }` : `@keyframes ${animationName} { 0% { stroke-dashoffset: ${totalLength}px; } 100% { stroke-dashoffset: 0; } }`;
        const styleId = `connector-animation-${shape.attr("data-conn-id")}`;
        if (!$7(`#${styleId}`).length) {
          $7("<style>").attr("id", styleId).text(`
                        ${keyframes}
                        [data-conn-id="${shape.attr("data-conn-id")}"].animated {
                            animation: ${animationName} ${animationDuration}ms linear infinite;
                        }
                    `).appendTo("head");
        }
        shape.addClass("animated");
      },
      _removeAnimation: (shape) => {
        shape.removeClass("data-flow data-flow-reverse animated");
        shape.removeClass("speed-1 speed-2 speed-3 speed-4 speed-5");
        shape.removeAttr("stroke-dasharray");
        const styleId = `connector-animation-${shape.attr("data-conn-id")}`;
        $7(`#${styleId}`).remove();
      },
      _selectPath: function(path) {
        const o2 = this.options;
        const target = $7(path);
        const connId = target.attr("data-conn-id");
        target.toggleClass("selected-path");
        if (target.hasClass("selected-path") && o2.deleteButton === true) {
          $7(`.connector-delete[data-conn-id=${connId}]`).show();
        }
      },
      _setupAutoUpdate: function() {
        const o2 = this.options;
        const pointA = $7(o2.pointA);
        const pointB = $7(o2.pointB);
        if (window.MutationObserver) {
          const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
              if (mutation.type === "attributes" && (mutation.attributeName === "style" || mutation.attributeName === "class")) {
                this.update();
              }
            });
          });
          const blockA = pointA.closest(".linked-block");
          const blockB = pointB.closest(".linked-block");
          if (blockA.length) {
            observer.observe(blockA[0], {
              attributes: true,
              attributeFilter: ["style", "class"]
            });
          }
          if (blockB.length) {
            observer.observe(blockB[0], {
              attributes: true,
              attributeFilter: ["style", "class"]
            });
          }
          this.observers.set(o2.id, observer);
        }
        $7(document).on("drag-move.connector." + o2.id, () => {
          setTimeout(() => this.update(), 10);
        });
        $7(document).on("drag-stop.connector." + o2.id, () => {
          setTimeout(() => this.update(), 10);
        });
      },
      _getOrCreateSharedSVG: (container) => {
        const $container = $7(container);
        let svg = $container.children("svg.connection-area").first();
        if (!svg.length) {
          if ($container.css("position") === "static") {
            $container.css("position", "relative");
          }
          const ns = "http://www.w3.org/2000/svg";
          const svgEl = document.createElementNS(ns, "svg");
          svgEl.setAttribute("xmlns", ns);
          svgEl.setAttribute("class", "connection-area");
          svg = $7(svgEl);
          $container.append(svg);
        }
        return svg;
      },
      // Маркер-стрілка з вашого SVG, зменшений у 2 рази
      _ensureArrowMarker: (svg) => {
        const ns = "http://www.w3.org/2000/svg";
        const markerId = Hooks.useId("connector-arrow");
        let defs = svg.find("defs");
        if (!defs.length) {
          const d4 = document.createElementNS(ns, "defs");
          svg[0].appendChild(d4);
          defs = $7(d4);
        }
        const marker = defs.find(`#${markerId}`);
        if (!marker.length) {
          const m5 = document.createElementNS(ns, "marker");
          m5.setAttribute("id", markerId);
          m5.setAttribute("markerWidth", "10");
          m5.setAttribute("markerHeight", "8");
          m5.setAttribute("viewBox", "0 0 8 8");
          m5.setAttribute("refX", "8");
          m5.setAttribute("refY", "4");
          m5.setAttribute("orient", "auto-start-reverse");
          m5.setAttribute("markerUnits", "userSpaceOnUse");
          const path = document.createElementNS(ns, "path");
          path.setAttribute(
            "d",
            "M1,8 c-0.04,0-0.08-0.016-0.11-0.045 c-0.048-0.05-0.055-0.125-0.018-0.185 L3.45,4 L0.87,0.23 c-0.038-0.058-0.03-0.135,0.018-0.185 c0.048-0.05,0.125-0.06,0.185-0.026 L7.4,3.54 c0.046,0.026,0.075,0.076,0.075,0.13 s-0.029,0.103-0.075,0.13 L1.06,7.32 C0.96,7.38,0.93,7.96,1,8z"
          );
          path.setAttribute("fill", "var(--linked-block-line-color)");
          path.setAttribute("stroke", "none");
          m5.appendChild(path);
          defs[0].appendChild(m5);
        }
        return markerId;
      },
      _applyArrows: function(shape, svg) {
        const o2 = this.options;
        const value = o2.arrow === true ? "end" : o2.arrow || "none";
        shape.removeAttr("marker-start").removeAttr("marker-end");
        if (value === "none" || value === false) return;
        const markerId = this._ensureArrowMarker(svg);
        if (value === "start" || value === "both") {
          shape.attr("marker-start", `url(#${markerId})`);
        }
        if (value === "end" || value === "both") {
          shape.attr("marker-end", `url(#${markerId})`);
        }
      },
      _createShape: (id, type, svg) => {
        const ns = "http://www.w3.org/2000/svg";
        let el;
        if (type === "line") {
          el = document.createElementNS(ns, "line");
          el.setAttribute("class", "cl-line");
        } else {
          el = document.createElementNS(ns, "path");
          el.setAttribute("class", "cl-curve");
        }
        el.setAttribute("data-conn-id", id);
        svg[0].appendChild(el);
        return $7(el);
      },
      _createDeleteButton: function(svg, id) {
        const ns = "http://www.w3.org/2000/svg";
        const g5 = document.createElementNS(ns, "g");
        g5.setAttribute("class", "connector-delete");
        g5.setAttribute("data-conn-id", id);
        g5.style.cursor = "pointer";
        g5.style.pointerEvents = "all";
        const parsed = new DOMParser().parseFromString(deleteIcon, "image/svg+xml");
        const iconSvg = parsed.documentElement;
        iconSvg.setAttribute("width", "16");
        iconSvg.setAttribute("height", "16");
        iconSvg.removeAttribute("x");
        iconSvg.removeAttribute("y");
        const bg = document.createElementNS(ns, "circle");
        bg.setAttribute("r", "10");
        bg.setAttribute("cx", "8");
        bg.setAttribute("cy", "8");
        bg.setAttribute("fill", "var(--default-background, #fff)");
        bg.setAttribute("stroke", "var(--linked-block-line-color)");
        bg.setAttribute("stroke-width", "0.5");
        g5.appendChild(bg);
        g5.appendChild(iconSvg);
        svg[0].appendChild(g5);
        $7(g5).on("click", (e2) => {
          e2.stopPropagation();
          const b1 = $7(this.options.pointA).closest(".linked-block");
          const b22 = $7(this.options.pointB).closest(".linked-block");
          const plugin = Metro2.getPlugin(this.element, "connector");
          if (plugin && plugin.options.id === id) {
            plugin.destroy();
          } else {
            const connection = this.connections.get(id);
            if (connection) {
              this.destroy();
            }
          }
          Metro2.getPlugin(b1, "linked-block")?.update();
          Metro2.getPlugin(b22, "linked-block")?.update();
        });
        return $7(g5);
      },
      _positionDeleteButton: (connection) => {
        const { type, shape, deleteBtn } = connection;
        if (!deleteBtn || !deleteBtn.length || !shape || !shape.length) return;
        let cx = 0, cy = 0;
        if (type === "line") {
          const x1 = parseFloat(shape.attr("x1"));
          const y1 = parseFloat(shape.attr("y1"));
          const x22 = parseFloat(shape.attr("x2"));
          const y22 = parseFloat(shape.attr("y2"));
          if (isFinite(x1) && isFinite(y1) && isFinite(x22) && isFinite(y22)) {
            cx = (x1 + x22) / 2;
            cy = (y1 + y22) / 2;
          }
        } else {
          const pathEl = shape[0];
          if (typeof pathEl.getTotalLength === "function") {
            const len = pathEl.getTotalLength();
            const pt3 = pathEl.getPointAtLength(len / 2);
            cx = pt3.x;
            cy = pt3.y;
          }
        }
        const offsetX = 10;
        const offsetY = 10;
        deleteBtn.attr("transform", `translate(${cx - offsetX}, ${cy - offsetY})`);
      },
      // Приватні методи оновлення
      _updateLine: (pointA, pointB, shape) => {
        const point1 = $7(pointA);
        const point2 = $7(pointB);
        const line = shape;
        const svg = line.closest("svg");
        const rect1 = point1.offset();
        const rect2 = point2.offset();
        const svgRect = svg.offset();
        const point1Width = point1.outerWidth();
        const point1Height = point1.outerHeight();
        const point2Width = point2.outerWidth();
        const point2Height = point2.outerHeight();
        const x1 = rect1.left - svgRect.left + point1Width / 2;
        const y1 = rect1.top - svgRect.top + point1Height / 2;
        const x22 = rect2.left - svgRect.left + point2Width / 2;
        const y22 = rect2.top - svgRect.top + point2Height / 2;
        line.attr({
          x1,
          y1,
          x2: x22,
          y2: y22
        });
      },
      _updateCurve: function(pointA, pointB, shape) {
        const point1 = $7(pointA);
        const point2 = $7(pointB);
        const parent1 = point1.parent();
        const parent2 = point2.parent();
        const path = shape;
        const svg = path.closest("svg");
        const coords = this._getCoordinates(point1, point2, svg);
        const { x1, y1, x2: x22, y2: y22 } = coords;
        const dx = x22 - x1;
        const dy = y22 - y1;
        const distance = Math.sqrt(dx * dx + dy * dy);
        let cp1x, cp1y, cp2x, cp2y;
        const side1 = parent1.attr("class").match(/(north|south|east|west)-side/)?.[1] || "north";
        const side2 = parent2.attr("class").match(/(north|south|east|west)-side/)?.[1] || "north";
        const magic = 20;
        if (side1 === side2) {
          const controlOffset = Math.max(60, distance * 0.3);
          switch (side1) {
            case "north":
              cp1x = x1;
              cp1y = y1 - controlOffset - magic;
              cp2x = x22;
              cp2y = y22 - controlOffset - magic;
              break;
            case "south":
              cp1x = x1;
              cp1y = y1 + controlOffset + magic;
              cp2x = x22;
              cp2y = y22 + controlOffset + magic;
              break;
            case "east":
              cp1x = x1 + controlOffset + magic;
              cp1y = y1;
              cp2x = x22 + controlOffset + magic;
              cp2y = y22;
              break;
            case "west":
              cp1x = x1 - controlOffset - magic;
              cp1y = y1;
              cp2x = x22 - controlOffset - magic;
              cp2y = y22;
              break;
          }
        } else {
          const controlDistance = Math.max(60, distance * 0.3);
          switch (side1) {
            case "north":
              cp1x = x1;
              cp1y = y1 - controlDistance;
              break;
            case "south":
              cp1x = x1;
              cp1y = y1 + controlDistance;
              break;
            case "east":
              cp1x = x1 + controlDistance;
              cp1y = y1;
              break;
            case "west":
              cp1x = x1 - controlDistance;
              cp1y = y1;
              break;
          }
          switch (side2) {
            case "north":
              cp2x = x22;
              cp2y = y22 - controlDistance;
              break;
            case "south":
              cp2x = x22;
              cp2y = y22 + controlDistance;
              break;
            case "east":
              cp2x = x22 + controlDistance;
              cp2y = y22;
              break;
            case "west":
              cp2x = x22 - controlDistance;
              cp2y = y22;
              break;
          }
        }
        const pathData = `M ${x1} ${y1} C ${cp1x} ${cp1y} ${cp2x} ${cp2y} ${x22} ${y22}`;
        path.attr("d", pathData);
      },
      _updateStep: function(pointA, pointB, shape) {
        const point1 = $7(pointA);
        const point2 = $7(pointB);
        const parent1 = point1.parent();
        const parent2 = point2.parent();
        const path = shape;
        const svg = path.closest("svg");
        const coords = this._getCoordinates(point1, point2, svg);
        const { x1, y1, x2: x22, y2: y22 } = coords;
        let pathData;
        const tolerance = 5;
        const dx = x22 - x1;
        const dy = y22 - y1;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const side1 = parent1.attr("class").match(/(north|south|east|west)-side/)?.[1] || "north";
        const side2 = parent2.attr("class").match(/(north|south|east|west)-side/)?.[1] || "north";
        const svgRect = svg[0].getBoundingClientRect();
        const containerHeight = svgRect.height || $7(svg).height() || 1e3;
        const containerWidth = svgRect.width || $7(svg).width() || 1e3;
        const minY = 20;
        const maxY = containerHeight - 20;
        const minX = 20;
        const maxX = containerWidth - 20;
        if (side1 === side2) {
          const offset = Math.max(40, distance * 0.25);
          const cornerRadius = Math.min(15, offset / 3);
          switch (side1) {
            case "north":
              if (Math.abs(x1 - x22) <= tolerance) {
                pathData = `M ${x1} ${y1} L ${x22} ${y22}`;
              } else {
                let topY = Math.min(y1, y22) - offset;
                if (topY < minY) {
                  topY = minY;
                }
                pathData = `M ${x1} ${y1}
                                L ${x1} ${topY + cornerRadius}
                                Q ${x1} ${topY} ${x1 + (x22 > x1 ? cornerRadius : -cornerRadius)} ${topY}
                                L ${x22 - (x22 > x1 ? cornerRadius : -cornerRadius)} ${topY}
                                Q ${x22} ${topY} ${x22} ${topY + cornerRadius}
                                L ${x22} ${y22}`;
              }
              break;
            case "south":
              if (Math.abs(x1 - x22) <= tolerance) {
                pathData = `M ${x1} ${y1} L ${x22} ${y22}`;
              } else {
                let bottomY = Math.max(y1, y22) + offset;
                if (bottomY > maxY) {
                  bottomY = maxY;
                }
                pathData = `M ${x1} ${y1}
                                L ${x1} ${bottomY - cornerRadius}
                                Q ${x1} ${bottomY} ${x1 + (x22 > x1 ? cornerRadius : -cornerRadius)} ${bottomY}
                                L ${x22 - (x22 > x1 ? cornerRadius : -cornerRadius)} ${bottomY}
                                Q ${x22} ${bottomY} ${x22} ${bottomY - cornerRadius}
                                L ${x22} ${y22}`;
              }
              break;
            case "east":
              if (Math.abs(y1 - y22) <= tolerance) {
                pathData = `M ${x1} ${y1} L ${x22} ${y22}`;
              } else {
                let rightX = Math.max(x1, x22) + offset;
                if (rightX > maxX) {
                  rightX = maxX;
                }
                pathData = `M ${x1} ${y1}
                                L ${rightX - cornerRadius} ${y1}
                                Q ${rightX} ${y1} ${rightX} ${y1 + (y22 > y1 ? cornerRadius : -cornerRadius)}
                                L ${rightX} ${y22 - (y22 > y1 ? cornerRadius : -cornerRadius)}
                                Q ${rightX} ${y22} ${rightX - cornerRadius} ${y22}
                                L ${x22} ${y22}`;
              }
              break;
            case "west":
              if (Math.abs(y1 - y22) <= tolerance) {
                pathData = `M ${x1} ${y1} L ${x22} ${y22}`;
              } else {
                let leftX = Math.min(x1, x22) - offset;
                if (leftX < minX) {
                  leftX = minX;
                }
                pathData = `M ${x1} ${y1}
                                L ${leftX + cornerRadius} ${y1}
                                Q ${leftX} ${y1} ${leftX} ${y1 + (y22 > y1 ? cornerRadius : -cornerRadius)}
                                L ${leftX} ${y22 - (y22 > y1 ? cornerRadius : -cornerRadius)}
                                Q ${leftX} ${y22} ${leftX + cornerRadius} ${y22}
                                L ${x22} ${y22}`;
              }
              break;
          }
        } else {
          const direction = this._getDirection(parent1, parent2);
          if (direction === "horizontal") {
            const horizontalDistance = Math.abs(dx);
            const cornerRadius = Math.min(20, horizontalDistance / 6);
            if (Math.abs(y1 - y22) <= tolerance) {
              pathData = `M ${x1} ${y1} L ${x22} ${y22}`;
            } else {
              const midX = x1 + dx / 2;
              if (y1 < y22) {
                pathData = `M ${x1} ${y1} 
                                L ${midX - cornerRadius} ${y1} 
                                Q ${midX} ${y1} ${midX} ${y1 + cornerRadius}
                                L ${midX} ${y22 - cornerRadius}
                                Q ${midX} ${y22} ${midX + cornerRadius} ${y22}
                                L ${x22} ${y22}`;
              } else {
                pathData = `M ${x1} ${y1} 
                                L ${midX - cornerRadius} ${y1} 
                                Q ${midX} ${y1} ${midX} ${y1 - cornerRadius}
                                L ${midX} ${y22 + cornerRadius}
                                Q ${midX} ${y22} ${midX + cornerRadius} ${y22}
                                L ${x22} ${y22}`;
              }
            }
          } else {
            const verticalDistance = Math.abs(dy);
            const cornerRadius = Math.min(20, verticalDistance / 6);
            if (Math.abs(x1 - x22) <= tolerance) {
              pathData = `M ${x1} ${y1} L ${x22} ${y22}`;
            } else {
              const midY = y1 + dy / 2;
              if (x1 < x22) {
                pathData = `M ${x1} ${y1} 
                                L ${x1} ${midY - cornerRadius} 
                                Q ${x1} ${midY} ${x1 + cornerRadius} ${midY}
                                L ${x22 - cornerRadius} ${midY}
                                Q ${x22} ${midY} ${x22} ${midY + cornerRadius}
                                L ${x22} ${y22}`;
              } else {
                pathData = `M ${x1} ${y1} 
                                L ${x1} ${midY - cornerRadius} 
                                Q ${x1} ${midY} ${x1 - cornerRadius} ${midY}
                                L ${x22 + cornerRadius} ${midY}
                                Q ${x22} ${midY} ${x22} ${midY + cornerRadius}
                                L ${x22} ${y22}`;
              }
            }
          }
        }
        path.attr("d", pathData);
      },
      // Допоміжні методи
      _getDirection: (parent1, parent2) => {
        const side1 = parent1.attr("class").match(/(north|south|east|west)-side/)?.[1];
        const side2 = parent2.attr("class").match(/(north|south|east|west)-side/)?.[1];
        if (side1 === side2) {
          return side1 === "north" || side1 === "south" ? "horizontal" : "vertical";
        }
        if (side1 === "east" && side2 === "west" || side1 === "west" && side2 === "east") {
          return "horizontal";
        } else if (side1 === "south" && side2 === "north" || side1 === "north" && side2 === "south") {
          return "vertical";
        }
        return side1 === "north" || side1 === "south" ? "vertical" : "horizontal";
      },
      _getCoordinates: (point1, point2, svg) => {
        const rect1 = point1.offset();
        const rect2 = point2.offset();
        const svgRect = svg.offset();
        const point1Width = point1.outerWidth();
        const point1Height = point1.outerHeight();
        const point2Width = point2.outerWidth();
        const point2Height = point2.outerHeight();
        return {
          x1: rect1.left - svgRect.left + point1Width / 2,
          y1: rect1.top - svgRect.top + point1Height / 2,
          x2: rect2.left - svgRect.left + point2Width / 2,
          y2: rect2.top - svgRect.top + point2Height / 2
        };
      },
      _cleanupAutoUpdate: function() {
        const o2 = this.options;
        const observer = this.observers.get(o2.id);
        if (observer) {
          observer.disconnect();
          this.observers.delete(o2.id);
        }
        $7(document).off(".connector." + o2.id);
      },
      _getStrokeWidth: (shape) => {
        const sw = parseFloat(getComputedStyle(shape[0]).strokeWidth || "1");
        return isFinite(sw) ? sw : 1;
      },
      _getDashArray: function(style, shape) {
        const sw = this._getStrokeWidth(shape);
        switch ((style || "").toLowerCase()) {
          case "dashed":
            return `${Math.max(4, 6 * sw)} ${Math.max(3, 4 * sw)}`;
          case "dotted":
            return `${Math.max(1, 1.5 * sw)} ${Math.max(2, 3 * sw)}`;
          case "solid":
          default:
            return null;
        }
      },
      _applyLineStyle: function(shape, style) {
        const dash = this._getDashArray(style, shape);
        if (dash) {
          shape.attr("stroke-dasharray", dash);
          shape.attr("data-line-style", style);
        } else {
          shape.removeAttr("stroke-dasharray");
          shape.attr("data-line-style", "solid");
        }
      },
      // Публічні методи
      setType: function(type) {
        if (["line", "curve", "step"].indexOf(type) === -1) {
          console.warn("Connector: \u043D\u0435\u0432\u0456\u0434\u043E\u043C\u0438\u0439 \u0442\u0438\u043F \u0437'\u0454\u0434\u043D\u0430\u043D\u043D\u044F:", type);
          return;
        }
        const o2 = this.options;
        const oldType = o2.type;
        o2.type = type;
        const connection = this.connections.get(o2.id);
        const oldShape = connection?.shape;
        const svg = connection?.svg || this.svgElement || this._getOrCreateSharedSVG(o2.container);
        const newShape = this._createShape(o2.id, type, svg);
        this._applyArrows(newShape, svg);
        this._applyLineStyle(newShape, o2.lineStyle);
        if (oldShape?.length) {
          oldShape.remove();
        }
        this.connections.set(o2.id, {
          ...connection,
          type,
          old: oldType,
          svg,
          shape: newShape,
          deleteBtn: connection?.deleteBtn
        });
        this.update();
      },
      setPoints: function(pointA, pointB) {
        const o2 = this.options;
        o2.pointA = pointA;
        o2.pointB = pointB;
        this.connections.set(o2.id, {
          ...this.connections.get(o2.id),
          pointA,
          pointB
        });
        if (o2.autoUpdate) {
          this._cleanupAutoUpdate();
          this._setupAutoUpdate();
        }
        this.update();
      },
      update: function() {
        const o2 = this.options;
        const connection = this.connections.get(o2.id);
        if (!connection) return;
        switch (o2.type) {
          case "line":
            this._updateLine(connection.pointA, connection.pointB, connection.shape);
            break;
          case "curve":
            this._updateCurve(connection.pointA, connection.pointB, connection.shape);
            break;
          case "step":
            this._updateStep(connection.pointA, connection.pointB, connection.shape);
            break;
        }
        this._positionDeleteButton(connection);
        this._fireEvent("connector-update", {
          connection,
          type: o2.type
        });
      },
      setLineStyle: function(style) {
        const allowed = ["solid", "dashed", "dotted"];
        if (allowed.indexOf((style || "").toLowerCase()) === -1) {
          console.warn("Connector: unknown line style:", style);
          return;
        }
        const o2 = this.options;
        o2.lineStyle = style.toLowerCase();
        const connection = this.connections.get(o2.id);
        if (!connection?.shape) return;
        this._applyLineStyle(connection.shape, o2.lineStyle);
        this.update();
      },
      setArrow: function(value) {
        const map = { true: "end", false: "none" };
        const v5 = typeof value === "boolean" ? map[String(value)] : String(value || "none").toLowerCase();
        if (!["none", "start", "end", "both"].includes(v5)) {
          console.warn(`Connector: unknown value for arrow: ${value}! Use one of: none, start, end, both.`);
          return;
        }
        this.options.arrow = v5;
        const connection = this.connections.get(this.options.id);
        if (connection?.shape && connection?.svg) {
          this._applyArrows(connection.shape, connection.svg);
          this.update();
        }
      },
      setAnimation: function(enabled, speed = 2, direction = "forward") {
        const o2 = this.options;
        o2.animated = enabled;
        o2.animationSpeed = speed;
        o2.animationDirection = direction;
        const connection = this.connections.get(o2.id);
        if (!connection?.shape) return;
        if (enabled) {
          this._applyAnimation(connection.shape, speed, direction);
        } else {
          this._removeAnimation(connection.shape);
        }
      },
      startAnimation: function() {
        this.setAnimation(true, this.options.animationSpeed, this.options.animationDirection);
      },
      stopAnimation: function() {
        this.setAnimation(false);
      },
      setAnimationSpeed: function(speed) {
        if (this.options.animated) {
          this.setAnimation(true, speed, this.options.animationDirection);
        } else {
          this.options.animationSpeed = speed;
        }
      },
      setAnimationDirection: function(direction) {
        if (this.options.animated) {
          this.setAnimation(true, this.options.animationSpeed, direction);
        } else {
          this.options.animationDirection = direction;
        }
      },
      changeAttribute: function(attr, newValue) {
        if (attr === "data-type") {
          this.setType(newValue);
        }
        if (attr === "data-line-style") {
          this.setLineStyle(newValue);
        }
        if (attr === "data-arrow") {
          this.setArrow(newValue);
        }
        if (attr === "data-animated") {
          this.setAnimation(newValue === "true" || newValue === true);
        }
        if (attr === "data-animation-speed") {
          this.setAnimationSpeed(parseInt(newValue) || 2);
        }
        if (attr === "data-animation-direction") {
          this.setAnimationDirection(newValue);
        }
      },
      destroy: function() {
        const o2 = this.options;
        const pointA = $7(o2.pointA);
        const pointB = $7(o2.pointB);
        if (!pointB.hasClass("temp-point")) {
          pointA.remove();
          pointB.remove();
        }
        this._cleanupAutoUpdate();
        const connection = this.connections.get(o2.id);
        if (connection?.shape) {
          const svg = connection.svg || this.svgElement;
          this._removeAnimation(connection.shape);
          connection.shape.remove();
          if (connection.deleteBtn) {
            connection.deleteBtn.remove();
          }
          if (svg && svg.find(".cl-line, .cl-curve").length === 0) {
            svg.remove();
          }
        }
        if (this.svgElement) {
          this.svgElement = null;
        }
        this.connections.delete(o2.id);
        this._fireEvent("connector-destroy", {
          id: o2.id
        });
        return this.element;
      }
    });
    Metro2.connector = {
      create: (pointA, pointB, options = {}) => {
        const defaultOptions = {
          ...ConnectorDefaultConfig,
          pointA,
          pointB,
          container: $7("body")
        };
        const config = $7.extend({}, defaultOptions, options);
        const element2 = $7("<div>");
        config.container.append(element2);
        return Metro2.makePlugin(element2, "connector", config);
      },
      connect: (blockA, blockB, options = {}) => {
        const block = blockA.element ? blockA : Metro2.getPlugin(blockA, "linked-block");
        if (!block) {
          console.warn("Connector: hasn't role linked-block");
          return null;
        }
        block.connect(blockB, options);
      },
      setType: (id, type) => {
        if (!type) {
          console.warn(`Unknown connector type!`);
          return;
        }
        const connectorComponent = Metro2.getPlugin($7(`#${id}`), "connector");
        if (!connectorComponent) {
          console.warn(`Connector with id ${id} not found`);
        }
        connectorComponent.setType(type);
      },
      setAnimation: (id, enabled, speed, direction) => {
        const connectorComponent = Metro2.getPlugin($7(`#${id}`), "connector");
        if (!connectorComponent) {
          console.warn(`Connector with id ${id} not found`);
          return;
        }
        connectorComponent.setAnimation(enabled, speed, direction);
      },
      startAnimation: (id) => {
        const connectorComponent = Metro2.getPlugin($7(`#${id}`), "connector");
        if (!connectorComponent) {
          console.warn(`Connector with id ${id} not found`);
          return;
        }
        connectorComponent.startAnimation();
      },
      stopAnimation: (id) => {
        const connectorComponent = Metro2.getPlugin($7(`#${id}`), "connector");
        if (!connectorComponent) {
          console.warn(`Connector with id ${id} not found`);
          return;
        }
        connectorComponent.stopAnimation();
      },
      destroy: (id) => {
        const connectorComponent = Metro2.getPlugin($7(`#${id}`), "connector");
        if (!connectorComponent) {
          console.warn(`Connector with id ${id} not found`);
        }
        connectorComponent.destroy();
      }
    };
  })(Metro, Dom);

  // ../metroui-lib/source/components/list/list.js
  ((Metro2, $7) => {
    "use strict";
    let ListDefaultConfig = {
      listDeferred: 0,
      templateBeginToken: "<%",
      templateEndToken: "%>",
      paginationDistance: 5,
      paginationShortMode: true,
      thousandSeparator: ",",
      decimalSeparator: ",",
      itemTag: "li",
      defaultTemplateTag: "div",
      sortClass: null,
      sortDir: "asc",
      sortInitial: true,
      filterClass: null,
      filter: null,
      filterString: "",
      filters: null,
      source: null,
      showItemsSteps: false,
      showSearch: false,
      showListInfo: false,
      showPagination: false,
      showActivity: true,
      muteList: true,
      items: -1,
      itemsSteps: "all, 10,25,50,100",
      itemsAllTitle: "Show all",
      listItemsCountTitle: "Show entries:",
      listSearchTitle: "Search:",
      listInfoTitle: "Showing $1 to $2 of $3 entries",
      paginationPrevTitle: "Prev",
      paginationNextTitle: "Next",
      activityType: "cycle",
      activityStyle: "color",
      activityTimeout: 100,
      searchWrapper: null,
      rowsWrapper: null,
      infoWrapper: null,
      paginationWrapper: null,
      searchThreshold: 500,
      clsComponent: "",
      clsList: "",
      clsListItem: "",
      clsListTop: "",
      clsItemsCount: "",
      clsSearch: "",
      clsListBottom: "",
      clsListInfo: "",
      clsListPagination: "",
      clsPagination: "",
      clsTemplateTag: "",
      onDraw: Metro2.noop,
      onDrawItem: Metro2.noop,
      onSortStart: Metro2.noop,
      onSortStop: Metro2.noop,
      onSortItemSwitch: Metro2.noop,
      onSearch: Metro2.noop,
      onRowsCountChange: Metro2.noop,
      onDataLoad: Metro2.noop,
      onDataLoaded: Metro2.noop,
      onDataLoadError: Metro2.noop,
      onFilterItemAccepted: Metro2.noop,
      onFilterItemDeclined: Metro2.noop,
      onListCreate: Metro2.noop
    };
    Metro2.listSetup = (options) => {
      ListDefaultConfig = $7.extend({}, ListDefaultConfig, options);
    };
    if (typeof globalThis.metroListSetup !== "undefined") {
      Metro2.listSetup(globalThis.metroListSetup);
    }
    Metro2.Component("list", {
      init: function(options, elem) {
        this._super(elem, options, ListDefaultConfig, {
          currentPage: 1,
          pagesCount: 1,
          filterString: "",
          data: null,
          activity: null,
          busy: false,
          filters: [],
          wrapperInfo: null,
          wrapperSearch: null,
          wrapperRows: null,
          wrapperPagination: null,
          filterIndex: null,
          filtersIndexes: [],
          itemTemplate: null,
          sort: {
            dir: "asc",
            colIndex: 0
          },
          header: null,
          items: []
        });
        return this;
      },
      _create: function() {
        const o2 = this.options;
        if (o2.source) {
          this._fireEvent("data-load", {
            source: o2.source
          });
          fetch(o2.source).then(Metro2.fetch.status).then(Metro2.fetch.json).then((data) => {
            this._fireEvent("data-loaded", {
              source: o2.source,
              data
            });
            this._build(data);
          }).catch((error) => {
            this._fireEvent("data-load-error", {
              source: o2.source,
              error
            });
          });
        } else {
          this._build();
        }
      },
      _build: function(data) {
        if (Metro2.utils.isValue(data)) {
          this._createItemsFromJSON(data);
        } else {
          this._createItemsFromHTML();
        }
        this._createStructure();
        this._createEvents();
        this._fireEvent("list-create");
      },
      _createItemsFromHTML: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const clsTemplateTag = `${o2.clsTemplateTag}`.toArray(",");
        this.items = [];
        $7.each(element2.children(o2.itemTag), function() {
          const tagChildren = $7(this).children("*");
          if (clsTemplateTag.length) {
            if (clsTemplateTag.length === 1) {
              tagChildren.addClass(clsTemplateTag[0]);
            } else {
              tagChildren.each((i3, child) => {
                $7(child).addClass(
                  clsTemplateTag[i3] ? clsTemplateTag[i3] : clsTemplateTag[clsTemplateTag.length - 1]
                );
              });
            }
          }
          that.items.push(this);
        });
      },
      _createItemsFromJSON: function(source) {
        const that = this;
        const o2 = this.options;
        const clsTemplateTag = `${o2.clsTemplateTag}`.toArray(",");
        this.items = [];
        if (Metro2.utils.isValue(source.template)) {
          this.itemTemplate = source.template;
        }
        if (Metro2.utils.isValue(source.header)) {
          this.header = source.header;
        }
        if (Metro2.utils.isValue(source.data)) {
          $7.each(source.data, function() {
            let item = "";
            const li = document.createElement(o2.itemTag);
            const tpl = that.itemTemplate;
            let tagChildren;
            if (!Metro2.utils.isValue(tpl)) {
              for (const i3 in this) {
                item += `<${o2.defaultTemplateTag}>${this[i3]}</${o2.defaultTemplateTag}>`;
              }
            } else {
              item = Metro2.template(tpl, this, {
                beginToken: o2.templateBeginToken,
                endToken: o2.templateEndToken
              });
            }
            li.innerHTML = item;
            tagChildren = $7(li).children("*");
            if (clsTemplateTag.length) {
              if (clsTemplateTag.length === 1) {
                tagChildren.addClass(clsTemplateTag[0]);
              } else {
                tagChildren.each((i3, child) => {
                  $7(child).addClass(
                    clsTemplateTag[i3] ? clsTemplateTag[i3] : clsTemplateTag[clsTemplateTag.length - 1]
                  );
                });
              }
            }
            that.items.push(li);
          });
        }
      },
      _createTopBlock: function() {
        const element2 = this.element;
        const o2 = this.options;
        const top_block = $7("<div>").addClass("list-top").addClass(o2.clsListTop).insertBefore(element2);
        let search_block;
        let rows_block;
        search_block = Metro2.utils.isValue(this.wrapperSearch) ? this.wrapperSearch : $7("<div>").addClass("list-search-block").addClass(o2.clsSearch).appendTo(top_block);
        const search_input = $7("<input>").attr("type", "text").appendTo(search_block);
        Metro2.makePlugin(search_input, "input", {
          prepend: o2.listSearchTitle
        });
        if (o2.showSearch !== true) {
          search_block.hide();
        }
        rows_block = Metro2.utils.isValue(this.wrapperRows) ? this.wrapperRows : $7("<div>").addClass("list-rows-block").addClass(o2.clsItemsCount).appendTo(top_block);
        const rows_select = $7("<select>").appendTo(rows_block);
        $7.each(o2.itemsSteps.toArray(), function() {
          const option = $7("<option>").attr("value", this === "all" ? -1 : this).text(this === "all" ? o2.itemsAllTitle : this).appendTo(rows_select);
          if (+this === +o2.items) option.attr("selected", "selected");
        });
        rows_select.select({
          filter: false,
          prepend: o2.listItemsCountTitle,
          onChange: (val) => {
            if (+val === +o2.items) return;
            o2.items = Number.parseInt(val);
            this.currentPage = 1;
            this._draw();
            this._fireEvent("rows-count-change", {
              val
            });
          }
        });
        if (o2.showItemsSteps !== true) {
          rows_block.hide();
        }
        return top_block;
      },
      _createBottomBlock: function() {
        const element2 = this.element;
        const o2 = this.options;
        const bottom_block = $7("<div>").addClass("list-bottom").addClass(o2.clsListBottom).insertAfter(element2);
        let info3;
        let pagination;
        info3 = $7("<div>").addClass("list-info").addClass(o2.clsListInfo).appendTo(bottom_block);
        if (o2.showListInfo !== true) {
          info3.hide();
        }
        pagination = $7("<div>").addClass("list-pagination").addClass(o2.clsListPagination).appendTo(bottom_block);
        if (o2.showPagination !== true) {
          pagination.hide();
        }
        return bottom_block;
      },
      _createStructure: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        let list_component;
        const w_search = $7(o2.searchWrapper);
        const w_info = $7(o2.infoWrapper);
        const w_rows = $7(o2.rowsWrapper);
        const w_paging = $7(o2.paginationWrapper);
        if (w_search.length > 0) {
          this.wrapperSearch = w_search;
        }
        if (w_info.length > 0) {
          this.wrapperInfo = w_info;
        }
        if (w_rows.length > 0) {
          this.wrapperRows = w_rows;
        }
        if (w_paging.length > 0) {
          this.wrapperPagination = w_paging;
        }
        if (!element2.parent().hasClass("list-component")) {
          list_component = $7("<div>").addClass("list-component").insertBefore(element2);
          element2.appendTo(list_component);
        } else {
          list_component = element2.parent();
        }
        list_component.addClass(o2.clsComponent);
        this.activity = $7("<div>").addClass("list-progress").appendTo(list_component);
        $7("<div>").activity({
          type: o2.activityType,
          style: o2.activityStyle
        }).appendTo(this.activity);
        if (o2.showActivity !== true) {
          this.activity.css({
            visibility: "hidden"
          });
        }
        element2.addClass(o2.clsList);
        this._createTopBlock();
        this._createBottomBlock();
        if (Metro2.utils.isValue(o2.filterString)) {
          this.filterString = o2.filterString;
        }
        let filter_func;
        if (Metro2.utils.isValue(o2.filter)) {
          filter_func = Metro2.utils.isFunc(o2.filter);
          if (filter_func === false) {
            filter_func = Metro2.utils.func(o2.filter);
          }
          that.filterIndex = that.addFilter(filter_func);
        }
        if (Metro2.utils.isValue(o2.filters) && typeof o2.filters === "string") {
          $7.each(o2.filters.toArray(), function() {
            filter_func = Metro2.utils.isFunc(this);
            if (filter_func !== false) {
              that.filtersIndexes.push(that.addFilter(filter_func));
            }
          });
        }
        this.currentPage = 1;
        if (o2.sortInitial !== false) this.sorting(o2.sortClass, o2.sortDir, true);
        else this.draw();
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const component = element2.parent();
        const search = component.find(".list-search-block input");
        let customSearch;
        let searchItem = function() {
          that.filterString = this.value.trim().toLowerCase();
          if (that.filterString[that.filterString.length - 1] === ":") {
            return;
          }
          that.currentPage = 1;
          that._draw();
        };
        searchItem = Hooks.useDebounce(searchItem, o2.searchThreshold);
        search.on(Metro2.events.inputchange, searchItem);
        if (Metro2.utils.isValue(this.wrapperSearch)) {
          customSearch = this.wrapperSearch.find("input");
          if (customSearch.length > 0) {
            customSearch.on(Metro2.events.inputchange, searchItem);
          }
        }
        function pageLinkClick(l2) {
          const link = $7(l2);
          const item = link.parent();
          if (item.hasClass("active")) {
            return;
          }
          if (item.hasClass("service")) {
            if (link.data("page") === "prev") {
              that.currentPage--;
              if (that.currentPage === 0) {
                that.currentPage = 1;
              }
            } else {
              that.currentPage++;
              if (that.currentPage > that.pagesCount) {
                that.currentPage = that.pagesCount;
              }
            }
          } else {
            that.currentPage = link.data("page");
          }
          that._draw();
        }
        component.on(Metro2.events.click, ".pagination .page-link", function() {
          pageLinkClick(this);
        });
        if (Metro2.utils.isValue(this.wrapperPagination)) {
          this.wrapperPagination.on(Metro2.events.click, ".pagination .page-link", function() {
            pageLinkClick(this);
          });
        }
      },
      _info: function(start, stop, length) {
        const element2 = this.element;
        const o2 = this.options;
        const component = element2.parent();
        const info3 = Metro2.utils.isValue(this.wrapperInfo) ? this.wrapperInfo : component.find(".list-info");
        let text;
        let _stop = stop;
        let _start = start;
        let _length = length;
        if (info3.length === 0) {
          return;
        }
        if (_stop > length) {
          _stop = length;
        }
        if (this.items.length === 0) {
          _start = _stop = _length = 0;
        }
        text = o2.listInfoTitle;
        text = text.replace("$1", _start);
        text = text.replace("$2", _stop);
        text = text.replace("$3", _length);
        info3.html(text);
      },
      _paging: function(length) {
        const element2 = this.element;
        const o2 = this.options;
        const component = element2.parent();
        this.pagesCount = Math.ceil(length / o2.items);
        Metro2.pagination({
          length,
          rows: o2.items,
          current: this.currentPage,
          target: Metro2.utils.isValue(this.wrapperPagination) ? this.wrapperPagination : component.find(".list-pagination"),
          claPagination: o2.clsPagination,
          prevTitle: o2.paginationPrevTitle,
          nextTitle: o2.paginationNextTitle,
          distance: o2.paginationShortMode === true ? o2.paginationDistance : 0
        });
      },
      _filter: function() {
        const o2 = this.options;
        let items;
        let i3;
        let data;
        let inset;
        let c1;
        let result;
        if (Metro2.utils.isValue(this.filterString) || this.filters.length > 0) {
          items = this.items.filter((item) => {
            data = "";
            if (Metro2.utils.isValue(o2.filterClass)) {
              inset = item.getElementsByClassName(o2.filterClass);
              if (inset.length > 0)
                for (i3 = 0; i3 < inset.length; i3++) {
                  data += inset[i3].textContent;
                }
            } else {
              data = item.textContent;
            }
            c1 = data.replace(/[\n\r]+|[\s]{2,}/g, " ").trim().toLowerCase();
            result = Metro2.utils.isValue(this.filterString) ? c1.indexOf(this.filterString) > -1 : true;
            if (result === true && this.filters.length > 0) {
              for (i3 = 0; i3 < this.filters.length; i3++) {
                if (Metro2.utils.exec(this.filters[i3], [item]) !== true) {
                  result = false;
                  break;
                }
              }
            }
            if (result) {
              this._fireEvent("filter-item-accepted", {
                item
              });
            } else {
              this._fireEvent("filter-item-declined", {
                item
              });
            }
            return result;
          });
          this._fireEvent("search", {
            search: this.filterString,
            items
          });
        } else {
          items = this.items;
        }
        return items;
      },
      _draw: function(cb) {
        const element2 = this.element;
        const o2 = this.options;
        let i3;
        const start = o2.items === -1 ? 0 : o2.items * (this.currentPage - 1);
        const stop = o2.items === -1 ? this.items.length - 1 : start + o2.items - 1;
        let items;
        items = this._filter();
        element2.children(o2.itemTag).remove();
        for (i3 = start; i3 <= stop; i3++) {
          if (Metro2.utils.isValue(items[i3])) {
            $7(items[i3]).addClass(o2.clsListItem).appendTo(element2);
          }
          this._fireEvent("draw-item", {
            item: items[i3]
          });
        }
        this._info(start + 1, stop + 1, items.length);
        this._paging(items.length);
        this.activity.hide();
        this._fireEvent("draw");
        if (cb) {
          Metro2.utils.exec(cb, [element2], element2[0]);
        }
      },
      _getItemContent: function(item) {
        const locale = this.locale;
        const o2 = this.options;
        const $item = $7(item);
        let i3;
        let inset;
        let data;
        let format;
        const formatMask = Metro2.utils.isValue($item.data("formatMask")) ? $item.data("formatMask") : null;
        if (Metro2.utils.isValue(o2.sortClass)) {
          data = "";
          inset = $7(item).find(`.${o2.sortClass}`);
          if (inset.length > 0)
            for (i3 = 0; i3 < inset.length; i3++) {
              data += inset[i3].textContent;
            }
          format = inset.length > 0 ? inset[0].getAttribute("data-format") : "";
        } else {
          data = item.textContent;
          format = item.getAttribute("data-format");
        }
        data = `${data}`.toLowerCase().replace(/[\n\r]+|[\s]{2,}/g, " ").trim();
        if (Metro2.utils.isValue(format)) {
          if (["number", "int", "integer", "float", "money"].indexOf(format) !== -1 && (o2.thousandSeparator !== "," || o2.decimalSeparator !== ".")) {
            data = Metro2.utils.parseNumber(data, o2.thousandSeparator, o2.decimalSeparator);
          }
          switch (format) {
            case "date":
              data = formatMask ? Datetime.from(data, formatMask, locale) : datetime(data);
              break;
            case "number":
              data = Number(data);
              break;
            case "int":
            case "integer":
              data = Number.parseInt(data);
              break;
            case "float":
              data = Number.parseFloat(data);
              break;
            case "money":
              data = Metro2.utils.parseMoney(data);
              break;
            case "card":
              data = Metro2.utils.parseCard(data);
              break;
            case "phone":
              data = Metro2.utils.parsePhone(data);
              break;
          }
        }
        return data;
      },
      deleteItem: function(value) {
        let i3;
        const deleteIndexes = [];
        let item;
        const is_func = Metro2.utils.isFunc(value);
        for (i3 = 0; i3 < this.items.length; i3++) {
          item = this.items[i3];
          if (is_func) {
            if (Metro2.utils.exec(value, [item])) {
              deleteIndexes.push(i3);
            }
          } else {
            if (item.textContent.includes(value)) {
              deleteIndexes.push(i3);
            }
          }
        }
        this.items = Metro2.utils.arrayDeleteByMultipleKeys(this.items, deleteIndexes);
        return this;
      },
      draw: function() {
        return this._draw();
      },
      sorting: function(source, dir, redraw) {
        const o2 = this.options;
        if (Metro2.utils.isValue(source)) {
          o2.sortClass = source;
        }
        if (Metro2.utils.isValue(dir) && ["asc", "desc"].indexOf(dir) > -1) {
          o2.sortDir = dir;
        }
        this._fireEvent("sort-start", {
          items: this.items
        });
        this.items.sort((a2, b5) => {
          const c1 = this._getItemContent(a2);
          const c22 = this._getItemContent(b5);
          let result = 0;
          if (c1 < c22) {
            result = o2.sortDir === "asc" ? -1 : 1;
          }
          if (c1 > c22) {
            result = o2.sortDir === "asc" ? 1 : -1;
          }
          if (result !== 0) {
            this._fireEvent("sort-item-switch", {
              a: a2,
              b: b5,
              result
            });
          }
          return result;
        });
        this._fireEvent("sort-stop", {
          items: this.items
        });
        if (redraw === true) {
          this._draw();
        }
        return this;
      },
      filter: function(val) {
        this.filterString = val.trim().toLowerCase();
        this.currentPage = 1;
        this._draw();
      },
      setData: function(data) {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        if (Metro2.utils.isValue(data) !== true) {
          return;
        }
        that._createItemsFromJSON(data);
        element2.html("");
        if (Metro2.utils.isValue(o2.filterString)) {
          that.filterString = o2.filterString;
        }
        let filter_func;
        if (Metro2.utils.isValue(o2.filter)) {
          filter_func = Metro2.utils.isFunc(o2.filter);
          if (filter_func === false) {
            filter_func = Metro2.utils.func(o2.filter);
          }
          that.filterIndex = that.addFilter(filter_func);
        }
        if (Metro2.utils.isValue(o2.filters) && typeof o2.filters === "string") {
          $7.each(o2.filters.toArray(), function() {
            filter_func = Metro2.utils.isFunc(this);
            if (filter_func !== false) {
              that.filtersIndexes.push(that.addFilter(filter_func));
            }
          });
        }
        that.currentPage = 1;
        that.sorting(o2.sortClass, o2.sortDir, true);
      },
      loadData: function(source) {
        const o2 = this.options;
        if (Metro2.utils.isValue(source) !== true) {
          return;
        }
        o2.source = source;
        this._fireEvent("data-load", {
          source: o2.source
        });
        fetch(o2.source).then(Metro2.fetch.status).then(Metro2.fetch.json).then((data) => {
          this._fireEvent("data-loaded", {
            source: o2.source,
            data
          });
          this.setData(data);
        }).catch((error) => {
          this._fireEvent("data-load-error", {
            source: o2.source,
            error
          });
        });
      },
      next: function() {
        if (this.items.length === 0) return;
        this.currentPage++;
        if (this.currentPage > this.pagesCount) {
          this.currentPage = this.pagesCount;
          return;
        }
        this._draw();
      },
      prev: function() {
        if (this.items.length === 0) return;
        this.currentPage--;
        if (this.currentPage === 0) {
          this.currentPage = 1;
          return;
        }
        this._draw();
      },
      first: function() {
        if (this.items.length === 0) return;
        this.currentPage = 1;
        this._draw();
      },
      last: function() {
        if (this.items.length === 0) return;
        this.currentPage = this.pagesCount;
        this._draw();
      },
      page: function(num) {
        let _num = Number.parseInt(num);
        if (_num <= 0) {
          _num = 1;
        }
        if (_num > this.pagesCount) {
          _num = this.pagesCount;
        }
        this.currentPage = _num;
        this._draw();
      },
      addFilter: function(f5, redraw) {
        const func = Metro2.utils.isFunc(f5);
        if (func === false) {
          return;
        }
        this.filters.push(func);
        if (redraw === true) {
          this.currentPage = 1;
          this.draw();
        }
        return this.filters.length - 1;
      },
      removeFilter: function(key, redraw) {
        Metro2.utils.arrayDeleteByKey(this.filters, key);
        if (redraw === true) {
          this.currentPage = 1;
          this.draw();
        }
        return this;
      },
      removeFilters: function(redraw) {
        this.filters = [];
        if (redraw === true) {
          this.currentPage = 1;
          this.draw();
        }
      },
      getFilters: function() {
        return this.filters;
      },
      getFilterIndex: function() {
        return this.filterIndex;
      },
      getFiltersIndexes: function() {
        return this.filtersIndexes;
      },
      changeAttribute: function(attributeName) {
        const element2 = this.element;
        const o2 = this.options;
        const changeSortDir = () => {
          const dir = element2.attr("data-sort-dir");
          if (!Metro2.utils.isValue(dir)) {
            return;
          }
          o2.sortDir = dir;
          this.sorting(o2.sortClass, o2.sortDir, true);
        };
        const changeSortClass = () => {
          const target = element2.attr("data-sort-source");
          if (!Metro2.utils.isValue(target)) {
            return;
          }
          o2.sortClass = target;
          this.sorting(o2.sortClass, o2.sortDir, true);
        };
        const changeFilterString = () => {
          const filter = element2.attr("data-filter-string");
          if (!Metro2.utils.isValue(filter)) {
            return;
          }
          o2.filterString = filter;
          this.filter(o2.filterString);
        };
        switch (attributeName) {
          case "data-sort-dir":
            changeSortDir();
            break;
          case "data-sort-source":
            changeSortClass();
            break;
          case "data-filter-string":
            changeFilterString();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const component = element2.parent();
        const search = component.find(".list-search-block input");
        let customSearch;
        search.off(Metro2.events.inputchange);
        if (Metro2.utils.isValue(this.wrapperSearch)) {
          customSearch = this.wrapperSearch.find("input");
          if (customSearch.length > 0) {
            customSearch.off(Metro2.events.inputchange);
          }
        }
        component.off(Metro2.events.click, ".pagination .page-link");
        if (Metro2.utils.isValue(this.wrapperPagination)) {
          this.wrapperPagination.off(Metro2.events.click, ".pagination .page-link");
        }
        return element2;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/listview/listview.js
  ((Metro2, $7) => {
    "use strict";
    const file_icon = `
    <svg width="800px" height="800px" fill="none" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
        <path class="a" d="M39.5,15.5h-9a2,2,0,0,1-2-2v-9h-18a2,2,0,0,0-2,2v35a2,2,0,0,0,2,2h27a2,2,0,0,0,2-2Z"/>
        <line class="a" x1="28.5" y1="4.5" x2="39.5" y2="15.5"/>
    </svg>`;
    const toggleImage = `<svg aria-hidden="true" width="16" height="16" viewBox="0 0 24 24"><path d="m14.83 11.29-4.24-4.24a1 1 0 1 0-1.42 1.41L12.71 12l-3.54 3.54a1 1 0 0 0 0 1.41 1 1 0 0 0 .71.29 1 1 0 0 0 .71-.29l4.24-4.24a1.002 1.002 0 0 0 0-1.42Z"></path></svg>`;
    let ListViewDefaultConfig = {
      listviewDeferred: 0,
      selectable: false,
      duration: 100,
      view: Metro2.listView.LIST,
      selectCurrent: true,
      defaultIcon: file_icon,
      onNodeInsert: Metro2.noop,
      onNodeDelete: Metro2.noop,
      onNodeClean: Metro2.noop,
      onCollapseNode: Metro2.noop,
      onExpandNode: Metro2.noop,
      onGroupNodeClick: Metro2.noop,
      onNodeClick: Metro2.noop,
      onNodeDblclick: Metro2.noop,
      onListViewCreate: Metro2.noop
    };
    Metro2.listViewSetup = (options) => {
      ListViewDefaultConfig = $7.extend({}, ListViewDefaultConfig, options);
    };
    if (typeof globalThis.metroListViewSetup !== "undefined") {
      Metro2.listViewSetup(globalThis.metroListViewSetup);
    }
    Metro2.Component("listview", {
      init: function(options, elem) {
        this._super(elem, options, ListViewDefaultConfig);
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("listview-create", {
          element: element2
        });
      },
      _createIcon: (data) => $7("<div>").addClass("icon").html(data),
      _createCaption: (data = "") => $7("<div>").addClass("caption").html(data),
      _createContent: (data = "") => $7("<div>").addClass("content").html(data),
      _createDesc: (data = "") => $7("<div>").addClass("desc").html(data),
      _createDate: (data = "") => $7("<div>").addClass("date").html(data),
      _createToggle: () => $7("<span>").addClass("node-toggle").html(toggleImage),
      _createNode: function(data) {
        const o2 = this.options;
        const node = $7("<li>");
        node.append($7("<input type='checkbox' data-role='checkbox'>").data("node", node));
        node.append(this._createIcon(data.icon ?? o2.defaultIcon));
        node.append(this._createCaption(data.caption));
        node.append(this._createDesc(data.desc));
        node.append(this._createDate(data.date));
        node.append(this._createContent(data.content));
        return node;
      },
      _createStructure: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const nodes = element2.find("li");
        element2.addClass("listview");
        element2.find("ul").addClass("listview");
        if (o2.selectable) {
          element2.addClass("selectable");
        }
        $7.each(nodes, function(index) {
          const node = $7(this);
          const nodeContent = node.html();
          const defaultFileName = `Item_${index + 1}`;
          if (node.children("ul").length > 0) {
            node.prepend(that._createCaption(node.data("caption") ?? defaultFileName));
            node.addClass("node-group");
            node.append(that._createToggle());
            if (node.data("collapsed") !== true) node.addClass("expanded");
          } else {
            node.clear().addClass("node");
            node.append($7("<input type='checkbox' data-role='checkbox'>").data("node", node));
            node.append(that._createIcon(node.data("icon") ?? o2.defaultIcon));
            node.append(that._createCaption(node.data("caption") ?? defaultFileName));
            node.append(that._createDesc(node.data("desc")));
            node.append(that._createDate(node.data("date")));
            node.append(that._createContent(nodeContent));
          }
        });
        if (o2.selectable) {
          element2.addClass("selectable");
        }
        this.view(o2.view);
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        element2.on(Metro2.events.dblclick, ".node", function() {
          const node = $7(this);
          that._fireEvent("node-dblclick", {
            node
          });
        });
        element2.on(Metro2.events.click, ".node", function() {
          const node = $7(this);
          const href = $7(this).attr("href");
          if (href) {
            globalThis.location.href = href;
            return;
          }
          const isCurrent = node.hasClass("current");
          element2.find(".node").removeClass("current");
          if (!isCurrent) {
            node.addClass("current");
          }
          if (o2.selectCurrent === true) {
            element2.find(".node").removeClass("current-select");
            if (!isCurrent) {
              node.addClass("current-select");
            }
          }
          that._fireEvent("node-click", {
            node
          });
        });
        element2.on(Metro2.events.click, ".node-toggle", function() {
          const node = $7(this).closest("li");
          that.toggleNode(node);
        });
        element2.on(Metro2.events.click, ".node-group > .caption", function() {
          const node = $7(this).closest("li");
          element2.find(".node-group").removeClass("current-group");
          node.addClass("current-group");
          that._fireEvent("group-node-click", {
            node
          });
        });
        element2.on(Metro2.events.dblclick, ".node-group > .caption", function() {
          const node = $7(this).closest("li");
          that.toggleNode(node);
          that._fireEvent("node-dbl-click", {
            node
          });
        });
      },
      view: function(v5) {
        const element2 = this.element;
        const o2 = this.options;
        if (v5 === void 0) {
          return o2.view;
        }
        o2.view = v5;
        $7.each(Metro2.listView, (i3, v6) => {
          element2.removeClass(`view-${v6}`);
          element2.find("ul").removeClass(`view-${v6}`);
        });
        element2.addClass(`view-${o2.view}`);
        element2.find("ul").addClass(`view-${o2.view}`);
      },
      toggleNode: function(node) {
        const o2 = this.options;
        const n3 = $7(node);
        if (!n3.hasClass("node-group")) {
          return;
        }
        n3.toggleClass("expanded");
        const func = n3.hasClass("expanded") !== true ? "slideUp" : "slideDown";
        this._fireEvent("collapse-node", {
          node: n3
        });
        n3.children("ul")[func](o2.duration);
      },
      toggleSelectable: function() {
        const element2 = this.element;
        const o2 = this.options;
        o2.selectable = !o2.selectable;
        const func = o2.selectable === true ? "addClass" : "removeClass";
        element2[func]("selectable");
        element2.find("ul")[func]("selectable");
      },
      add: function(data, node = null) {
        const element2 = this.element;
        const o2 = this.options;
        let target;
        let toggle;
        let n3;
        if (node === null) {
          target = element2;
        } else {
          n3 = $7(node);
          if (!n3.hasClass("node-group")) {
            return;
          }
          target = n3.children("ul");
          if (target.length === 0) {
            target = $7("<ul>").addClass("listview").addClass(`view-${o2.view}`).appendTo(n3);
            toggle = this._createToggle();
            toggle.appendTo(n3);
            n3.addClass("expanded");
          }
        }
        const new_node = this._createNode(data);
        new_node.addClass("node").appendTo(target);
        const cb = $7("<input type='checkbox'>");
        cb.data("node", new_node);
        new_node.prepend(cb);
        Metro2.makePlugin(cb, "checkbox", {});
        this._fireEvent("node-insert", {
          newNode: new_node,
          parentNode: node,
          list: target
        });
        return new_node;
      },
      addGroup: function(data) {
        const element2 = this.element;
        const o2 = this.options;
        if (data.icon) delete data.icon;
        const node = this._createNode(data);
        node.addClass("node-group").appendTo(element2);
        node.append(this._createToggle());
        node.addClass("expanded");
        node.append($7("<ul>").addClass("listview").addClass(`view-${o2.view}`));
        this._fireEvent("node-insert", {
          newNode: node,
          parentNode: null,
          list: element2
        });
        return node;
      },
      insertBefore: function(data, node) {
        const n3 = $7(node);
        if (!n3.length) {
          return;
        }
        const new_node = this._createNode(data);
        new_node.addClass("node").insertBefore(n3);
        const parent_node = new_node.closest(".node");
        const list = new_node.closest("ul");
        this._fireEvent("node-insert", {
          newNode: new_node,
          parentNode: parent_node,
          list
        });
        return new_node;
      },
      insertAfter: function(data, node) {
        const n3 = $7(node);
        if (!n3.length) {
          return;
        }
        const new_node = this._createNode(data);
        new_node.addClass("node").insertAfter(n3);
        const parent_node = new_node.closest(".node");
        const list = new_node.closest("ul");
        this._fireEvent("node-insert", {
          newNode: new_node,
          parentNode: parent_node,
          list
        });
        return new_node;
      },
      del: function(node) {
        const element2 = this.element;
        const n3 = $7(node);
        if (!n3.length) {
          return;
        }
        const parent_list = n3.closest("ul");
        const parent_node = parent_list.closest("li");
        n3.remove();
        if (parent_list.children().length === 0 && !parent_list.is(element2)) {
          parent_list.remove();
          parent_node.removeClass("expanded");
          parent_node.children(".node-toggle").remove();
        }
        this._fireEvent("node-delete", {
          node: n3
        });
      },
      clean: function(node) {
        const n3 = $7(node);
        if (!n3.length) {
          return;
        }
        n3.children("ul").remove();
        n3.removeClass("expanded");
        n3.children(".node-toggle").remove();
        this._fireEvent("node-clean", {
          node: n3
        });
      },
      getSelected: function() {
        const element2 = this.element;
        const nodes = [];
        $7.each(element2.find(":checked"), function() {
          const check = $7(this);
          nodes.push(check.closest(".node")[0]);
        });
        return nodes;
      },
      clearSelected: function() {
        this.element.find(":checked").prop("checked", false);
        this.element.trigger("change");
      },
      selectAll: function(mode = true) {
        this.element.find(".checkbox input").prop("checked", mode);
        this.element.trigger("change");
      },
      selectByAttribute: function(attributeName, attributeValue, select = true) {
        this.element.find(`li[${attributeName}="${attributeValue}"] > .checkbox input`).prop("checked", select);
        this.element.trigger("change");
      },
      changeAttribute: function(attributeName) {
        const element2 = this.element;
        const o2 = this.options;
        const changeView = () => {
          const new_view = `view-${element2.attr("data-view")}`;
          this.view(new_view);
        };
        const changeSelectable = () => {
          o2.selectable = JSON.parse(element2.attr("data-selectable")) === true;
          this.toggleSelectable();
        };
        switch (attributeName) {
          case "data-view":
            changeView();
            break;
          case "data-selectable":
            changeSelectable();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, ".node");
        element2.off(Metro2.events.click, ".node-toggle");
        element2.off(Metro2.events.click, ".node-group > .caption");
        element2.off(Metro2.events.dblclick, ".node-group > .caption");
        element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/marquee/marquee.js
  ((Metro2, $7) => {
    "use strict";
    let MarqueeDefaultConfig = {
      items: null,
      loop: true,
      height: "auto",
      width: "100%",
      duration: 1e4,
      direction: "left",
      ease: "linear",
      mode: "default",
      // default || accent
      accentPause: 2e3,
      firstPause: 1e3,
      stopOnHover: true,
      splitBy: "\n",
      clsMarquee: "",
      clsMarqueeItem: "",
      onMarqueeItem: Metro2.noop,
      onMarqueeItemComplete: Metro2.noop,
      onMarqueeComplete: Metro2.noop,
      onMarqueeCreate: Metro2.noop
    };
    Metro2.marqueeSetup = (options) => {
      MarqueeDefaultConfig = $7.extend({}, MarqueeDefaultConfig, options);
    };
    if (typeof globalThis.metroMarqueeSetup !== "undefined") {
      Metro2.marqueeSetup(globalThis.metroMarqueeSetup);
    }
    Metro2.Component("marquee", {
      init: function(options, elem) {
        this._super(elem, options, MarqueeDefaultConfig, {
          // define instance vars here
          origin: null,
          items: [],
          running: false,
          current: -1,
          chain: []
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("marquee-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("marquee").addClass(o2.clsMarquee);
        element2.css({
          height: o2.height,
          width: o2.width
        });
        const items = element2.html().split(o2.splitBy).map((a2) => a2.trim()).filter((a2) => a2.length);
        const itemsFromOptions = Metro2.utils.isObject(o2.items) || [];
        this.origin = [...items, ...itemsFromOptions];
        this.setItems(this.origin, true);
        if (this.items.length) {
          this.current = 0;
          this.createChain();
          this.start();
        }
      },
      setItems: function(items, replace = true) {
        const element2 = this.element;
        const o2 = this.options;
        const dir = o2.direction.toLowerCase();
        if (replace) {
          this.items.length = 0;
        }
        element2.clear();
        this.items = items.map((item) => {
          return $7("<div>").html(item).addClass("marquee__item").addClass(o2.clsMarqueeItem).appendTo(element2)[0];
        });
        $7(this.items).addClass(dir === "left" || dir === "right" ? "moveLeftRight" : "moveUpDown");
        if (o2.height === "auto") {
          let h3 = 0;
          $7(this.items).each(function() {
            const el = $7(this);
            const eh = +el.outerHeight(true);
            if (eh > h3) {
              h3 = eh;
            }
          });
          element2.height(h3);
        }
        return this;
      },
      setItem: function(index, value) {
        const target = $7(this.items[index]);
        let h3;
        const o2 = this.options;
        const element2 = this.element;
        if (!target.length) {
          return;
        }
        target.html(value);
        h3 = target.outerHeight(true);
        if (o2.height === "auto" && element2.height() < h3) {
          element2.height(h3);
        }
        return this;
      },
      addItem: function(item, index = -1) {
        const element2 = this.element;
        const o2 = this.options;
        let ins;
        const $item = $7(item);
        let trg;
        let h3;
        ins = $item.length ? $item : $7("<div>").html(item);
        if (index < 0) {
          element2.append(ins);
        } else {
          trg = this.items[index];
          if (trg) {
            ins.insertBefore(trg);
          } else {
            element2.append(ins);
          }
        }
        h3 = ins.outerHeight(true);
        if (o2.height === "auto" && element2.height() < h3) {
          element2.height(h3);
        }
        return this;
      },
      createChain: function() {
        const element2 = this.element;
        const o2 = this.options;
        const magic = 20;
        let dir = o2.direction;
        let ease = o2.ease;
        let dur = +o2.duration;
        let i3 = 0;
        const rect = element2[0].getBoundingClientRect();
        this.chain.length = 0;
        if (o2.mode === "default") {
          for (const item of this.items) {
            const el = $7(item);
            const elRect = item.getBoundingClientRect();
            const half = (rect.width - elRect.width) / 2;
            let draw;
            if (el.attr("data-direction")) {
              dir = el.attr("data-direction");
            }
            if (el.attr("data-duration")) {
              dur = +el.attr("data-duration");
            }
            if (el.attr("data-ease")) {
              ease = el.attr("data-ease");
            } else {
              ease = o2.ease;
            }
            if (["left", "right"].indexOf(dir) > -1) {
              draw = {
                left: dir === "left" ? [rect.width, -elRect.width - magic] : [-elRect.width - magic, rect.width]
              };
            } else {
              draw = {
                top: dir === "up" ? [rect.height, -elRect.height - magic] : [-elRect.height - magic, rect.height]
              };
            }
            this.chain.push({
              el: el[0],
              draw,
              dur,
              ease,
              defer: i3 === 0 ? +o2.firstPause : 0
            });
            i3++;
          }
        } else {
          for (const item of this.items) {
            const el = $7(item);
            const elRect = item.getBoundingClientRect();
            const halfW = (rect.width - elRect.width) / 2;
            const halfH = (rect.height - elRect.height) / 2;
            let draw1;
            let draw2;
            dur = o2.duration / 2;
            if (el.attr("data-direction")) {
              dir = el.attr("data-direction").toLowerCase();
            }
            if (el.attr("data-duration")) {
              dur = +el.attr("data-duration") / 2;
            }
            let _ease = ease ? ease.split(" ") : ["linear"];
            if (el.attr("data-ease")) {
              _ease = el.attr("data-ease").split(" ");
            }
            if (["left", "right"].includes(dir)) {
              draw1 = {
                left: dir === "left" ? [rect.width, halfW] : [-elRect.width - magic, halfW]
              };
              draw2 = {
                left: dir === "left" ? [halfW, -elRect.width - magic] : [halfW, rect.width + magic]
              };
            } else {
              draw1 = {
                top: dir === "up" ? [rect.height, halfH] : [-elRect.height - magic, halfH]
              };
              draw2 = {
                top: dir === "up" ? [halfH, -elRect.height - magic] : [halfH, rect.height + magic]
              };
            }
            this.chain.push({
              el: el[0],
              draw: draw1,
              dur,
              ease: _ease[0] || "linear",
              defer: i3 === 0 ? +o2.firstPause : 0
            });
            this.chain.push({
              el: el[0],
              draw: draw2,
              dur,
              ease: _ease[1] ? _ease[1] : _ease[0] ? _ease[0] : "linear",
              defer: +o2.accentPause
            });
            i3++;
          }
        }
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.on(Metro2.events.enter, () => {
          if (o2.stopOnHover) $7.pauseAll(this.items);
        });
        element2.on(Metro2.events.leave, () => {
          if (o2.stopOnHover) $7.resumeAll(this.items);
        });
        const resize = Hooks.useDebounce((e2) => {
          this.stop();
          this.setItems(this.items, true);
          this.createChain();
          this.start();
        }, 1e3);
        $7(window).on(Metro2.events.resize, resize);
      },
      start: function() {
        const o2 = this.options;
        this.running = true;
        $7.chain(this.chain, {
          loop: o2.loop,
          onChainItem: Metro2.utils.isFunc(o2.onMarqueeItem),
          onChainItemComplete: Metro2.utils.isFunc(o2.onMarqueeItemComplete),
          onChainComplete: Metro2.utils.isFunc(o2.onMarqueeComplete)
        });
        return this;
      },
      stop: function() {
        this.running = false;
        $7.stopAll(false);
        return this;
      },
      changeAttribute: (attr, val) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/master/master.js
  ((Metro2, $7) => {
    "use strict";
    let MasterDefaultConfig = {
      masterDeferred: 0,
      effect: "slide",
      // slide, fade, switch, slowdown, custom
      effectFunc: "linear",
      duration: 200,
      controlPrev: "\u2190",
      controlNext: "\u2192",
      controlTitle: "Master, page $1 of $2",
      backgroundImage: "",
      clsMaster: "",
      clsControls: "",
      clsControlPrev: "",
      clsControlNext: "",
      clsControlTitle: "",
      clsPages: "",
      clsPage: "",
      onBeforePage: Metro2.noop_true,
      onBeforeNext: Metro2.noop_true,
      onBeforePrev: Metro2.noop_true,
      onNextPage: Metro2.noop,
      onPrevPage: Metro2.noop,
      onMasterCreate: Metro2.noop
    };
    Metro2.masterSetup = (options) => {
      MasterDefaultConfig = $7.extend({}, MasterDefaultConfig, options);
    };
    if (typeof globalThis.metroMasterSetup !== "undefined") {
      Metro2.masterSetup(globalThis.metroMasterSetup);
    }
    Metro2.Component("master", {
      init: function(options, elem) {
        this._super(elem, options, MasterDefaultConfig, {
          pages: [],
          currentIndex: 0,
          isAnimate: false,
          id: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        this.id = Hooks.useId(this.elem);
        element2.addClass("master").addClass(o2.clsMaster);
        element2.css({
          backgroundImage: `url(${o2.backgroundImage})`
        });
        this._createControls();
        this._createPages();
        this._createEvents();
        this._fireEvent("master-create", {
          element: element2
        });
      },
      _createControls: function() {
        const element2 = this.element;
        const o2 = this.options;
        const controls_position = ["top", "bottom"];
        let controls;
        let title;
        const pages = element2.find(".page");
        title = String(o2.controlTitle).replace("$1", "1");
        title = String(title).replace("$2", pages.length);
        $7.each(controls_position, function() {
          controls = $7("<div>").addClass(`controls controls-${this}`).addClass(o2.clsControls).appendTo(element2);
          $7("<span>").addClass("prev").addClass(o2.clsControlPrev).html(o2.controlPrev).appendTo(controls);
          $7("<span>").addClass("next").addClass(o2.clsControlNext).html(o2.controlNext).appendTo(controls);
          $7("<span>").addClass("title").addClass(o2.clsControlTitle).html(title).appendTo(controls);
        });
        this._enableControl("prev", false);
      },
      _enableControl: function(type, state2) {
        const control = this.element.find(`.controls .${type}`);
        if (state2 === true) {
          control.removeClass("disabled");
        } else {
          control.addClass("disabled");
        }
      },
      _setTitle: function() {
        const title = this.element.find(".controls .title");
        let title_str = this.options.controlTitle.replace("$1", this.currentIndex + 1);
        title_str = title_str.replace("$2", String(this.pages.length));
        title.html(title_str);
      },
      _createPages: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        let pages = element2.find(".pages");
        const page = element2.find(".page");
        if (pages.length === 0) {
          pages = $7("<div>").addClass("pages").appendTo(element2);
        }
        pages.addClass(o2.clsPages);
        $7.each(page, function() {
          const p5 = $7(this);
          if (p5.data("cover")) {
            element2.css({
              backgroundImage: `url(${p5.data("cover")})`
            });
          } else {
            element2.css({
              backgroundImage: `url(${o2.backgroundImage})`
            });
          }
          p5.css({
            left: "100%"
          });
          p5.addClass(o2.clsPage).hide(0);
          that.pages.push(p5);
        });
        page.appendTo(pages);
        this.currentIndex = 0;
        if (this.pages[this.currentIndex] !== void 0) {
          if (this.pages[this.currentIndex].data("cover") !== void 0) {
            element2.css({
              backgroundImage: `url(${this.pages[this.currentIndex].data("cover")})`
            });
          }
          this.pages[this.currentIndex].css("left", "0").show(0);
          setTimeout(() => {
            pages.css({
              height: that.pages[0].outerHeight(true) + 2
            });
          }, 0);
        }
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.on(Metro2.events.click, ".controls .prev", () => {
          if (this.isAnimate === true) {
            return;
          }
          if (Metro2.utils.exec(o2.onBeforePrev, [this.currentIndex, this.pages[this.currentIndex], element2]) === true && Metro2.utils.exec(o2.onBeforePage, [
            "prev",
            this.currentIndex,
            this.pages[this.currentIndex],
            element2
          ]) === true) {
            this.prev();
          }
        });
        element2.on(Metro2.events.click, ".controls .next", () => {
          if (this.isAnimate === true) {
            return;
          }
          if (Metro2.utils.exec(o2.onBeforeNext, [this.currentIndex, this.pages[this.currentIndex], element2]) === true && Metro2.utils.exec(o2.onBeforePage, [
            "next",
            this.currentIndex,
            this.pages[this.currentIndex],
            element2
          ]) === true) {
            this.next();
          }
        });
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            element2.find(".pages").height(this.pages[this.currentIndex].outerHeight(true) + 2);
          },
          { ns: this.id }
        );
      },
      _slideToPage: function(index) {
        if (this.pages[index] === void 0) {
          return;
        }
        if (this.currentIndex === index) {
          return;
        }
        const to2 = index > this.currentIndex ? "next" : "prev";
        const current = this.pages[this.currentIndex];
        const next = this.pages[index];
        this.currentIndex = index;
        this._effect(current, next, to2);
      },
      _slideTo: function(to2) {
        const forward = to2.toLowerCase() === "next";
        const current = this.pages[this.currentIndex];
        if (forward) {
          if (this.currentIndex + 1 >= this.pages.length) {
            return;
          }
          this.currentIndex++;
        } else {
          if (this.currentIndex - 1 < 0) {
            return;
          }
          this.currentIndex--;
        }
        const next = this.pages[this.currentIndex];
        this._fireEvent(forward ? "next-page" : "prev-page", {
          current,
          next,
          forward
        });
        this._effect(current, next, to2);
      },
      _effect: function(current, next, to2) {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const out = element2.width();
        const pages = element2.find(".pages");
        this._setTitle();
        if (this.currentIndex === this.pages.length - 1) {
          this._enableControl("next", false);
        } else {
          this._enableControl("next", true);
        }
        if (this.currentIndex === 0) {
          this._enableControl("prev", false);
        } else {
          this._enableControl("prev", true);
        }
        setTimeout(() => {
          that.isAnimate = true;
          pages.animate({
            draw: {
              height: next.outerHeight(true) + 2
            },
            onDone: () => {
              finish();
            }
          });
        }, 0);
        pages.css("overflow", "hidden");
        function finish() {
          if (next.data("cover") !== void 0) {
            element2.css({
              backgroundImage: `url(${next.data("cover")})`
            });
          } else {
            element2.css({
              backgroundImage: `url(${o2.backgroundImage})`
            });
          }
          pages.css("overflow", "initial");
          that.isAnimate = false;
        }
        function _slide() {
          current.stop(true).animate({
            draw: {
              left: to2 === "next" ? -out : out
            },
            dur: o2.duration,
            ease: o2.effectFunc,
            onDone: () => {
              current.hide(0);
            }
          });
          next.stop(true).css({
            left: to2 === "next" ? out : -out
          }).show(0).animate({
            draw: {
              left: 0
            },
            dur: o2.duration,
            ease: o2.effectFunc,
            onDone: () => {
              finish();
            }
          });
        }
        function _switch() {
          current.hide();
          next.css({
            top: 0,
            left: 0,
            opacity: 0
          }).show(() => {
            finish();
          });
        }
        function _fade() {
          current.fadeOut(o2.duration);
          next.css({
            top: 0,
            left: 0,
            opacity: 0
          }).fadeIn(o2.duration, "linear", () => {
            finish();
          });
        }
        switch (o2.effect) {
          case "fade":
            _fade();
            break;
          case "switch":
            _switch();
            break;
          default:
            _slide();
        }
      },
      toPage: function(index) {
        this._slideToPage(index);
      },
      next: function() {
        this._slideTo("next");
      },
      prev: function() {
        this._slideTo("prev");
      },
      changeEffect: function() {
        this.options.effect = this.element.attr("data-effect");
      },
      changeEffectFunc: function() {
        this.options.effectFunc = this.element.attr("data-effect-func");
      },
      changeEffectDuration: function() {
        this.options.duration = this.element.attr("data-duration");
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-effect":
            this.changeEffect();
            break;
          case "data-effect-func":
            this.changeEffectFunc();
            break;
          case "data-duration":
            this.changeEffectDuration();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, ".controls .prev");
        element2.off(Metro2.events.click, ".controls .next");
        $7(globalThis).off(Metro2.events.resize, { ns: this.id });
        element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/navview/navview.js
  ((Metro2, $7) => {
    "use strict";
    let NavigationViewDefaultConfig = {
      navViewDeferred: 0,
      expandPoint: null,
      // compacted: false,
      toggle: null,
      animate: true,
      activeState: true,
      initialView: "expand",
      onMenuItemClick: Metro2.noop,
      onPaneClose: Metro2.noop,
      onBeforePaneClose: Metro2.noop,
      onPaneOpen: Metro2.noop,
      onBeforePaneOpen: Metro2.noop,
      onNavviewCreate: Metro2.noop
    };
    Metro2.navViewSetup = (options) => {
      NavigationViewDefaultConfig = $7.extend({}, NavigationViewDefaultConfig, options);
    };
    if (typeof globalThis.metroNavViewSetup !== "undefined") {
      Metro2.navViewSetup(globalThis.metroNavViewSetup);
    }
    Metro2.Component("nav-view", {
      init: function(options, elem) {
        this._super(elem, options, NavigationViewDefaultConfig, {
          pane: null,
          content: null,
          paneToggle: null,
          id: null,
          menuScrollDistance: 0,
          menuScrollStep: 0
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("navview-create");
      },
      _calcMenuHeight: function() {
        const element2 = this.element;
        let elements_height = 0;
        const pane = element2.children(".navview-pane");
        if (pane.length === 0) {
          return;
        }
        const menu_container = pane.children(".navview-menu-container");
        if (menu_container.length === 0) {
          return;
        }
        $7.each(menu_container.prevAll(), function() {
          elements_height += $7(this).outerHeight(true);
        });
        $7.each(menu_container.nextAll(), function() {
          elements_height += $7(this).outerHeight(true);
        });
        menu_container.css({
          height: `calc(100% - ${elements_height}px)`
        });
        this.menuScrollStep = 48;
        this.menuScrollDistance = Metro2.utils.nearest(menu_container[0].scrollHeight - menu_container.height(), 48);
      },
      _recalc: function() {
        setTimeout(() => {
          this._calcMenuHeight();
        }, 200);
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        let menu;
        element2.addClass("navview");
        if (element2.attr("id") === void 0) {
          element2.attr("id", Hooks.useId(this.elem));
        }
        this.id = element2.attr("id");
        if (o2.initialView !== "compact" && Metro2.utils.mediaExist(o2.expandPoint)) {
          element2.addClass("expanded");
        } else {
          element2.addClass("compacted handmade");
        }
        const state2 = Metro2.storage.getItem("navview:compacted");
        if (state2 === true) {
          element2.removeClass("expanded");
          element2.addClass("compacted handmade");
        }
        const pane = element2.children(".navview-pane");
        const content = element2.children(".navview-content");
        const toggle = $7(o2.toggle);
        menu = pane.children(".navview-menu");
        if (menu.length) {
          menu.prevAll().reverse().wrapAll($7("<div>").addClass("navview-container"));
          menu.wrap($7("<div>").addClass("navview-menu-container"));
          menu.find("a").each(function() {
            const a2 = $7(this);
            const icon = a2.children(".icon");
            const caption = a2.children(".caption");
            if (!icon.length) {
              const text = (caption.text() || "A B").split(" ");
              a2.prepend(
                $7("<span>").addClass("icon icon-replacer").html(`${text[0][0]}${text[1] ? text[1][0] : ""}`)
              );
            }
          });
        }
        this.pane = pane.length > 0 ? pane : null;
        this.content = content.length > 0 ? content : null;
        this.paneToggle = toggle.length > 0 ? toggle : null;
        if (o2.animate) {
          element2.addClass("animate-panes");
        }
        this._recalc();
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const menu_container = element2.find(".navview-menu-container");
        const menu = menu_container.children(".navview-menu");
        menu_container.on(
          "mousewheel",
          (e2) => {
            const pane_width = element2.find(".navview-pane").width();
            const dir = e2.deltaY > 0 ? -1 : 1;
            const step = that.menuScrollStep;
            const distance = that.menuScrollDistance;
            const top = Number.parseInt(menu.css("top"));
            if (pane_width > 50) {
              return false;
            }
            if (dir === -1 && Math.abs(top) <= distance) {
              menu.css("top", Number.parseInt(menu.css("top")) + step * dir);
            }
            if (dir === 1 && top <= -step) {
              menu.css("top", Number.parseInt(menu.css("top")) + step * dir);
            }
          },
          {
            passive: true
          }
        );
        element2.on(Metro2.events.click, ".pull-button", function() {
          that._pullClick(this, "pull");
        });
        element2.on(Metro2.events.click, ".holder", function() {
          that._pullClick(this, "holder");
        });
        element2.on(Metro2.events.click, ".navview-menu li", function() {
          if (o2.activeState === true) {
            element2.find(".navview-menu li.active").removeClass("active");
            $7(this).toggleClass("active");
          }
        });
        element2.on(Metro2.events.click, ".navview-menu li > a", function() {
          that._fireEvent("menu-item-click", {
            item: this
          });
        });
        if (this.paneToggle !== null) {
          this.paneToggle.on(Metro2.events.click, () => {
          });
        }
        menu.find("a").on(Metro2.events.enter, function() {
          if (!element2.hasClass("compacted")) {
            return;
          }
          const a2 = $7(this);
          const r2 = Metro2.utils.rect(this);
          const c5 = a2.children(".caption");
          c5.css({
            position: "fixed",
            top: r2.top,
            left: r2.left + menu_container.width(),
            borderRadius: 4,
            paddingLeft: 10,
            boxShadow: "0 0 5px 0 var(--shadow-color)"
          });
        });
        menu.find("a").on(Metro2.events.leave, function() {
          if (!element2.hasClass("compacted")) {
            return;
          }
          const a2 = $7(this);
          const c5 = a2.children(".caption");
          c5[0].style = "";
        });
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            this._recalc();
            if (!element2.hasClass("handmade")) {
              if (Metro2.utils.isValue(o2.expandPoint) && Metro2.utils.mediaExist(o2.expandPoint)) {
                element2.removeClass("compacted");
                element2.addClass("expanded");
              } else {
                element2.removeClass("expanded");
                element2.addClass("compacted");
              }
            }
          },
          { ns: this.id }
        );
      },
      _togglePaneMode: function(hand = false) {
        const element2 = this.element;
        const o2 = this.options;
        element2.toggleClass("expanded");
        element2.toggleClass("compacted");
        element2.toggleClass("handmade");
        if (element2.hasClass("compacted")) {
          Metro2.storage.setItem("navview:compacted", true);
          Metro2.utils.exec(o2.onPaneClose, null, this);
        } else {
          Metro2.storage.setItem("navview:compacted", false);
          Metro2.utils.exec(o2.onPaneOpen, null, this);
        }
      },
      _pullClick: function(el, sender) {
        let input;
        const target = $7(el);
        if (target?.hasClass("holder")) {
          input = target.parent().find("input");
          setTimeout(() => {
            input.focus();
          }, 200);
        }
        this._togglePaneMode(sender === "pull");
        this._recalc();
        return true;
      },
      toggle: function() {
        this._togglePaneMode();
      },
      compact: function() {
        const element2 = this.element;
        element2.addClass("compacted handmade");
        element2.removeClass("expanded");
        this._recalc();
      },
      expand: function() {
        const element2 = this.element;
        element2.addClass("expanded");
        element2.removeClass("compacted handmade");
        this._recalc();
      },
      state() {
        return this.element.hasClass("expanded") ? "expand" : "compact";
      },
      changeAttribute: (attr, val) => {
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, ".pull-button, .holder");
        element2.off(Metro2.events.click, ".navview-menu li");
        element2.off(Metro2.events.click, ".navview-menu li > a");
        if (this.paneToggle !== null) {
          this.paneToggle.off(Metro2.events.click);
        }
        $7(globalThis).off(Metro2.events.resize, { ns: this.id });
        element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/notify/notify.js
  ((Metro2, $7) => {
    "use strict";
    const NOTIFY_TIMEOUT = 3e3;
    const NOTIFY_WIDTH = 220;
    const NOTIFY_DURATION = 200;
    let NotifyDefaultConfig = {
      container: null,
      width: NOTIFY_WIDTH,
      timeout: NOTIFY_TIMEOUT,
      duration: NOTIFY_DURATION,
      distance: "max",
      animation: "linear",
      clsNotify: "",
      onClick: Metro2.noop,
      onClose: Metro2.noop,
      onShow: Metro2.noop,
      onAppend: Metro2.noop,
      onNotifyCreate: Metro2.noop
    };
    Metro2.notifySetup = (options) => {
      NotifyDefaultConfig = $7.extend({}, NotifyDefaultConfig, options);
    };
    if (typeof globalThis.metroNotifySetup !== "undefined") {
      Metro2.notifySetup(globalThis.metroNotifySetup);
    }
    const Notify = {
      container: null,
      options: {},
      notifies: [],
      setup: function(options) {
        this.options = $7.extend({}, NotifyDefaultConfig, options);
        return this;
      },
      reset: function() {
        const reset_options = {
          width: NOTIFY_WIDTH,
          timeout: NOTIFY_TIMEOUT,
          duration: NOTIFY_DURATION,
          distance: "max",
          animation: "linear"
        };
        this.options = $7.extend({}, NotifyDefaultConfig, reset_options);
      },
      _createContainer: () => {
        const container = $7("<div>").addClass("notify-container");
        $7("body").prepend(container);
        return container;
      },
      create: function(message, title, options = {}) {
        const that = this;
        const o2 = this.options;
        let notify;
        let t;
        const id = Metro2.utils.elementId("notify");
        if (!message) {
          return false;
        }
        notify = $7("<div>").addClass("notify").addClass(o2.clsNotify).attr("id", id);
        notify.css({
          width: o2.width
        });
        if (title) {
          t = $7("<div>").addClass("notify-title").html(title);
          notify.prepend(t);
        }
        const m5 = $7("<div>").addClass("notify-message").html(message);
        m5.appendTo(notify);
        if (options.clsNotify) {
          notify.addClass(options.clsNotify);
        }
        if (options.width !== void 0) {
          notify.css({
            width: options.width
          });
        }
        notify.on(Metro2.events.click, function() {
          Metro2.utils.exec(Metro2.utils.isValue(options.onClick) ? options.onClick : o2.onClick, null, this);
          that.kill(
            $7(this).closest(".notify"),
            Metro2.utils.isValue(options.onClose) ? options.onClose : o2.onClose
          );
        });
        if (Notify.container === null) {
          Notify.container = Notify._createContainer();
        }
        notify.appendTo(Notify.container);
        notify.hide(() => {
          Metro2.utils.exec(
            Metro2.utils.isValue(options.onAppend) ? options.onAppend : o2.onAppend,
            null,
            notify[0]
          );
          const duration = Metro2.utils.isValue(options.duration) ? options.duration : o2.duration;
          const animation = Metro2.utils.isValue(options.animation) ? options.animation : o2.animation;
          let distance = Metro2.utils.isValue(options.distance) ? options.distance : o2.distance;
          if (distance === "max" || isNaN(distance)) {
            distance = $7(globalThis).height();
          }
          notify.show().animate({
            draw: {
              marginTop: [distance, 4],
              opacity: [0, 1]
            },
            dur: duration,
            ease: animation,
            onDone: function() {
              Metro2.utils.exec(o2.onNotifyCreate, null, this);
              if (options !== void 0 && options.keepOpen === true) {
              } else {
                setTimeout(() => {
                  that.kill(notify, Metro2.utils.isValue(options.onClose) ? options.onClose : o2.onClose);
                }, o2.timeout);
              }
              Metro2.utils.exec(
                Metro2.utils.isValue(options.onShow) ? options.onShow : o2.onShow,
                null,
                notify[0]
              );
            }
          });
        });
      },
      kill: function(notify, callback) {
        notify.off(Metro2.events.click);
        notify.zoomOut(300, "linear", () => {
          Metro2.utils.exec(callback ? callback : this.options.onClose, null, notify[0]);
          notify.remove();
        });
      },
      killAll: function() {
        const that = this;
        const notifies = $7(".notify");
        $7.each(notifies, function() {
          that.kill($7(this));
        });
      }
    };
    Metro2.notify = Notify.setup();
  })(Metro, Dom);

  // ../metroui-lib/source/components/tabs/tabs.js
  ((Metro2, $7) => {
    "use strict";
    let TabsDefaultConfig = {
      tabsDeferred: 0,
      expand: false,
      expandPoint: null,
      type: "default",
      // default, text, group, pills, n8n
      updateUri: false,
      position: "top",
      // top, bottom, left, right
      align: "left",
      // left, center, right
      link: "",
      clsTabs: "",
      clsTabsList: "",
      clsTabsListItem: "",
      clsTabsListItemActive: "",
      onTab: Metro2.noop,
      onTabOpen: Metro2.noop,
      onTabClose: Metro2.noop,
      onBeforeTab: Metro2.noop_true,
      onTabsCreate: Metro2.noop
    };
    Metro2.tabsSetup = (options) => {
      TabsDefaultConfig = $7.extend({}, TabsDefaultConfig, options);
    };
    if (typeof globalThis.metroTabsSetup !== "undefined") {
      Metro2.tabsSetup(globalThis.metroTabsSetup);
    }
    Metro2.Component("tabs", {
      init: function(options, elem) {
        this._super(elem, options, TabsDefaultConfig, {
          _targets: [],
          id: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const tab = element2.find(".active")[0];
        this.id = element2.attr("id") || Hooks.useId(this.elem);
        this._createStructure();
        this._createEvents();
        this._open(tab);
        this._fireEvent("tabs-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.wrap("<div>").addClass("tabs");
        let hamburger;
        container.addClass(`tabs-${o2.position}`);
        element2.addClass("tabs-list");
        element2.addClass(`tabs-${o2.type}`);
        element2.addClass(`align-${o2.align}`);
        element2.data("expanded", false);
        const expandTitle = $7("<div>").addClass("expand-title");
        container.prepend(expandTitle);
        hamburger = container.find(".hamburger");
        if (hamburger.length === 0) {
          hamburger = $7("<button>").attr("type", "button").addClass("hamburger menu-down").appendTo(container);
          for (let i3 = 0; i3 < 3; i3++) {
            $7("<span>").addClass("line").appendTo(hamburger);
          }
        }
        container.addClass(o2.clsTabs);
        element2.addClass(o2.clsTabsList);
        element2.children("li").addClass(o2.clsTabsListItem);
        if (o2.expand === true) {
          if (!["left", "right"].includes(o2.position)) {
            container.addClass("tabs-expand");
          }
        } else {
          if (Metro2.utils.isValue(o2.expandPoint) && Metro2.utils.mediaExist(o2.expandPoint) && !["left", "right"].includes(o2.position)) {
            container.addClass("tabs-expand");
          }
        }
        if (["left", "right"].includes(o2.position)) {
          container.addClass("tabs-expand");
        }
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.parent();
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            if (["left", "right"].includes(o2.position)) {
              return;
            }
            if (o2.expand === true) {
              if (!["left", "right"].includes(o2.position)) {
                container.addClass("tabs-expand");
              }
            } else {
              if (Metro2.utils.isValue(o2.expandPoint) && Metro2.utils.mediaExist(o2.expandPoint) && !["left", "right"].includes(o2.position)) {
                if (!container.hasClass("tabs-expand")) container.addClass("tabs-expand");
              } else {
                if (container.hasClass("tabs-expand")) container.removeClass("tabs-expand");
              }
            }
          },
          { ns: this.id }
        );
        container.on(Metro2.events.click, ".hamburger, .expand-title", () => {
          if (element2.data("expanded") === false) {
            element2.addClass("expand");
            element2.data("expanded", true);
            container.find(".hamburger").addClass("active");
          } else {
            element2.removeClass("expand");
            element2.data("expanded", false);
            container.find(".hamburger").removeClass("active");
          }
        });
        element2.on(Metro2.events.click, "li", function(e2) {
          const link = $7(this).children("a");
          const href = link.attr("href").trim();
          const tab = link.parent("li");
          that._fireEvent("tab", {
            tab: tab[0],
            target: tab.children("a").href()
          });
          if (tab.hasClass("active")) {
          }
          if (element2.data("expanded") === true) {
            element2.removeClass("expand");
            element2.data("expanded", false);
            container.find(".hamburger").removeClass("active");
          }
          if (Metro2.utils.exec(o2.onBeforeTab, [tab, element2], tab[0]) !== true) {
            return false;
          }
          if (href) {
            if (href.startsWith("#") && typeof link.attr("data-link") === "undefined") {
              that._open(tab);
              e2.preventDefault();
            } else {
              globalThis.location.href = href;
            }
          }
        });
        $7(globalThis).on("hashchange", () => {
          let hash;
          let tab;
          if (o2.updateUri) {
            hash = globalThis.location.hash;
            tab = that._findTabByTarget(hash);
            that._open($7(tab));
          }
        });
      },
      _findTabByTarget: function(target) {
        const element2 = this.element;
        const tabs = element2.find("li");
        let tab;
        tabs.each((i3, el) => {
          if (!tab && $7(el).children("a").attr("href") === target) {
            tab = el;
          }
        });
        return tab;
      },
      _collectTargets: function() {
        const that = this;
        const element2 = this.element;
        const tabs = element2.find("li");
        this._targets = [];
        $7.each(tabs, function() {
          const tab = $7(this);
          if (tab.hasClass("divider")) return;
          const target = tab.find("a").attr("href").trim();
          if (target.length > 1 && target[0] === "#") {
            that._targets.push(target);
          }
        });
      },
      _open: function(tab_to_open) {
        const element2 = this.element;
        const o2 = this.options;
        const tabs = element2.find("li");
        const expandTitle = element2.siblings(".expand-title");
        const activeTab = element2.find("li.active");
        if (tabs.length === 0) {
          return;
        }
        this._collectTargets();
        const tab = typeof tab_to_open === "undefined" ? $7(tabs[0]) : $7(tab_to_open);
        const link = tab.find("a");
        const target = link.attr("href");
        const tabIndex = tab.index();
        if (target === void 0) {
          return;
        }
        tabs.removeClass("active").removeClass(o2.clsTabsListItemActive);
        if (tab.parent().hasClass("d-menu")) {
          tab.parent().parent().addClass("active");
        } else {
          tab.addClass("active");
        }
        if (typeof link.attr("data-link") !== "undefined") {
          return;
        }
        if (o2.link) {
          $7(`[data-link=${o2.link}]`).each((i3, el) => {
            if (el === this.elem) return;
            const tabs2 = $7(el).find("li");
            if (tabs2.length && tabs2[tabIndex]) {
              tabs2[tabIndex].click();
            }
          });
        }
        $7.each(this._targets, function() {
          const t = $7(this);
          if (t.length > 0) t.hide();
        });
        if (target !== "#" && target[0] === "#") {
          if (o2.updateUri) {
            globalThis.location.hash = target;
          }
          $7(target).show();
        }
        expandTitle.html(tab.find("a").html());
        tab.addClass(o2.clsTabsListItemActive);
        if (!activeTab.is(tab)) {
          this._fireEvent("tab-open", {
            tab: tab[0],
            target: tab.children("a").attr("href")
          });
          this._fireEvent("tab-close", {
            tab: activeTab[0],
            target: activeTab.children("a").attr("href")
          });
        }
      },
      next: function() {
        const element2 = this.element;
        let next;
        const active_tab = element2.find("li.active");
        next = active_tab.next("li");
        if (next.length > 0) {
          this._open(next);
        }
      },
      prev: function() {
        const element2 = this.element;
        let next;
        const active_tab = element2.find("li.active");
        next = active_tab.prev("li");
        if (next.length > 0) {
          this._open(next);
        }
      },
      openByTarget: function(target) {
        const tab = this._findTabByTarget(target);
        if (tab) {
          this._open($7(tab));
        }
      },
      openByIndex: function(index) {
        const element2 = this.element;
        const tabs = element2.find("li");
        if (Metro2.utils.isValue(tabs[index])) this._open($7(tabs[index]));
      },
      open: function(tab = 1) {
        if (typeof tab === "number") {
          this.openByIndex(tab - 1);
        } else {
          this.openByTarget(tab);
        }
      },
      changeAttribute: () => {
      },
      destroy: function() {
        const element2 = this.element;
        const container = element2.parent();
        $7(globalThis).off(Metro2.events.resize, { ns: this.id });
        container.off(Metro2.events.click, ".hamburger, .expand-title");
        element2.off(Metro2.events.click, "a");
        element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/package-manager/package-manager.js
  ((Metro2, $7) => {
    "use strict";
    const copy_image = `<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path fill-rule="evenodd" clip-rule="evenodd" d="M21 8C21 6.34315 19.6569 5 18 5H10C8.34315 5 7 6.34315 7 8V20C7 21.6569 8.34315 23 10 23H18C19.6569 23 21 21.6569 21 20V8ZM19 8C19 7.44772 18.5523 7 18 7H10C9.44772 7 9 7.44772 9 8V20C9 20.5523 9.44772 21 10 21H18C18.5523 21 19 20.5523 19 20V8Z"/>
        <path d="M6 3H16C16.5523 3 17 2.55228 17 2C17 1.44772 16.5523 1 16 1H6C4.34315 1 3 2.34315 3 4V18C3 18.5523 3.44772 19 4 19C4.55228 19 5 18.5523 5 18V4C5 3.44772 5.44772 3 6 3Z"/>
    </svg>`;
    const npm_image = `<svg width="800px" height="800px" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
        <path d="M0 9.781v10.667h8.885v1.771h7.115v-1.771h16v-10.667zM8.885 18.661h-1.771v-5.333h-1.781v5.333h-3.552v-7.104h7.104zM14.219 18.661v1.787h-3.552v-8.891h7.115v7.109h-3.563zM30.224 18.661h-1.776v-5.333h-1.781v5.333h-1.781v-5.333h-1.771v5.333h-3.563v-7.104h10.672zM14.219 13.333h1.781v3.557h-1.781z"/>
    </svg>`;
    const pnpm_image = `<svg width="800px" height="800px" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
        <path d="M30,10.75H21.251V2H30Z" />
        <path d="M20.374,10.75h-8.75V2h8.75Z" />
        <path d="M10.749,10.75H2V2h8.749Z" />
        <path d="M30,20.375H21.251v-8.75H30Z" />
        <path d="M20.374,20.375h-8.75v-8.75h8.75Z"/>
        <path d="M20.374,30h-8.75V21.25h8.75Z"/>
        <path d="M30,30H21.251V21.25H30Z" />
        <path d="M10.749,30H2V21.25h8.749Z" />
    </svg>`;
    const yarn_image = `<svg width="800px" height="800px" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
        <path d="M28.208,24.409a10.493,10.493,0,0,0-3.959,1.822,23.743,23.743,0,0,1-5.835,2.642,1.632,1.632,0,0,1-.983.55A62.228,62.228,0,0,1,10.984,30c-1.163.009-1.876-.3-2.074-.776a1.573,1.573,0,0,1,.866-2.074,3.759,3.759,0,0,1-.514-.379c-.171-.171-.352-.514-.406-.388-.225.55-.343,1.894-.947,2.5-.83.839-2.4.559-3.328.072-1.019-.541.072-1.813.072-1.813a.73.73,0,0,1-.992-.343,4.847,4.847,0,0,1-.667-2.949,5.374,5.374,0,0,1,1.749-2.895,9.334,9.334,0,0,1,.658-4.4,10.445,10.445,0,0,1,3.165-3.661S6.628,10.747,7.35,8.817c.469-1.262.658-1.253.812-1.308a3.633,3.633,0,0,0,1.452-.857,5.265,5.265,0,0,1,4.41-1.7S15.2,1.4,16.277,2.09a18.349,18.349,0,0,1,1.533,2.886s1.281-.748,1.425-.469a11.334,11.334,0,0,1,.523,6.132,14.01,14.01,0,0,1-2.6,5.411c-.135.225,1.551.938,2.615,3.887.983,2.7.108,4.96.262,5.212.027.045.036.063.036.063s1.127.09,3.391-1.308A8.5,8.5,0,0,1,27.739,22.3a1.081,1.081,0,0,1,.469,2.11Z"/>
    </svg>`;
    const bun_image = `<svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M11.966 22.566c6.609 0 11.966-4.326 11.966-9.661 0-3.308-2.051-6.23-5.204-7.963-1.283-.713-2.291-1.353-3.13-1.885-1.58-1.004-2.555-1.623-3.632-1.623-1.094 0-2.327.783-3.955 1.816a49.78 49.78 0 0 1-2.808 1.692C2.051 6.675 0 9.597 0 12.905c0 5.335 5.357 9.66 11.966 9.66Zm-1.397-17.83a5.885 5.885 0 0 0 .497-2.403c0-.144.201-.186.229-.028.656 2.775-.9 4.15-2.051 4.61-.124.048-.199-.12-.103-.208a5.748 5.748 0 0 0 1.428-1.971Zm2.052-.102a5.795 5.795 0 0 0-.78-2.3v-.015c-.068-.123.086-.263.185-.172 1.956 2.105 1.303 4.055.554 5.037-.082.102-.229-.003-.188-.126a5.837 5.837 0 0 0 .229-2.424Zm1.771-.559a5.708 5.708 0 0 0-1.607-1.801V2.26c-.112-.085-.024-.274.113-.218 2.588 1.084 2.766 3.171 2.452 4.395a.116.116 0 0 1-.048.071.11.11 0 0 1-.153-.026.118.118 0 0 1-.022-.083 5.864 5.864 0 0 0-.735-2.324Zm-5.072.559c-.616.544-1.279.758-2.058.997-.116 0-.194-.078-.155-.18 1.747-.907 2.369-1.645 2.99-2.771 0 0 .155-.117.188.085 0 .303-.348 1.325-.965 1.869Zm4.931 11.205a2.949 2.949 0 0 1-.935 1.549 2.16 2.16 0 0 1-1.282.618 2.167 2.167 0 0 1-1.323-.618 2.95 2.95 0 0 1-.923-1.549.243.243 0 0 1 .064-.197.23.23 0 0 1 .192-.069h3.954a.226.226 0 0 1 .19.07.239.239 0 0 1 .063.196Zm-5.443-2.17a1.85 1.85 0 0 1-2.377-.244 1.969 1.969 0 0 1-.233-2.44c.207-.318.502-.565.846-.711a1.84 1.84 0 0 1 1.089-.11c.365.075.701.26.964.53.264.27.443.616.515.99a1.98 1.98 0 0 1-.108 1.118 1.923 1.923 0 0 1-.696.866Zm8.471.005a1.849 1.849 0 0 1-2.374-.252 1.956 1.956 0 0 1-.546-1.362c0-.383.11-.758.319-1.076.207-.318.502-.566.847-.711a1.84 1.84 0 0 1 1.09-.108c.366.076.702.261.965.533s.44.617.512.993a1.98 1.98 0 0 1-.113 1.118 1.922 1.922 0 0 1-.7.865Z"/>
    </svg>`;
    let PackageManagerDefaultConfig = {
      link: "package-manager",
      default: "npm",
      deps: "",
      // dev, peer, or empty for default
      package: "",
      onPackageManagerCreate: Metro2.noop
    };
    Metro2.packageManagerSetup = (options) => {
      PackageManagerDefaultConfig = $7.extend({}, PackageManagerDefaultConfig, options);
    };
    if (typeof globalThis.metroPackageManagerSetup !== "undefined") {
      Metro2.packageManagerSetup(globalThis.metroPackageManagerSetup);
    }
    Metro2.Component("package-manager", {
      init: function(options, elem) {
        this._super(elem, options, PackageManagerDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("component-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const timestamp = (/* @__PURE__ */ new Date()).getTime();
        const npmId = Hooks.useId(`pm-npm-${timestamp}`);
        const pnpmId = Hooks.useId(`pm-pnpm-${timestamp}`);
        const yarnId = Hooks.useId(`pm-yarn-${timestamp}`);
        const bunId = Hooks.useId(`pm-bun-${timestamp}`);
        element2.addClass("package-manager");
        element2.html(`
                <ul data-role="tabs" data-expand="true" data-link="${o2.link}">
                    <li class="${o2.default === "npm" ? "active" : ""}"><a href="#${npmId}">${npm_image} npm</a></li>
                    <li class="${o2.default === "pnpm" ? "active" : ""}"><a href="#${pnpmId}">${pnpm_image} pnpm</a></li>
                    <li class="${o2.default === "yarn" ? "active" : ""}"><a href="#${yarnId}">${yarn_image} yarn</a></li>
                    <li class="${o2.default === "bun" ? "active" : ""}"><a href="#${bunId}">${bun_image} bun</a></li>
                </ul>
                <div>
                    <div class="pm-command" id="${npmId}">
                        <button class="small square"><span class="icon">${copy_image}</span></button>
                        <code>npm i ${o2.deps === "" ? "" : o2.deps === "dev" ? "-D" : ""} ${o2.package}</code>
                    </div>
                    <div class="pm-command" id="${pnpmId}">
                        <button class="small square"><span class="icon">${copy_image}</span></button>
                        <code>pnpm add ${o2.deps === "" ? "" : o2.deps === "dev" ? "-D" : "--save-peer"} ${o2.package}</code>
                    </div>
                    <div class="pm-command" id="${yarnId}">
                        <button class="small square"><span class="icon">${copy_image}</span></button>
                        <code>yarn add ${o2.deps === "" ? "" : o2.deps === "dev" ? "-D" : "-P"} ${o2.package}</code>
                    </div>
                    <div class="pm-command" id="${bunId}">
                        <button class="small square"><span class="icon">${copy_image}</span></button>
                        <code>bun add ${o2.deps === "" ? "" : o2.deps === "dev" ? "-D" : "--peer"} ${o2.package}</code>
                    </div>
                </div>
            `);
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.on("click", ".pm-command button", function() {
          const command = $7(this).parent().find("code").text();
          Metro2.utils.copy2clipboard(command);
        });
      },
      changeAttribute: (attr, newValue) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/page-control/pagecontrol.js
  ((Metro2, $7) => {
    "use strict";
    let PageControlDefaultConfig = {
      appendButton: true,
      tabsPosition: "left",
      customButtons: null,
      activateNewTab: true,
      defaultNewTabTitle: "New File",
      defaultNewCanClose: true,
      defaultNewTabIcon: "",
      defaultNewTabImage: "",
      defaultNewTabPosition: "before",
      // before, after
      appendActions: null,
      tabsActions: null,
      tabActions: null,
      refControl: false,
      onAppendButtonClick: Metro2.noop,
      onTabCreate: Metro2.noop_arg,
      onTabActivate: Metro2.noop,
      onTabDeactivate: Metro2.noop,
      onTabBeforeClose: Metro2.noop_true,
      onTabClose: Metro2.noop,
      onTabRename: Metro2.noop,
      onTabPropChange: Metro2.noop,
      onTabOrganized: Metro2.noop
    };
    Metro2.pageControlSetup = (options) => {
      PageControlDefaultConfig = $7.extend({}, PageControlDefaultConfig, options);
    };
    if (typeof globalThis.metroPageControlSetup !== "undefined") {
      Metro2.pageControlSetup(globalThis.metroPageControlSetup);
    }
    Metro2.Component("page-control", {
      init: function(options, elem) {
        this._super(elem, options, PageControlDefaultConfig, {
          // define instance vars here
          newFileIndex: 1,
          invisibleTabsHolderToggle: null,
          invisibleTabsHolder: null
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("page-control-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        this.component = $7("<div>").addClass("page-control").insertBefore(element2);
        element2.addClass("page-control__tabs").appendTo(this.component);
        element2.addClass(`tabs-position-${o2.tabsPosition}`);
        const items = element2.children("li:not(.page-control__tab-custom)");
        let activeTabExists = false;
        items.each((index, el) => {
          const $el = $7(el);
          const html = $el.html();
          const active = $el.hasClass("active");
          const tab = this.createTab({
            caption: html,
            icon: $el.attr("data-icon"),
            image: $el.attr("data-image"),
            canClose: $el.attr("data-close") !== "false",
            data: $el.attr("data-data"),
            ref: $el.attr("data-ref")
          });
          if (active && !activeTabExists) {
            activeTabExists = true;
            tab.addClass("active");
            this._fireEvent("tab-activate", { tab: tab[0] });
          }
          element2.append(tab);
          $el.remove();
        });
        if (!activeTabExists) {
          const tab = this.element.children(".page-control__tab").first();
          tab.addClass("active");
          this._fireEvent("tab-activate", { tab: tab[0] });
        }
        if (o2.refControl) {
          this._updateRefs();
        }
        if (o2.appendButton) {
          const appendButton = $7("<li>").addClass("page-control__tab__append").html(`<span class="toggle">+</span>`);
          if (o2.appendActions) {
            const appendItems = Metro2.utils.exec(o2.appendActions, null, this);
            if (!Array.isArray(appendItems)) {
              throw "PageControl Error! Prop appendActions must be a function that returns an array.";
            }
            const appendMenu = $7("<ul data-role='dropdown' class='d-menu context'>");
            appendItems.map((el) => appendMenu.append(this._renderMenuItem(el)));
            appendButton.append(appendMenu);
          }
          element2.append(appendButton);
        }
        const services = $7("<li>").addClass("page-control__tab__service").addClass("invisible-tabs").appendTo(element2);
        services.append(
          $7("<div>").addClass("page-control__service-button").html(`
                    <span class="toggle">\u21A7</span>
                    <ul class="d-menu place-right context page-control__invisible_tabs_holder"></ul>
                `)
        );
        this.invisibleTabsHolderToggle = services.find(
          ".page-control__tab__service.invisible-tabs > .page-control__service-button"
        );
        this.invisibleTabsHolder = Metro2.makePlugin(
          services.find(".page-control__invisible_tabs_holder"),
          "dropdown",
          {
            onClick: (e2) => {
              const parent2 = $7(e2.target.parentNode);
              if (parent2.hasClass("page-control__tab__closer")) {
                this.closeButtonClick(e2);
              } else {
                this.activateTab(parent2[0]);
              }
              e2.preventDefault();
              e2.stopPropagation();
            }
          }
        ).element;
        this.invisibleTabsHolderToggle.hide();
        this.organizeTabs();
        const tabsServices = $7("<li>").addClass("page-control__tab__service").addClass("tabs-menu").appendTo(element2);
        tabsServices.append(
          $7("<div>").addClass("page-control__service-button").html(`
                    <span class="toggle">\uFE19</span>
                    <ul class="d-menu place-right context" data-role="dropdown"></ul>
                `)
        );
        if (!o2.tabsActions) {
          tabsServices.hide();
        } else {
          const tabsMenu = tabsServices.find("ul");
          const tabsMenuItems = Metro2.utils.exec(o2.tabsActions, null, this);
          tabsMenuItems.map((el) => tabsMenu.append(this._renderMenuItem(el)));
        }
      },
      _updateRefs: function() {
        const tabs = this.element.find(".page-control__tab");
        const activeTab = this.element.find(".page-control__tab.active");
        tabs.each((_5, el) => $7($7(el).data("ref")).hide());
        $7(activeTab.data("ref")).show();
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        element2.on("click", ".page-control__tab__closer", this.closeButtonClick.bind(this));
        element2.on("click", ".page-control__tab__menu > li > a", function(e2) {
          const action = $7(this).attr("data-action");
          const menu = Metro2.getPlugin($7(this).closest("ul"), "dropdown");
          const tab = $7(this).closest(".page-control__tab")[0];
          menu.close();
          switch (action) {
            case "close": {
              that.closeTab(tab);
              break;
            }
            case "close-all": {
              that.closeAll();
              break;
            }
            case "close-other": {
              that.closeOtherTabs(tab);
              break;
            }
            case "close-inactive": {
              that.closeInactiveTabs();
              break;
            }
            case "close-left": {
              that.closeTabsOnTheLeft(tab);
              break;
            }
            case "close-right": {
              that.closeTabsOnTheRight(tab);
              break;
            }
            case "rename": {
              that.renameTab(tab);
              break;
            }
          }
          e2.preventDefault();
          e2.stopPropagation();
        });
        element2.on("click", ".page-control__tab", function() {
          const tab = $7(this);
          if (tab.hasClass("active")) {
            return;
          }
          that.activateTab(this);
        });
        element2.on("click", ".page-control__tab__append > span", (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
          const tab = that.createTab({
            caption: `${o2.defaultNewTabTitle} ${that.newFileIndex++}`,
            canClose: o2.defaultNewCanClose,
            icon: o2.defaultNewTabIcon,
            image: o2.defaultNewTabImage,
            data: null
          });
          that._fireEvent("tab-append", { tab });
          that.activateTab(tab);
          that.organizeTabs();
          that._fireEvent("append-button-click", { tab });
        });
        $7(globalThis).on("resize", () => {
          this.organizeTabs();
        });
      },
      _renderMenuItem: (el) => {
        const li = $7("<li>");
        const an = $7("<a>");
        if (el.icon || el.image) {
          an.append(
            el.icon ? $7("<span class='icon'>").addClass(el.icon) : $7("<img class='icon'>").attr("src", el.image).attr("alt", "")
          );
        }
        if (el.title) {
          an.append($7("<span>").addClass("caption").text(el.title));
        }
        an.data("data", el.data);
        if (el.onclick) an.on("click", (e2) => el.onclick(e2));
        li.append(an);
        return li;
      },
      createTab: function({ caption, icon, image, canClose = true, hasMenu = true, data, ref }) {
        const element2 = this.element;
        const o2 = this.options;
        const tab = $7("<li>").addClass("page-control__tab").appendTo(element2);
        if (hasMenu) {
          tab.append(
            $7("<div>").addClass("page-control__tab__menu__holder").html(`
                        <span class="">\uFE19</span>
                        <ul class="d-menu context page-control__tab__menu" data-role="dropdown">
                            <li><a data-action="rename">${this.strings.label_rename_tab}</a></li>
                            <li class="divider"></li>
                            <li><a data-action="close">${this.strings.label_close_tab}</a></li>
                            <li><a data-action="close-other">${this.strings.label_close_other_tabs}</a></li>
                            <li><a data-action="close-left">${this.strings.label_close_tabs_left}</a></li>
                            <li><a data-action="close-right">${this.strings.label_close_tabs_right}</a></li>
                            <li><a data-action="close-all">${this.strings.label_close_all_tabs}</a></li>
                            <li><a data-action="close-inactive">${this.strings.label_close_inactive_tabs}</a></li>
                        </ul>
                    `)
          );
          if (o2.tabActions) {
            const tabMenu = tab.find("ul");
            const tabMenuItems = Metro2.utils.exec(o2.tabActions);
            if (!Array.isArray(tabMenuItems)) {
              throw "PageControl Error! Prop tabActions must be a function that returns an array.";
            }
            tabMenu.append($7("<li class='divider'>"));
            tabMenuItems.map((el) => tabMenu.append(this._renderMenuItem(el)));
          }
        }
        if (icon || image) {
          tab.append(
            $7("<span>").addClass("page-control__tab__icon").html(icon ? `<span class="${icon}">` : `<img src="${image}" alt=""/>`)
          );
        }
        tab.append($7("<span>").addClass("page-control__tab__caption").html(caption));
        if (canClose) {
          tab.append($7("<span>").addClass("page-control__tab__closer").html("<span>\u2715</span>"));
        }
        tab.data("data", data);
        tab.data("ref", ref);
        this._fireEvent("tab-create", { tab: tab[0] });
        element2[o2.defaultNewTabPosition === "before" ? "prepend" : "append"](tab);
        return tab[0];
      },
      closeButtonClick: function(e2) {
        const o2 = this.options;
        const tab = $7(e2.target).closest(".page-control__tab");
        const parent2 = tab.closest("ul");
        if (!o2.onTabBeforeClose(tab[0])) {
          return;
        }
        this.closeTab(tab[0]);
        if (parent2.hasClass("page-control__invisible_tabs_holder") && parent2.children(".page-control__tab").length === 0) {
          Metro2.getPlugin(this.invisibleTabsHolder, "dropdown").close();
          this.invisibleTabsHolderToggle.hide();
        }
        e2.preventDefault();
        e2.stopPropagation();
      },
      closeTab: function(tab, reorg = true) {
        const $tab = $7(tab);
        if ($tab.hasClass("active")) {
          const prev = $tab.prev(".page-control__tab");
          const next = $tab.next(".page-control__tab");
          if (prev.length) {
            this.activateTab(prev[0]);
          } else if (next.length) {
            this.activateTab(next[0]);
          } else if ($tab.parent().hasClass("page-control__invisible_tabs_holder") && parent.children(".page-control__tab").length === 1) {
            if (element.children(".page-control__tab").length) {
              this.activateTab(element.children(".page-control__tab").last()[0]);
            }
          }
        }
        this._fireEvent("tab-close", { tab });
        if (this.options.refControl) {
          $7($tab.data("ref")).remove();
        }
        $tab.remove();
        if (reorg) this.organizeTabs();
        return this;
      },
      activateTab: function(tab) {
        const element2 = this.element;
        const o2 = this.options;
        element2.find(".page-control__tab").each((index, el) => {
          const t = $7(el);
          if (t.hasClass("active")) {
            this._fireEvent("tab-deactivate", { tab: el });
            t.removeClass("active");
          }
        });
        $7(tab).addClass("active");
        if (o2.refControl) {
          this._updateRefs();
        }
        this._fireEvent("tab-activate", { tab });
        if ($7(tab).parent().hasClass("page-control__invisible_tabs_holder")) {
          element2.prepend(tab);
          this.organizeTabs();
        }
        return this;
      },
      organizeTabs: function() {
        const element2 = this.element;
        const tabsWidth = this.elem.getBoundingClientRect().width;
        const holder = this.invisibleTabsHolder;
        const addTabButton = element2.find(".page-control__tab__append");
        holder.children(".page-control__tab").each((_5, el) => {
          const tab = $7(el);
          if (addTabButton.length) {
            tab.insertBefore(addTabButton);
          } else {
            tab.appendTo(element2);
          }
        });
        const tabs = element2.children(".page-control__tab");
        let w6 = 0;
        for (const tab of tabs) {
          const tabRect = tab.getBoundingClientRect();
          if (w6 + tabRect.width + 50 > tabsWidth) {
            $7(tab).nextAll(".page-control__tab").appendTo(holder);
            $7(tab).appendTo(holder);
            break;
          }
          w6 += tabRect.width;
        }
        if (holder.children().length) {
          this.invisibleTabsHolderToggle.show(function() {
            $7(this).css({
              display: "flex"
            });
          });
        } else {
          this.invisibleTabsHolderToggle.hide();
        }
        this._fireEvent("tab-organized", null);
      },
      addTab: function({ caption, icon, image, canClose = true, hasMenu = true, data, ref }, insert = "before") {
        const o2 = this.options;
        const newTab = this.createTab({ caption, icon, image, canClose, hasMenu, data, ref });
        if (o2.activateNewTab) {
          this.activateTab(newTab);
        }
        this.element[insert === "before" ? "prepend" : "append"](newTab);
        this.organizeTabs();
        return newTab;
      },
      getActiveTab: function() {
        return this.component.find(".page-control__tab.active")[0];
      },
      getActiveTabIndex: function() {
        return this.component.find(".page-control__tab").index(".active", false);
      },
      getTabByIndex: function(index) {
        return this.component.find(".page-control__tab").get(index);
      },
      getTabByTitle: function(caption) {
        if (!caption) {
          return void 0;
        }
        const tabs = this.component.find(".page-control__tab");
        for (const tab of tabs) {
          if ($7(tab).find(".caption").text() === caption) {
            return tab;
          }
        }
        return void 0;
      },
      closeAll: function() {
        this.component.find(".page-control__tab").each((index, tab) => {
          this.closeTab(tab, false);
        });
        this.organizeTabs();
        return this;
      },
      closeInactiveTabs: function() {
        this.component.find(".page-control__tab").each((index, tab) => {
          if (!$7(tab).hasClass("active")) this.closeTab(tab, false);
        });
        this.organizeTabs();
        return this;
      },
      closeOtherTabs: function(tab) {
        const _tab = typeof tab === "number" ? this.getTabByIndex(tab) : $7(tab);
        this.component.find(".page-control__tab").each((index, tab2) => {
          if (_tab[0] !== tab2) this.closeTab(tab2, false);
        });
        this.activateTab(tab);
        this.organizeTabs();
        return this;
      },
      closeTabsOnTheLeft: function(tab) {
        const tabs = this.component.find(".page-control__tab");
        const tabIndex = tabs.indexOf($7(tab));
        this.component.find(".page-control__tab").each((index, _tab) => {
          if (index < tabIndex) this.closeTab(_tab, false);
        });
        this.organizeTabs();
        return this;
      },
      closeTabsOnTheRight: function(tab) {
        const tabs = this.component.find(".page-control__tab");
        const tabIndex = tabs.indexOf($7(tab));
        this.component.find(".page-control__tab").each((index, _tab) => {
          if (index > tabIndex) this.closeTab(_tab, false);
        });
        this.organizeTabs();
        return this;
      },
      setupTab: function(tab, prop, val) {
        const $tab = $7(tab);
        switch (prop) {
          case "caption": {
            $tab.find(".page-control__tab__caption").text(val);
            break;
          }
          case "icon": {
            $tab.find(".page-control__tab__icon")[0].className = val;
            break;
          }
          case "image": {
            $tab.find(".page-control__tab__image").attr("src", val);
            break;
          }
          case "data": {
            $tab.data("data", val);
            break;
          }
          case "ref": {
            $tab.data("ref", val);
            break;
          }
        }
        this._fireEvent("tab-prop-change", { tab });
        this.organizeTabs();
      },
      renameTab: function(tab) {
        const caption = $7(tab).find(".page-control__tab__caption");
        Metro2.dialog.create({
          title: this.strings.label_rename_tab,
          content: `
                    <form style="width: 100%">
                        <input type="text" data-role="input" value="${caption.text()}">
                    </form>
                `,
          defaultActions: false,
          customButtons: [
            {
              text: this.strings.label_ok,
              cls: "js-dialog-close info",
              onclick: (dlg) => {
                this.setupTab(tab, "caption", dlg.find("input").val());
              }
            },
            {
              text: this.strings.label_cancel,
              cls: "js-dialog-close"
            }
          ]
        });
      },
      changeAttribute: (attr, newValue) => {
      },
      destroy: function() {
        this.component.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/pagination/pagination.js
  ((Metro2, $7) => {
    "use strict";
    Metro2.pagination = (c5) => {
      const defConf = {
        length: 0,
        //total rows
        rows: 0,
        // page size
        current: 0,
        target: "body",
        clsPagination: "",
        prevTitle: "",
        nextTitle: "",
        distance: 5,
        islandSize: 3,
        shortTrack: 10,
        lang: void 0
      };
      let i3;
      let prev;
      let next;
      const conf = $7.extend({}, defConf, c5);
      const distance = Number.parseInt(conf.distance);
      const shortTrack = Number.parseInt(conf.shortTrack);
      const islandSize = Number.parseInt(conf.islandSize);
      const totalRows = Number.parseInt(conf.length);
      const pageSize = Number.parseInt(conf.rows);
      const totalPages = Math.ceil(totalRows / pageSize);
      const current = Number.parseInt(conf.current);
      const pagination_wrapper = $7(conf.target).html("");
      const pagination = $7("<ul>").addClass("pagination").addClass(conf.clsPagination).appendTo(pagination_wrapper);
      let lang = conf.lang || pagination_wrapper.closest("[lang]").attr("lang") || "en";
      if (Metro2.locales[lang] === void 0) {
        lang = "en";
      }
      const strings = Metro2.locales[lang];
      if (totalRows === 0) {
        return;
      }
      if (pageSize === -1) {
        return;
      }
      const add_item = (item_title, item_type, data) => {
        const li = $7("<li>").addClass("page-item").addClass(item_type);
        const a2 = $7("<a>").addClass("page-link").html(item_title);
        a2.data("page", data);
        a2.appendTo(li);
        return li;
      };
      prev = add_item(conf.prevTitle || strings.label_prev, "service prev-page", "prev");
      pagination.append(prev);
      pagination.append(add_item(1, current === 1 ? "active" : "", 1));
      if (distance === 0 || totalPages <= shortTrack) {
        for (i3 = 2; i3 < totalPages; i3++) {
          pagination.append(add_item(i3, i3 === current ? "active" : "", i3));
        }
      } else {
        if (current < distance) {
          for (i3 = 2; i3 <= distance; i3++) {
            pagination.append(add_item(i3, i3 === current ? "active" : "", i3));
          }
          if (totalPages > distance) {
            pagination.append(add_item("...", "no-link", null));
          }
        } else if (current <= totalPages && current > totalPages - distance + 1) {
          if (totalPages > distance) {
            pagination.append(add_item("...", "no-link", null));
          }
          for (i3 = totalPages - distance + 1; i3 < totalPages; i3++) {
            pagination.append(add_item(i3, i3 === current ? "active" : "", i3));
          }
        } else {
          pagination.append(add_item("...", "no-link", null));
          for (let i4 = islandSize; i4 > 0; i4--) {
            pagination.append(add_item(current - i4, "", current - i4));
          }
          pagination.append(add_item(current, "active", current));
          for (let i4 = 1; i4 <= islandSize; i4++) {
            pagination.append(add_item(current + i4, "", current + i4));
          }
          pagination.append(add_item("...", "no-link", null));
        }
      }
      if (totalPages > 1 || current < totalPages)
        pagination.append(add_item(totalPages, current === totalPages ? "active" : "", totalPages));
      next = add_item(conf.nextTitle || strings.label_next, "service next-page", "next");
      pagination.append(next);
      if (current === 1) {
        prev.addClass("disabled");
      }
      if (current === totalPages) {
        next.addClass("disabled");
      }
      if (totalRows === 0) {
        pagination.addClass("disabled");
        pagination.children().addClass("disabled");
      }
      return pagination;
    };
  })(Metro, Dom);

  // ../metroui-lib/source/components/panel/panel.js
  ((Metro2, $7) => {
    "use strict";
    const toggleImage = `<svg aria-hidden="true" width="16" height="16" viewBox="0 0 24 24"><path d="m14.83 11.29-4.24-4.24a1 1 0 1 0-1.42 1.41L12.71 12l-3.54 3.54a1 1 0 0 0 0 1.41 1 1 0 0 0 .71.29 1 1 0 0 0 .71-.29l4.24-4.24a1.002 1.002 0 0 0 0-1.42Z"></path></svg>`;
    let PanelDefaultConfig = {
      panelDeferred: 0,
      id: null,
      titleCaption: "",
      titleIcon: "",
      collapsible: false,
      collapsed: false,
      collapseDuration: 100,
      width: "auto",
      height: "auto",
      draggable: false,
      customButtons: null,
      clsCustomButton: "",
      clsPanel: "",
      clsTitle: "",
      clsTitleCaption: "",
      clsTitleIcon: "",
      clsContent: "",
      clsCollapseToggle: "",
      onCollapse: Metro2.noop,
      onExpand: Metro2.noop,
      onDragStart: Metro2.noop,
      onDragStop: Metro2.noop,
      onDragMove: Metro2.noop,
      onPanelCreate: Metro2.noop
    };
    Metro2.panelSetup = (options) => {
      PanelDefaultConfig = $7.extend({}, PanelDefaultConfig, options);
    };
    if (typeof globalThis.metroPanelSetup !== "undefined") {
      Metro2.panelSetup(globalThis.metroPanelSetup);
    }
    Metro2.Component("panel", {
      init: function(options, elem) {
        this._super(elem, options, PanelDefaultConfig);
        return this;
      },
      _addCustomButtons: function(buttons) {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const title = element2.closest(".panel").find(".panel-title");
        let buttonsContainer;
        let customButtons = [];
        customButtons = Metro2.utils.isObject(buttons);
        if (!customButtons) {
          console.warn("Unknown format for custom buttons", buttons);
          return;
        }
        if (title.length === 0) {
          console.warn("No place for custom buttons");
          return;
        }
        buttonsContainer = title.find(".custom-buttons");
        if (buttonsContainer.length === 0) {
          buttonsContainer = $7("<div>").addClass("custom-buttons").appendTo(title);
        } else {
          buttonsContainer.find(".btn-custom").off(Metro2.events.click);
          buttonsContainer.html("");
        }
        $7.each(customButtons, function() {
          const btn = $7("<span>");
          btn.addClass("button btn-custom").addClass(o2.clsCustomButton).addClass(this.cls).attr("tabindex", -1).html(this.text || this.html || "");
          that._setAttributes(btn, this.attr);
          if (this.onclick) {
            btn.on(Metro2.events.click, (e2) => {
              if (Metro2.utils.isRightMouse(e2)) return;
              Metro2.utils.exec(this.onclick, [btn[0], element2[0]]);
            });
          }
          buttonsContainer.prepend(btn);
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        const panel = $7("<div>").addClass("panel").addClass(o2.clsPanel);
        const id = o2.id ? o2.id : Hooks.useId(this.elem);
        const original_classes = element2[0].className;
        let title;
        panel.attr("id", id).addClass(original_classes);
        panel.insertBefore(element2);
        element2.appendTo(panel);
        element2[0].className = "";
        element2.addClass("panel-content").addClass(o2.clsContent).appendTo(panel);
        if (o2.titleCaption !== "" || o2.titleIcon !== "" || o2.collapsible === true) {
          title = $7("<div>").addClass("panel-title").addClass(o2.clsTitle);
          if (o2.titleCaption !== "") {
            $7("<span>").addClass("caption").addClass(o2.clsTitleCaption).html(o2.titleCaption).appendTo(title);
          }
          if (o2.titleIcon !== "") {
            $7(o2.titleIcon).addClass("icon").addClass(o2.clsTitleIcon).appendTo(title);
          }
          if (o2.collapsible === true) {
            const collapseToggle = $7("<span>").addClass("dropdown-toggle marker-center active-toggle").addClass(o2.clsCollapseToggle).appendTo(title);
            collapseToggle.append(toggleImage);
            Metro2.makePlugin(element2, "collapse", {
              toggleElement: collapseToggle,
              duration: o2.collapseDuration,
              onCollapse: o2.onCollapse,
              onExpand: o2.onExpand
            });
            if (o2.collapsed === true) {
              this.collapse();
            }
          }
          title.appendTo(panel);
        }
        if (title && Metro2.utils.isValue(o2.customButtons)) {
          this._addCustomButtons(o2.customButtons);
        }
        if (o2.draggable === true) {
          let dragElement;
          if (title) {
            dragElement = title.find(".caption, .icon");
          } else {
            dragElement = panel;
          }
          Metro2.makePlugin(panel, "draggable", {
            dragContext: panel[0],
            dragElement,
            onDragStart: o2.onDragStart,
            onDragStop: o2.onDragStop,
            onDragMove: o2.onDragMove
          });
        }
        if (o2.width !== "auto" && Number.parseInt(o2.width) >= 0) {
          panel.outerWidth(Number.parseInt(o2.width));
        }
        if (o2.height !== "auto" && Number.parseInt(o2.height) >= 0) {
          panel.outerHeight(Number.parseInt(o2.height));
          element2.css({ overflow: "auto" });
        }
        this.panel = panel;
        this._fireEvent("panel-create", {
          element: element2,
          panel
        });
      },
      customButtons: function(buttons) {
        return this._addCustomButtons(buttons);
      },
      collapse: function() {
        const element2 = this.element;
        if (Metro2.utils.isMetroObject(element2, "collapse") === false) {
          return;
        }
        Metro2.getPlugin(element2, "collapse").collapse();
      },
      open: function() {
        this.expand();
      },
      close: function() {
        this.collapse();
      },
      expand: function() {
        const element2 = this.element;
        if (Metro2.utils.isMetroObject(element2, "collapse") === false) {
          return;
        }
        Metro2.getPlugin(element2, "collapse").expand();
      },
      changeAttribute: (attr, val) => {
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (o2.collapsible === true) {
          Metro2.getPlugin(element2, "collapse").destroy();
        }
        if (o2.draggable === true) {
          Metro2.getPlugin(element2, "draggable").destroy();
        }
        return element2;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/popover/popover.js
  ((Metro2, $7) => {
    "use strict";
    let PopoverDefaultConfig = {
      popoverDeferred: 0,
      popoverText: "",
      popoverHide: 3e3,
      popoverTimeout: 10,
      popoverOffset: 10,
      popoverTrigger: Metro2.popoverEvents.HOVER,
      popoverPosition: Metro2.position.TOP,
      hideOnLeave: false,
      closeButton: true,
      clsPopover: "",
      clsPopoverContent: "",
      onPopoverShow: Metro2.noop,
      onPopoverHide: Metro2.noop,
      onPopoverCreate: Metro2.noop
    };
    Metro2.popoverSetup = (options) => {
      PopoverDefaultConfig = $7.extend({}, PopoverDefaultConfig, options);
    };
    if (typeof globalThis.metroPopoverSetup !== "undefined") {
      Metro2.popoverSetup(globalThis.metroPopoverSetup);
    }
    Metro2.Component("popover", {
      init: function(options, elem) {
        this._super(elem, options, PopoverDefaultConfig, {
          popover: null,
          popovered: false,
          size: {
            width: 0,
            height: 0
          },
          id: null
        });
        return this;
      },
      _create: function() {
        this.id = Hooks.useId(this.elem);
        this._createEvents();
        this._fireEvent("popover-create", {
          element: this.element
        });
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        let event;
        switch (o2.popoverTrigger) {
          case Metro2.popoverEvents.CLICK:
            event = Metro2.events.click;
            break;
          case Metro2.popoverEvents.FOCUS:
            event = Metro2.events.focus;
            break;
          default:
            event = Metro2.events.enter;
        }
        element2.on(event, () => {
          if (this.popover !== null || this.popovered === true) {
            return;
          }
          setTimeout(() => {
            this.createPopover();
            this._fireEvent("popover-show", {
              popover: this.popover
            });
            if (o2.popoverHide > 0) {
              setTimeout(() => {
                this.removePopover();
              }, o2.popoverHide);
            }
          }, o2.popoverTimeout);
        });
        if (o2.hideOnLeave === true) {
          element2.on(Metro2.events.leave, () => {
            this.removePopover();
          });
        }
        $7(globalThis).on(
          Metro2.events.scroll,
          () => {
            if (this.popover !== null) this.setPosition();
          },
          { ns: this.id }
        );
      },
      setPosition: function() {
        const popover = this.popover;
        const size = this.size;
        const o2 = this.options;
        const element2 = this.element;
        if (o2.popoverPosition === Metro2.position.BOTTOM) {
          popover.addClass("bottom");
          popover.css({
            top: element2.offset().top - $7(globalThis).scrollTop() + element2.outerHeight() + o2.popoverOffset,
            left: element2.offset().left + element2.outerWidth() / 2 - size.width / 2 - $7(globalThis).scrollLeft()
          });
        } else if (o2.popoverPosition === Metro2.position.RIGHT) {
          popover.addClass("right");
          popover.css({
            top: element2.offset().top + element2.outerHeight() / 2 - size.height / 2 - $7(globalThis).scrollTop(),
            left: element2.offset().left + element2.outerWidth() - $7(globalThis).scrollLeft() + o2.popoverOffset
          });
        } else if (o2.popoverPosition === Metro2.position.LEFT) {
          popover.addClass("left");
          popover.css({
            top: element2.offset().top + element2.outerHeight() / 2 - size.height / 2 - $7(globalThis).scrollTop(),
            left: element2.offset().left - size.width - $7(globalThis).scrollLeft() - o2.popoverOffset
          });
        } else {
          popover.addClass("top");
          popover.css({
            top: element2.offset().top - $7(globalThis).scrollTop() - size.height - o2.popoverOffset,
            left: element2.offset().left + element2.outerWidth() / 2 - size.width / 2 - $7(globalThis).scrollLeft()
          });
        }
      },
      createPopover: function() {
        const elem = this.elem;
        let element2 = this.element;
        const o2 = this.options;
        let popover;
        let neb_pos;
        const id = this.id;
        let closeButton;
        if (this.popovered) {
          return;
        }
        popover = $7("<div>").addClass("popover neb").addClass(o2.clsPopover);
        popover.attr("id", id);
        $7("<div>").addClass("popover-content").addClass(o2.clsPopoverContent).html(o2.popoverText).appendTo(popover);
        if (o2.popoverHide === 0 && o2.closeButton === true) {
          closeButton = $7("<button>").addClass("square small popover-close-button").html("&times;").appendTo(popover);
          closeButton.on(Metro2.events.click, () => {
            this.removePopover();
          });
        }
        switch (o2.popoverPosition) {
          case Metro2.position.TOP:
            neb_pos = "neb-s";
            break;
          case Metro2.position.BOTTOM:
            neb_pos = "neb-n";
            break;
          case Metro2.position.RIGHT:
            neb_pos = "neb-w";
            break;
          case Metro2.position.LEFT:
            neb_pos = "neb-e";
            break;
        }
        popover.addClass(neb_pos);
        if (o2.closeButton !== true) {
          popover.on(Metro2.events.click, () => {
            this.removePopover();
          });
        }
        this.popover = popover;
        this.size = Metro2.utils.hiddenElementSize(popover);
        if (elem.tagName === "TD" || elem.tagName === "TH") {
          const wrp = $7("<div/>").css("display", "inline-block").html(element2.html());
          element2.html(wrp);
          element2 = wrp;
        }
        this.setPosition();
        popover.appendTo($7("body"));
        this.popovered = true;
        this._fireEvent("popover-create", {
          popover
        });
      },
      removePopover: function() {
        const timeout = this.options.onPopoverHide === Metro2.noop ? 0 : 300;
        const popover = this.popover;
        if (!this.popovered) {
          return;
        }
        this._fireEvent("popover-hide", {
          popover
        });
        setTimeout(() => {
          popover.hide(0, () => {
            popover.remove();
            this.popover = null;
            this.popovered = false;
          });
        }, timeout);
      },
      show: function() {
        const o2 = this.options;
        if (this.popovered === true) {
          return;
        }
        setTimeout(() => {
          this.createPopover();
          this._fireEvent("popover-show", {
            popover: this.popover
          });
          if (o2.popoverHide > 0) {
            setTimeout(() => {
              this.removePopover();
            }, o2.popoverHide);
          }
        }, o2.popoverTimeout);
      },
      hide: function() {
        this.removePopover();
      },
      changeAttribute: function(attributeName) {
        const element2 = this.element;
        const o2 = this.options;
        const changeText = () => {
          o2.popoverText = element2.attr("data-popover-text");
          if (this.popover) {
            this.popover.find(".popover-content").html(o2.popoverText);
            this.setPosition();
          }
        };
        const changePosition = () => {
          o2.popoverPosition = element2.attr("data-popover-position");
          this.setPosition();
        };
        switch (attributeName) {
          case "data-popover-text":
            changeText();
            break;
          case "data-popover-position":
            changePosition();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        let event;
        switch (o2.popoverTrigger) {
          case Metro2.popoverEvents.CLICK:
            event = Metro2.events.click;
            break;
          case Metro2.popoverEvents.FOCUS:
            event = Metro2.events.focus;
            break;
          default:
            event = Metro2.events.enter;
        }
        element2.off(event);
        if (o2.hideOnLeave === true) {
          element2.off(Metro2.events.leave);
        }
        $7(globalThis).off(Metro2.events.scroll, { ns: this.id });
        return element2;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/progress/progress.js
  ((Metro2, $7) => {
    "use strict";
    let ProgressDefaultConfig = {
      progressDeferred: 0,
      showValue: false,
      showLabel: false,
      label: "Progress:",
      value: 0,
      buffer: 0,
      type: "bar",
      small: false,
      segmentSize: 10,
      clsProgress: "",
      clsBack: "",
      clsBar: "",
      clsBuffer: "",
      clsValue: "",
      clsLabel: "",
      clsData: "",
      onValueChange: Metro2.noop,
      onBufferChange: Metro2.noop,
      onComplete: Metro2.noop,
      onBuffered: Metro2.noop,
      onProgressCreate: Metro2.noop
    };
    Metro2.progressSetup = (options) => {
      ProgressDefaultConfig = $7.extend({}, ProgressDefaultConfig, options);
    };
    if (typeof globalThis.metroProgressSetup !== "undefined") {
      Metro2.progressSetup(globalThis.metroProgressSetup);
    }
    Metro2.Component("progress", {
      init: function(options, elem) {
        this._super(elem, options, ProgressDefaultConfig, {
          value: 0,
          buffer: 0
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const elem = this.elem;
        const o2 = this.options;
        if (typeof o2.type === "string") o2.type = o2.type.toLowerCase();
        element2.html("").addClass("progress");
        this.component = element2.wrap("<div>").addClass("progress-component").addClass(o2.clsProgress);
        function _progress() {
          elem.innerHTML = `<div class="bar"></div>`;
        }
        function _buffer() {
          elem.innerHTML = `
                    <div class="bar"></div>
                    <div class="buffer"></div>
                `;
        }
        function _load() {
          element2.addClass("with-load");
          elem.innerHTML = `
                    <div class="bar"></div>
                    <div class="buffer"></div>
                    <div class="load"></div>
                `;
        }
        function _line() {
          element2.addClass("line");
        }
        function _segment() {
          element2.addClass("segments");
          element2.append(`<div class="bar"></div>`);
          const width = element2.width();
          const segments = Math.ceil(width / (o2.segmentSize || 10));
          for (let i3 = 0; i3 < segments; i3++) {
            elem.innerHTML += `<div class="segment" style="width: ${o2.segmentSize}px"></div>`;
          }
        }
        switch (o2.type) {
          case "buffer":
            _buffer();
            break;
          case "load":
            _load();
            break;
          case "line":
            _line();
            break;
          case "segment":
            _segment();
            break;
          default:
            _progress();
        }
        if (o2.small === true) element2.addClass("small");
        element2.addClass(o2.clsBack);
        element2.find(".bar").addClass(o2.clsBar);
        element2.find(".buffer").addClass(o2.clsBuffer);
        const data = $7("<div>").addClass("progress-data").addClass(o2.clsData).insertBefore(element2);
        const label = $7("<div>").addClass("progress-label").addClass(o2.clsLabel).html(o2.label).appendTo(data);
        const value = $7("<div>").addClass("progress-value").addClass(o2.clsLabel).html(o2.value).appendTo(data);
        if (o2.showLabel === false) {
          label.hide();
        }
        if (o2.showValue === false) {
          value.hide();
        }
        this.val(o2.value);
        this.buff(o2.buffer);
        this._fireEvent("progress-create", {
          element: element2
        });
      },
      val: function(v5) {
        const element2 = this.element;
        const value = this.component.find(".progress-value");
        if (v5 === void 0) {
          return this.value;
        }
        const bar = element2.find(".bar");
        if (bar.length === 0) {
          return false;
        }
        this.value = Number.parseInt(v5, 10);
        bar.css("width", `${this.value}%`);
        value.html(`${this.value}%`);
        this._fireEvent("value-change", {
          val: this.value
        });
        if (this.value === 100) {
          this._fireEvent("complete", {
            val: this.value
          });
        }
      },
      buff: function(v5) {
        const element2 = this.element;
        if (v5 === void 0) {
          return this.buffer;
        }
        const bar = element2.find(".buffer");
        if (bar.length === 0) {
          return false;
        }
        this.buffer = Number.parseInt(v5, 10);
        bar.css("width", `${this.buffer}%`);
        this._fireEvent("buffer-change", {
          val: this.buffer
        });
        if (this.buffer === 100) {
          this._fireEvent("buffered", {
            val: this.buffer
          });
        }
      },
      changeValue: function() {
        this.val(this.element.attr("data-value"));
      },
      changeBuffer: function() {
        this.buff(this.element.attr("data-buffer"));
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-value":
            this.changeValue();
            break;
          case "data-buffer":
            this.changeBuffer();
            break;
        }
      },
      destroy: function() {
        this.component.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/rating/rating.js
  ((Metro2, $7) => {
    "use strict";
    let RatingDefaultConfig = {
      ratingDeferred: 0,
      label: "",
      static: false,
      title: null,
      value: 0,
      values: null,
      message: "",
      stars: 5,
      onColor: null,
      offColor: null,
      roundFunc: "round",
      // ceil, floor, round
      half: true,
      symbol: "\u2605",
      clsRating: "",
      clsTitle: "",
      clsStars: "",
      clsResult: "",
      clsLabel: "",
      onStarClick: Metro2.noop,
      onRatingCreate: Metro2.noop
    };
    Metro2.ratingSetup = (options) => {
      RatingDefaultConfig = $7.extend({}, RatingDefaultConfig, options);
    };
    if (typeof globalThis.metroRatingSetup !== "undefined") {
      Metro2.ratingSetup(globalThis.metroRatingSetup);
    }
    Metro2.Component("rating", {
      init: function(options, elem) {
        this._super(elem, options, RatingDefaultConfig, {
          value: 0,
          originValue: 0,
          values: [],
          rate: 0,
          rating: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        let i3;
        if (isNaN(o2.value)) {
          o2.value = 0;
        } else {
          o2.value = Number.parseFloat(o2.value).toFixed(1);
        }
        if (o2.values !== null) {
          if (Array.isArray(o2.values)) {
            this.values = o2.values;
          } else if (typeof o2.values === "string") {
            this.values = o2.values.toArray();
          }
        } else {
          for (i3 = 1; i3 <= o2.stars; i3++) {
            this.values.push(i3);
          }
        }
        this.originValue = o2.value;
        this.value = o2.value > 0 && o2.roundFunc !== "none" ? Math[o2.roundFunc](o2.value) : Math.abs(o2.value);
        this._createRating();
        this._createEvents();
        this._fireEvent("rating-create", {
          element: element2
        });
      },
      _createRating: function() {
        const element2 = this.element;
        const o2 = this.options;
        let i3;
        let stars;
        let li;
        const sheet = Metro2.sheet;
        const value = o2.static ? Math.floor(this.originValue) : this.value;
        const rating = element2.wrap("<div>").addClass(`rating ${element2[0].className}`).addClass(o2.clsRating);
        const id = Hooks.useId(rating[0]);
        element2.val(this.value);
        rating.attr("id", element2.id() ? `rating--${element2.id()}` : id);
        stars = $7("<ul>").addClass("stars").addClass(o2.clsStars).appendTo(rating);
        for (i3 = 1; i3 <= o2.stars; i3++) {
          li = $7("<li>").attr("data-symbol", o2.symbol).data("value", this.values[i3 - 1]).appendTo(stars);
          if (i3 <= value) {
            li.addClass("on");
          }
        }
        const result = $7("<span>").addClass("result").addClass(o2.clsResult).appendTo(rating);
        result.html(o2.message);
        if (o2.offColor !== null && (o2.offColor.includes("var(") || Farbe.Routines.isColor(o2.offColor))) {
        }
        if (o2.onColor !== null && (o2.onColor.includes("var(") || Farbe.Routines.isColor(o2.onColor))) {
          Metro2.utils.addCssRule(sheet, `#${id} .stars:hover li`, `color: ${o2.onColor};`);
          Metro2.utils.addCssRule(sheet, `#${id} .stars li.on`, `color: ${o2.onColor};`);
          Metro2.utils.addCssRule(sheet, `#${id} .stars li.half::after`, `color: ${o2.onColor};`);
        }
        if (o2.title !== null) {
          const title = $7("<span>").addClass("title").addClass(o2.clsTitle).html(o2.title);
          rating.prepend(title);
        }
        if (o2.static === true) {
          rating.addClass("static");
          if (o2.half === true) {
            const dec = Math.round(this.originValue % 1 * 10);
            if (dec > 0 && dec <= 9) {
              rating.find(".stars li.on").last().next("li").addClass(`half half-${dec * 10}`);
            }
          }
        }
        element2[0].className = "";
        if (o2.label) {
          const label = $7("<label>").addClass("label-for-input").addClass(o2.clsLabel).html(o2.label).insertBefore(rating);
          if (element2.attr("id")) {
            label.attr("for", element2.attr("id"));
          } else {
            const id2 = Hooks.useId(element2[0]);
            label.attr("for", id2);
            element2.attr("id", id2);
          }
          if (element2.attr("dir") === "rtl") {
            label.addClass("rtl");
          }
        }
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        this.rating = rating;
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const rating = this.rating;
        rating.on(Metro2.events.click, ".stars li", function() {
          if (o2.static === true) {
            return;
          }
          const star = $7(this);
          const value = star.data("value");
          star.addClass("scale");
          setTimeout(() => {
            star.removeClass("scale");
          }, 300);
          element2.val(value).trigger("change");
          star.addClass("on");
          star.prevAll().addClass("on");
          star.nextAll().removeClass("on");
          that._fireEvent("star-click", {
            value,
            star: star[0]
          });
        });
      },
      val: function(v5) {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const rating = this.rating;
        if (v5 === void 0) {
          return this.value;
        }
        this.value = v5 > 0 ? Math[o2.roundFunc](v5) : 0;
        element2.val(this.value).trigger("change");
        const stars = rating.find(".stars li").removeClass("on");
        $7.each(stars, function() {
          const star = $7(this);
          if (star.data("value") <= that.value) {
            star.addClass("on");
          }
        });
        return this;
      },
      msg: function(m5) {
        const rating = this.rating;
        if (m5 === void 0) {
          return;
        }
        rating.find(".result").html(m5);
        return this;
      },
      static: function(mode) {
        const o2 = this.options;
        const rating = this.rating;
        o2.static = mode;
        if (mode === true) {
          rating.addClass("static");
        } else {
          rating.removeClass("static");
        }
      },
      changeAttributeStatic: function() {
        const element2 = this.element;
        const isStatic = JSON.parse(element2.attr("data-static")) === true;
        this.static(isStatic);
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      changeAttribute: function(attributeName, value) {
        switch (attributeName) {
          case "value":
          case "data-value":
            this.val(value);
            break;
          case "disabled":
            this.toggleState();
            break;
          case "data-message":
            this.msg(value);
            break;
          case "data-static":
            this.changeAttributeStatic();
            break;
        }
      },
      destroy: function() {
        const o2 = this.options;
        const rating = this.rating;
        rating.off(Metro2.events.click, ".stars li");
        if (o2.label) {
          rating.prev("label").remove();
        }
        rating.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/remote-dataset/remote-dataset.js
  ((Metro2, $7) => {
    "use strict";
    let RemoteDatasetDefaultConfig = {
      caption: "",
      url: "",
      urlSearch: "",
      method: "GET",
      limit: 10,
      offset: null,
      sort: "",
      keyLimit: "",
      keyOffset: "",
      keyTotal: "",
      keyData: "",
      keySort: "",
      keyOrder: "",
      keySearch: "q",
      shortPagination: false,
      rows: 10,
      rowsSteps: "10,25,50,100",
      sortRules: "",
      showServiceBlock: true,
      quickSearch: true,
      selectOrder: true,
      selectCount: true,
      showMore: true,
      showPagination: true,
      params: null,
      searchControl: null,
      sortingControl: null,
      rowsCountControl: null,
      searchThreshold: 3,
      sortLabel: "",
      rowsLabel: "",
      searchLabel: "",
      pageMode: "offset",
      // offset or page
      clsBody: "",
      clsPagination: "",
      clsSearchBlock: "",
      clsOrderBlock: "",
      clsRowsCountBlock: "",
      clsServiceBlock: "",
      onBeforeLoad: (f5) => f5,
      onLoad: (f5) => f5,
      onDrawEntry: Metro2.noop,
      onDatasetCreate: Metro2.noop
    };
    Metro2.remoteDatasetSetup = (options) => {
      RemoteDatasetDefaultConfig = $7.extend({}, RemoteDatasetDefaultConfig, options);
    };
    if (typeof globalThis.metroRemoteDatasetSetup !== "undefined") {
      Metro2.remoteDatasetSetup(globalThis.metroRemoteDatasetSetup);
    }
    Metro2.Component("remote-dataset", {
      init: function(options, elem) {
        this._super(elem, options, RemoteDatasetDefaultConfig, {
          // define instance vars here
          data: null,
          total: 0,
          params: {}
        });
        return this;
      },
      _create: function() {
        const o2 = this.options;
        if (o2.offset === null) {
          o2.offset = o2.pageMode === "offset" ? 0 : 1;
        }
        this.offset = o2.offset;
        this.rowSteps = o2.rowsSteps.toArray(",", "int");
        this.limit = +o2.rows;
        this.url = o2.url;
        this.search = "";
        const [field, order] = o2.sort.toArray(":");
        this.sortField = field;
        this.sortOrder = order;
        this.sortRules = o2.sortRules.toArray(",").filter((f5) => f5).map((rule) => rule.toArray(":"));
        const params = Metro2.utils.isObject(o2.params);
        if (params) {
          this.params = { ...params };
        }
        this._createStructure();
        this._createEvents();
        this._loadData().then(() => {
        });
        this._fireEvent("dataset-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const entries = $7("<div>").addClass("dataset-entry");
        element2.addClass("remote-dataset");
        element2.append(entries);
        entries.html(`
                <div class="service-block ${o2.clsServiceBlock} ${o2.showServiceBlock ? "" : "d-none"}">
                    <div class="search-block ${o2.clsSearchBlock} ${o2.quickSearch ? "" : "d-none"}"></div>                   
                    <div class="order-block ${o2.clsOrderBlock} ${this.sortRules.length === 0 || o2.selectOrder === false ? "d-none" : ""}"></div>                   
                    <div class="count-block ${o2.clsRowsCountBlock} ${o2.selectCount ? "" : "d-none"}"></div>
                </div>
                ${o2.caption ? `<div class="dataset-caption">${o2.caption}</div>` : ""}
                <div class="dataset-body"></div>
            `);
        let search_input;
        if (o2.searchControl) {
          search_input = $7(o2.searchControl);
        } else {
          search_input = $7("<input>").attr("type", "text").addClass("medium").appendTo(entries.find(".search-block"));
        }
        if (search_input.length) {
          search_input.attr("name", "search-control");
          Metro2.makePlugin(search_input, "input", {
            searchButton: true
          });
          const searchFn = Hooks.useDebounce(() => {
            const val = search_input.val().trim();
            if (!val) {
              this.search = "";
              this.url = o2.url;
              this._loadData().then(() => {
              });
              return;
            }
            if (val.length < o2.searchThreshold) {
              return;
            }
            this.addParam(o2.keySearch, val);
            if (o2.urlSearch) {
              this.url = o2.urlSearch;
            }
            this.offset = o2.pageMode === "offset" ? 0 : 1;
            this._loadData().then(() => {
            });
          }, 300);
          search_input.on(Metro2.events.inputchange, searchFn);
        }
        let select_order;
        let select_rows_count;
        if (o2.sortingControl) {
          select_order = $7(o2.sortingControl);
        } else {
          select_order = $7("<select>").addClass("medium").attr("name", "sort-order").appendTo(entries.find(".order-block"));
        }
        if (select_order.length) {
          select_order.html(
            this.sortRules.map(
              (rule) => `
                                    <option value="${rule[0]}:${rule[1]}" 
                                            ${rule[0] === this.sortField && rule[1] === this.sortOrder ? "selected" : ""}
                                            data-icon="${rule[3] ? rule[3] : ""}"
                                    >
                                        ${rule[2]}
                                    </option>
                                `
            ).join("")
          );
          Metro2.makePlugin(select_order, "select", {
            prepend: o2.sortLabel || this.strings.label_sorting,
            filter: false,
            onChange: (value) => {
              const [field, order] = ("" + value).split(":");
              this.url = o2.url;
              this.sortField = field;
              this.sortOrder = order;
              this.offset = o2.pageMode === "offset" ? 0 : 1;
              this._loadData().then(() => {
              });
            }
          });
        }
        if (o2.rowsCountControl) {
          select_rows_count = $7(o2.rowsCountControl);
        } else {
          select_rows_count = $7("<select>").addClass("medium").attr("name", "rows-count").appendTo(entries.find(".count-block"));
        }
        if (select_rows_count.length) {
          select_rows_count.html(
            this.rowSteps.map(
              (step) => `
                                    <option value="${step}" ${+step === +o2.rows ? "selected" : ""}>
                                        ${step}
                                    </option>
                                `
            ).join("")
          );
          Metro2.makePlugin(select_rows_count, "select", {
            prepend: o2.rowsLabel || this.strings.label_rows_count,
            filter: false,
            onChange: (value) => {
              this.limit = +value;
              this.offset = o2.pageMode === "offset" ? 0 : 1;
              this._loadData().then(() => {
              });
            }
          });
        }
        this.body = entries.find(".dataset-body").addClass(o2.clsBody);
        this.loadMore = $7("<div>").addClass("dataset-load-more");
        this.loadMore.html(`
                <button class="button large cycle link load-more-button">
                    <span class="icon">\u27F3</span>
                    ${this.strings.label_load_more}
                </button>
            `).appendTo(element2);
        if (o2.showMore === false) {
          this.loadMore.addClass("d-none");
        }
        this.pagination = $7("<div>").addClass("dataset-pagination");
        if (o2.showPagination === false) {
          this.pagination.addClass("d-none");
        }
        element2.append(this.pagination);
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        element2.on("click", ".page-link", function() {
          const parent2 = $7(this).parent();
          if (parent2.hasClass("service")) {
            if (parent2.hasClass("prev-page")) {
              if (o2.pageMode === "offset") {
                that.offset -= that.limit;
                if (that.offset < 0) {
                  that.offset = 0;
                }
              } else {
                that.offset -= 1;
                if (that.offset < 1) {
                  that.offset = 1;
                }
              }
            } else {
              if (o2.pageMode === "offset") {
                that.offset += that.limit;
              } else {
                that.offset += 1;
              }
            }
            that._loadData().then(() => {
            });
            return;
          }
          that.offset = o2.pageMode === "offset" ? $7(this).data("page") * that.limit - that.limit : $7(this).data("page");
          that._loadData().then(() => {
          });
        });
        element2.on("click", ".load-more-button", () => {
          that.offset += o2.pageMode === "offset" ? that.limit : 1;
          that._loadData(true).then(() => {
          });
        });
      },
      _createEntries: function(append = false) {
        const o2 = this.options;
        if (!this.data) {
          return;
        }
        const usePagination = Metro2.utils.isValue(this.data[o2.keyTotal]);
        this.entries = this.data[o2.keyData];
        this.total = o2.keyTotal ? this.data[o2.keyTotal] : this.entries.length;
        if (append === false) this.body.clear();
        this.entries.forEach((entry, index) => {
          this.body.append(Metro2.utils.exec(o2.onDrawEntry, [entry, index], this));
        });
        if (usePagination && !o2.shortPagination) {
          const current = o2.pageMode === "offset" ? this.offset === 0 ? 1 : Math.round(this.offset / this.limit) + 1 : this.offset;
          Metro2.pagination({
            length: this.total,
            rows: this.limit,
            current,
            target: this.pagination,
            clsPagination: o2.clsPagination
          });
        } else {
          this.pagination.html(`
                    <div class="short-pagination">
                        <div class="button service prev-page"><a href="javascript:void(0)" class="page-link">${this.strings.label_prev}</a></div>
                        <div class="button service next-page"><a href="javascript:void(0)" class="page-link">${this.strings.label_next}</a></div>
                    </div>
                `);
        }
      },
      _loadData: async function(append = false) {
        const o2 = this.options;
        if (!this.url) {
          return;
        }
        let url = `${this.url}?`;
        if (o2.keyLimit) {
          url += `${o2.keyLimit}=${this.limit}&`;
        }
        if (o2.keyOffset) {
          url += `${o2.keyOffset}=${this.offset}`;
        }
        if (this.sortField) {
          if (o2.keySort) {
            url += `&${o2.keySort}=${this.sortField}`;
          }
          if (o2.keyOrder) {
            url += `&${o2.keyOrder}=${this.sortOrder}`;
          }
        }
        for (const key in this.params) {
          if (Object.hasOwn(this.params, key)) {
            url += `&${key}=${encodeURIComponent(this.params[key])}`;
          }
        }
        url = o2.onBeforeLoad(url, this);
        const response = await fetch(url, { method: o2.method });
        if (response.ok === false) {
          return;
        }
        const responseData = await response.json();
        this.data = Metro2.utils.exec(o2.onLoad, [responseData], this);
        this._createEntries(append);
      },
      addParam: function(key, value) {
        if (this.params === null) {
          this.params = {};
        }
        this.params[key] = value;
        return this;
      },
      addParams: function(params = {}) {
        if (this.params === null) {
          this.params = {};
        }
        for (const key in params) {
          if (Object.hasOwn(params, key)) {
            this.params[key] = params[key];
          }
        }
        return this;
      },
      clearParams: function() {
        this.params = {};
        return this;
      },
      load: function(append = false) {
        if (this.url === "") {
          return;
        }
        this._loadData(append).then(() => {
        });
      },
      changeAttribute: (attr, newValue) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/remote-table/remote-table.js
  ((Metro2, $7) => {
    "use strict";
    let RemoteTableDefaultConfig = {
      caption: "",
      url: "",
      urlSearch: "",
      method: "GET",
      limit: 10,
      offset: null,
      fields: "",
      sortableFields: "",
      colSize: "",
      sort: "",
      sortOrder: "asc",
      captions: null,
      keyLimit: "",
      keyOffset: "",
      keyTotal: "",
      keyData: "",
      keySort: "",
      keyOrder: "",
      keySearch: "q",
      shortPagination: false,
      rows: 10,
      rowsSteps: "10,25,50,100",
      showServiceBlock: true,
      quickSearch: true,
      selectOrder: true,
      selectCount: true,
      showPagination: true,
      params: null,
      searchControl: null,
      rowsCountControl: null,
      searchThreshold: 3,
      rowsLabel: "",
      searchLabel: "",
      pageMode: "offset",
      // offset or page
      clsTable: "",
      clsRow: "",
      clsCell: "",
      clsHead: "",
      clsPagination: "",
      onBeforeLoad: (f5) => f5,
      onLoad: (f5) => f5,
      onDrawRow: Metro2.noop,
      onDrawCell: Metro2.noop,
      onDrawHeadCell: Metro2.noop,
      onTableCreate: Metro2.noop
    };
    Metro2.remoteTableSetup = (options) => {
      RemoteTableDefaultConfig = $7.extend({}, RemoteTableDefaultConfig, options);
    };
    if (typeof globalThis.metroRemoteTableSetup !== "undefined") {
      Metro2.remoteTableSetup(globalThis.metroRemoteTableSetup);
    }
    Metro2.Component("remote-table", {
      init: function(options, elem) {
        this._super(elem, options, RemoteTableDefaultConfig, {
          // define instance vars here
          data: null,
          total: 0,
          params: {}
        });
        return this;
      },
      _create: function() {
        const o2 = this.options;
        if (o2.offset === null) {
          o2.offset = o2.pageMode === "offset" ? 0 : 1;
        }
        this.offset = +o2.offset;
        this.fields = o2.fields.toArray(",");
        this.captions = o2.captions ? o2.captions.toArray(",") : null;
        this.rowSteps = o2.rowsSteps.toArray(",");
        this.colSize = o2.colSize.toArray(",");
        this.limit = +o2.rows;
        this.url = o2.url;
        this.search = "";
        this.sortField = o2.sort;
        this.sortOrder = o2.sortOrder;
        const params = Metro2.utils.isObject(o2.params);
        if (params) {
          this.params = { ...params };
        }
        this._createStructure();
        this._createEvents();
        this._loadData().then(() => {
        });
        this._fireEvent("table-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const entries = $7("<div>").addClass("table-entry");
        element2.addClass("table-component remote-table");
        element2.append(entries);
        entries.html(`
                <div class="service-block ${o2.clsServiceBlock} ${o2.showServiceBlock ? "" : "d-none"}">
                    <div class="search-block ${o2.clsSearchBlock} ${o2.quickSearch ? "" : "d-none"}"></div>                   
                    <div class="count-block ${o2.clsRowsCountBlock} ${o2.selectCount ? "" : "d-none"}"></div>
                </div>
                <table class="table ${o2.clsTable}">
                    <caption>${o2.caption}</caption>
                    <thead></thead>
                    <tbody></tbody>
                </table>
            `);
        let search_input;
        if (o2.searchControl) {
          search_input = $7(o2.searchControl);
        } else {
          search_input = $7("<input>").attr("type", "text").addClass("medium").appendTo(entries.find(".search-block"));
        }
        if (search_input.length) {
          search_input.attr("name", "search-control");
          Metro2.makePlugin(search_input, "input", {
            searchButton: true
          });
          const searchFn = Hooks.useDebounce(() => {
            const val = search_input.val().trim();
            if (!val) {
              this.search = "";
              this.url = o2.url;
              this._loadData().then(() => {
              });
              return;
            }
            if (val.length < o2.searchThreshold) {
              return;
            }
            this.addParam(o2.keySearch, val);
            if (o2.urlSearch) {
              this.url = o2.urlSearch;
            }
            this.offset = o2.pageMode === "offset" ? 0 : 1;
            this._loadData().then(() => {
            });
          }, 300);
          search_input.on(Metro2.events.inputchange, searchFn);
        }
        let select_rows_count;
        if (o2.rowsCountControl) {
          select_rows_count = $7(o2.rowsCountControl);
        } else {
          select_rows_count = $7("<select>").addClass("medium").attr("name", "rows-count").appendTo(entries.find(".count-block"));
        }
        if (select_rows_count.length) {
          select_rows_count.html(
            this.rowSteps.map(
              (step) => `
                                    <option value="${step}" ${+step === +o2.rows ? "selected" : ""}>
                                        ${step}
                                    </option>
                                `
            ).join("")
          );
          Metro2.makePlugin(select_rows_count, "select", {
            prepend: o2.rowsLabel || this.strings.label_rows_count,
            filter: false,
            onChange: (value) => {
              this.limit = +value;
              this.offset = o2.pageMode === "offset" ? 0 : 1;
              this._loadData().then(() => {
              });
            }
          });
        }
        this.header = entries.find("thead");
        this.body = entries.find("tbody");
        this.pagination = $7("<div>").addClass("table-pagination");
        if (o2.showPagination === false) {
          this.pagination.addClass("d-none");
        }
        element2.append(this.pagination);
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        element2.on("click", ".page-link", function() {
          const parent2 = $7(this).parent();
          if (parent2.hasClass("service")) {
            if (parent2.hasClass("prev-page")) {
              if (o2.pageMode === "offset") {
                that.offset -= that.limit;
                if (that.offset < 0) {
                  that.offset = 0;
                }
              } else {
                that.offset -= 1;
                if (that.offset < 1) {
                  that.offset = 1;
                }
              }
            } else {
              if (o2.pageMode === "offset") {
                that.offset += that.limit;
              } else {
                that.offset += 1;
              }
            }
            that._loadData().then(() => {
            });
            return;
          }
          that.offset = o2.pageMode === "offset" ? $7(this).data("page") * that.limit - that.limit : $7(this).data("page");
          that._loadData().then(() => {
          });
        });
        element2.on("click", ".sortable-column", function() {
          const field = $7(this).attr("data-field");
          if (that.sortField === field) {
            that.sortOrder = that.sortOrder === "asc" ? "desc" : "asc";
          } else {
            that.sortField = field;
            that.sortOrder = "asc";
          }
          that._loadData().then(() => {
          });
        });
      },
      _createEntries: function() {
        const o2 = this.options;
        if (!this.data) {
          return;
        }
        const usePagination = Metro2.utils.isValue(this.data[o2.keyTotal]);
        this.entries = this.data[o2.keyData];
        this.total = this.data[o2.keyTotal];
        this.header.clear();
        this.body.clear();
        const headerRow = $7("<tr>").addClass("table-header").appendTo(this.header);
        let hIndex = 0;
        for (const key of Object.keys(this.entries[0])) {
          if (this.fields.length && !this.fields.includes(key)) {
            continue;
          }
          const cellData = this.captions ? this.captions[hIndex] : key;
          const cell = $7("<th>").html(cellData).attr("data-field", key);
          if (o2.sortableFields?.includes(key)) {
            cell.addClass("sortable-column");
            if (this.sortField === key) {
              cell.addClass(`sort-${this.sortOrder}`);
            }
          }
          cell.appendTo(headerRow).addClass(`head-cell-${key}`);
          if (this.colSize[hIndex]) {
            cell.css("width", this.colSize[hIndex]);
          }
          Metro2.utils.exec(
            o2.onDrawHeadCell,
            [
              cell[0],
              cellData,
              key,
              hIndex,
              o2.sortableFields.includes(key),
              this.sortField === key,
              this.sortOrder
            ],
            this
          );
          hIndex++;
        }
        this.entries.forEach((entry, index) => {
          const row = $7("<tr>").addClass("table-row");
          this.body.append(row);
          Metro2.utils.exec(o2.onDrawRow, [row, entry, index], this);
          let hIndex2 = 0;
          for (const key in entry) {
            if (this.fields.length && !this.fields.includes(key)) {
              continue;
            }
            const cell = $7("<td>").attr("data-label", this.captions ? this.captions[hIndex2] : key).addClass(`data-cell-${key}`).html(entry[key]);
            row.append(cell);
            Metro2.utils.exec(o2.onDrawCell, [cell[0], entry[key], key, entry, index], this);
            hIndex2++;
          }
        });
        if (usePagination && !o2.shortPagination) {
          const current = o2.pageMode === "offset" ? this.offset === 0 ? 1 : Math.round(this.offset / this.limit) + 1 : this.offset;
          Metro2.pagination({
            length: this.total,
            rows: this.limit,
            current,
            target: this.pagination,
            clsPagination: o2.clsPagination
          });
        } else {
          this.pagination.html(`
                    <div class="short-pagination">
                        <div class="button service prev-page"><a href="javascript:void(0)" class="page-link">${this.strings.label_prev}</a></div>
                        <div class="button service next-page"><a href="javascript:void(0)" class="page-link">${this.strings.label_next}</a></div>
                    </div>
                `);
        }
      },
      _loadData: async function() {
        const o2 = this.options;
        if (!this.url) {
          return;
        }
        let url = `${this.url}?`;
        if (o2.keyLimit) {
          url += `${o2.keyLimit}=${this.limit}&`;
        }
        if (o2.keyOffset) {
          url += `${o2.keyOffset}=${this.offset}`;
        }
        if (this.sortField) {
          if (o2.keySort) {
            url += `&${o2.keySort}=${this.sortField}`;
          }
          if (o2.keyOrder) {
            url += `&${o2.keyOrder}=${this.sortOrder}`;
          }
        }
        for (const key in this.params) {
          if (Object.hasOwn(this.params, key)) {
            url += `&${key}=${encodeURIComponent(this.params[key])}`;
          }
        }
        url = o2.onBeforeLoad(url, this);
        const response = await fetch(url, { method: o2.method });
        if (response.ok === false) {
          return;
        }
        const responseData = await response.json();
        this.data = Metro2.utils.exec(o2.onLoad, [responseData], this);
        this._createEntries();
      },
      addParam: function(key, value) {
        if (this.params === null) {
          this.params = {};
        }
        this.params[key] = value;
        return this;
      },
      addParams: function(params = {}) {
        if (this.params === null) {
          this.params = {};
        }
        for (const key in params) {
          if (Object.hasOwn(params, key)) {
            this.params[key] = params[key];
          }
        }
        return this;
      },
      clearParams: function() {
        this.params = {};
        return this;
      },
      load: function(append = false) {
        if (this.url === "") {
          return;
        }
        this._loadData(append).then(() => {
        });
      },
      changeAttribute: (attr, newValue) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/resizable-container/resizable-container.js
  ((Metro2, $7) => {
    "use strict";
    let ResizableContainerDefaultConfig = {
      canResize: true,
      resizePointers: "nw, n, ne, e, se, s, sw, w",
      minWidth: 0,
      minHeight: 0,
      maxWidth: 0,
      maxHeight: 0,
      initWidth: 0,
      initHeight: 0,
      onResizeStart: Metro2.noop,
      onResize: Metro2.noop,
      onResizeStop: Metro2.noop,
      onResizeEnable: Metro2.noop,
      onResizeDisable: Metro2.noop,
      onResizableContainerCreate: Metro2.noop
    };
    Metro2.resizableContainerSetup = (options) => {
      ResizableContainerDefaultConfig = $7.extend({}, ResizableContainerDefaultConfig, options);
    };
    if (typeof window.metroResizableContainerSetup !== "undefined") {
      Metro2.resizableContainerSetup(window.metroResizableContainerSetup);
    }
    Metro2.Component("resizable-container", {
      init: function(options, elem) {
        this._super(elem, options, ResizableContainerDefaultConfig, {
          // define instance vars here
          id: null,
          pointers: []
        });
        return this;
      },
      _create: function() {
        this.id = Hooks.useId(this.elem);
        this.pointers = this.options.resizePointers.toArray(this.options.resizePointers.includes(",") ? "," : " ");
        this._createStructure();
        this._createEvents();
        this._fireEvent("resizable-container-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const zIndex = element2.find("*").map((el) => {
          const z5 = getComputedStyle(el).zIndex;
          return !isNaN(z5) ? parseInt(z5) : 0;
        }).filter((v5) => v5 !== "auto").sort((a2, b5) => b5 - a2)[0] || 0;
        element2.addClass("resizable-container");
        if (Metro2.utils.getStyleOne(element2[0], "position") === "static") {
          element2.css("position", "relative");
        }
        if (o2.minWidth) {
          element2.css("minWidth", o2.minWidth);
        }
        if (o2.minHeight) {
          element2.css("minHeight", o2.minHeight);
        }
        if (o2.initWidth) {
          element2.css("width", o2.initWidth);
        }
        if (o2.initHeight) {
          element2.css("height", o2.initHeight);
        }
        const contour = $7(`<div>`).addClass("rc-contour").css({ zIndex: zIndex + 2 }).appendTo(element2);
        for (const p5 of this.pointers) {
          $7(`<div>`).addClass(`rc-point -${p5}`).css({ zIndex: zIndex + 3 }).attr("data-resize-direction", p5).appendTo(contour);
        }
        const { top, left, width, height } = element2.rect();
        element2.css({
          top,
          left,
          width,
          height
        });
        if (o2.canResize === false) {
          this.disable();
        }
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const minW = o2.minWidth || 0;
        const minH = o2.minHeight || 0;
        const maxW = o2.maxWidth || 0;
        const maxH = o2.maxHeight || 0;
        const clamp = Metro2.utils.clamp;
        element2.on(Metro2.events.startAll, ".rc-point", function(e2) {
          e2.preventDefault();
          e2.stopPropagation();
          const point = $7(this).attr("data-resize-direction");
          const startXY = Metro2.utils.pageXY(e2);
          const { height, width, top, left } = element2[0].getBoundingClientRect();
          const { top: pTop, left: pLeft } = element2.parent()[0].getBoundingClientRect();
          that._fireEvent("resize-start", {
            size: that.size(),
            element: element2[0],
            point
          });
          $7(document).on(
            Metro2.events.moveAll,
            (e3) => {
              const moveXY = Metro2.utils.pageXY(e3);
              const deltaX = moveXY.x - startXY.x;
              const deltaY = moveXY.y - startXY.y;
              if (point === "n") {
                const rawH = height - deltaY;
                const newH = clamp(rawH, minH, maxH);
                const effDy = height - newH;
                const newTop = top + effDy - pTop;
                element2.css({
                  height: `${newH}px`,
                  top: `${newTop}px`
                });
              }
              if (point === "s") {
                const rawH = height + deltaY;
                const newH = clamp(rawH, minH, maxH);
                element2.css({
                  height: `${newH}px`
                });
              }
              if (point === "e") {
                const rawW = width + deltaX;
                const newW = clamp(rawW, minW, maxW);
                element2.css({
                  width: `${newW}px`
                });
              }
              if (point === "w") {
                const rawW = width - deltaX;
                const newW = clamp(rawW, minW, maxW);
                const effDx = width - newW;
                const newLeft = left + effDx - pLeft;
                element2.css({
                  width: `${newW}px`,
                  left: `${newLeft}px`
                });
              }
              if (point === "ne") {
                const rawW = width + deltaX;
                const newW = clamp(rawW, minW, maxW);
                const rawH = height - deltaY;
                const newH = clamp(rawH, minH, maxH);
                const effDy = height - newH;
                const newTop = top + effDy - pTop;
                element2.css({
                  width: `${newW}px`,
                  height: `${newH}px`,
                  top: `${newTop}px`
                });
              }
              if (point === "nw") {
                const rawW = width - deltaX;
                const newW = clamp(rawW, minW, maxW);
                const effDx = width - newW;
                const newLeft = left + effDx - pLeft;
                const rawH = height - deltaY;
                const newH = clamp(rawH, minH, maxH);
                const effDy = height - newH;
                const newTop = top + effDy - pTop;
                element2.css({
                  width: `${newW}px`,
                  height: `${newH}px`,
                  left: `${newLeft}px`,
                  top: `${newTop}px`
                });
              }
              if (point === "se") {
                const rawW = width + deltaX;
                const newW = clamp(rawW, minW, maxW);
                const rawH = height + deltaY;
                const newH = clamp(rawH, minH, maxH);
                element2.css({
                  width: `${newW}px`,
                  height: `${newH}px`
                });
              }
              if (point === "sw") {
                const rawW = width - deltaX;
                const newW = clamp(rawW, minW, maxW);
                const effDx = width - newW;
                const newLeft = left + effDx - pLeft;
                const rawH = height + deltaY;
                const newH = clamp(rawH, minH, maxH);
                element2.css({
                  width: `${newW}px`,
                  height: `${newH}px`,
                  left: `${newLeft}px`
                });
              }
              that._fireEvent("resize", {
                size: that.size(),
                element: element2[0],
                point
              });
            },
            { ns: that.id }
          );
          $7(document).on(
            Metro2.events.stopAll,
            () => {
              $7(document).off(Metro2.events.moveAll, { ns: that.id });
              $7(document).off(Metro2.events.stopAll, { ns: that.id });
              that._fireEvent("resize-stop", {
                size: that.size(),
                element: element2[0],
                point
              });
            },
            { ns: that.id }
          );
        });
      },
      size: function(width, height) {
        const element2 = this.element;
        const clamp = Metro2.utils.clamp;
        const o2 = this.options;
        if (width !== void 0) {
          element2.css("width", clamp(width, o2.minWidth, o2.maxWidth));
        }
        if (height !== void 0) {
          element2.css("height", clamp(height, o2.minHeight, o2.maxHeight));
        }
        const rect = element2[0].getBoundingClientRect();
        return {
          width: rect.width,
          height: rect.height,
          top: rect.top,
          left: rect.left
        };
      },
      enable: function() {
        this.element.find(".rc-contour").removeClass("disabled");
        this._fireEvent("resize-enable", {
          size: this.size(),
          element: this.element
        });
      },
      disable: function() {
        this.element.find(".rc-contour").addClass("disabled");
        this._fireEvent("resize-disable", {
          size: this.size(),
          element: this.element
        });
      },
      changeAttribute: function(attr, val) {
        console.log(attr, val);
        switch (attr) {
          case "data-can-resize": {
            if (val === "true") {
              this.enable();
            } else {
              this.disable();
            }
            break;
          }
        }
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/resizer/resizer.js
  ((Metro2, $7) => {
    "use strict";
    let ResizerDefaultConfig = {
      resizerDeferred: 0,
      onMediaPoint: Metro2.noop,
      onMediaPointEnter: Metro2.noop,
      onMediaPointLeave: Metro2.noop,
      onWindowResize: Metro2.noop,
      onElementResize: Metro2.noop,
      onResizerCreate: Metro2.noop
    };
    Metro2.resizerSetup = (options) => {
      ResizerDefaultConfig = $7.extend({}, ResizerDefaultConfig, options);
    };
    if (typeof globalThis.metroResizerSetup !== "undefined") {
      Metro2.resizerSetup(globalThis.metroResizerSetup);
    }
    Metro2.Component("resizer", {
      init: function(options, elem) {
        this._super(elem, options, ResizerDefaultConfig, {
          size: { width: 0, height: 0 },
          media: globalThis.METRO_MEDIA,
          id: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this.id = Hooks.useId(this.elem);
        this.size = {
          width: element2.width(),
          height: element2.height()
        };
        this._createStructure();
        this._createEvents();
        this._fireEvent("resizer-create", {
          element: element2
        });
      },
      _createStructure: () => {
      },
      _createEvents: function() {
        const element2 = this.element;
        const win = $7.window();
        win.on(
          "resize",
          () => {
            const windowWidth = win.width();
            const windowHeight = win.height();
            const elementWidth = element2.width();
            const elementHeight = element2.height();
            const oldSize = this.size;
            let point;
            this._fireEvent("window-resize", {
              width: windowWidth,
              height: windowHeight,
              media: globalThis.METRO_MEDIA
            });
            if (this.size.width !== elementWidth || this.size.height !== elementHeight) {
              this.size = {
                width: elementWidth,
                height: elementHeight
              };
              this._fireEvent("element-resize", {
                width: elementWidth,
                height: elementHeight,
                oldSize,
                media: globalThis.METRO_MEDIA
              });
            }
            if (this.media.length !== globalThis.METRO_MEDIA.length) {
              if (this.media.length > globalThis.METRO_MEDIA.length) {
                point = this.media.filter((x5) => !globalThis.METRO_MEDIA.includes(x5));
                this._fireEvent("media-point-leave", {
                  point,
                  media: globalThis.METRO_MEDIA
                });
              } else {
                point = globalThis.METRO_MEDIA.filter((x5) => !this.media.includes(x5));
                this._fireEvent("media-point-enter", {
                  point,
                  media: globalThis.METRO_MEDIA
                });
              }
              this.media = globalThis.METRO_MEDIA;
              this._fireEvent("media-point", {
                point,
                media: globalThis.METRO_MEDIA
              });
            }
          },
          { ns: this.id }
        );
      },
      changeAttribute: () => {
      },
      destroy: function() {
        $7(globalThis).off("resize", { ns: this.id });
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/ribbon-menu/ribbon-menu.js
  ((Metro2, $7) => {
    "use strict";
    let RibbonMenuDefaultConfig = {
      ribbonMenuDeferred: 0,
      onStatic: Metro2.noop,
      onBeforeTab: Metro2.noop_true,
      onTab: Metro2.noop,
      onRibbonMenuCreate: Metro2.noop
    };
    Metro2.ribbonMenuSetup = (options) => {
      RibbonMenuDefaultConfig = $7.extend({}, RibbonMenuDefaultConfig, options);
    };
    if (typeof globalThis.metroRibbonMenuSetup !== "undefined") {
      Metro2.ribbonMenuSetup(globalThis.metroRibbonMenuSetup);
    }
    Metro2.Component("ribbon-menu", {
      init: function(options, elem) {
        this._super(elem, options, RibbonMenuDefaultConfig);
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("ribbon-menu-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        element2.addClass("ribbon-menu");
        const fluentGroups = element2.find(".ribbon-toggle-group");
        $7.each(fluentGroups, function() {
          const g5 = $7(this);
          g5.buttongroup({
            clsActive: "active"
          });
          let gw = 0;
          const btns = g5.find(".ribbon-icon-button");
          $7.each(btns, function() {
            const b5 = $7(this);
            const w6 = b5.outerWidth(true);
            if (w6 > gw) gw = w6;
          });
          g5.css("width", gw * Math.ceil(btns.length / 3) + 4);
        });
        element2.find(".section").addClass("non-active");
        const tabs = element2.find(".tabs-holder li:not(.static)");
        const active_tab = element2.find(".tabs-holder li.active");
        if (active_tab.length > 0) {
          this.open($7(active_tab[0]));
        } else {
          if (tabs.length > 0) {
            this.open($7(tabs[0]));
          }
        }
        setTimeout(() => {
          $7(window).trigger("resize");
        });
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const content_holder = element2.find(".content-holder").get(0);
        element2.on(Metro2.events.click, ".tabs-holder li a", function(e2) {
          const link = $7(this);
          const tab = $7(this).parent("li");
          if (tab.hasClass("static")) {
            if (o2.onStatic === Metro2.noop && link.attr("href") !== void 0) {
              document.location.href = link.attr("href");
            } else {
              that._fireEvent("static", {
                tab: tab[0]
              });
            }
          } else {
            if (Metro2.utils.exec(o2.onBeforeTab, [tab[0]], element2[0]) === true) {
              that.open(tab[0]);
            }
          }
          $7(window).trigger("resize");
          e2.preventDefault();
        });
        window.addEventListener("resize", () => {
          if (content_holder.clientWidth < content_holder.scrollWidth) {
            $7(content_holder).addClass("scrollable");
          } else {
            $7(content_holder).removeClass("scrollable");
          }
        });
      },
      open: function(tab) {
        const element2 = this.element;
        const $tab = $7(tab);
        const tabs = element2.find(".tabs-holder li");
        const sections = element2.find(".content-holder .section");
        const target = $tab.children("a").attr("href");
        const target_section = target !== "#" ? element2.find(target) : null;
        sections.addClass("non-active");
        tabs.removeClass("active");
        $tab.addClass("active");
        sections.removeClass("active");
        if (target_section) {
          target_section.addClass("active").removeClass("non-active");
        }
        this._fireEvent("tab", {
          tab: $tab[0]
        });
      },
      changeAttribute: () => {
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, ".tabs-holder li a");
        element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/ripple/ripple.js
  ((Metro2, $7) => {
    "use strict";
    let RippleDefaultConfig = {
      rippleDeferred: 0,
      rippleColor: "#fff",
      rippleAlpha: 0.4,
      rippleTarget: "default",
      onRippleCreate: Metro2.noop
    };
    Metro2.rippleSetup = (options) => {
      RippleDefaultConfig = $7.extend({}, RippleDefaultConfig, options);
    };
    if (typeof globalThis.metroRippleSetup !== "undefined") {
      Metro2.rippleSetup(globalThis.metroRippleSetup);
    }
    const getRipple = (target, color = "#fff", alpha = 0.4, event = false) => {
      const el = $7(target);
      const rect = Metro2.utils.rect(el[0]);
      let x5;
      let y4;
      if (el.length === 0) {
        return;
      }
      if (el.css("position") === "static") {
        el.css("position", "relative");
      }
      el.css({
        overflow: "hidden"
      });
      $7(".ripple").remove();
      const size = Math.max(el.outerWidth(), el.outerHeight());
      const ripple = $7("<span class='ripple'></span>").css({
        width: size,
        height: size
      });
      el.prepend(ripple);
      if (event) {
        x5 = event.pageX - el.offset().left - ripple.width() / 2;
        y4 = event.pageY - el.offset().top - ripple.height() / 2;
      } else {
        x5 = rect.width / 2 - ripple.width() / 2;
        y4 = rect.height / 2 - ripple.height() / 2;
      }
      ripple.css({
        background: Farbe.Routines.toRGBA(Farbe.Routines.parse(color), alpha),
        width: size,
        height: size,
        top: `${y4}px`,
        left: `${x5}px`
      }).addClass("rippleEffect");
      setTimeout(() => {
        ripple.remove();
      }, 400);
    };
    Metro2.Component("ripple", {
      init: function(options, elem) {
        this._super(elem, options, RippleDefaultConfig);
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        const target = o2.rippleTarget === "default" ? null : o2.rippleTarget;
        element2.on(Metro2.events.click, target, function(e2) {
          getRipple(this, o2.rippleColor, o2.rippleAlpha, e2);
        });
        this._fireEvent("riopple-create", {
          element: element2
        });
      },
      changeAttribute: function(attributeName) {
        const element2 = this.element;
        const o2 = this.options;
        function changeColor() {
          const color = element2.attr("data-ripple-color");
          if (!Farbe.Routines.isColor(color)) {
            return;
          }
          o2.rippleColor = color;
        }
        function changeAlpha() {
          const alpha = +element2.attr("data-ripple-alpha");
          if (isNaN(alpha)) {
            return;
          }
          o2.rippleColor = alpha;
        }
        switch (attributeName) {
          case "data-ripple-color":
            changeColor();
            break;
          case "data-ripple-alpha":
            changeAlpha();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        const target = o2.rippleTarget === "default" ? null : o2.rippleTarget;
        element2.off(Metro2.events.click, target);
      }
    });
    Metro2.ripple = getRipple;
  })(Metro, Dom);

  // ../metroui-lib/source/components/sidebar/sidebar.js
  ((Metro2, $7) => {
    "use strict";
    let SidebarDefaultConfig = {
      menuScrollbar: false,
      sidebarDeferred: 0,
      position: "left",
      shift: null,
      staticShift: null,
      toggle: null,
      duration: 300,
      static: null,
      closeOutside: true,
      onOpen: Metro2.noop,
      onClose: Metro2.noop,
      onToggle: Metro2.noop,
      onStaticSet: Metro2.noop,
      onStaticLoss: Metro2.noop,
      onSidebarCreate: Metro2.noop
    };
    Metro2.sidebarSetup = (options) => {
      SidebarDefaultConfig = $7.extend({}, SidebarDefaultConfig, options);
    };
    if (typeof globalThis.metroSidebarSetup !== "undefined") {
      Metro2.sidebarSetup(globalThis.metroSidebarSetup);
    }
    Metro2.Component("sidebar", {
      init: function(options, elem) {
        this._super(elem, options, SidebarDefaultConfig, {
          toggle_element: null,
          id: null,
          shiftedContent: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        this.id = element2.attr("id") || Hooks.useId(this.elem);
        if (o2.shift) {
          this.shiftedContent = $7(o2.shift);
          if (this.shiftedContent.length !== 0) {
            if (Metro2.utils.getStyleOne(this.shiftedContent[0], "position") === "static") {
              this.shiftedContent.css({
                position: "relative"
              });
            }
          }
        }
        this._createStructure();
        this._createEvents();
        $7(globalThis).resize();
        this._checkStatic();
        this._fireEvent("sidebar-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const header = element2.find(".sidebar-header");
        const sheet = Metro2.sheet;
        const menu = element2.find(".sidebar-menu");
        const size = element2.outerWidth();
        element2.addClass("sidebar").addClass(`on-${o2.position}`);
        if (o2.menuScrollbar === false) {
          menu.addClass("hide-scroll");
        }
        if (o2.toggle !== null && $7(o2.toggle).length > 0) {
          this.toggle_element = $7(o2.toggle);
        }
        if (header.length > 0) {
          if (header.data("image")) {
            header.css({
              backgroundImage: `url(${header.data("image")})`
            });
          }
        }
        if (o2.static !== null) {
          if (o2.staticShift !== null) {
            if (o2.position === "left") {
              Metro2.utils.addCssRule(
                sheet,
                `@media screen and ${Metro2.media_queries[o2.static.toUpperCase()]}`,
                `${o2.staticShift}{margin-left: ${size}px; width: calc(100% - ${size}px);}`
              );
            } else {
              Metro2.utils.addCssRule(
                sheet,
                `@media screen and ${Metro2.media_queries[o2.static.toUpperCase()]}`,
                `${o2.staticShift}{margin-right: ${size}px; width: calc(100% - ${size}px);}`
              );
            }
          }
        }
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        const toggle = this.toggle_element;
        if (toggle !== null) {
          toggle.on(Metro2.events.click, (e2) => {
            this.toggle();
            e2.stopPropagation();
          });
        } else if (o2.toggle) {
          $7.document().on("click", o2.toggle, (e2) => {
            this.toggle();
            e2.stopPropagation();
          });
        }
        if (o2.static !== null && Metro2.media_modes.includes(o2.static)) {
          $7(globalThis).on(
            Metro2.events.resize,
            () => {
              this._checkStatic();
            },
            { ns: this.id }
          );
        }
        element2.on(Metro2.events.click, ".sidebar-menu .js-sidebar-close", (e2) => {
          this.close();
          e2.stopPropagation();
        });
        element2.on(Metro2.events.click, (e2) => {
          e2.stopPropagation();
        });
        $7(document).on(Metro2.events.click, () => {
          if (o2.closeOutside === true) {
            if (this.isOpen()) this.close();
          }
        });
      },
      _checkStatic: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (Metro2.utils.mediaExist(o2.static) && !element2.hasClass("static")) {
          element2.addClass("static");
          element2.data("opened", false).removeClass("open");
          if (o2.shift !== null) {
            $7.each(o2.shift.split(","), function() {
              $7(this).animate({
                draw: {
                  left: 0
                },
                dur: o2.duration
              });
            });
          }
          this._fireEvent("static-set");
        }
        if (!Metro2.utils.mediaExist(o2.static)) {
          element2.removeClass("static");
          this._fireEvent("static-loss");
        }
      },
      isOpen: function() {
        return this.element.data("opened") === true;
      },
      open: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (element2.hasClass("static")) {
          return;
        }
        element2.data("opened", true).addClass("open");
        if (o2.shift) {
          $7(o2.shift).animate({
            draw: {
              left: [0, element2.outerWidth()]
            },
            dur: o2.duration
          });
        }
        this._fireEvent("open");
      },
      close: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (element2.hasClass("static")) {
          return;
        }
        element2.data("opened", false).removeClass("open");
        if (o2.shift !== null) {
          $7(o2.shift).animate({
            draw: {
              left: 0
            },
            dur: o2.duration
          });
        }
        this._fireEvent("close");
      },
      toggle: function() {
        if (this.isOpen()) {
          this.close();
        } else {
          this.open();
        }
        this._fireEvent("toggle");
      },
      changeAttribute: () => {
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        const toggle = this.toggle_element;
        if (toggle !== null) {
          toggle.off(Metro2.events.click);
        }
        if (o2.static !== null && Metro2.media_modes.includes(o2.static)) {
          $7(globalThis).off(Metro2.events.resize, { ns: this.id });
        }
        element2.off(Metro2.events.click, ".js-sidebar-close");
        return element2;
      }
    });
    Metro2.sidebar = {
      isSidebar: (el) => Metro2.utils.isMetroObject(el, "sidebar"),
      open: function(el) {
        if (!this.isSidebar(el)) {
          return;
        }
        Metro2.getPlugin(el, "sidebar").open();
      },
      close: function(el) {
        if (!this.isSidebar(el)) {
          return;
        }
        Metro2.getPlugin(el, "sidebar").close();
      },
      toggle: function(el) {
        if (!this.isSidebar(el)) {
          return;
        }
        Metro2.getPlugin(el, "sidebar").toggle();
      },
      isOpen: function(el) {
        if (!this.isSidebar(el)) {
          return;
        }
        return Metro2.getPlugin(el, "sidebar").isOpen();
      }
    };
  })(Metro, Dom);

  // ../metroui-lib/source/components/sidenav/sidenav.js
  ((Metro2, $7) => {
    "use strict";
    let SidenavDefaultConfig = {
      compacted: false,
      toggle: null,
      expandPoint: "fs",
      onMenuItemClick: Metro2.noop,
      onCollapse: Metro2.noop,
      onExpand: Metro2.noop,
      onSidenavCreate: Metro2.noop
    };
    Metro2.sidenavSetup = (options) => {
      SidenavDefaultConfig = $7.extend({}, SidenavDefaultConfig, options);
    };
    if (typeof globalThis.metroSidenavSetup !== "undefined") {
      Metro2.sidenavSetup(globalThis.metroSidenavSetup);
    }
    Metro2.Component("sidenav", {
      init: function(options, elem) {
        this._super(elem, options, SidenavDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("sidenav-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("sidenav");
        if (Metro2.utils.mediaExist(o2.expandPoint)) {
          element2.addClass("expanded");
        }
        if (!element2.id()) {
          element2.attr("id", Hooks.useId(element2[0]));
        }
        const id = element2.id();
        const state2 = Metro2.storage.getItem(`sidenav:${id}:compacted`);
        if (state2 === true) {
          element2.removeClass("expanded");
          element2.addClass("handmade");
        }
        const items = element2.children("li:has(a)");
        items.each((_5, item) => {
          const $item = $7(item);
          const $a = $item.children("a");
          const $icon = $a.children(".icon");
          $item.title($item.find(".caption").text());
          if ($icon.length === 0) {
            const [w1, w22] = $a.text().toArray(" ");
            const caption = w1 ? w1.charAt(0) + (w22 ? w22.charAt(0) : w1.charAt(1)) : "DA";
            $a.prepend(`<span class='icon'><span class='default-icon text-upper'>${caption}</span></span>`);
          }
        });
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        const id = element2.id();
        if (o2.toggle) {
          $7(o2.toggle).on("click", () => {
            element2.toggleClass("expanded");
            element2.toggleClass("handmade");
            Metro2.storage.setItem(`sidenav:${id}:compacted`, !element2.hasClass("expanded"));
          });
        }
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            if (element2.hasClass("handmade")) {
              return;
            }
            if (Metro2.utils.mediaExist(o2.expandPoint)) {
              element2.addClass("expanded");
            } else {
              element2.removeClass("expanded");
            }
          },
          { ns: this.id }
        );
      },
      setValue: function(index, value = 0) {
        const element2 = this.element;
        const item = element2.find("li").eq(index);
        item.find(".counter").text(value);
      },
      changeAttribute: (attr, newValue) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/sidenav-counter/sidenav-counter.js
  ((Metro2, $7) => {
    "use strict";
    let SidenavCounterDefaultConfig = {
      compacted: false,
      toggle: null,
      expandPoint: "fs",
      onMenuItemClick: Metro2.noop,
      onCollapse: Metro2.noop,
      onExpand: Metro2.noop,
      onSidenavCreate: Metro2.noop
    };
    Metro2.sidenavCounterSetup = (options) => {
      SidenavCounterDefaultConfig = $7.extend({}, SidenavCounterDefaultConfig, options);
    };
    if (typeof globalThis.metroSidenavCounterSetup !== "undefined") {
      Metro2.sidenavCounterSetup(globalThis.metroSidenavCounterSetup);
    }
    Metro2.Component("sidenav-counter", {
      init: function(options, elem) {
        this._super(elem, options, SidenavCounterDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("sidenav-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("sidenav-counter");
        if (Metro2.utils.mediaExist(o2.expandPoint)) {
          element2.addClass("expanded");
        }
        const state2 = Metro2.storage.getItem("sidenav-counter:compacted");
        if (state2 === true) {
          element2.removeClass("expanded");
          element2.addClass("handmade");
        }
        const items = element2.find("li");
        items.each((index, item) => {
          const $item = $7(item);
          $item.title($item.find(".title").text());
        });
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (o2.toggle) {
          $7(o2.toggle).on("click", () => {
            element2.toggleClass("expanded");
            element2.toggleClass("handmade");
            Metro2.storage.setItem("sidenav-counter:compacted", !element2.hasClass("expanded"));
          });
        }
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            if (element2.hasClass("handmade")) {
              return;
            }
            if (Metro2.utils.mediaExist(o2.expandPoint)) {
              element2.addClass("expanded");
            } else {
              element2.removeClass("expanded");
            }
          },
          { ns: this.id }
        );
      },
      setValue: function(index, value = 0) {
        const element2 = this.element;
        const item = element2.find("li").eq(index);
        item.find(".counter").text(value);
      },
      changeAttribute: (attr, newValue) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/sidenav-simple/sidenav-simple.js
  ((Metro2, $7) => {
    "use strict";
    let SidenavSimpleDefaultConfig = {
      compacted: false,
      toggle: null,
      expandPoint: "fs",
      onMenuItemClick: Metro2.noop,
      onCollapse: Metro2.noop,
      onExpand: Metro2.noop,
      onSidenavCreate: Metro2.noop
    };
    Metro2.sidenavSimpleSetup = (options) => {
      SidenavSimpleDefaultConfig = $7.extend({}, SidenavSimpleDefaultConfig, options);
    };
    if (typeof globalThis.metroSidenavSimpleSetup !== "undefined") {
      Metro2.sidenavSimpleSetup(globalThis.metroSidenavSimpleSetup);
    }
    Metro2.Component("sidenav-simple", {
      init: function(options, elem) {
        this._super(elem, options, SidenavSimpleDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("sidenav-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("sidenav-simple");
        if (Metro2.utils.mediaExist(o2.expandPoint)) {
          element2.addClass("expanded");
        }
        const state2 = Metro2.storage.getItem("sidenav-simple:compacted");
        if (state2 === true) {
          element2.removeClass("expanded");
          element2.addClass("handmade");
        }
        const items = element2.find("li");
        items.each((index, item) => {
          const $item = $7(item);
          $item.title($item.find(".title").text());
        });
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (o2.toggle) {
          $7(o2.toggle).on("click", () => {
            element2.toggleClass("expanded");
            element2.toggleClass("handmade");
            Metro2.storage.setItem("sidenav-simple:compacted", !element2.hasClass("expanded"));
          });
        }
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            if (element2.hasClass("handmade")) {
              return;
            }
            if (Metro2.utils.mediaExist(o2.expandPoint)) {
              element2.addClass("expanded");
            } else {
              element2.removeClass("expanded");
            }
          },
          { ns: this.id }
        );
      },
      changeAttribute: (attr, newValue) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/sorter/sorter.js
  ((Metro2, $7) => {
    "use strict";
    let SorterDefaultConfig = {
      sorterDeferred: 0,
      thousandSeparator: ",",
      decimalSeparator: ",",
      sortTarget: null,
      sortSource: null,
      sortDir: "asc",
      sortStart: true,
      saveInitial: true,
      onSortStart: Metro2.noop,
      onSortStop: Metro2.noop,
      onSortItemSwitch: Metro2.noop,
      onSorterCreate: Metro2.noop
    };
    Metro2.sorterSetup = (options) => {
      SorterDefaultConfig = $7.extend({}, SorterDefaultConfig, options);
    };
    if (typeof globalThis.metroSorterSetup !== "undefined") {
      Metro2.sorterSetup(globalThis.metroSorterSetup);
    }
    Metro2.Component("sorter", {
      init: function(options, elem) {
        this._super(elem, options, SorterDefaultConfig, {
          initial: []
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._fireEvent("sorter-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (o2.sortTarget === null) {
          o2.sortTarget = element2.children()[0].tagName;
        }
        this.initial = element2.find(o2.sortTarget).get();
        if (o2.sortStart === true) {
          this.sort(o2.sortDir);
        }
      },
      _getItemContent: function(item) {
        const o2 = this.options;
        let data;
        let inset;
        let i3;
        let format;
        if (Metro2.utils.isValue(o2.sortSource)) {
          data = "";
          inset = item.getElementsByClassName(o2.sortSource);
          if (inset.length > 0)
            for (i3 = 0; i3 < inset.length; i3++) {
              data += inset[i3].textContent;
            }
          format = inset[0].dataset.format;
        } else {
          data = item.textContent;
          format = item.dataset.format;
        }
        data = `${data}`.toLowerCase().replace(/[\n\r]+|[\s]{2,}/g, " ").trim();
        if (Metro2.utils.isValue(format)) {
          if (["number", "int", "float", "money"].indexOf(format) !== -1 && (o2.thousandSeparator !== "," || o2.decimalSeparator !== ".")) {
            data = Metro2.utils.parseNumber(data, o2.thousandSeparator, o2.decimalSeparator);
          }
          switch (format) {
            case "date":
              data = Metro2.utils.isDate(data) ? new Date(data) : "";
              break;
            case "number":
              data = Number(data);
              break;
            case "int":
              data = Number.parseInt(data);
              break;
            case "float":
              data = Number.parseFloat(data);
              break;
            case "money":
              data = Metro2.utils.parseMoney(data);
              break;
            case "card":
              data = Metro2.utils.parseCard(data);
              break;
            case "phone":
              data = Metro2.utils.parsePhone(data);
              break;
          }
        }
        return data;
      },
      sort: function(dir) {
        const element2 = this.element;
        const o2 = this.options;
        let items;
        const id = Metro2.utils.elementId("temp");
        let prev;
        if (dir) {
          o2.sortDir = dir;
        }
        items = element2.find(o2.sortTarget).get();
        if (items.length === 0) {
          return;
        }
        prev = $7("<div>").attr("id", id).insertBefore($7(element2.find(o2.sortTarget)[0]));
        this._fireEvent("sort-start", {
          items
        });
        items.sort((a2, b5) => {
          const c1 = this._getItemContent(a2);
          const c22 = this._getItemContent(b5);
          let result = 0;
          if (c1 < c22) {
            result = -1;
          }
          if (c1 > c22) {
            result = 1;
          }
          if (result !== 0) {
            this._fireEvent("sort-item-switch", {
              a: a2,
              b: b5,
              result
            });
          }
          return result;
        });
        if (o2.sortDir === "desc") {
          items.reverse();
        }
        element2.find(o2.sortTarget).remove();
        $7.each(items, function() {
          const $this = $7(this);
          $this.insertAfter(prev);
          prev = $this;
        });
        $7(`#${id}`).remove();
        this._fireEvent("sort-stop", {
          items
        });
      },
      reset: function() {
        const element2 = this.element;
        const o2 = this.options;
        const id = Metro2.utils.elementId("sorter");
        let prev;
        const items = this.initial;
        if (items.length === 0) {
          return;
        }
        prev = $7("<div>").attr("id", id).insertBefore($7(element2.find(o2.sortTarget)[0]));
        element2.find(o2.sortTarget).remove();
        $7.each(items, function() {
          const $this = $7(this);
          $this.insertAfter(prev);
          prev = $this;
        });
        $7(`#${id}`).remove();
      },
      changeAttribute: function(attributeName) {
        const element2 = this.element;
        const o2 = this.options;
        const changeSortDir = () => {
          const dir = element2.attr("data-sort-dir").trim();
          if (dir === "") return;
          o2.sortDir = dir;
          this.sort();
        };
        const changeSortContent = () => {
          const content = element2.attr("data-sort-content").trim();
          if (content === "") return;
          o2.sortContent = content;
          this.sort();
        };
        switch (attributeName) {
          case "data-sort-dir":
            changeSortDir();
            break;
          case "data-sort-content":
            changeSortContent();
            break;
        }
      },
      destroy: function() {
        return this.element;
      }
    });
    Metro2.sorter = {
      create: (el, op) => Metro2.utils.$()(el).sorter(op),
      isSorter: (el) => Metro2.utils.isMetroObject(el, "sorter"),
      sort: function(el, dir = "asc") {
        if (!this.isSorter(el)) {
          return false;
        }
        Metro2.getPlugin(el, "sorter").sort(dir);
      },
      reset: function(el) {
        if (!this.isSorter(el)) {
          return false;
        }
        Metro2.getPlugin(el, "sorter").reset();
      }
    };
  })(Metro, Dom);

  // ../metroui-lib/source/components/storage/storage.js
  ((Metro2, $7) => {
    "use strict";
    const MetroStorage = (type) => new MetroStorage.init(type);
    MetroStorage.prototype = {
      setKey: function(key) {
        this.key = key;
      },
      getKey: function() {
        return this.key;
      },
      setItem: function(key, value) {
        this.storage.setItem(`${this.key}:${key}`, JSON.stringify(value));
      },
      getItem: function(key, default_value, reviver) {
        let result;
        let value;
        value = this.storage.getItem(`${this.key}:${key}`);
        try {
          result = JSON.parse(value, reviver);
        } catch (e2) {
          result = null;
        }
        return Metro2.utils.nvl(result, default_value);
      },
      getItemPart: function(key, sub_key, default_value, reviver) {
        let i3;
        let val = this.getItem(key, default_value, reviver);
        const _sub_key = sub_key.split("->");
        for (i3 = 0; i3 < _sub_key.length; i3++) {
          val = val[_sub_key[i3]];
        }
        return val;
      },
      delItem: function(key) {
        this.storage.removeItem(`${this.key}:${key}`);
      },
      size: function(unit) {
        let divider;
        switch (unit) {
          case "m":
          case "M": {
            divider = 1024 * 1024;
            break;
          }
          case "k":
          case "K": {
            divider = 1024;
            break;
          }
          default:
            divider = 1;
        }
        return JSON.stringify(this.storage).length / divider;
      }
    };
    MetroStorage.init = function(type) {
      this.key = "";
      this.storage = type ? type : globalThis.localStorage;
      return this;
    };
    MetroStorage.init.prototype = MetroStorage.prototype;
    Metro2.storage = MetroStorage(globalThis.localStorage);
    Metro2.session = MetroStorage(globalThis.sessionStorage);
  })(Metro, Dom);

  // ../metroui-lib/source/components/splitter/splitter.js
  ((Metro2, $7) => {
    "use strict";
    const SPLIT_MODE = {
      VERTICAL: "vertical",
      HORIZONTAL: "horizontal"
    };
    const Storage = Metro2.storage;
    let SplitterDefaultConfig = {
      splitterDeferred: 0,
      split: SPLIT_MODE.VERTICAL,
      // horizontal or vertical
      splitSizes: null,
      gutterSize: 5,
      gutterStyle: "default",
      // ribbed, dashed, dotted, default
      minSizes: null,
      children: "*",
      gutterClick: "expand",
      // TODO expand or collapse
      saveState: false,
      noResize: false,
      onResizeStart: Metro2.noop,
      onResizeStop: Metro2.noop,
      onResizeSplit: Metro2.noop,
      onResizeWindow: Metro2.noop,
      onSplitterCreate: Metro2.noop
    };
    Metro2.splitterSetup = (options) => {
      SplitterDefaultConfig = $7.extend({}, SplitterDefaultConfig, options);
    };
    if (typeof globalThis.metroSplitterSetup !== "undefined") {
      Metro2.splitterSetup(globalThis.metroSplitterSetup);
    }
    Metro2.Component("splitter", {
      init: function(options, elem) {
        this._super(elem, options, SplitterDefaultConfig, {
          storage: Metro2.storage,
          storageKey: "SPLITTER:",
          id: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this.id = Hooks.useId(this.elem);
        this._createStructure();
        this._createEvents();
        this._fireEvent("splitter-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const children = element2.children(o2.children).addClass("split-block");
        let i3;
        let children_sizes = [];
        const resizeProp = o2.split === SPLIT_MODE.HORIZONTAL ? "height" : "width";
        element2.addClass("splitter");
        element2.addClass(o2.split.toLowerCase() === SPLIT_MODE.VERTICAL ? "vertical" : "horizontal");
        if (o2.gutterStyle !== "default") {
          element2.addClass(`gutter-style-${o2.gutterStyle}`);
        }
        if (o2.noResize === true) {
          element2.addClass("static-size");
        }
        for (i3 = 0; i3 < children.length - 1; i3++) {
          $7("<div>").addClass("gutter").css(resizeProp, o2.gutterSize).insertAfter($7(children[i3]));
        }
        this._setSize();
        if (Metro2.utils.isValue(o2.minSizes)) {
          if (`${o2.minSizes}`.includes(",")) {
            children_sizes = o2.minSizes.toArray();
            for (i3 = 0; i3 < children_sizes.length; i3++) {
              $7(children[i3]).data("min-size", children_sizes[i3]);
              children[i3].style.setProperty(
                `min-${resizeProp}`,
                `${children_sizes[i3]}`.includes("%") ? children_sizes[i3] : `${`${children_sizes[i3]}`.replace("px", "")}px`,
                "important"
              );
            }
          } else {
            $7.each(children, function() {
              this.style.setProperty(
                `min-${resizeProp}`,
                `${o2.minSizes}`.includes("%") ? o2.minSizes : `${`${o2.minSizes}`.replace("px", "")}px`,
                "important"
              );
            });
          }
        }
        if (o2.saveState && this.storage !== null) {
          this._getSize();
        }
      },
      _setSize: function() {
        const element2 = this.element;
        const o2 = this.options;
        let gutters;
        let children_sizes;
        const children = element2.children(".split-block");
        const w6 = element2.width();
        gutters = element2.children(".gutter");
        if (!Metro2.utils.isValue(o2.splitSizes)) {
          children.css({
            flexBasis: `calc(${100 / children.length}% - ${gutters.length * o2.gutterSize}px)`
          });
        } else {
          children_sizes = `${o2.splitSizes}`.toArray();
          let remnant = 100;
          let i3 = 0;
          for (; i3 < children_sizes.length; i3++) {
            let s2 = children_sizes[i3];
            if (!s2.includes("%")) {
              s2 = +s2 * 100 / w6;
            } else {
              s2 = Number.parseInt(s2);
            }
            remnant -= s2;
            $7(children[i3]).css({
              flexBasis: `calc(${s2}% - ${gutters.length * o2.gutterSize}px)`
            });
          }
          for (; i3 < children.length; i3++) {
            $7(children[i3]).css({
              flexBasis: `calc(${remnant / (children.length - i3)}% - ${gutters.length * o2.gutterSize}px)`
            });
          }
        }
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const gutters = element2.children(".gutter");
        gutters.on(
          Metro2.events.startAll,
          function(e2) {
            if (o2.noResize === true) {
              return false;
            }
            const w6 = o2.split === SPLIT_MODE.VERTICAL ? element2.width() : element2.height();
            const gutter = $7(this);
            const prev_block = gutter.prev(".split-block");
            const next_block = gutter.next(".split-block");
            const prev_block_size = 100 * (o2.split === SPLIT_MODE.VERTICAL ? prev_block.outerWidth(true) : prev_block.outerHeight(true)) / w6;
            const next_block_size = 100 * (o2.split === SPLIT_MODE.VERTICAL ? next_block.outerWidth(true) : next_block.outerHeight(true)) / w6;
            const start_pos = Metro2.utils.getCursorPosition(element2[0], e2);
            gutter.addClass("active");
            prev_block.addClass("stop-pointer");
            next_block.addClass("stop-pointer");
            that._fireEvent("resize-start", {
              pos: start_pos,
              gutter: gutter[0],
              prevBlock: prev_block[0],
              nextBlock: next_block[0]
            });
            $7(globalThis).on(
              Metro2.events.moveAll,
              (e3) => {
                const pos = Metro2.utils.getCursorPosition(element2[0], e3);
                let new_pos;
                if (o2.split === SPLIT_MODE.VERTICAL) {
                  new_pos = pos.x * 100 / w6 - start_pos.x * 100 / w6;
                } else {
                  new_pos = pos.y * 100 / w6 - start_pos.y * 100 / w6;
                }
                prev_block.css(
                  "flex-basis",
                  `calc(${prev_block_size + new_pos}% - ${gutters.length * o2.gutterSize}px)`
                );
                next_block.css(
                  "flex-basis",
                  `calc(${next_block_size - new_pos}% - ${gutters.length * o2.gutterSize}px)`
                );
                that._fireEvent("resize-split", {
                  pos,
                  gutter: gutter[0],
                  prevBlock: prev_block[0],
                  nextBlock: next_block[0]
                });
              },
              { ns: that.id }
            );
            $7(globalThis).on(
              Metro2.events.stopAll,
              (e3) => {
                prev_block.removeClass("stop-pointer");
                next_block.removeClass("stop-pointer");
                that._saveSize();
                gutter.removeClass("active");
                $7(globalThis).off(Metro2.events.moveAll, { ns: that.id });
                $7(globalThis).off(Metro2.events.stopAll, { ns: that.id });
                const cur_pos = Metro2.utils.getCursorPosition(element2[0], e3);
                that._fireEvent("resize-stop", {
                  pos: cur_pos,
                  gutter: gutter[0],
                  prevBlock: prev_block[0],
                  nextBlock: next_block[0]
                });
              },
              { ns: that.id }
            );
          },
          { passive: true }
        );
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            const gutter = element2.children(".gutter");
            const prev_block = gutter.prev(".split-block");
            const next_block = gutter.next(".split-block");
            that._fireEvent("resize-window", {
              prevBlock: prev_block[0],
              nextBlock: next_block[0]
            });
          },
          { ns: that.id }
        );
      },
      _saveSize: function() {
        const element2 = this.element;
        const o2 = this.options;
        const storage = this.storage;
        const itemsSize = [];
        const id = element2.attr("id") || this.id;
        if (o2.saveState === true && storage !== null) {
          $7.each(element2.children(".split-block"), function() {
            const item = $7(this);
            itemsSize.push(item.css("flex-basis"));
          });
          if (storage) storage.setItem(this.storageKey + id, itemsSize);
        }
      },
      _getSize: function() {
        const element2 = this.element;
        const o2 = this.options;
        const storage = this.storage;
        let itemsSize = [];
        const id = element2.attr("id") || this.id;
        if (o2.saveState === true && storage !== null) {
          itemsSize = storage.getItem(this.storageKey + id);
          $7.each(element2.children(".split-block"), (i3, v5) => {
            const item = $7(v5);
            if (Metro2.utils.isValue(itemsSize) && Metro2.utils.isValue(itemsSize[i3]))
              item.css("flex-basis", itemsSize[i3]);
          });
        }
      },
      size: function(size) {
        const o2 = this.options;
        if (Metro2.utils.isValue(size)) {
          o2.splitSizes = size;
          this._setSize();
        }
        return this;
      },
      changeAttribute: function(attributeName) {
        const that = this;
        const element2 = this.element;
        function changeSize() {
          const size = element2.attr("data-split-sizes");
          that.size(size);
        }
        if (attributeName === "data-split-sizes") {
          changeSize();
        }
      },
      destroy: function() {
        const element2 = this.element;
        const gutters = element2.children(".gutter");
        gutters.off(Metro2.events.start);
        return element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/stack-menu/stack-menu.js
  ((Metro2, $7) => {
    "use strict";
    let StackMenuDefaultConfig = {
      rootTitle: "Root Menu",
      backButtonIcon: "\u2190",
      size: "default",
      onStackMenuCreate: Metro2.noop
    };
    Metro2.stackMenuSetup = (options) => {
      StackMenuDefaultConfig = $7.extend({}, StackMenuDefaultConfig, options);
    };
    if (typeof window.metroStackMenuSetup !== "undefined") {
      Metro2.stackMenuSetup(window.metroStackMenuSetup);
    }
    Metro2.Component("stack-menu", {
      init: function(options, elem) {
        this._super(elem, options, StackMenuDefaultConfig, {
          // define instance vars here
          menus: /* @__PURE__ */ new Map(),
          stack: []
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("menu-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("stack-menu");
        if (o2.size !== "default") {
          element2.css({
            width: o2.size
          });
        }
        element2.find("ul").each((i3, el) => {
          const parent2 = $7(el).parent("li");
          if (typeof parent2 === "undefined") {
            this.menus.set("root", el);
          } else {
            parent2.attr("data-menu-id", `ul-${i3}`);
            this.menus.set(`ul-${i3}`, el);
          }
        });
        element2.children("ul").hide();
        element2.append($7("<ul>").addClass("--menu"));
        this._drawMenu("root");
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        element2.on(Metro2.events.click, "li", function(e2) {
          e2.preventDefault();
          e2.stopPropagation();
          const key = $7(this).attr("data-menu-id");
          const title = that._getText($7(this).children("a")[0]);
          if (key && that.menus.has(key)) {
            that.stack.push({
              key: that.currentKey || "root",
              title: that.currentTitle || that.options.rootTitle
            });
            that.currentKey = key;
            that.currentTitle = title;
            that._drawMenu(key, title);
          }
        });
        element2.on(Metro2.events.click, ".back-menu-button", (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
          if (that.stack.length > 0) {
            const previousState = that.stack.pop();
            that.currentKey = previousState.key;
            that.currentTitle = previousState.title;
            that._drawMenu(previousState.key, previousState.title);
          }
        });
      },
      _getText: (el) => {
        const whitespace = /^\s*$/;
        for (const node of el.childNodes) {
          if (node.nodeType === node.TEXT_NODE && !whitespace.test(node.textContent)) {
            return node.textContent;
          }
        }
        return "";
      },
      _setTitle: function(title) {
        const element2 = this.element;
        const o2 = this.options;
        const titleContent = `
                ${this.stack.length === 0 ? "" : `<button class='back-menu-button cycle small flat mr-2'>${o2.backButtonIcon}</button>`}
                <span>${title || o2.rootTitle}</span>
            `;
        element2.find(".title").html(titleContent);
      },
      _drawMenu: function(key = "root", title) {
        const menu = this.menus.get(key);
        const target = this.element.children("ul.--menu");
        this._setTitle(title);
        target.clear();
        if (menu) {
          const items = [];
          $7(menu).children("li").each((_5, el) => {
            const item = $7(el);
            const id = item.attr("data-menu-id") || "none";
            const anchor = item.children("a").clone(true);
            const newItem = $7("<li>").addClass("-initial").attr("data-menu-id", id).appendTo(target).append(anchor);
            items.push(newItem);
          });
          setTimeout(() => {
            items.forEach((item, index) => {
              setTimeout(() => {
                item.removeClass("-initial");
              }, index * 30);
            });
          }, 10);
        }
      },
      changeAttribute: (attr, newValue) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/stepper/stepper.js
  ((Metro2, $7) => {
    "use strict";
    let StepperDefaultConfig = {
      stepperDeferred: 0,
      view: Metro2.stepperView.SQUARE,
      // square, cycle, diamond
      steps: 3,
      step: 1,
      stepClick: false,
      clsStepper: "",
      clsStep: "",
      clsComplete: "",
      clsCurrent: "",
      onStep: Metro2.noop,
      onStepClick: Metro2.noop,
      onStepperCreate: Metro2.noop
    };
    Metro2.stepperSetup = (options) => {
      StepperDefaultConfig = $7.extend({}, StepperDefaultConfig, options);
    };
    if (typeof globalThis.metroStepperSetup !== "undefined") {
      Metro2.stepperSetup(globalThis.metroStepperSetup);
    }
    Metro2.Component("stepper", {
      init: function(options, elem) {
        this._super(elem, options, StepperDefaultConfig, {
          current: 0
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        if (o2.step <= 0) {
          o2.step = 1;
        }
        this._createStepper();
        this._createEvents();
        this._fireEvent("stepper-create", {
          element: element2
        });
      },
      _createStepper: function() {
        const element2 = this.element;
        const o2 = this.options;
        let i3;
        element2.addClass("stepper").addClass(o2.view).addClass(o2.clsStepper);
        for (i3 = 1; i3 <= o2.steps; i3++) {
          $7("<span>").addClass("step").addClass(o2.clsStep).data("step", i3).html(`<span>${i3}</span>`).appendTo(element2);
        }
        this.current = 1;
        this.toStep(o2.step);
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        element2.on(Metro2.events.click, ".step", function() {
          const step = $7(this).data("step");
          if (o2.stepClick === true) {
            that.toStep(step);
            that._fireEvent("step-click", {
              step
            });
          }
        });
      },
      next: function() {
        const element2 = this.element;
        const steps = element2.find(".step");
        if (this.current + 1 > steps.length) {
          return;
        }
        this.current++;
        this.toStep(this.current);
      },
      prev: function() {
        if (this.current - 1 === 0) {
          return;
        }
        this.current--;
        this.toStep(this.current);
      },
      last: function() {
        const element2 = this.element;
        this.toStep(element2.find(".step").length);
      },
      first: function() {
        this.toStep(1);
      },
      toStep: function(step) {
        const element2 = this.element;
        const o2 = this.options;
        const target = $7(element2.find(".step").get(step - 1));
        const prevStep = this.current;
        if (target.length === 0) {
          return;
        }
        this.current = step;
        element2.find(".step").removeClass("complete current").removeClass(o2.clsCurrent).removeClass(o2.clsComplete);
        target.addClass("current").addClass(o2.clsCurrent);
        target.prevAll().addClass("complete").addClass(o2.clsComplete);
        this._fireEvent("step", {
          step: this.current,
          prev: prevStep
        });
      },
      changeAttribute: () => {
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, ".step");
        element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/streamer/streamer.js
  ((Metro2, $7) => {
    "use strict";
    let StreamerDefaultConfig = {
      streamerDeferred: 0,
      wheel: true,
      wheelStep: 20,
      duration: 200,
      defaultClosedIcon: "",
      defaultOpenIcon: "",
      changeUri: true,
      encodeLink: true,
      closed: false,
      chromeNotice: false,
      startFrom: null,
      slideToStart: true,
      startSlideSleep: 1e3,
      source: null,
      data: null,
      eventClick: "select",
      selectGlobal: true,
      streamSelect: false,
      excludeSelectElement: null,
      excludeClickElement: null,
      excludeElement: null,
      excludeSelectClass: "",
      excludeClickClass: "",
      excludeClass: "",
      onDataLoad: Metro2.noop,
      onDataLoaded: Metro2.noop,
      onDataLoadError: Metro2.noop,
      onDrawEvent: Metro2.noop,
      onDrawGlobalEvent: Metro2.noop,
      onDrawStream: Metro2.noop,
      onStreamClick: Metro2.noop,
      onStreamSelect: Metro2.noop,
      onEventClick: Metro2.noop,
      onEventSelect: Metro2.noop,
      onEventsScroll: Metro2.noop,
      onStreamerCreate: Metro2.noop
    };
    Metro2.streamerSetup = (options) => {
      StreamerDefaultConfig = $7.extend({}, StreamerDefaultConfig, options);
    };
    if (typeof globalThis.metroStreamerSetup !== "undefined") {
      Metro2.streamerSetup(globalThis.metroStreamerSetup);
    }
    Metro2.Component("streamer", {
      init: function(options, elem) {
        this._super(elem, options, StreamerDefaultConfig, {
          data: null,
          scroll: 0,
          scrollDir: "left",
          events: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("streamer");
        if (element2.attr("id") === void 0) {
          element2.attr("id", Hooks.useId(this.elem));
        }
        if (o2.source === null && o2.data === null) {
          return false;
        }
        $7("<div>").addClass("streams").appendTo(element2);
        $7("<div>").addClass("events-area").appendTo(element2);
        if (o2.source !== null) {
          this._fireEvent("data-load", {
            source: o2.source
          });
          this._loadSource();
        } else {
          this.data = o2.data;
          this.build();
        }
      },
      _loadSource: function() {
        const o2 = this.options;
        fetch(o2.source).then(Metro2.fetch.status).then(Metro2.fetch.json).then((data) => {
          this._fireEvent("data-loaded", {
            source: o2.source,
            data
          });
          this.data = data;
          this.build();
        }).catch((error) => {
          this._fireEvent("data-load-error", {
            source: o2.source,
            error
          });
        });
      },
      build: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const data = this.data;
        const streams = element2.find(".streams").html("");
        const events_area = element2.find(".events-area").html("");
        let fake_timeline;
        const timeline = $7("<ul>").addClass("streamer-timeline").html("").appendTo(events_area);
        const streamer_events = $7("<div>").addClass("streamer-events").appendTo(events_area);
        const event_group_main = $7("<div>").addClass("event-group").appendTo(streamer_events);
        let StreamerIDS = Metro2.utils.getURIParameter(null, "StreamerIDS");
        if (StreamerIDS !== null && o2.encodeLink === true) {
          StreamerIDS = atob(StreamerIDS);
        }
        const StreamerIDS_i = StreamerIDS ? StreamerIDS.split("|")[0] : null;
        const StreamerIDS_a = StreamerIDS ? StreamerIDS.split("|")[1].split(",") : [];
        if (data.actions !== void 0) {
          const actions = $7("<div>").addClass("streamer-actions").appendTo(streams);
          $7.each(data.actions, function() {
            const button = $7("<button>").addClass("streamer-action").addClass(this.cls).html(this.html);
            if (this.onclick)
              button.on(Metro2.events.click, () => {
                Metro2.utils.exec(this.onclick, [element2]);
              });
            button.appendTo(actions);
          });
        }
        timeline.html("");
        if (data.timeline === void 0) {
          data.timeline = {
            start: "09:00",
            stop: "18:00",
            step: 20
          };
        }
        const start = /* @__PURE__ */ new Date();
        const stop = /* @__PURE__ */ new Date();
        const start_time_array = data.timeline.start ? data.timeline.start.split(":") : [9, 0];
        const stop_time_array = data.timeline.stop ? data.timeline.stop.split(":") : [18, 0];
        const step = data.timeline.step ? Number.parseInt(data.timeline.step) * 60 : 1200;
        start.setHours(start_time_array[0]);
        start.setMinutes(start_time_array[1]);
        start.setSeconds(0);
        stop.setHours(stop_time_array[0]);
        stop.setMinutes(stop_time_array[1]);
        stop.setSeconds(0);
        let i3;
        let t;
        let h3;
        let v5;
        let m5;
        let j5;
        let fm;
        let li;
        let fli;
        let fli_w;
        for (i3 = start.getTime() / 1e3; i3 <= stop.getTime() / 1e3; i3 += step) {
          t = new Date(i3 * 1e3);
          h3 = t.getHours();
          m5 = t.getMinutes();
          v5 = `${Str.lpad(h3, "0", 2)}:${Str.lpad(m5, "0", 2)}`;
          li = $7("<li>").data("time", v5).addClass(`js-time-point-${v5.replace(":", "-")}`).html(`<em>${v5}</em>`).appendTo(timeline);
          fli_w = li.width() / Number.parseInt(data.timeline.step);
          fake_timeline = $7("<ul>").addClass("streamer-fake-timeline").html("").appendTo(li);
          for (j5 = 0; j5 < Number.parseInt(data.timeline.step); j5++) {
            fm = m5 + j5;
            v5 = `${Str.lpad(h3, "0", 2)}:${Str.lpad(fm, "0", 2)}`;
            fli = $7("<li>").data("time", v5).addClass(`js-fake-time-point-${v5.replace(":", "-")}`).html("|").appendTo(fake_timeline);
            fli.css({
              width: fli_w
            });
          }
        }
        if (data.streams !== void 0) {
          $7.each(data.streams, function(stream_index, stream_item) {
            const stream_height = 75;
            let rows = 0;
            const stream = $7("<div>").addClass("stream").addClass(this.cls).appendTo(streams);
            stream.addClass(stream_item.cls).data("one", false).data("data", stream_item.data);
            $7("<div>").addClass("stream-title").html(stream_item.title).appendTo(stream);
            $7("<div>").addClass("stream-secondary").html(stream_item.secondary).appendTo(stream);
            $7(stream_item.icon).addClass("stream-icon").appendTo(stream);
            const bg = Farbe.Routines.toHEX(Metro2.utils.getStyleOne(stream, "background-color"));
            const fg = Farbe.Routines.toHEX(Metro2.utils.getStyleOne(stream, "color"));
            const stream_events = $7("<div>").addClass("stream-events").data("background-color", bg).data("text-color", fg).appendTo(event_group_main);
            if (stream_item.events !== void 0) {
              $7.each(stream_item.events, function(event_index, event_item) {
                const row = event_item.row === void 0 ? 1 : Number.parseInt(event_item.row);
                let _icon;
                const sid = `${stream_index}:${event_index}`;
                const custom_html = event_item.custom !== void 0 ? event_item.custom : "";
                const custom_html_open = event_item.custom_open !== void 0 ? event_item.custom_open : "";
                const custom_html_close = event_item.custom_close !== void 0 ? event_item.custom_close : "";
                let event;
                if (event_item.skip !== void 0 && Metro2.utils.bool(event_item.skip)) {
                  return;
                }
                event = $7("<div>").data("origin", event_item).data("sid", sid).data("data", event_item.data).data("time", event_item.time).data("target", event_item.target).addClass("stream-event").addClass(
                  `size-${event_item.size}${["half", "one-third"].includes(event_item.size) ? "" : "x"}`
                ).addClass(event_item.cls).appendTo(stream_events);
                const time_point = timeline.find(`.js-fake-time-point-${this.time.replace(":", "-")}`);
                const left = time_point.offset().left - stream_events.offset().left;
                const top = 75 * (row - 1);
                if (row > rows) {
                  rows = row;
                }
                event.css({
                  position: "absolute",
                  left,
                  top
                });
                if (Metro2.utils.isNull(event_item.html)) {
                  const slide = $7("<div>").addClass("stream-event-slide").appendTo(event);
                  const slide_logo = $7("<div>").addClass("slide-logo").appendTo(slide);
                  const slide_data = $7("<div>").addClass("slide-data").appendTo(slide);
                  if (event_item.icon !== void 0) {
                    if (Metro2.utils.isTag(event_item.icon)) {
                      $7(event_item.icon).addClass("icon").appendTo(slide_logo);
                    } else {
                      $7("<img>").addClass("icon").attr("src", event_item.icon).attr("alt", "").appendTo(slide_logo);
                    }
                  }
                  $7("<span>").addClass("time").css({
                    backgroundColor: bg,
                    color: fg
                  }).html(event_item.time).appendTo(slide_logo);
                  $7("<div>").addClass("title").html(event_item.title).appendTo(slide_data);
                  $7("<div>").addClass("subtitle").html(event_item.subtitle).appendTo(slide_data);
                  $7("<div>").addClass("desc").html(event_item.desc).appendTo(slide_data);
                  if (o2.closed === false && element2.attr("id") === StreamerIDS_i && StreamerIDS_a.indexOf(sid) !== -1 || event_item.selected === true || Number.parseInt(event_item.selected) === 1) {
                    event.addClass("selected");
                  }
                  if (o2.closed === true || event_item.closed === true || Number.parseInt(event_item.closed) === 1) {
                    _icon = event_item.closedIcon !== void 0 ? Metro2.utils.isTag(event_item.closedIcon) ? event_item.closedIcon : `<span>${event_item.closedIcon}</span>` : Metro2.utils.isTag(o2.defaultClosedIcon) ? o2.defaultClosedIcon : `<span>${o2.defaultClosedIcon}</span>`;
                    $7(_icon).addClass("state-icon").addClass(event_item.clsClosedIcon).appendTo(slide);
                    event.data("closed", true).data("target", event_item.target);
                    event.append(custom_html_open);
                  } else {
                    _icon = event_item.openIcon !== void 0 ? Metro2.utils.isTag(event_item.openIcon) ? event_item.openIcon : `<span>${event_item.openIcon}</span>` : Metro2.utils.isTag(o2.defaultOpenIcon) ? o2.defaultOpenIcon : `<span>${o2.defaultOpenIcon}</span>`;
                    $7(_icon).addClass("state-icon").addClass(event_item.clsOpenIcon).appendTo(slide);
                    event.data("closed", false);
                    event.append(custom_html_close);
                  }
                  event.append(custom_html);
                } else {
                  event.html(event_item.html);
                }
                that._fireEvent("draw-event", {
                  event: event[0]
                });
              });
              const last_child = stream_events.find(".stream-event").last();
              if (last_child.length > 0)
                stream_events.outerWidth(last_child[0].offsetLeft + last_child.outerWidth());
            }
            stream_events.css({
              height: stream_height * rows
            });
            element2.find(".stream").eq(stream_events.index()).css({
              height: stream_height * rows
            });
            that._fireEvent("draw-stream", {
              stream: stream[0]
            });
          });
        }
        if (data.global !== void 0) {
          const streamer_events_left = streamer_events.offset().left;
          $7.each(["before", "after"], (_5, global_item) => {
            if (data.global[global_item] !== void 0) {
              $7.each(data.global[global_item], function(_6, event_item) {
                const group = $7("<div>").addClass("event-group").addClass(
                  `size-${event_item.size}${["half", "one-third"].includes(event_item.size) ? "" : "x"}`
                );
                const events = $7("<div>").addClass("stream-events global-stream").appendTo(group);
                const event = $7("<div>").addClass("stream-event").appendTo(events);
                event.addClass("global-event").addClass(event_item.cls).data("time", event_item.time).data("origin", event_item).data("data", event_item.data);
                $7("<div>").addClass("event-title").html(event_item.title).appendTo(event);
                $7("<div>").addClass("event-subtitle").html(event_item.subtitle).appendTo(event);
                $7("<div>").addClass("event-html").html(event_item.html).appendTo(event);
                let left;
                const t2 = timeline.find(`.js-fake-time-point-${this.time.replace(":", "-")}`);
                if (t2.length > 0) {
                  left = t2.offset().left - streamer_events_left;
                }
                group.css({
                  position: "absolute",
                  left,
                  height: "100%"
                }).appendTo(streamer_events);
                that._fireEvent("draw-global-event", {
                  event: event[0]
                });
              });
            }
          });
        }
        element2.data("stream", -1);
        element2.find(".events-area").scrollLeft(0);
        this.events = element2.find(".stream-event");
        this._createEvents();
        if (o2.startFrom !== null && o2.slideToStart === true) {
          setTimeout(() => {
            that.slideTo(o2.startFrom);
          }, o2.startSlideSleep);
        }
        this._fireEvent("streamer-create");
        this._fireScroll();
      },
      _fireScroll: function() {
        const element2 = this.element;
        const scrollable = element2.find(".events-area");
        const oldScroll = this.scroll;
        if (scrollable.length === 0) {
          return void 0;
        }
        this.scrollDir = this.scroll < scrollable[0].scrollLeft ? "left" : "right";
        this.scroll = scrollable[0].scrollLeft;
        this._fireEvent("events-scroll", {
          scrollLeft: scrollable[0].scrollLeft,
          oldScroll,
          scrollDir: this.scrollDir,
          events: $7.toArray(this.events)
        });
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        function disableScroll() {
          const scrollTop = globalThis.pageYOffset || document.documentElement.scrollTop;
          const scrollLeft = globalThis.pageXOffset || document.documentElement.scrollLeft;
          globalThis.onscroll = () => {
            globalThis.scrollTo(scrollLeft, scrollTop);
          };
        }
        function enableScroll() {
          globalThis.onscroll = () => {
          };
        }
        element2.off(Metro2.events.click, ".stream-event").on(Metro2.events.click, ".stream-event", function(e2) {
          const event = $7(this);
          if (o2.excludeClass !== "" && event.hasClass(o2.excludeClass)) {
            return;
          }
          if (o2.excludeElement !== null && $7(e2.target).is(o2.excludeElement)) {
            return;
          }
          if (o2.closed === false && event.data("closed") !== true && o2.eventClick === "select") {
            if (o2.excludeSelectClass !== "" && event.hasClass(o2.excludeSelectClass)) {
            } else {
              if (o2.excludeSelectElement !== null && $7(e2.target).is(o2.excludeSelectElement)) {
              } else {
                if (event.hasClass("global-event")) {
                  if (o2.selectGlobal === true) {
                    event.toggleClass("selected");
                  }
                } else {
                  event.toggleClass("selected");
                }
                if (o2.changeUri === true) {
                  that._changeURI();
                }
                that._fireEvent("event-select", {
                  event: event[0],
                  selected: event.hasClass("selected")
                });
              }
            }
          } else {
            if (o2.excludeClickClass !== "" && event.hasClass(o2.excludeClickClass)) {
            } else {
              if (o2.excludeClickElement !== null && $7(e2.target).is(o2.excludeClickElement)) {
              } else {
                that._fireEvent("event-click", {
                  event: event[0]
                });
                if (o2.closed === true || event.data("closed") === true) {
                  const target = event.data("target");
                  if (target) {
                    globalThis.location.href = target;
                  }
                }
              }
            }
          }
        });
        element2.off(Metro2.events.click, ".stream").on(Metro2.events.click, ".stream", function() {
          const stream = $7(this);
          const index = stream.index();
          if (o2.streamSelect === false) {
            return;
          }
          if (element2.data("stream") === index) {
            element2.find(".stream-event").removeClass("disabled");
            element2.data("stream", -1);
          } else {
            element2.data("stream", index);
            element2.find(".stream-event").addClass("disabled");
            that.enableStream(stream);
            that._fireEvent("stream-select", {
              stream
            });
          }
          that._fireEvent("stream-click", {
            stream
          });
        });
        if (o2.wheel === true) {
          element2.find(".events-area").off(Metro2.events.mousewheel).on(
            Metro2.events.mousewheel,
            function(e2) {
              if (e2.deltaY === void 0) {
                return;
              }
              const scrollable = $7(this);
              const dir = e2.deltaY > 0 ? -1 : 1;
              const step = o2.wheelStep;
              const scroll = scrollable.scrollLeft() - dir * step;
              scrollable.scrollLeft(scroll);
            },
            {
              passive: true
            }
          );
          element2.find(".events-area").off("mouseenter").on("mouseenter", () => {
            disableScroll();
          });
          element2.find(".events-area").off("mouseleave").on("mouseleave", () => {
            enableScroll();
          });
        }
        element2.find(".events-area").last().off("scroll").on("scroll", () => {
          that._fireScroll();
        });
        if ($7.touchable === true) {
          element2.off(Metro2.events.click, ".stream").on(Metro2.events.click, ".stream", function() {
            const stream = $7(this);
            stream.toggleClass("focused");
            $7.each(element2.find(".stream"), function() {
              if ($7(this).is(stream)) return;
              $7(this).removeClass("focused");
            });
          });
        }
      },
      _changeURI: function() {
        const link = this.getLink();
        history.pushState({}, document.title, link);
      },
      slideTo: function(time) {
        const element2 = this.element;
        const o2 = this.options;
        let target;
        if (time === void 0) {
          target = $7(element2.find(".streamer-timeline li")[0]);
        } else {
          target = $7(element2.find(`.streamer-timeline .js-time-point-${time.replace(":", "-")}`)[0]);
        }
        element2.find(".events-area").animate({
          draw: {
            scrollLeft: target[0].offsetLeft - element2.find(".streams .stream").outerWidth()
          },
          dur: o2.duration
        });
      },
      enableStream: function(stream) {
        const element2 = this.element;
        const index = stream.index() - 1;
        stream.removeClass("disabled").data("streamDisabled", false);
        element2.find(".stream-events").eq(index).find(".stream-event").removeClass("disabled");
      },
      disableStream: function(stream) {
        const element2 = this.element;
        const index = stream.index() - 1;
        stream.addClass("disabled").data("streamDisabled", true);
        element2.find(".stream-events").eq(index).find(".stream-event").addClass("disabled");
      },
      toggleStream: function(stream) {
        if (stream.data("streamDisabled") === true) {
          this.enableStream(stream);
        } else {
          this.disableStream(stream);
        }
      },
      getLink: function() {
        const element2 = this.element;
        const o2 = this.options;
        const events = element2.find(".stream-event");
        const a2 = [];
        let link;
        const origin = globalThis.location.href;
        $7.each(events, function() {
          const event = $7(this);
          if (event.data("sid") === void 0 || !event.hasClass("selected")) {
            return;
          }
          a2.push(event.data("sid"));
        });
        link = `${element2.attr("id")}|${a2.join(",")}`;
        if (o2.encodeLink === true) {
          link = btoa(link);
        }
        return Metro2.utils.updateURIParameter(origin, "StreamerIDS", link);
      },
      getTimes: function() {
        const element2 = this.element;
        const times = element2.find(".streamer-timeline > li");
        const result = [];
        $7.each(times, function() {
          result.push($7(this).data("time"));
        });
        return result;
      },
      getEvents: function(event_type, include_global) {
        const element2 = this.element;
        let items;
        const events = [];
        switch (event_type) {
          case "selected":
            items = element2.find(".stream-event.selected");
            break;
          case "non-selected":
            items = element2.find(".stream-event:not(.selected)");
            break;
          default:
            items = element2.find(".stream-event");
        }
        $7.each(items, function() {
          const item = $7(this);
          if (include_global !== true && item.parent().hasClass("global-stream")) return;
          const origin = item.data("origin");
          events.push(origin);
        });
        return events;
      },
      source: function(s2) {
        const element2 = this.element;
        if (s2 === void 0) {
          return this.options.source;
        }
        element2.attr("data-source", s2);
        this.options.source = s2;
        this.changeSource();
      },
      dataSet: function(s2) {
        if (s2 === void 0) {
          return this.options.data;
        }
        this.options.data = s2;
        this.changeData(s2);
      },
      getStreamerData: function() {
        return this.data;
      },
      toggleEvent: function(event) {
        const o2 = this.options;
        const _event = $7(event);
        if (_event.hasClass("global-event") && o2.selectGlobal !== true) {
          return;
        }
        if (_event.hasClass("selected")) {
          this.selectEvent(event, false);
        } else {
          this.selectEvent(event, true);
        }
      },
      selectEvent: function(event, state2 = true) {
        const o2 = this.options;
        const _event = $7(event);
        if (_event.hasClass("global-event") && o2.selectGlobal !== true) {
          return;
        }
        if (state2 === true) _event.addClass("selected");
        else _event.removeClass("selected");
        if (o2.changeUri === true) {
          this._changeURI();
        }
        this._fireEvent("event-select", {
          event: _event[0],
          selected: state2
        });
      },
      changeSource: function() {
        const element2 = this.element;
        const o2 = this.options;
        const new_source = element2.attr("data-source");
        if (String(new_source).trim() === "") {
          return;
        }
        o2.source = new_source;
        this._fireEvent("data-load", {
          source: o2.source
        });
        this._loadSource();
        this._fireEvent("source-change");
      },
      changeData: function(data) {
        const element2 = this.element;
        const o2 = this.options;
        const old_data = this.data;
        o2.data = typeof data === "object" ? data : JSON.parse(element2.attr("data-data"));
        this.data = o2.data;
        this.build();
        this._fireEvent("data-change", {
          oldData: old_data,
          newData: o2.data
        });
      },
      changeStreamSelectOption: function() {
        const element2 = this.element;
        const o2 = this.options;
        o2.streamSelect = element2.attr("data-stream-select").toLowerCase() === "true";
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-source":
            this.changeSource();
            break;
          case "data-data":
            this.changeData();
            break;
          case "data-stream-select":
            this.changeStreamSelectOption();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, ".stream-event");
        element2.off(Metro2.events.click, ".stream");
        element2.find(".events-area").off(Metro2.events.mousewheel);
        element2.find(".events-area").last().off("scroll");
        element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/swipe/swipe.js
  ((Metro2, $7) => {
    "use strict";
    let SwipeDefaultConfig = {
      swipeThreshold: 32,
      onSwipe: Metro2.noop,
      onSwipeRight: Metro2.noop,
      onSwipeLeft: Metro2.noop,
      onSwipeUp: Metro2.noop,
      onSwipeDown: Metro2.noop,
      onSwipeCreate: Metro2.noop
    };
    Metro2.swipeSetup = (options) => {
      SwipeDefaultConfig = $7.extend({}, SwipeDefaultConfig, options);
    };
    if (typeof globalThis.metroSwipeSetup !== "undefined") {
      Metro2.swipeSetup(globalThis.metroSwipeSetup);
    }
    Metro2.Component("swipe", {
      init: function(options, elem) {
        this._super(elem, options, SwipeDefaultConfig, {});
        return this;
      },
      _create: function() {
        this.element.css({
          userSelect: "none"
        });
        this._createEvents();
        this._fireEvent("swipe-create");
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.on("touchstart mousedown", (e2) => {
          const start = Metro2.utils.pageXY(e2);
          const swipe = {
            x: 0,
            y: 0
          };
          element2.on("touchmove mousemove", (e3) => {
            const changes = Metro2.utils.pageXY(e3);
            swipe.x = changes.x - start.x;
            swipe.y = changes.y - start.y;
          });
          element2.on("touchend mouseup", (e3) => {
            let direction = "";
            if (Math.abs(swipe.x) > o2.swipeThreshold || Math.abs(swipe.y) > o2.swipeThreshold) {
              if (Math.abs(swipe.x) > Math.abs(swipe.y)) {
                if (swipe.x > 0) {
                  direction = "right";
                  this._fireEvent("swipe-right", {
                    start,
                    swipe
                  });
                } else {
                  direction = "left";
                  this._fireEvent("swipe-left", {
                    start,
                    swipe
                  });
                }
              } else {
                if (swipe.y > 0) {
                  direction = "down";
                  this._fireEvent("swipe-down", {
                    start,
                    swipe
                  });
                } else {
                  direction = "up";
                  this._fireEvent("swipe-up", {
                    start,
                    swipe
                  });
                }
              }
              this._fireEvent("swipe", {
                start,
                swipe,
                direction
              });
            }
            element2.off("touchmove mousemove");
            element2.off("touchend mouseup");
          });
        });
      },
      changeAttribute: (attr, newValue) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/switch/switch.js
  ((Metro2, $7) => {
    "use strict";
    let SwitchDefaultConfig = {
      switchDeferred: 0,
      material: false,
      prepend: "",
      append: "",
      clsSwitch: "",
      clsCheck: "",
      clsCaption: "",
      onoff: false,
      on: "",
      off: "",
      showOnOff: false,
      onSwitchCreate: Metro2.noop
    };
    Metro2.switchSetup = (options) => {
      SwitchDefaultConfig = $7.extend({}, SwitchDefaultConfig, options);
    };
    if (typeof globalThis.metroSwitchSetup !== "undefined") {
      Metro2.switchSetup(globalThis.metroSwitchSetup);
    }
    Metro2.Component("switch", {
      init: function(options, elem) {
        this._super(elem, options, SwitchDefaultConfig, {});
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        const strings = this.strings;
        const container = element2.wrap("<label>").addClass("switch").addClass(element2[0].className).addClass(o2.clsSwitch);
        element2.attr("type", "checkbox");
        if (element2.attr("readonly")) {
          element2.on("click", (e2) => {
            e2.preventDefault();
          });
        }
        this.component = container;
        element2[0].className = "";
        if (o2.prepend) {
          container.prepend(
            $7("<span>").addClass("caption-prepend").addClass(o2.clsPrepend).addClass(o2.clsCaption).html(o2.prepend)
          );
        }
        if (o2.append) {
          container.append(
            $7("<span>").addClass("caption-append").addClass(o2.clsAppend).addClass(o2.clsCaption).html(o2.append)
          );
        }
        if (o2.onoff === true) {
          element2.attr("data-on", o2.on || strings.label_on);
          element2.attr("data-off", o2.off || strings.label_off);
        } else {
          element2.removeAttr("data-on");
          element2.removeAttr("data-off");
        }
        if (o2.material === true) {
          container.addClass("material");
        }
        this._fireEvent("switch-create");
      },
      toggle: function(v5) {
        const element2 = this.element;
        if (element2.is(":disabled")) return this;
        if (!Metro2.utils.isValue(v5)) {
          element2.prop("checked", !Metro2.utils.bool(element2.prop("checked")));
        } else {
          element2.prop("checked", v5 === 1);
        }
        return this;
      },
      changeAttribute: (attr, newVal) => {
      },
      destroy: function() {
        return this.element;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/typer/typer.js
  ((Metro2, $7) => {
    "use strict";
    let TyperDefaultConfig = {
      splitter: ",",
      variance: 0,
      delay: 100,
      blinkDelay: 400,
      deleteDelay: 800,
      loop: true,
      cursor: "_",
      colors: "",
      onType: Metro2.noop,
      onTyperCreate: Metro2.noop
    };
    Metro2.typerSetup = (options) => {
      TyperDefaultConfig = $7.extend({}, TyperDefaultConfig, options);
    };
    if (typeof globalThis.metroTyperSetup !== "undefined") {
      Metro2.typerSetup(globalThis.metroTyperSetup);
    }
    Metro2.Component("typer", {
      init: function(options, elem) {
        this._super(elem, options, TyperDefaultConfig, {
          // define instance vars here
          original: null,
          lines: null,
          text: null,
          cursor: null,
          on: true,
          interval: null,
          colors: null,
          colorIndex: 0,
          typing: false
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("typer");
        this.original = element2.text();
        this.words = this.original.toArray(o2.splitter);
        this.colors = o2.colors.toArray(",");
        this.cursor = $7("<span>").addClass("typer-cursor").html(o2.cursor).insertAfter(element2);
        this.interval = setInterval(() => this._blink(), +o2.blinkDelay);
        this.progress = { word: 0, char: 0, building: true, looped: 0 };
        if (this.colors.length) {
          this.elem.style.color = this.colors[0];
        }
        element2.clear();
        this.start();
      },
      _blink: function() {
        if (this.on) {
          this.cursor[0].style.opacity = 0;
          this.on = false;
        } else {
          this.cursor[0].style.opacity = 1;
          this.on = true;
        }
      },
      doTyping: function() {
        const element2 = this.element;
        const elem = this.elem;
        const o2 = this.options;
        const p5 = this.progress;
        const w6 = p5.word;
        const c5 = p5.char;
        const curr = [...this.words[w6]].slice(0, c5).join("");
        const timeout = (2 * Math.random() - 1) * o2.variance + o2.delay;
        let atWordEnd;
        this.cursor[0].style.opacity = "1";
        this.on = true;
        clearInterval(this.interval);
        this.interval = setInterval(() => this._blink(), +o2.blinkDelay);
        element2.html(curr);
        if (p5.building) {
          atWordEnd = p5.char === this.words[w6].length;
          if (atWordEnd) {
            p5.building = false;
          } else {
            p5.char += 1;
          }
        } else {
          if (p5.char === 0) {
            p5.building = true;
            p5.word = (p5.word + 1) % this.words.length;
            if (this.colors.length) {
              this.colorIndex = (this.colorIndex + 1) % this.colors.length;
              elem.style.color = this.colors[this.colorIndex];
            }
          } else {
            p5.char -= 1;
          }
        }
        if (p5.word === this.words.length - 1) {
          p5.looped += 1;
        }
        if (!p5.building && this.loop <= p5.looped) {
          this.typing = false;
        }
        setTimeout(
          () => {
            if (this.typing) {
              this.doTyping();
            }
          },
          atWordEnd ? o2.deleteDelay : timeout
        );
      },
      start: function() {
        if (!this.typing) {
          this.typing = true;
          this.doTyping();
        }
      },
      stop: function() {
        this.typing = false;
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/table/table.js
  var TABLE_COL_OPTIONS = {
    title: void 0,
    format: void 0,
    formatMask: void 0,
    name: void 0,
    colspan: null,
    size: void 0,
    sortable: false,
    sortDir: void 0,
    clsColumn: void 0,
    cls: void 0,
    show: true,
    required: true,
    field: void 0,
    fieldType: void 0,
    validator: void 0,
    template: void 0,
    type: "data"
  };
  ((Metro2, $7) => {
    "use strict";
    let TableDefaultConfig = {
      caption: "",
      // cardMode: "",
      useCurrentSlice: false,
      showInspectorButton: false,
      inspectorButtonIcon: "\u{1F527}",
      tableDeferred: 0,
      templateBeginToken: "<%",
      templateEndToken: "%>",
      paginationDistance: 5,
      paginationIslandSize: 3,
      paginationShortTrack: 10,
      horizontalScroll: false,
      horizontalScrollStop: null,
      check: false,
      checkType: "checkbox",
      checkColIndex: 0,
      checkName: null,
      checkStoreKey: "TABLE:$1:KEYS",
      rownum: false,
      rownumTitle: "#",
      filters: null,
      filtersOperator: "and",
      head: null,
      body: null,
      source: null,
      static: false,
      searchMinLength: 1,
      searchThreshold: 500,
      searchFields: null,
      showRowsSteps: true,
      showSearch: true,
      showTableInfo: true,
      showPagination: true,
      paginationShortMode: true,
      showActivity: true,
      muteTable: true,
      showSkip: false,
      rows: 10,
      rowsSteps: "10,25,50,100",
      staticView: false,
      viewSaveMode: "client",
      viewSavePath: "TABLE:$1:OPTIONS",
      sortDir: "asc",
      decimalSeparator: ".",
      thousandSeparator: ",",
      tableRowsCountTitle: null,
      tableSearchTitle: null,
      tableSearchPlaceholder: "",
      tableInfoTitle: null,
      paginationPrevTitle: null,
      paginationNextTitle: null,
      allRecordsTitle: null,
      inspectorTitle: null,
      tableSkipTitle: null,
      emptyTableTitle: null,
      activityType: "atom",
      activityStyle: "color",
      activityTimeout: 100,
      searchWrapper: null,
      rowsWrapper: null,
      infoWrapper: null,
      paginationWrapper: null,
      skipWrapper: null,
      cellWrapper: true,
      clsComponent: "",
      clsTableContainer: "",
      clsTable: "",
      clsHead: "",
      clsHeadRow: "",
      clsHeadCell: "",
      clsBody: "",
      clsBodyRow: "",
      clsBodyCell: "",
      clsCellWrapper: "",
      clsFooter: "",
      clsFooterRow: "",
      clsFooterCell: "",
      clsTableTop: "",
      clsRowsCount: "",
      clsSearch: "",
      clsTableBottom: "",
      clsTableInfo: "",
      clsTablePagination: "",
      clsPagination: "",
      clsTableSkip: "",
      clsTableSkipInput: "",
      clsTableSkipButton: "",
      clsEvenRow: "",
      clsOddRow: "",
      clsRow: "",
      clsEmptyTableTitle: "",
      onDraw: Metro2.noop,
      onDrawRow: Metro2.noop,
      onDrawCell: Metro2.noop,
      onAppendRow: Metro2.noop,
      onAppendCell: Metro2.noop,
      onSortStart: Metro2.noop,
      onSortStop: Metro2.noop,
      onSortItemSwitch: Metro2.noop,
      onSearch: Metro2.noop,
      onRowsCountChange: Metro2.noop,
      onDataLoad: Metro2.noop,
      onDataLoadError: Metro2.noop,
      onDataLoaded: Metro2.noop,
      onDataLoadEnd: Metro2.noop,
      onDataSaveError: Metro2.noop,
      onFilterRowAccepted: Metro2.noop,
      onFilterRowDeclined: Metro2.noop,
      onCheckClick: Metro2.noop,
      onCheckClickAll: Metro2.noop,
      onCheckDraw: Metro2.noop,
      onViewSave: Metro2.noop,
      onViewGet: Metro2.noop,
      onViewCreated: Metro2.noop,
      onTableCreate: Metro2.noop,
      onSkip: Metro2.noop,
      onDrawHead: Metro2.noop,
      onDrawFoot: Metro2.noop,
      onDrawBody: Metro2.noop,
      onInspectorOpen: Metro2.noop,
      onInspectorClose: Metro2.noop,
      onFieldShow: Metro2.noop,
      onFieldHide: Metro2.noop,
      onFieldToggle: Metro2.noop,
      onFieldMove: Metro2.noop,
      onSort: Metro2.noop,
      onPageChange: Metro2.noop,
      onRowClick: Metro2.noop,
      onRowDblClick: Metro2.noop,
      onCellClick: Metro2.noop,
      onCellDblClick: Metro2.noop
    };
    Metro2.tableSetup = (options) => {
      TableDefaultConfig = $7.extend({}, TableDefaultConfig, options);
    };
    if (typeof globalThis.metroTableSetup !== "undefined") {
      Metro2.tableSetup(globalThis.metroTableSetup);
    }
    Metro2.Component("table", {
      init: function(options, elem) {
        this._super(elem, options, TableDefaultConfig, {
          currentPage: 1,
          pagesCount: 1,
          searchString: "",
          data: null,
          activity: null,
          loadActivity: null,
          busy: false,
          filters: [],
          wrapperInfo: null,
          wrapperSearch: null,
          wrapperRows: null,
          wrapperPagination: null,
          wrapperSkip: null,
          filterIndex: null,
          filtersIndexes: [],
          component: null,
          inspector: null,
          view: {},
          viewDefault: {},
          input_interval: null,
          searchFields: [],
          id: null,
          sort: {
            dir: "asc",
            colIndex: 0
          },
          service: [],
          heads: [],
          items: [],
          foots: [],
          filteredItems: [],
          currentSlice: [],
          index: {}
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        const id = Hooks.useId(this.elem);
        let table_container;
        if (!element2.id()) {
          console.warn("To use all table component features, please set an ID for the table element!");
          element2.id(id);
        }
        if (Metro2.utils.isValue(o2.searchFields)) {
          this.searchFields = o2.searchFields.toArray();
        }
        if (Metro2.utils.isValue(o2.head)) {
          const _head = o2.head;
          o2.head = Metro2.utils.isObject(o2.head);
          if (!o2.head) {
            console.warn(`Head ${_head} defined but not exists!`);
            o2.head = null;
          }
        }
        if (Metro2.utils.isValue(o2.body)) {
          const _body = o2.body;
          o2.body = Metro2.utils.isObject(o2.body);
          if (!o2.body) {
            console.warn(`Body ${_body} defined but not exists!`);
            o2.body = null;
          }
        }
        if (o2.static === true) {
          o2.showPagination = false;
          o2.showRowsSteps = false;
          o2.showSearch = false;
          o2.showTableInfo = false;
          o2.showSkip = false;
          o2.rows = -1;
        }
        const table_component = $7("<div>").addClass("table-component");
        table_component.insertBefore(element2);
        table_container = $7("<div>").addClass("table-container").addClass(o2.clsTableContainer).appendTo(table_component);
        element2.appendTo(table_container);
        if (o2.horizontalScroll === true) {
          table_container.addClass("horizontal-scroll");
        }
        if (!Metro2.utils.isNull(o2.horizontalScrollStop) && Metro2.utils.mediaExist(o2.horizontalScrollStop)) {
          table_container.removeClass("horizontal-scroll");
        }
        table_component.addClass(o2.clsComponent);
        this.activity = $7("<div>").addClass("table-progress").appendTo(table_component);
        const activity = $7("<div>").appendTo(this.activity);
        Metro2.makePlugin(activity, "activity", {
          type: o2.activityType,
          style: o2.activityStyle
        });
        if (o2.showActivity !== true) {
          this.activity.css({
            visibility: "hidden"
          });
        }
        this.component = table_component[0];
        if (o2.source !== null) {
          this._fireEvent("data-load", {
            source: o2.source
          });
          const objSource = Metro2.utils.isObject(o2.source);
          if (objSource !== false && $7.isPlainObject(objSource)) {
            this._build(objSource);
          } else {
            this.activity.show(() => {
              fetch(o2.source).then(Metro2.fetch.status).then(Metro2.fetch.json).then((data) => {
                this.activity.hide();
                if (typeof data !== "object") {
                  throw new Error("Data for table is not a object");
                }
                this._fireEvent("data-loaded", {
                  source: o2.source,
                  data
                });
                this._build(data);
              }).catch((error) => {
                this.activity.hide();
                this._fireEvent("data-load-error", {
                  source: o2.source,
                  error
                });
              });
            });
          }
        } else {
          this._build();
        }
      },
      _createIndex: function() {
        const colIndex = this.options.checkColIndex;
        setImmediate(() => {
          this.items.forEach((v5, i3) => {
            this.index[v5[colIndex]] = i3;
          });
        });
      },
      _build: function(data) {
        const element2 = this.element;
        const o2 = this.options;
        let view;
        const id = element2.attr("id");
        let viewPath;
        o2.rows = +o2.rows;
        this.items = [];
        this.heads = [];
        this.foots = [];
        if (Array.isArray(o2.head)) {
          this.heads = o2.head;
        }
        if (Array.isArray(o2.body)) {
          this.items = o2.body;
        }
        if (Metro2.utils.isValue(data)) {
          this._createItemsFromJSON(data);
        } else {
          this._createItemsFromHTML();
        }
        this._createIndex();
        this.view = this._createView();
        this.viewDefault = Metro2.utils.objectClone(this.view);
        viewPath = o2.viewSavePath.replace("$1", id);
        if (o2.viewSaveMode.toLowerCase() === "client") {
          view = Metro2.storage.getItem(viewPath);
          if (Metro2.utils.isValue(view) && Metro2.utils.objectLength(view) === Metro2.utils.objectLength(this.view)) {
            this.view = view;
            this._fireEvent("view-get", {
              source: "client",
              view
            });
          }
          this._final();
        } else {
          fetch(viewPath).then(Metro2.fetch.status).then(Metro2.fetch.json).then((view2) => {
            if (Metro2.utils.isValue(view2) && Metro2.utils.objectLength(view2) === Metro2.utils.objectLength(this.view)) {
              this.view = view2;
              this._fireEvent("view-get", {
                source: "server",
                view: view2
              });
            }
            this._final();
          }).catch((error) => {
            this._final();
            console.warn(`Warning! Error loading view for table ${element2.attr("id")}: ${error}`);
          });
        }
      },
      _final: function() {
        const element2 = this.element;
        const o2 = this.options;
        const id = element2.attr("id");
        this._service();
        this._createStructure();
        this._createInspector();
        this._createEvents();
        this._fireEvent("table-create", {
          element: element2
        });
      },
      _service: function() {
        const o2 = this.options;
        this.service = [
          {
            // Rownum
            ...TABLE_COL_OPTIONS,
            title: o2.rownumTitle,
            clsColumn: `rownum-cell ${o2.rownum !== true ? "d-none" : ""}`,
            cls: `rownum-cell ${o2.rownum !== true ? "d-none" : ""}`,
            type: "rownum"
          },
          {
            // Checkbox
            ...TABLE_COL_OPTIONS,
            title: o2.checkType === "checkbox" ? `<input type='checkbox' data-role='checkbox' class='table-service-check-all' data-style='${o2.checkStyle}'>` : "",
            clsColumn: `check-cell ${o2.check !== true ? "d-none" : ""}`,
            cls: `check-cell ${o2.check !== true ? "d-none" : ""}`,
            type: "rowcheck"
          }
        ];
      },
      _createView: function() {
        const view = {};
        $7.each(this.heads, function(i3) {
          if (Metro2.utils.isValue(this.cls)) {
            this.cls = this.cls.replace("hidden", "");
          }
          if (Metro2.utils.isValue(this.clsColumn)) {
            this.clsColumn = this.clsColumn.replace("hidden", "");
          }
          view[i3] = {
            index: i3,
            "index-view": i3,
            show: !Metro2.utils.isValue(this.show) ? true : this.show,
            size: Metro2.utils.isValue(this.size) ? this.size : ""
          };
        });
        this._fireEvent("view-created", {
          view
        });
        return view;
      },
      _createInspectorItems: function(table) {
        const that = this;
        const o2 = this.options;
        let j5;
        const tds = [];
        let row;
        const cells = this.heads;
        table.html("");
        for (j5 = 0; j5 < cells.length; j5++) {
          tds[j5] = null;
        }
        $7.each(cells, function(i3) {
          row = $7("<tr>");
          row.data("index", i3);
          row.data("index-view", i3);
          $7("<td>").html(
            `<input type='checkbox' data-style='${o2.checkStyle}' data-role='checkbox' name='column_show_check[]' value='${i3}' ${Metro2.utils.bool(that.view[i3].show) ? "checked" : ""}>`
          ).appendTo(row);
          $7("<td>").html(`<div>${this.title}</div>`).appendTo(row);
          $7("<td>").html(
            `<input type='number' data-role='spinner' name='column_size' value='${that.view[i3].size}' data-index='${i3}'>`
          ).appendTo(row);
          $7("<td>").html(
            "<button class='button square js-table-inspector-field-up' type='button'>\u2191</button><button class='button square js-table-inspector-field-down' type='button'>\u2193</button>"
          ).appendTo(row);
          tds[that.view[i3]["index-view"]] = row;
        });
        for (j5 = 0; j5 < cells.length; j5++) {
          tds[j5].appendTo(table);
        }
      },
      _createInspector: function() {
        const o2 = this.options;
        const strings = this.strings;
        const inspector = $7(
          "<div data-role='draggable' data-drag-element='.table-inspector-header' data-drag-area='body'>"
        ).addClass("table-inspector");
        inspector.attr("for", this.element.attr("id"));
        $7(`<div class='table-inspector-header'>${o2.inspectorTitle || strings.label_inspector}</div>`).appendTo(
          inspector
        );
        const table_wrap = $7("<div>").addClass("table-wrap").appendTo(inspector);
        const table = $7("<table>").addClass("table subcompact");
        const tbody = $7("<tbody>").appendTo(table);
        table.appendTo(table_wrap);
        this._createInspectorItems(tbody);
        const actions = $7("<div class='table-inspector-actions'>").appendTo(inspector);
        $7("<button class='button primary js-table-inspector-save' type='button'>").html(strings.label_save).appendTo(actions);
        $7("<button class='button secondary js-table-inspector-reset ml-2 mr-2' type='button'>").html(strings.label_reset).appendTo(actions);
        $7("<button class='button link js-table-inspector-cancel place-right' type='button'>").html(strings.label_cancel).appendTo(actions);
        inspector.data("open", false);
        this.inspector = inspector;
        $7("body").append(inspector);
        this._createInspectorEvents();
      },
      _resetInspector: function() {
        const inspector = this.inspector;
        const table = inspector.find("table tbody");
        this._createInspectorItems(table);
        this._createInspectorEvents();
      },
      _createHeadsFromHTML: function() {
        const that = this;
        const element2 = this.element;
        const head = element2.find("thead");
        if (head.length > 0) {
          $7.each(head.find("tr > *"), function() {
            const item = $7(this);
            let dir;
            let item_class;
            if (item.hasClass("rownum-cell") || item.hasClass("check-cell")) return;
            if (Metro2.utils.isValue(item.data("sort-dir"))) {
              dir = item.data("sort-dir");
            } else {
              if (item.hasClass("sort-asc")) {
                dir = "asc";
              } else if (item.hasClass("sort-desc")) {
                dir = "desc";
              } else {
                dir = void 0;
              }
            }
            item_class = item[0].className.replace("sortable-column", "");
            item_class = item_class.replace("sort-asc", "");
            item_class = item_class.replace("sort-desc", "");
            item_class = item_class.replace("hidden", "");
            const head_item = {
              type: "data",
              title: item.html(),
              name: Metro2.utils.isValue(item.data("name")) ? item.data("name") : item.text().replace(" ", "_"),
              sortable: item.hasClass("sortable-column") || Metro2.utils.isValue(item.data("sortable")) && JSON.parse(item.data("sortable")) === true,
              sortDir: dir,
              format: Metro2.utils.isValue(item.data("format")) ? item.data("format") : "string",
              formatMask: Metro2.utils.isValue(item.data("format-mask")) ? item.data("format-mask") : null,
              clsColumn: Metro2.utils.isValue(item.data("cls-column")) ? item.data("cls-column") : "",
              cls: item_class,
              colspan: item.attr("colspan"),
              size: Metro2.utils.isValue(item.data("size")) ? item.data("size") : "",
              show: !(item.hasClass("hidden") || Metro2.utils.isValue(item.data("show")) && JSON.parse(item.data("show")) === false),
              required: Metro2.utils.isValue(item.data("required")) ? JSON.parse(item.data("required")) === true : false,
              field: Metro2.utils.isValue(item.data("field")) ? item.data("field") : "input",
              fieldType: Metro2.utils.isValue(item.data("field-type")) ? item.data("field-type") : "text",
              validator: Metro2.utils.isValue(item.data("validator")) ? item.data("validator") : null,
              template: Metro2.utils.isValue(item.data("template")) ? item.data("template") : null
            };
            that.heads.push(head_item);
          });
        }
      },
      _createFootsFromHTML: function() {
        const that = this;
        const element2 = this.element;
        const foot = element2.find("tfoot");
        if (foot.length > 0)
          $7.each(foot.find("tr > *"), function() {
            const item = $7(this);
            const foot_item = {
              title: item.html(),
              name: Metro2.utils.isValue(item.data("name")) ? item.data("name") : false,
              cls: item[0].className,
              colspan: item.attr("colspan")
            };
            that.foots.push(foot_item);
          });
      },
      _createItemsFromHTML: function() {
        const that = this;
        const element2 = this.element;
        const body = element2.find("tbody");
        if (body.length > 0)
          $7.each(body.find("tr"), function() {
            const row = $7(this);
            const tr4 = [];
            $7.each(row.children("td"), function() {
              const td = $7(this);
              tr4.push(td.html());
            });
            that.items.push(tr4);
          });
        this._createHeadsFromHTML();
        this._createFootsFromHTML();
      },
      _createItemsFromJSON: function(src) {
        const that = this;
        const source = typeof src === "string" ? JSON.parse(src) : src;
        if (source.header !== void 0) {
          that.heads = source.header;
        } else {
          this._createHeadsFromHTML();
        }
        if (source.data !== void 0) {
          $7.each(source.data, function() {
            const tr4 = [];
            $7.each(this, function() {
              tr4.push(this);
            });
            that.items.push(tr4);
          });
        }
        if (source.footer !== void 0) {
          this.foots = source.footer;
        } else {
          this._createFootsFromHTML();
        }
      },
      _createTableHeader: function() {
        const element2 = this.element;
        const o2 = this.options;
        let head = element2.find("thead");
        let tr4;
        let th;
        const tds = [];
        let j5;
        let cells;
        const view = o2.staticView ? this._createView() : this.view;
        if (head.length === 0) {
          head = $7("<thead>");
          element2.prepend(head);
        }
        head.clear().addClass(o2.clsHead);
        if (o2.caption && head.prev("caption").length === 0) {
          $7("<caption>").html(o2.caption).insertBefore(head);
        }
        if (this.heads.length === 0) {
          return head;
        }
        tr4 = $7("<tr>").addClass(o2.clsHeadRow).appendTo(head);
        $7.each(this.service, function() {
          const classes = [];
          const th2 = $7("<th>");
          if (Metro2.utils.isValue(this.title)) {
            th2.html(this.title);
          }
          if (Metro2.utils.isValue(this.size)) {
            th2.css({ width: this.size });
          }
          if (Metro2.utils.isValue(this.cls)) {
            classes.push(this.cls);
          }
          classes.push(o2.clsHeadCell);
          th2.addClass(classes.join(" "));
          tr4.append(th2);
        });
        cells = this.heads;
        for (j5 = 0; j5 < cells.length; j5++) {
          tds[j5] = null;
        }
        $7.each(cells, function(cell_index) {
          const classes = [];
          const th2 = $7("<th>");
          th2.data("index", cell_index);
          if (Metro2.utils.isValue(this.title)) {
            th2.html(this.title);
          }
          if (Metro2.utils.isValue(this.format)) {
            th2.attr("data-format", this.format);
          }
          if (Metro2.utils.isValue(this.formatMask)) {
            th2.attr("data-format-mask", this.formatMask);
          }
          if (Metro2.utils.isValue(this.name)) {
            th2.attr("data-name", this.name);
          }
          if (Metro2.utils.isValue(this.colspan)) {
            th2.attr("colspan", this.colspan);
          }
          if (Metro2.utils.isValue(this.size)) {
            th2.attr("data-size", this.size);
          }
          if (Metro2.utils.isValue(this.sortable)) {
            th2.attr("data-sortable", this.sortable);
          }
          if (Metro2.utils.isValue(this.sortDir)) {
            th2.attr("data-sort-dir", this.sortDir);
          }
          if (Metro2.utils.isValue(this.clsColumn)) {
            th2.attr("data-cls-column", this.clsColumn);
          }
          if (Metro2.utils.isValue(this.cls)) {
            th2.attr("data-cls", this.cls);
          }
          if (Metro2.utils.isValue(this.show)) {
            th2.attr("data-show", this.show);
          }
          if (Metro2.utils.isValue(this.required)) {
            th2.attr("data-required", this.required);
          }
          if (Metro2.utils.isValue(this.field)) {
            th2.attr("data-field", this.field);
          }
          if (Metro2.utils.isValue(this.fieldType)) {
            th2.attr("data-field-type", this.fieldType);
          }
          if (Metro2.utils.isValue(this.validator)) {
            th2.attr("data-validator", this.validator);
          }
          if (Metro2.utils.isValue(this.template)) {
            th2.attr("data-template", this.template);
          }
          if (Metro2.utils.isValue(view[cell_index].size)) {
            th2.css({ width: view[cell_index].size });
          }
          if (this.sortable === true) {
            classes.push("sortable-column");
            if (Metro2.utils.isValue(this.sortDir)) {
              classes.push(`sort-${this.sortDir}`);
            }
          }
          if (Metro2.utils.isValue(this.cls)) {
            $7.each(this.cls.toArray(), function() {
              classes.push(this);
            });
          }
          if (Metro2.utils.bool(view[cell_index].show) === false) {
            if (classes.indexOf("hidden") === -1) classes.push("hidden");
          }
          classes.push(o2.clsHeadCell);
          if (Metro2.utils.bool(view[cell_index].show)) {
            Metro2.utils.arrayDelete(classes, "hidden");
          }
          th2.addClass(classes.join(" "));
          tds[view[cell_index]["index-view"]] = th2;
        });
        for (j5 = 0; j5 < cells.length; j5++) {
          tds[j5].appendTo(tr4);
        }
        this._fireEvent("draw-head", {
          head
        });
      },
      _createTableBody: function() {
        let body;
        let head;
        const element2 = this.element;
        head = element2.find("thead");
        body = element2.find("tbody");
        if (body.length === 0) {
          body = $7("<tbody>").addClass(this.options.clsBody);
          if (head.length !== 0) {
            body.insertAfter(head);
          } else {
            element2.append(body);
          }
        }
        body.clear();
      },
      _createTableFooter: function() {
        const element2 = this.element;
        const o2 = this.options;
        let foot = element2.find("tfoot");
        let th;
        if (foot.length === 0) {
          foot = $7("<tfoot>").appendTo(element2);
        }
        foot.clear().addClass(o2.clsFooter);
        if (this.foots.length === 0) {
          return;
        }
        const tr4 = $7("<tr>").addClass(o2.clsHeadRow).appendTo(foot);
        $7.each(this.foots, function() {
          th = $7("<th>").appendTo(tr4);
          if (this.title) {
            th.html(this.title);
          }
          if (this.name) {
            th.addClass(`foot-column-name-${this.name}`);
          }
          if (this.cls) {
            th.addClass(this.cls);
          }
          if (Metro2.utils.isValue(this.colspan)) {
            th.attr("colspan", this.colspan);
          }
          th.appendTo(tr4);
        });
        this._fireEvent("draw-foot", {
          foot
        });
      },
      _createTopBlock: function() {
        const element2 = this.element;
        const o2 = this.options;
        const strings = this.strings;
        const top_block = $7("<div>").addClass("table-top").addClass(o2.clsTableTop).insertBefore(element2.parent());
        let search_block;
        let rows_block;
        search_block = Metro2.utils.isValue(this.wrapperSearch) ? this.wrapperSearch : $7("<div>").addClass("table-search-block").addClass(o2.clsSearch).appendTo(top_block);
        search_block.addClass(o2.clsSearch);
        const search_input = $7("<input>").attr("type", "text").attr("placeholder", o2.tableSearchPlaceholder).appendTo(search_block);
        Metro2.makePlugin(search_input, "input", {
          prepend: o2.tableSearchTitle || strings.label_search
        });
        if (o2.showSearch !== true) {
          search_block.hide();
        }
        rows_block = Metro2.utils.isValue(this.wrapperRows) ? this.wrapperRows : $7("<div>").addClass("table-rows-block").appendTo(top_block);
        rows_block.addClass(o2.clsRowsCount);
        const rows_select = $7("<select>").appendTo(rows_block);
        $7.each(o2.rowsSteps.toArray(), function() {
          const val = Number.parseInt(this);
          const option = $7("<option>").attr("value", val).text(val === -1 ? o2.allRecordsTitle || strings.label_all : val).appendTo(rows_select);
          if (val === Number.parseInt(o2.rows)) {
            option.attr("selected", "selected");
          }
        });
        Metro2.makePlugin(rows_select, "select", {
          filter: false,
          prepend: o2.tableRowsCountTitle || strings.label_rows_count,
          onChange: (val) => {
            const _val = Number.parseInt(val);
            if (_val === o2.rows) {
              return;
            }
            o2.rows = val;
            this.currentPage = 1;
            this._draw();
            this._fireEvent("rows-count-change", {
              val
            });
          }
        });
        if (o2.showInspectorButton) {
          $7("<button>").addClass("button inspector-button").attr("type", "button").html(o2.inspectorButtonIcon).insertAfter(rows_block);
        }
        if (o2.showRowsSteps !== true) {
          rows_block.hide();
        }
        return top_block;
      },
      _createBottomBlock: function() {
        const element2 = this.element;
        const o2 = this.options;
        const strings = this.strings;
        const bottom_block = $7("<div>").addClass("table-bottom").addClass(o2.clsTableBottom).insertAfter(element2.parent());
        let info3;
        let pagination;
        let skip;
        info3 = Metro2.utils.isValue(this.wrapperInfo) ? this.wrapperInfo : $7("<div>").addClass("table-info").appendTo(bottom_block);
        info3.addClass(o2.clsTableInfo);
        if (o2.showTableInfo !== true) {
          info3.hide();
        }
        pagination = Metro2.utils.isValue(this.wrapperPagination) ? this.wrapperPagination : $7("<div>").addClass("table-pagination").appendTo(bottom_block);
        pagination.addClass(o2.clsTablePagination);
        if (o2.showPagination !== true) {
          pagination.hide();
        }
        skip = Metro2.utils.isValue(this.wrapperSkip) ? this.wrapperSkip : $7("<div>").appendTo(bottom_block);
        skip.addClass("table-skip").addClass(o2.clsTableSkip);
        $7(`<input type='text' data-role='input' placeholder="${strings.label_enter_page}">`).addClass("table-skip-input").addClass(o2.clsTableSkipInput).appendTo(skip);
        $7("<button>").addClass("button table-skip-button").addClass(o2.clsTableSkipButton).html(o2.tableSkipTitle || strings.label_goto_page).appendTo(skip);
        if (o2.showSkip !== true) {
          skip.hide();
        }
        return bottom_block;
      },
      _createStructure: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        let columns;
        const w_search = $7(o2.searchWrapper);
        const w_info = $7(o2.infoWrapper);
        const w_rows = $7(o2.rowsWrapper);
        const w_paging = $7(o2.paginationWrapper);
        const w_skip = $7(o2.skipWrapper);
        if (w_search.length > 0) {
          this.wrapperSearch = w_search;
        }
        if (w_info.length > 0) {
          this.wrapperInfo = w_info;
        }
        if (w_rows.length > 0) {
          this.wrapperRows = w_rows;
        }
        if (w_paging.length > 0) {
          this.wrapperPagination = w_paging;
        }
        if (w_skip.length > 0) {
          this.wrapperSkip = w_skip;
        }
        element2.addClass(o2.clsTable);
        this._createTableHeader();
        this._createTableBody();
        this._createTableFooter();
        this._createTopBlock();
        this._createBottomBlock();
        let need_sort = false;
        if (this.heads.length > 0)
          $7.each(this.heads, function(i3) {
            if (!need_sort && ["asc", "desc"].indexOf(this.sortDir) > -1) {
              need_sort = true;
              that.sort.colIndex = i3;
              that.sort.dir = this.sortDir;
            }
          });
        if (need_sort) {
          columns = element2.find("thead th");
          this._resetSortClass(columns);
          $7(columns.get(this.sort.colIndex + that.service.length)).addClass(`sort-${this.sort.dir}`);
          this.sorting();
        }
        let filter_func;
        if (Metro2.utils.isValue(o2.filters) && typeof o2.filters === "string") {
          $7.each(o2.filters.toArray(), function() {
            filter_func = Metro2.utils.isFunc(this);
            if (filter_func !== false) {
              that.filtersIndexes.push(that.addFilter(filter_func));
            }
          });
        }
        this.currentPage = 1;
        this._draw();
      },
      _resetSortClass: (el) => {
        $7(el).removeClass("sort-asc sort-desc");
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const component = element2.closest(".table-component");
        const table_container = component.find(".table-container");
        const search = component.find(".table-search-block input");
        const skip_button = o2.skipWrapper ? $7(o2.skipWrapper).find(".table-skip-button") : component.find(".table-skip-button");
        const skip_input = o2.skipWrapper ? $7(o2.skipWrapper).find(".table-skip-input") : component.find(".table-skip-input");
        let customSearch;
        const id = element2.attr("id");
        const inspectorButton = component.find(".inspector-button");
        inspectorButton.on(Metro2.events.click, () => {
          that.toggleInspector();
        });
        skip_button.on(Metro2.events.click, () => {
          const skipTo = Number.parseInt(skip_input.val().trim());
          if (isNaN(skipTo) || skipTo <= 0 || skipTo > that.pagesCount) {
            skip_input.val("");
            return false;
          }
          skip_input.val("");
          that._fireEvent("skip", {
            skipTo,
            skipFrom: that.currentPage
          });
          that.page(skipTo);
        });
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            if (o2.horizontalScroll === true) {
              if (!Metro2.utils.isNull(o2.horizontalScrollStop) && Metro2.utils.mediaExist(o2.horizontalScrollStop)) {
                table_container.removeClass("horizontal-scroll");
              } else {
                table_container.addClass("horizontal-scroll");
              }
            }
          },
          { ns: this.id }
        );
        element2.on(Metro2.events.click, ".sortable-column", function() {
          if (o2.muteTable === true) element2.addClass("disabled");
          if (that.busy) {
            return false;
          }
          that.busy = true;
          const col = $7(this);
          that.activity.show(() => {
            setImmediate(() => {
              that.currentPage = 1;
              that.sort.colIndex = col.data("index");
              if (!col.hasClass("sort-asc") && !col.hasClass("sort-desc")) {
                that.sort.dir = o2.sortDir;
              } else {
                if (col.hasClass("sort-asc")) {
                  that.sort.dir = "desc";
                } else {
                  that.sort.dir = "asc";
                }
              }
              that._resetSortClass(element2.find(".sortable-column"));
              col.addClass(`sort-${that.sort.dir}`);
              that.sorting();
              that._draw(() => {
                that.busy = false;
                if (o2.muteTable === true) element2.removeClass("disabled");
              });
              that._fireEvent("sort", {
                col: col[0],
                dir: that.sort.dir
              });
            });
          });
        });
        element2.on(Metro2.events.click, ".table-service-check", function() {
          const check = $7(this);
          const status = check.is(":checked");
          const val = `${check.val()}`;
          const store_key = o2.checkStoreKey.replace("$1", id);
          const storage = Metro2.storage;
          let data = storage.getItem(store_key);
          const is_radio = check.attr("type") === "radio";
          if (is_radio) {
            data = [];
          }
          if (status) {
            if (!Metro2.utils.isValue(data)) {
              data = [val];
            } else {
              if (Array(data).indexOf(val) === -1) {
                data.push(val);
              }
            }
          } else {
            if (Metro2.utils.isValue(data)) {
              Metro2.utils.arrayDelete(data, val);
            } else {
              data = [];
            }
          }
          storage.setItem(store_key, data);
          that._fireEvent("check-click", {
            check: this,
            status,
            data
          });
        });
        element2.on(Metro2.events.click, ".table-service-check-all", function() {
          const checked = $7(this).is(":checked");
          const store_key = o2.checkStoreKey.replace("$1", id);
          const storage = Metro2.storage;
          let data = [];
          let stored_keys;
          if (o2.useCurrentSlice === true) {
            stored_keys = storage.getItem(store_key, []);
            if (checked) {
              $7.each(that.currentSlice, function() {
                if (stored_keys.indexOf(`${this[o2.checkColIndex]}`) === -1) {
                  stored_keys.push(`${this[o2.checkColIndex]}`);
                }
              });
            } else {
              $7.each(that.currentSlice, function() {
                const key = `${this[o2.checkColIndex]}`;
                if (stored_keys.indexOf(key) !== -1) {
                  Metro2.utils.arrayDelete(stored_keys, key);
                }
              });
            }
            data = stored_keys;
          } else {
            if (checked) {
              $7.each(that.filteredItems, function() {
                if (data.indexOf(this[o2.checkColIndex]) !== -1) return;
                data.push(`${this[o2.checkColIndex]}`);
              });
            } else {
              data = [];
            }
          }
          storage.setItem(store_key, data);
          that._draw();
          that._fireEvent("check-click-all", {
            check: this,
            status: checked,
            data
          });
        });
        element2.on(Metro2.events.click, "tbody > tr > td", function() {
          that._fireEvent(
            "cell-click",
            {
              cell: this
            },
            false,
            false,
            this
          );
        });
        element2.on(Metro2.events.dblclick, "tbody > tr > td", function() {
          that._fireEvent(
            "cell-dbl-click",
            {
              cell: this
            },
            false,
            false,
            this
          );
        });
        element2.on(Metro2.events.click, "tbody > tr", function() {
          that._fireEvent(
            "row-click",
            {
              row: this
            },
            false,
            false,
            this
          );
        });
        element2.on(Metro2.events.dblclick, "tbody > tr", function() {
          that._fireEvent(
            "row-dbl-click",
            {
              row: this
            },
            false,
            false,
            this
          );
        });
        let _search = function() {
          that.searchString = this.value.trim().toLowerCase();
          that.currentPage = 1;
          that._draw();
        };
        _search = Hooks.useDebounce(_search, o2.searchThreshold);
        search.on(Metro2.events.inputchange, _search);
        if (Metro2.utils.isValue(this.wrapperSearch)) {
          customSearch = this.wrapperSearch.find("input");
          if (customSearch.length > 0) {
            customSearch.on(Metro2.events.inputchange, _search);
          }
        }
        function pageLinkClick(l2) {
          const link = $7(l2);
          const item = link.parent();
          if (that.filteredItems.length === 0) {
            return;
          }
          if (item.hasClass("active")) {
            return;
          }
          if (item.hasClass("service")) {
            if (link.data("page") === "prev") {
              that.currentPage--;
              if (that.currentPage === 0) {
                that.currentPage = 1;
              }
            } else {
              that.currentPage++;
              if (that.currentPage > that.pagesCount) {
                that.currentPage = that.pagesCount;
              }
            }
          } else {
            that.currentPage = +link.data("page");
          }
          that._draw();
          that._fireEvent("page-change", {
            page: that.currentPage
          });
        }
        component.on(Metro2.events.click, ".pagination .page-link", function() {
          pageLinkClick(this);
        });
        if (Metro2.utils.isValue(this.wrapperPagination)) {
          this.wrapperPagination.on(Metro2.events.click, ".pagination .page-link", function() {
            pageLinkClick(this);
          });
        }
        this._createInspectorEvents();
        element2.on(Metro2.events.click, ".js-table-crud-button", () => {
        });
      },
      _createInspectorEvents: function() {
        const that = this;
        const inspector = this.inspector;
        this._removeInspectorEvents();
        inspector.on(Metro2.events.click, ".js-table-inspector-field-up", function() {
          const button = $7(this);
          const tr4 = button.closest("tr");
          const tr_prev = tr4.prev("tr");
          const index = tr4.data("index");
          let index_view;
          if (tr_prev.length === 0) {
            return;
          }
          tr4.insertBefore(tr_prev);
          tr4.addClass("flash");
          setTimeout(() => {
            tr4.removeClass("flash");
          }, 1e3);
          index_view = tr4.index();
          tr4.data("index-view", index_view);
          that.view[index]["index-view"] = index_view;
          $7.each(tr4.nextAll(), function() {
            const t = $7(this);
            index_view++;
            t.data("index-view", index_view);
            that.view[t.data("index")]["index-view"] = index_view;
          });
          that._fireEvent("field-move", {
            field: that.heads[index],
            index,
            direction: "up"
          });
          that._createTableHeader();
          that._draw();
        });
        inspector.on(Metro2.events.click, ".js-table-inspector-field-down", function() {
          const button = $7(this);
          const tr4 = button.closest("tr");
          const tr_next = tr4.next("tr");
          const index = tr4.data("index");
          let index_view;
          if (tr_next.length === 0) {
            return;
          }
          tr4.insertAfter(tr_next);
          tr4.addClass("flash");
          setTimeout(() => {
            tr4.removeClass("flash");
          }, 1e3);
          index_view = tr4.index();
          tr4.data("index-view", index_view);
          that.view[index]["index-view"] = index_view;
          $7.each(tr4.prevAll(), function() {
            const t = $7(this);
            index_view--;
            t.data("index-view", index_view);
            that.view[t.data("index")]["index-view"] = index_view;
          });
          that._fireEvent("field-move", {
            field: that.heads[index],
            index,
            direction: "down"
          });
          that._createTableHeader();
          that._draw();
        });
        inspector.on(Metro2.events.click, "input[type=checkbox]", function() {
          const check = $7(this);
          const status = check.is(":checked");
          const index = check.val();
          const op = ["cls", "clsColumn"];
          if (status) {
            $7.each(op, function() {
              const a2 = Metro2.utils.isValue(that.heads[index][this]) ? that.heads[index][this].toArray(" ") : [];
              Metro2.utils.arrayDelete(a2, "hidden");
              that.heads[index][this] = a2.join(" ");
              that.view[index].show = true;
            });
            that._fireEvent("field-show", {
              field: that.heads[index],
              index
            });
          } else {
            $7.each(op, function() {
              const a2 = Metro2.utils.isValue(that.heads[index][this]) ? that.heads[index][this].toArray(" ") : [];
              if (a2.indexOf("hidden") === -1) {
                a2.push("hidden");
              }
              that.heads[index][this] = a2.join(" ");
              that.view[index].show = false;
            });
            that._fireEvent("field-hide", {
              field: that.heads[index],
              index
            });
          }
          that._fireEvent("field-toggle", {
            field: that.heads[index],
            index,
            status
          });
          that._createTableHeader();
          that._draw();
        });
        inspector.find("input[type=number]").on(Metro2.events.inputchange, function() {
          const input = $7(this);
          const index = input.attr("data-index");
          const val = Number.parseInt(input.val());
          that.view[index].size = val === 0 ? "" : val;
          that._createTableHeader();
        });
        inspector.on(Metro2.events.click, ".js-table-inspector-save", () => {
          that._saveTableView();
          that.openInspector(false);
        });
        inspector.on(Metro2.events.click, ".js-table-inspector-cancel", () => {
          that.openInspector(false);
        });
        inspector.on(Metro2.events.click, ".js-table-inspector-reset", () => {
          that.resetView();
        });
      },
      _removeInspectorEvents: function() {
        const inspector = this.inspector;
        inspector.off(Metro2.events.click, ".js-table-inspector-field-up");
        inspector.off(Metro2.events.click, ".js-table-inspector-field-down");
        inspector.off(Metro2.events.click, "input[type=checkbox]");
        inspector.off(Metro2.events.click, ".js-table-inspector-save");
        inspector.off(Metro2.events.click, ".js-table-inspector-cancel");
        inspector.off(Metro2.events.click, ".js-table-inspector-reset");
        inspector.off(Metro2.events.inputchange, "input[type=number]");
      },
      _saveTableView: function() {
        const element2 = this.element;
        const o2 = this.options;
        const view = this.view;
        const id = element2.attr("id");
        const viewPath = o2.viewSavePath.replace("$1", id);
        const storage = Metro2.storage;
        if (o2.viewSaveMode.toLowerCase() === "client") {
          storage.setItem(viewPath, view);
          this._fireEvent("view-save", {
            target: "client",
            path: o2.viewSavePath,
            view
          });
        } else {
          const post_data = {
            id: element2.attr("id"),
            view
          };
          fetch(viewPath, {
            method: "POST",
            body: JSON.stringify(post_data),
            header: {
              "Content-type": "application/json;charset=utf-8"
            }
          }).then(Metro2.fetch.status).then(Metro2.fetch.text).then((data) => {
            this._fireEvent("view-save", {
              target: "server",
              path: o2.viewSavePath,
              view,
              post_data,
              response: data
            });
          }).catch((error) => {
            this._fireEvent("data-save-error", {
              source: o2.viewSavePath,
              error,
              post_data
            });
          });
        }
      },
      _info: function(start, stop, length) {
        const element2 = this.element;
        const o2 = this.options;
        const strings = this.strings;
        const component = element2.closest(".table-component");
        const info3 = Metro2.utils.isValue(this.wrapperInfo) ? this.wrapperInfo : component.find(".table-info");
        let text;
        let _start = start;
        let _stop = stop;
        let _length = length;
        if (info3.length === 0) {
          return;
        }
        if (_stop > _length) {
          _stop = _length;
        }
        if (this.items.length === 0) {
          _start = _stop = _length = 0;
        }
        text = o2.tableInfoTitle || strings.label_table_info;
        text = text.replace("$1", _start);
        text = text.replace("$2", _stop);
        text = text.replace("$3", _length);
        info3.html(text);
      },
      _paging: function(length) {
        const element2 = this.element;
        const o2 = this.options;
        const strings = this.strings;
        const component = element2.closest(".table-component");
        this.pagesCount = Math.ceil(length / o2.rows);
        Metro2.pagination({
          length,
          rows: o2.rows,
          current: this.currentPage,
          target: Metro2.utils.isValue(this.wrapperPagination) ? this.wrapperPagination : component.find(".table-pagination"),
          claPagination: o2.clsPagination,
          prevTitle: o2.paginationPrevTitle || strings.label_prev,
          nextTitle: o2.paginationNextTitle || strings.label_next,
          distance: o2.paginationDistance,
          islandSize: o2.paginationIslandSize,
          shortTrack: o2.paginationShortTrack
        });
      },
      _filter: function() {
        const o2 = this.options;
        let items;
        if (Metro2.utils.isValue(this.searchString) && this.searchString.length >= o2.searchMinLength || this.filters.length > 0) {
          items = this.items.filter((row) => {
            let row_data = "";
            let result;
            let i3;
            let j5 = 0;
            if (this.filters.length > 0) {
              result = o2.filtersOperator.toLowerCase() === "and";
              for (i3 = 0; i3 < this.filters.length; i3++) {
                if (Metro2.utils.isNull(this.filters[i3])) continue;
                j5++;
                result = o2.filtersOperator.toLowerCase() === "and" ? result && Metro2.utils.exec(this.filters[i3], [row, this.heads]) : result || Metro2.utils.exec(this.filters[i3], [row, this.heads]);
              }
              if (j5 === 0) result = true;
            } else {
              result = true;
            }
            if (this.searchFields.length > 0) {
              $7.each(this.heads, (i4, v5) => {
                if (this.searchFields.indexOf(v5.name) > -1) {
                  row_data += `\u2022${row[i4]}`;
                }
              });
            } else {
              row_data = row.join("\u2022");
            }
            row_data = row_data.replace(/[\n\r]+|[\s]{2,}/g, " ").trim().toLowerCase();
            const search_result = Metro2.utils.isValue(this.searchString) && this.searchString.length >= o2.searchMinLength ? ~row_data.indexOf(this.searchString) : true;
            result = result && search_result;
            if (result) {
              this._fireEvent("filter-row-accepted", {
                row
              });
            } else {
              this._fireEvent("filter-row-declined", {
                row
              });
            }
            return result;
          });
        } else {
          items = this.items;
        }
        this._fireEvent("search", {
          search: this.searchString,
          items
        });
        this.filteredItems = items;
        return items;
      },
      _draw: function(cb) {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const strings = this.strings;
        const body = element2.find("tbody");
        let i3;
        let j5;
        let tr4;
        let td;
        let check;
        let cells;
        let tds;
        let is_even_row;
        const rows = Number.parseInt(o2.rows);
        const start = rows === -1 ? 0 : rows * (+this.currentPage - 1);
        const stop = rows === -1 ? this.items.length - 1 : +start + rows - 1;
        let items;
        let checkedItems = [];
        const stored_keys = Metro2.storage.getItem(o2.checkStoreKey.replace("$1", element2.attr("id")));
        const view = o2.staticView ? this.viewDefault : this.view;
        body.html("");
        if (!this.heads.length) {
          console.warn(`Heads is not defined for table ID ${element2.attr("id")}`);
          return;
        }
        items = this._filter();
        this.currentSlice = items.slice(start, stop + 1);
        checkedItems = [];
        if (items.length > 0) {
          for (i3 = start; i3 <= stop; i3++) {
            cells = items[i3];
            tds = [];
            if (!Metro2.utils.isValue(cells)) {
              continue;
            }
            tr4 = $7("<tr>").addClass(o2.clsBodyRow);
            tr4.data("original", cells);
            is_even_row = i3 % 2 === 0;
            td = $7("<td>").attr("data-label", "#").attr("aria-label", "#").html(i3 + 1);
            if (that.service[0].clsColumn !== void 0) {
              td.addClass(that.service[0].clsColumn);
            }
            td.appendTo(tr4);
            td = $7("<td>").attr("data-label", "CHK").attr("aria-label", "CHK");
            if (o2.checkType === "checkbox") {
              check = $7(
                `<input type='checkbox' data-style='${o2.checkStyle}' data-role='checkbox' name='${Metro2.utils.isValue(o2.checkName) ? o2.checkName : "table_row_check"}[]' value='${items[i3][o2.checkColIndex]}'>`
              );
            } else {
              check = $7(
                `<input type='radio' data-style='${o2.checkStyle}' data-role='radio' name='${Metro2.utils.isValue(o2.checkName) ? o2.checkName : "table_row_check"}' value='${items[i3][o2.checkColIndex]}'>`
              );
            }
            if (Metro2.utils.isValue(stored_keys) && Array.isArray(stored_keys) && stored_keys.indexOf(`${items[i3][o2.checkColIndex]}`) > -1) {
              check.prop("checked", true);
              checkedItems.push(cells);
            }
            check.addClass("table-service-check");
            this._fireEvent("check-draw", {
              check
            });
            check.appendTo(td);
            if (that.service[1].clsColumn !== void 0) {
              td.addClass(that.service[1].clsColumn);
            }
            td.appendTo(tr4);
            for (j5 = 0; j5 < cells.length; j5++) {
              tds[j5] = null;
            }
            $7.each(cells, function(cell_index) {
              let val = this;
              const td2 = $7("<td>").attr("data-label", that.heads[cell_index].title).attr("aria-label", that.heads[cell_index].title);
              if (Metro2.utils.isValue(that.heads[cell_index].template)) {
                val = that.heads[cell_index].template.replace(/%VAL%/g, val);
              }
              td2.html(val);
              td2.addClass(o2.clsBodyCell);
              if (Metro2.utils.isValue(that.heads[cell_index].clsColumn)) {
                td2.addClass(that.heads[cell_index].clsColumn);
              }
              if (Metro2.utils.bool(view[cell_index].show) === false) {
                td2.addClass("hidden");
              }
              if (Metro2.utils.bool(view[cell_index].show)) {
                td2.removeClass("hidden");
              }
              td2.data("original", this);
              tds[view[cell_index]["index-view"]] = td2;
              that._fireEvent("draw-cell", {
                td: td2,
                val,
                cellIndex: cell_index,
                head: that.heads[cell_index],
                items: cells
              });
              if (o2.cellWrapper === true) {
                val = $7("<div>").addClass("data-wrapper").addClass(o2.clsCellWrapper).html(td2.html());
                td2.html("").append(val);
              }
            });
            for (j5 = 0; j5 < cells.length; j5++) {
              tds[j5].appendTo(tr4);
              that._fireEvent("append-cell", {
                td: tds[j5],
                tr: tr4,
                index: j5
              });
            }
            that._fireEvent("draw-row", {
              tr: tr4,
              view: that.view,
              heads: that.heads,
              items: cells
            });
            tr4.addClass(o2.clsRow).addClass(is_even_row ? o2.clsEvenRow : o2.clsOddRow).appendTo(body);
            that._fireEvent("append-row", {
              tr: tr4
            });
          }
          $7(this.component).find(".table-service-check-all input").prop("checked", checkedItems.length);
        } else {
          j5 = 0;
          $7.each(view, function() {
            if (this.show) j5++;
          });
          if (o2.check === true) {
            j5++;
          }
          if (o2.rownum === true) {
            j5++;
          }
          tr4 = $7("<tr>").addClass(o2.clsBodyRow).appendTo(body);
          td = $7("<td>").attr("colspan", j5).addClass("text-center").html(
            $7("<span>").addClass(o2.clsEmptyTableTitle).html(o2.emptyTableTitle || strings.label_empty)
          );
          td.appendTo(tr4);
        }
        this._info(start + 1, stop + 1, items.length);
        this._paging(items.length);
        if (this.activity) this.activity.hide();
        this._fireEvent("draw");
        if (cb !== void 0) {
          Metro2.utils.exec(cb, null, element2[0]);
        }
        this._fireEvent("draw-body", {
          body
        });
      },
      _getItemContent: function(row) {
        const o2 = this.options;
        const locale = this.locale;
        let result;
        const col = row[this.sort.colIndex];
        const format = this.heads[this.sort.colIndex].format;
        const formatMask = !Metro2.utils.isNull(this.heads) && !Metro2.utils.isNull(this.heads[this.sort.colIndex]) && Metro2.utils.isValue(this.heads[this.sort.colIndex].formatMask) ? this.heads[this.sort.colIndex].formatMask : "%Y-%m-%d";
        const thousandSeparator = this.heads?.[this.sort.colIndex] && this.heads[this.sort.colIndex].thousandSeparator ? this.heads[this.sort.colIndex].thousandSeparator : o2.thousandSeparator;
        const decimalSeparator = this.heads?.[this.sort.colIndex] && this.heads[this.sort.colIndex].decimalSeparator ? this.heads[this.sort.colIndex].decimalSeparator : o2.decimalSeparator;
        result = `${col}`.toLowerCase().replace(/[\n\r]+|[\s]{2,}/g, " ").trim();
        if (Metro2.utils.isValue(result) && Metro2.utils.isValue(format)) {
          if (["number", "int", "float", "money"].indexOf(format) !== -1) {
            result = Metro2.utils.parseNumber(result, thousandSeparator, decimalSeparator);
          }
          switch (format) {
            case "date":
              result = formatMask ? Datetime.from(result, formatMask, locale) : datetime(result);
              break;
            case "number":
              result = +result;
              break;
            case "int":
              result = Number.parseInt(result);
              break;
            case "float":
              result = Number.parseFloat(result);
              break;
            case "money":
              result = Metro2.utils.parseMoney(result);
              break;
            case "card":
              result = Metro2.utils.parseCard(result);
              break;
            case "phone":
              result = Metro2.utils.parsePhone(result);
              break;
          }
        }
        return result;
      },
      addItem: function(item, redraw) {
        if (!Array.isArray(item)) {
          console.warn("Item is not an array and can't be added");
          return this;
        }
        this.items.push(item);
        if (redraw !== false) this.draw();
      },
      addItems: function(items, redraw) {
        if (!Array.isArray(items)) {
          console.warn("Items is not an array and can't be added");
          return this;
        }
        for (const item of items) {
          if (Array.isArray(item)) this.items.push(item, false);
        }
        this.draw();
        if (redraw !== false) this.draw();
      },
      updateItem: function(key, field, value) {
        const item = this.items[this.index[key]];
        let fieldIndex = null;
        if (Metro2.utils.isNull(item)) {
          console.warn("Item is undefined for update");
          return this;
        }
        if (isNaN(field)) {
          this.heads.forEach((v5, i3) => {
            if (v5.name === field) {
              fieldIndex = i3;
            }
          });
        }
        if (Metro2.utils.isNull(fieldIndex)) {
          console.warn(`Item is undefined for update. Field ${field} not found in data structure`);
          return this;
        }
        item[fieldIndex] = value;
        this.items[this.index[key]] = item;
        return this;
      },
      getItem: function(key) {
        return this.items[this.index[key]];
      },
      deleteItem: function(fieldIndex, value) {
        let i3;
        const deleteIndexes = [];
        const is_func = Metro2.utils.isFunc(value);
        for (i3 = 0; i3 < this.items.length; i3++) {
          if (is_func) {
            if (Metro2.utils.exec(value, [this.items[i3][fieldIndex]])) {
              deleteIndexes.push(i3);
            }
          } else {
            if (this.items[i3][fieldIndex] === value) {
              deleteIndexes.push(i3);
            }
          }
        }
        this.items = Metro2.utils.arrayDeleteByMultipleKeys(this.items, deleteIndexes);
        return this;
      },
      deleteItemByName: function(fieldName, value) {
        let i3;
        let fieldIndex;
        const deleteIndexes = [];
        const is_func = Metro2.utils.isFunc(value);
        for (i3 = 0; i3 < this.heads.length; i3++) {
          if (this.heads[i3].name === fieldName) {
            fieldIndex = i3;
            break;
          }
        }
        for (i3 = 0; i3 < this.items.length; i3++) {
          if (is_func) {
            if (Metro2.utils.exec(value, [this.items[i3][fieldIndex]])) {
              deleteIndexes.push(i3);
            }
          } else {
            if (this.items[i3][fieldIndex] === value) {
              deleteIndexes.push(i3);
            }
          }
        }
        this.items = Metro2.utils.arrayDeleteByMultipleKeys(this.items, deleteIndexes);
        return this;
      },
      draw: function() {
        this._draw();
        return this;
      },
      sorting: function(dir) {
        if (Metro2.utils.isValue(dir)) {
          this.sort.dir = dir;
        }
        this._fireEvent("sort-start", {
          items: this.items
        });
        this.items.sort((a2, b5) => {
          const c1 = this._getItemContent(a2);
          const c22 = this._getItemContent(b5);
          let result = 0;
          if (c1 < c22) {
            result = this.sort.dir === "asc" ? -1 : 1;
          }
          if (c1 > c22) {
            result = this.sort.dir === "asc" ? 1 : -1;
          }
          if (result !== 0) {
            this._fireEvent("sort-item-switch", {
              a: a2,
              b: b5,
              result
            });
          }
          return result;
        });
        this._fireEvent("sort-stop", {
          items: this.items
        });
        return this;
      },
      search: function(val) {
        this.searchString = val.trim().toLowerCase();
        this.currentPage = 1;
        this._draw();
        return this;
      },
      _rebuild: function(review) {
        const that = this;
        const element2 = this.element;
        let need_sort = false;
        let sortable_columns;
        this._createIndex();
        if (review === true) {
          this.view = this._createView();
        }
        this._createTableHeader();
        this._createTableBody();
        this._createTableFooter();
        if (this.heads.length > 0)
          $7.each(this.heads, function(i3) {
            if (!need_sort && ["asc", "desc"].indexOf(this.sortDir) > -1) {
              need_sort = true;
              that.sort.colIndex = i3;
              that.sort.dir = this.sortDir;
            }
          });
        if (need_sort) {
          sortable_columns = element2.find(".sortable-column");
          this._resetSortClass(sortable_columns);
          $7(sortable_columns.get(that.sort.colIndex)).addClass(`sort-${that.sort.dir}`);
          this.sorting();
        }
        that.currentPage = 1;
        that._draw();
      },
      setHeads: function(data) {
        this.heads = data;
        return this;
      },
      setHeadItem: function(name2, data) {
        let i3;
        let index;
        for (i3 = 0; i3 < this.heads.length; i3++) {
          if (this.heads[i3].name === name2) {
            index = i3;
            break;
          }
        }
        this.heads[index] = data;
        return this;
      },
      setItems: function(data) {
        this.items = data;
        return this;
      },
      setData: function(data) {
        const o2 = this.options;
        this.activity.show(() => {
          this.items = [];
          this.heads = [];
          this.foots = [];
          if (Array.isArray(o2.head)) {
            this.heads = o2.head;
          }
          if (Array.isArray(o2.body)) {
            this.items = o2.body;
          }
          this._createItemsFromJSON(data);
          this._rebuild(true);
          this.activity.hide();
        });
        return this;
      },
      loadData: function(source, review = true) {
        const element2 = this.element;
        const o2 = this.options;
        element2.html("");
        if (!Metro2.utils.isValue(source)) {
          this._rebuild(review);
        } else {
          o2.source = source;
          this._fireEvent("data-load", {
            source: o2.source
          });
          this.activity.show(() => {
            fetch(o2.source).then(Metro2.fetch.status).then(Metro2.fetch.json).then((data) => {
              this.activity.hide();
              this.items = [];
              this.heads = [];
              this.foots = [];
              this._fireEvent("data-loaded", {
                source: o2.source,
                data
              });
              if (Array.isArray(o2.head)) {
                this.heads = o2.head;
              }
              if (Array.isArray(o2.body)) {
                this.items = o2.body;
              }
              this._createItemsFromJSON(data);
              this._rebuild(review);
              this._resetInspector();
              this._fireEvent("data-load-end", {
                source: o2.source,
                data
              });
            }).catch((error) => {
              this.activity.hide();
              this._fireEvent("data-load-error", {
                source: o2.source,
                error
              });
            });
          });
        }
      },
      reload: function(review) {
        this.loadData(this.options.source, review);
      },
      clear: function() {
        this.items = [];
        return this.draw();
      },
      next: function() {
        if (this.items.length === 0) return;
        this.currentPage++;
        if (this.currentPage > this.pagesCount) {
          this.currentPage = this.pagesCount;
          return;
        }
        this._draw();
        return this;
      },
      prev: function() {
        if (this.items.length === 0) return;
        this.currentPage--;
        if (this.currentPage === 0) {
          this.currentPage = 1;
          return;
        }
        this._draw();
        return this;
      },
      first: function() {
        if (this.items.length === 0) return;
        this.currentPage = 1;
        this._draw();
        return this;
      },
      last: function() {
        if (this.items.length === 0) return;
        this.currentPage = this.pagesCount;
        this._draw();
        return this;
      },
      page: function(num) {
        let _num = num;
        if (_num <= 0) {
          _num = 1;
        }
        if (_num > this.pagesCount) {
          _num = this.pagesCount;
        }
        this.currentPage = _num;
        this._draw();
        return this;
      },
      addFilter: function(f5, redraw) {
        let filterIndex = null;
        let i3;
        const func = Metro2.utils.isFunc(f5);
        if (func === false) {
          return;
        }
        for (i3 = 0; i3 < this.filters.length; i3++) {
          if (Metro2.utils.isNull(this.filters[i3])) {
            filterIndex = i3;
            this.filters[i3] = func;
            break;
          }
        }
        if (Metro2.utils.isNull(filterIndex)) {
          this.filters.push(func);
          filterIndex = this.filters.length - 1;
        }
        if (redraw === true) {
          this.currentPage = 1;
          this.draw();
        }
        return filterIndex;
      },
      removeFilter: function(key, redraw) {
        this.filters[key] = null;
        if (redraw === true) {
          this.currentPage = 1;
          this.draw();
        }
        return this;
      },
      removeFilters: function(redraw) {
        this.filters = [];
        if (redraw === true) {
          this.currentPage = 1;
          this.draw();
        }
        return this;
      },
      getItems: function() {
        return this.items;
      },
      getHeads: function() {
        return this.heads;
      },
      getView: function() {
        return this.view;
      },
      getFilteredItems: function() {
        return this.filteredItems.length > 0 ? this.filteredItems : this.items;
      },
      getSelectedItems: function() {
        const element2 = this.element;
        const o2 = this.options;
        const stored_keys = Metro2.storage.getItem(o2.checkStoreKey.replace("$1", element2.attr("id")));
        const selected = [];
        if (!Metro2.utils.isValue(stored_keys)) {
          return [];
        }
        $7.each(this.items, function() {
          if (stored_keys.indexOf(`${this[o2.checkColIndex]}`) !== -1) {
            selected.push(this);
          }
        });
        return selected;
      },
      getStoredKeys: function() {
        const element2 = this.element;
        const o2 = this.options;
        return Metro2.storage.getItem(o2.checkStoreKey.replace("$1", element2.attr("id")), []);
      },
      clearSelected: function(redraw) {
        const element2 = this.element;
        const o2 = this.options;
        Metro2.storage.setItem(o2.checkStoreKey.replace("$1", element2.attr("id")), []);
        element2.find("table-service-check-all input").prop("checked", false);
        if (redraw === true) this._draw();
      },
      getFilters: function() {
        return this.filters;
      },
      getFiltersIndexes: function() {
        return this.filtersIndexes;
      },
      openInspector: function(mode) {
        const ins = this.inspector;
        if (mode) {
          ins.show(0, () => {
            ins.css({
              top: ($7(globalThis).height() - ins.outerHeight(true)) / 2 + pageYOffset,
              left: ($7(globalThis).width() - ins.outerWidth(true)) / 2 + pageXOffset
            }).data("open", true);
          });
          this._fireEvent("inspector-open", {
            target: ins
          });
        } else {
          ins.hide().data("open", false);
          this._fireEvent("inspector-close", {
            target: ins
          });
        }
      },
      closeInspector: function() {
        this.openInspector(false);
      },
      toggleInspector: function() {
        this.openInspector(!this.inspector.data("open"));
      },
      resetView: function() {
        this.view = this._createView();
        this._createTableHeader();
        this._createTableFooter();
        this._draw();
        this._resetInspector();
        this._saveTableView();
      },
      rebuildIndex: function() {
        this._createIndex();
      },
      getIndex: function() {
        return this.index;
      },
      export: function(to2, mode, filename, options) {
        const Export = Metro2.export;
        const that = this;
        const o2 = this.options;
        const table = document.createElement("table");
        const head = $7("<thead>").appendTo(table);
        const body = $7("<tbody>").appendTo(table);
        let i3;
        let j5;
        let cells;
        const tds = [];
        let items;
        let tr4;
        let td;
        let start;
        let stop;
        if (typeof Export.tableToCSV !== "function") {
          return;
        }
        const _mode = Metro2.utils.isValue(mode) ? mode.toLowerCase() : "all-filtered";
        const _filename = Metro2.utils.isValue(filename) ? filename : `${element.id() || Hooks.useId()}-export.csv`;
        tr4 = $7("<tr>");
        cells = this.heads;
        for (j5 = 0; j5 < cells.length; j5++) {
          tds[j5] = null;
        }
        $7.each(cells, function(cell_index) {
          if (Metro2.utils.bool(that.view[cell_index].show) === false) {
            return;
          }
          td = $7("<th>");
          if (Metro2.utils.isValue(this.title)) {
            td.html(this.title);
          }
          tds[that.view[cell_index]["index-view"]] = td;
        });
        for (j5 = 0; j5 < cells.length; j5++) {
          if (Metro2.utils.isValue(tds[j5])) tds[j5].appendTo(tr4);
        }
        tr4.appendTo(head);
        switch (_mode) {
          case "checked": {
            items = this.getSelectedItems();
            start = 0;
            stop = items.length - 1;
            break;
          }
          case "view": {
            items = this._filter();
            start = Number.parseInt(o2.rows) === -1 ? 0 : o2.rows * (this.currentPage - 1);
            stop = Number.parseInt(o2.rows) === -1 ? items.length - 1 : start + o2.rows - 1;
            break;
          }
          case "all": {
            items = this.items;
            start = 0;
            stop = items.length - 1;
            break;
          }
          default: {
            items = this._filter();
            start = 0;
            stop = items.length - 1;
          }
        }
        for (i3 = start; i3 <= stop; i3++) {
          if (Metro2.utils.isValue(items[i3])) {
            tr4 = $7("<tr>");
            cells = items[i3];
            for (j5 = 0; j5 < cells.length; j5++) {
              tds[j5] = null;
            }
            $7.each(cells, function(cell_index) {
              if (Metro2.utils.bool(that.view[cell_index].show) === false) {
                return;
              }
              td = $7("<td>").html(this);
              tds[that.view[cell_index]["index-view"]] = td;
            });
            for (j5 = 0; j5 < cells.length; j5++) {
              if (Metro2.utils.isValue(tds[j5])) tds[j5].appendTo(tr4);
            }
            tr4.appendTo(body);
          }
        }
        Export.tableToCSV(table, _filename, options);
        table.remove();
      },
      changeAttribute: function(attributeName) {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        function dataCheck() {
          o2.check = Metro2.utils.bool(element2.attr("data-check"));
          that._service();
          that._createTableHeader();
          that._draw();
        }
        function dataRownum() {
          o2.rownum = Metro2.utils.bool(element2.attr("data-rownum"));
          that._service();
          that._createTableHeader();
          that._draw();
        }
        switch (attributeName) {
          case "data-check":
            dataCheck();
            break;
          case "data-rownum":
            dataRownum();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const component = element2.closest(".table-component");
        const search_input = component.find("input");
        const rows_select = component.find("select");
        search_input.data("input").destroy();
        rows_select.data("select").destroy();
        $7(globalThis).off(Metro2.events.resize, { ns: this.id });
        element2.off(Metro2.events.click, ".sortable-column");
        element2.off(Metro2.events.click, ".table-service-check input");
        element2.off(Metro2.events.click, ".table-service-check-all input");
        search_input.off(Metro2.events.inputchange);
        if (Metro2.utils.isValue(this.wrapperSearch)) {
          const customSearch = this.wrapperSearch.find("input");
          if (customSearch.length > 0) {
            customSearch.off(Metro2.events.inputchange);
          }
        }
        component.off(Metro2.events.click, ".pagination .page-link");
        if (Metro2.utils.isValue(this.wrapperPagination)) {
          this.wrapperPagination.off(Metro2.events.click, ".pagination .page-link");
        }
        element2.off(Metro2.events.click, ".js-table-crud-button");
        this._removeInspectorEvents();
        element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/tabs-material/tabs-material.js
  ((Metro2, $7) => {
    "use strict";
    let MaterialTabsDefaultConfig = {
      wheelStep: 20,
      materialTabsDeferred: 0,
      deep: false,
      fixedTabs: false,
      duration: 300,
      appBar: false,
      clsComponent: "",
      clsTabs: "",
      clsTab: "",
      clsTabActive: "",
      clsMarker: "",
      onBeforeTabOpen: Metro2.noop_true,
      onTabOpen: Metro2.noop,
      onTabsScroll: Metro2.noop,
      onTabsCreate: Metro2.noop
    };
    Metro2.materialTabsSetup = (options) => {
      MaterialTabsDefaultConfig = $7.extend({}, MaterialTabsDefaultConfig, options);
    };
    if (typeof globalThis.metroMaterialTabsSetup !== "undefined") {
      Metro2.materialTabsSetup(globalThis.metroMaterialTabsSetup);
    }
    Metro2.Component("material-tabs", {
      init: function(options, elem) {
        this._super(elem, options, MaterialTabsDefaultConfig, {
          marker: null,
          scroll: 0,
          scrollDir: "left"
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createStructure();
        this._createEvents();
        this._fireEvent("tabs-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const tabs = element2.find("li");
        const active_tab = element2.find("li.active");
        const wrapper = $7("<div>").addClass("tabs-material-wrapper").addClass(o2.clsComponent).insertBefore(element2);
        if (o2.appBar === true) {
          wrapper.addClass("app-bar-present");
        }
        if (o2.appBar === "more") {
          wrapper.addClass("app-bar-present-more");
        }
        element2.appendTo(wrapper);
        element2.addClass("tabs-material").addClass(o2.clsTabs);
        tabs.addClass(o2.clsTab);
        if (o2.deep === true) {
          element2.addClass("deep");
        }
        if (o2.fixedTabs === true) {
          element2.addClass("fixed-tabs");
        }
        this.marker = element2.find(".tab-marker");
        if (this.marker.length === 0) {
          this.marker = $7("<span>").addClass("tab-marker").addClass(o2.clsMarker).appendTo(element2);
        }
        this.openTab(active_tab.length === 0 ? tabs[0] : active_tab[0]);
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        element2.on(Metro2.events.click, "li", function(e2) {
          const tab = $7(this);
          const active_tab = element2.find("li.active");
          const tab_next = tab.index() > active_tab.index();
          const target = tab.children("a").attr("href");
          e2.preventDefault();
          if (Metro2.utils.isValue(target) && target[0] === "#") {
            if (tab.hasClass("active")) return;
            if (tab.hasClass("disabled")) return;
            if (Metro2.utils.exec(o2.onBeforeTabOpen, [tab, target, tab_next], this) === false) return;
            that.openTab(tab, tab_next);
          }
        });
        element2.on(Metro2.events.scroll, () => {
          const oldScroll = that.scroll;
          that.scrollDir = that.scroll < element2[0].scrollLeft ? "left" : "right";
          that.scroll = element2[0].scrollLeft;
          that._fireEvent("tabs-scroll", {
            scrollLeft: element2[0].scrollLeft,
            oldScroll,
            scrollDir: that.scrollDir
          });
        });
        element2.on(
          Metro2.events.mousewheel,
          function(e2) {
            if (e2.deltaY === void 0) {
              return;
            }
            const scrollable = $7(this);
            const dir = e2.deltaY > 0 ? -1 : 1;
            const step = o2.wheelStep;
            const scroll = scrollable.scrollLeft() - dir * step;
            scrollable.scrollLeft(scroll);
          },
          {
            passive: true
          }
        );
      },
      openTab: function(tab_to_open, tab_next) {
        const element2 = this.element;
        const o2 = this.options;
        const tabs = element2.find("li");
        const magic = 52;
        let target;
        let tab_left;
        let scroll;
        let scrollLeft;
        const tab = $7(tab_to_open);
        $7.each(tabs, function() {
          const target2 = $7(this).find("a").attr("href");
          if (!Metro2.utils.isValue(target2)) return;
          if (target2[0] === "#" && target2.length > 1) {
            $7(target2).hide();
          }
        });
        const width = element2.width();
        scroll = element2.scrollLeft();
        tab_left = tab.position().left;
        const tab_width = tab.width();
        const shift = tab_left + tab_width;
        tabs.removeClass("active").removeClass(o2.clsTabActive);
        tab.addClass("active").addClass(o2.clsTabActive);
        if (shift + magic > width + scroll) {
          scrollLeft = scroll + magic * 2;
        } else if (tab_left < scroll) {
          scrollLeft = tab_left - magic * 2;
        } else {
          scrollLeft = scroll;
        }
        element2.animate({
          draw: {
            scrollLeft
          },
          dur: o2.duration
        });
        this.marker.animate({
          draw: {
            left: tab_left,
            width: tab_width
          },
          dur: o2.duration
        });
        target = tab.find("a").attr("href");
        if (Metro2.utils.isValue(target)) {
          if (target[0] === "#" && target.length > 1) {
            $7(target).show();
          }
        }
        this._fireEvent("tab-open", {
          tab: tab[0],
          target,
          tab_next
        });
      },
      open: function(tab_num) {
        const element2 = this.element;
        const tabs = element2.find("li");
        const active_tab = element2.find("li.active");
        const tab = tabs.eq(tab_num - 1);
        const tab_next = tabs.index(tab) > tabs.index(active_tab);
        this.openTab(tab, tab_next);
      },
      changeAttribute: () => {
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, "li");
        element2.off(Metro2.events.scroll);
        element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/tag-input/tag-input.js
  ((Metro2, $7) => {
    "use strict";
    let TagInputDefaultConfig = {
      autocomplete: null,
      autocompleteUnique: true,
      autocompleteUrl: null,
      autocompleteUrlMethod: "GET",
      autocompleteUrlKey: null,
      autocompleteDivider: ",",
      autocompleteListHeight: 200,
      label: "",
      size: "normal",
      tagInputDeferred: 0,
      static: false,
      clearButton: true,
      clearButtonIcon: "\u2716",
      randomColor: false,
      maxTags: 0,
      tagSeparator: ",",
      tagTrigger: "Enter, Space, Comma",
      backspace: true,
      clsComponent: "",
      clsInput: "",
      clsClearButton: "",
      clsTag: "",
      clsTagTitle: "",
      clsTagAction: "",
      clsLabel: "",
      onBeforeTagAdd: Metro2.noop_true,
      onTagAdd: Metro2.noop,
      onBeforeTagRemove: Metro2.noop_true,
      onTagRemove: Metro2.noop,
      onTag: Metro2.noop,
      onClear: Metro2.noop,
      onTagTrigger: Metro2.noop,
      onTagInputCreate: Metro2.noop
    };
    Metro2.tagInputSetup = (options) => {
      TagInputDefaultConfig = $7.extend({}, TagInputDefaultConfig, options);
    };
    if (typeof globalThis.metroTagInputSetup !== "undefined") {
      Metro2.tagInputSetup(globalThis.metroTagInputSetup);
    }
    Metro2.Component("tag-input", {
      init: function(options, elem) {
        this._super(elem, options, TagInputDefaultConfig, {
          values: [],
          triggers: [],
          autocomplete: []
        });
        return this;
      },
      _create: function() {
        this.triggers = `${this.options.tagTrigger}`.toArray(",");
        if (this.triggers.includes("Space") || this.triggers.includes("Spacebar")) {
          this.triggers.push(" ");
          this.triggers.push("Spacebar");
        }
        if (this.triggers.includes("Comma")) {
          this.triggers.push(",");
        }
        this._createStructure();
        this._createEvents();
        this._fireEvent("tag-input-create", {
          element: this.element
        });
      },
      _createStructure: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        let container;
        let clearButton;
        const values = element2.val().trim();
        container = element2.wrap("<div>").addClass(`tag-input ${element2[0].className}`).addClass(o2.clsComponent);
        container.attr("id", Hooks.useId(container[0]));
        element2[0].className = "";
        element2.addClass("original-input");
        const input = $7("<input type='text'>").addClass("input-wrapper").addClass(o2.clsInput).attr("size", 1);
        input.appendTo(container);
        if (o2.clearButton !== false && !element2[0].readOnly) {
          container.addClass("padding-for-clear");
          clearButton = $7("<button>").addClass("button input-clear-button").attr("tabindex", -1).attr("type", "button").html(o2.clearButtonIcon);
          clearButton.appendTo(container);
        }
        if (Metro2.utils.isValue(values)) {
          $7.each(values.toArray(o2.tagSeparator), function() {
            that._addTag(this);
          });
        }
        this._addLabel(o2.label, container, {
          className: o2.clsLabel,
          id: container.attr("id"),
          dir: element2.attr("dir")
        });
        if (element2.is(":disabled")) {
          this.disable();
        } else {
          this.enable();
        }
        if (o2.static === true || element2.attr("readonly") !== void 0) {
          container.addClass("static-mode");
        }
        if (!o2.autocomplete || !o2.autocompleteUrl) {
          $7("<div>").addClass("autocomplete-list").css({
            maxHeight: o2.autocompleteListHeight,
            display: "none"
          }).appendTo(container);
        }
        if (o2.autocomplete) {
          const autocomplete_obj = Metro2.utils.isObject(o2.autocomplete);
          if (autocomplete_obj !== false) {
            this.autocomplete = autocomplete_obj;
          } else {
            this.autocomplete = o2.autocomplete.toArray(o2.autocompleteDivider);
          }
        }
        if (o2.autocompleteUrl) {
          fetch(o2.autocompleteUrl, {
            method: o2.autocompleteUrlMethod
          }).then((response) => response.text()).then((data) => {
            let newData = [];
            try {
              newData = JSON.parse(data);
              if (o2.autocompleteUrlKey) {
                newData = newData[o2.autocompleteUrlKey];
              }
            } catch (e2) {
              newData = data.split("\n");
            }
            that.autocomplete = that.autocomplete.concat(newData);
          });
        }
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.closest(".tag-input");
        const input = container.find(".input-wrapper");
        const autocompleteList = container.find(".autocomplete-list");
        input.on(Metro2.events.focus, () => {
          container.addClass("focused");
        });
        input.on(Metro2.events.blur, () => {
          container.removeClass("focused");
        });
        input.on(Metro2.events.inputchange, () => {
          input.attr("size", Math.ceil(input.val().length / 2) + 2);
        });
        input.on(Metro2.events.keydown, (e2) => {
          const val = input.val().trim();
          const key = e2.key;
          if (key === "Enter") e2.preventDefault();
          if (o2.backspace === true && key === "Backspace" && val.length === 0) {
            if (that.values.length > 0) {
              that.values.splice(-1, 1);
              element2.siblings(".tag").last().remove();
              element2.val(that.values.join(o2.tagSeparator));
            }
            return;
          }
          if (val === "") {
            return;
          }
          if (!that.triggers.includes(key)) {
            return;
          }
          that._fireEvent("tag-trigger", {
            key
          });
          input.val("");
          that._addTag(val);
          input.attr("size", 1);
        });
        input.on(Metro2.events.keyup, (e2) => {
          const val = input.val();
          const key = e2.key;
          if (that.triggers.includes(key) && val[val.length - 1] === key) {
            input.val(val.slice(0, -1));
          }
        });
        container.on(Metro2.events.click, ".tag .action", function() {
          const tag = $7(this).closest(".tag");
          that._delTag(tag);
        });
        container.on(Metro2.events.click, () => {
          input.focus();
        });
        container.on(Metro2.events.click, ".input-clear-button", () => {
          const val = element2.val();
          that.clear();
          that._fireEvent("clear", {
            val
          });
        });
        input.on(Metro2.events.input, function() {
          const val = this.value.toLowerCase();
          that._drawAutocompleteList(val);
        });
        container.on(Metro2.events.click, ".autocomplete-list .item", function() {
          const val = $7(this).attr("data-autocomplete-value");
          input.val("");
          that._addTag(val);
          input.attr("size", 1);
          autocompleteList.css({
            display: "none"
          });
          that._fireEvent("autocomplete-select", {
            value: val
          });
        });
      },
      _drawAutocompleteList: function(val) {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.closest(".tag-input");
        const input = container.find(".input-wrapper");
        const autocompleteList = container.find(".autocomplete-list");
        if (autocompleteList.length === 0) {
          return;
        }
        autocompleteList.html("");
        const items = this.autocomplete.filter((item) => item.toLowerCase().indexOf(val) > -1);
        autocompleteList.css({
          display: items.length > 0 ? "block" : "none",
          left: input.position().left
        });
        $7.each(items, function() {
          if (o2.autocompleteUnique && that.values.indexOf(this) !== -1) {
            return;
          }
          const index = this.toLowerCase().indexOf(val);
          let content;
          const item = $7("<div>").addClass("item").attr("data-autocomplete-value", this);
          if (index === 0) {
            content = `<strong>${this.substring(0, val.length)}</strong>${this.substring(val.length)}`;
          } else {
            content = `${this.substring(0, index)}<strong>${this.substring(index, val.length)}</strong>${this.substring(index + val.length)}`;
          }
          item.html(content).appendTo(autocompleteList);
          that._fireEvent("draw-autocomplete-item", {
            item
          });
        });
      },
      _addTag: function(val) {
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.closest(".tag-input");
        const input = container.find(".input-wrapper");
        let tag;
        let remover;
        let tagSize;
        if (o2.maxTags > 0 && this.values.length === o2.maxTags) {
          return;
        }
        if (`${val}`.trim() === "") {
          return;
        }
        if (!Metro2.utils.exec(o2.onBeforeTagAdd, [val, this.values], element2[0])) {
          return;
        }
        tag = $7("<span>").addClass("tag").addClass(tagSize).addClass(o2.clsTag).insertBefore(input);
        tag.data("value", val);
        const tagStatic = o2.static || container.hasClass("static-mode") || element2.readonly || element2.disabled || container.hasClass("disabled");
        if (tagStatic) {
          tag.addClass("static");
        }
        const title = $7("<span>").addClass("title").addClass(o2.clsTagTitle).html(val);
        remover = $7("<span>").addClass("action").addClass(o2.clsTagAction).html("&times;");
        title.appendTo(tag);
        remover.appendTo(tag);
        if (o2.randomColor === true) {
          const colors = Object.values(Object.assign({}, Farbe.StandardColors, Farbe.MetroColors));
          const bg = colors[$7.random(0, colors.length - 1)];
          const bg_r = Farbe.Routines.darken(bg, 15);
          const fg = Farbe.Routines.isDark(bg) ? "#ffffff" : "#000000";
          tag.css({
            backgroundColor: bg,
            color: fg
          });
          remover.css({
            backgroundColor: bg_r,
            color: fg
          });
        }
        this.values.push(val);
        element2.val(this.values.join(o2.tagSeparator));
        this._fireEvent("tag-add", {
          tag: tag[0],
          val,
          values: this.values
        });
        this._fireEvent("tag", {
          tag: tag[0],
          val,
          values: this.values
        });
      },
      _delTag: function(tag) {
        const element2 = this.element;
        const o2 = this.options;
        const val = tag.data("value");
        if (!Metro2.utils.exec(o2.onBeforeTagRemove, [tag, val, this.values], element2[0])) {
          return;
        }
        Metro2.utils.arrayDelete(this.values, val);
        element2.val(this.values.join(o2.tagSeparator));
        this._fireEvent("tag-remove", {
          tag: tag[0],
          val,
          values: this.values
        });
        this._fireEvent("tag", {
          tag: tag[0],
          val,
          values: this.values
        });
        tag.remove();
      },
      tags: function() {
        return this.values;
      },
      val: function(v5) {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.closest(".tag-input");
        let newValues = [];
        if (!Metro2.utils.isValue(v5)) {
          return this.tags();
        }
        this.values = [];
        container.find(".tag").remove();
        if (typeof v5 === "string") {
          newValues = `${v5}`.toArray(o2.tagSeparator);
        } else {
          if (Array.isArray(v5)) {
            newValues = v5;
          }
        }
        $7.each(newValues, function() {
          that._addTag(this);
        });
        return this;
      },
      append: function(v5) {
        const that = this;
        const o2 = this.options;
        let newValues = this.values;
        if (typeof v5 === "string") {
          newValues = `${v5}`.toArray(o2.tagSeparator);
        } else {
          if (Array.isArray(v5)) {
            newValues = v5;
          }
        }
        $7.each(newValues, function() {
          that._addTag(this);
        });
        return this;
      },
      clear: function() {
        const element2 = this.element;
        const container = element2.closest(".tag-input");
        this.values = [];
        element2.val("").trigger("change");
        container.find(".tag").remove();
        return this;
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      toggleStatic: function(val) {
        const container = this.element.closest(".tag-input");
        let staticMode;
        if (Metro2.utils.isValue(val)) {
          staticMode = Metro2.utils.bool(val);
        } else {
          staticMode = !container.hasClass("static-mode");
        }
        if (staticMode) {
          container.addClass("static-mode");
        } else {
          container.removeClass("static-mode");
        }
      },
      setAutocompleteList: function(l2) {
        const autocomplete_list = Metro2.utils.isObject(l2);
        if (autocomplete_list !== false) {
          this.autocomplete = autocomplete_list;
        } else if (typeof l2 === "string") {
          this.autocomplete = l2.toArray(this.options.autocompleteDivider);
        }
      },
      changeAttribute: function(attributeName) {
        const element2 = this.element;
        const o2 = this.options;
        const changeValue = () => {
          const val = element2.attr("value").trim();
          this.clear();
          if (!Metro2.utils.isValue(val)) {
            return;
          }
          this.val(val.toArray(o2.tagSeparator));
        };
        switch (attributeName) {
          case "value":
            changeValue();
            break;
          case "disabled":
            this.toggleState();
            break;
          case "static":
            this.toggleStatic();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        const container = element2.closest(".tag-input");
        const input = container.find(".input-wrapper");
        input.off(Metro2.events.focus);
        input.off(Metro2.events.blur);
        input.off(Metro2.events.keydown);
        container.off(Metro2.events.click, ".tag .action");
        container.off(Metro2.events.click);
        if (o2.label) {
          container.prev("label").remove();
        }
        container.remove();
      }
    });
    $7(document).on(Metro2.events.click, () => {
      $7(".tag-input .autocomplete-list").hide();
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/task-bar/task-bar.js
  ((Metro2, $7) => {
    "use strict";
    let TaskBarDefaultConfig = {
      onTaskClick: Metro2.noop,
      onMyObjectCreate: Metro2.noop
    };
    Metro2.taskBarSetup = (options) => {
      TaskBarDefaultConfig = $7.extend({}, TaskBarDefaultConfig, options);
    };
    if (typeof globalThis.metroTaskBarSetup !== "undefined") {
      Metro2.taskBarSetup(globalThis.metroTaskBarSetup);
    }
    Metro2.Component("task-bar", {
      init: function(options, elem) {
        this._super(elem, options, TaskBarDefaultConfig, {
          // define instance vars here
          tasks: [],
          systemTray: [],
          widgets: []
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("task-bar-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("task-bar");
        element2.append($7("<div>").addClass("widgets"));
        element2.append($7("<div>").addClass("tasks"));
        element2.append($7("<div>").addClass("system-tray"));
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        element2.on(Metro2.events.click, ".task", function() {
          const task = that.tasks[$7(this).index()];
          for (const t of that.tasks) {
            t.active = false;
          }
          task.active = true;
          that._renderTasks();
          that._fireEvent("task-click", {
            task,
            element: task.ref
          });
        });
        element2.on(Metro2.events.click, ".system-tray-item", function() {
          const item = that.systemTray[$7(this).index()];
          that._fireEvent("system-tray-click", {
            item
          });
        });
        element2.on(Metro2.events.click, ".widget", function() {
          const item = that.widgets[$7(this).index()];
          that._fireEvent("widget-click", {
            item
          });
        });
      },
      _renderTasks: function() {
        const element2 = this.element;
        const o2 = this.options;
        const tasks = element2.find(".tasks").clear();
        for (const task of this.tasks) {
          const taskItem = $7("<div>").addClass("task").attr("title", task.title).html(task.icon);
          if (task.active) {
            taskItem.addClass("active");
          }
          tasks.append(taskItem);
        }
      },
      _renderSystemTray: function() {
        const element2 = this.element;
        const systemTray = element2.find(".system-tray").clear();
        for (const item of this.systemTray) {
          systemTray.append($7(item).addClass("system-tray-item"));
        }
      },
      _renderWidgets: function() {
        const element2 = this.element;
        const widgets = element2.find(".widgets").clear();
        for (const widget of this.widgets) {
          widgets.append($7(widget).addClass("widget"));
        }
      },
      /*
       * task = {
       *   title: "Task title",
       *   description: "Task description",
       *   icon: "<span class='mif-cogs'></span>",
       *   ref: null, // Reference to the element in the DOM
       * }
       * */
      addTask: function(task, active = false) {
        if (active) {
          for (const t of this.tasks) {
            t.active = false;
          }
        }
        this.tasks.push({ ...task, active });
        this._renderTasks();
      },
      removeTask: function(task) {
        this.tasks = this.tasks.filter((t) => t.ref !== task);
        this._renderTasks();
      },
      activateTask: function(ref) {
        const tasks = this.tasks.filter((t) => t.ref === ref);
        if (tasks.length === 0) {
          return;
        }
        const task = tasks[0];
        for (const t of this.tasks) {
          t.active = false;
        }
        task.active = true;
        this._renderTasks();
      },
      /*
       * item = HTMLElement
       * */
      addToSystemTray: function(item) {
        this.systemTray.push(item);
        this._renderSystemTray();
      },
      /*
       * widget = HTMLElement
       * */
      addWidget: function(widget) {
        this.widgets.push(widget);
        this._renderWidgets();
      },
      changeAttribute: (attr, newValue) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/template/template.js
  ((Metro2, $7) => {
    "use strict";
    const Engine = (html, options, conf) => {
      let ReEx;
      let re3 = "<%(.+?)%>";
      const reExp = /(^( )?(var|if|for|else|switch|case|break|{|}|;))(.*)?/g;
      let code = "with(obj) { var r=[];\n";
      let cursor = 0;
      let result;
      let match;
      const add = (line, js) => {
        js ? (
          // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>
          code += line.match(reExp) ? `${line}
` : `r.push(${line});
`
        ) : (
          // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>
          code += line !== "" ? `r.push("${line.replace(/"/g, '\\"')}");
` : ""
        );
        return add;
      };
      if (Metro2.utils.isValue(conf)) {
        if ($7.hasProp(conf, "beginToken")) {
          re3 = re3.replace("<%", conf.beginToken);
        }
        if ($7.hasProp(conf, "endToken")) {
          re3 = re3.replace("%>", conf.endToken);
        }
      }
      ReEx = new RegExp(re3, "g");
      match = ReEx.exec(html);
      while (match) {
        add(html.slice(cursor, match.index))(match[1], true);
        cursor = match.index + match[0].length;
        match = ReEx.exec(html);
      }
      add(html.substring(cursor, html.length - cursor));
      code = `${code}return r.join(""); }`.replace(/[\r\t\n]/g, " ");
      try {
        result = new Function("obj", code).apply(options, [options]);
      } catch (err) {
        console.error(`'${err.message}'`, " in \n\nCode:\n", code, "\n");
      }
      return result;
    };
    let TemplateDefaultConfig = {
      templateData: null,
      onTemplateCompile: Metro2.noop,
      onTemplateCreate: Metro2.noop
    };
    Metro2.templateSetup = (options) => {
      TemplateDefaultConfig = $7.extend({}, TemplateDefaultConfig, options);
    };
    if (typeof globalThis.metroTemplateSetup !== "undefined") {
      Metro2.templateSetup(globalThis.metroTemplateSetup);
    }
    Metro2.Component("template", {
      init: function(options, elem) {
        this._super(elem, options, TemplateDefaultConfig, {
          template: null,
          data: {}
        });
        return this;
      },
      _compile: function() {
        const element2 = this.element;
        const template = this.template.replace(/(&lt;%)/gm, "<%").replace(/(%&gt;)/gm, "%>").replace(/(&lt;)/gm, "<").replace(/(&gt;)/gm, ">");
        const compiled = Engine(template, this.data);
        element2.html(compiled);
        this._fireEvent("template-compile", {
          template,
          compiled,
          element: element2
        });
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        this.template = element2.html();
        this.data = Metro2.utils.isObject(o2.templateData) || {};
        this._compile();
        this._fireEvent("template-create", {
          element: element2
        });
      },
      buildWith: function(obj) {
        const data = Metro2.utils.isObject(obj);
        if (!data) {
          return;
        }
        this.data = data;
        this._compile();
      },
      changeAttribute: function(a2, v5) {
        if (a2 === "data-template-data") {
          this.options.templateData = v5;
          this.data = Metro2.utils.isObject(v5) || {};
          this._compile();
        }
      },
      destroy: function() {
        return this.element;
      }
    });
    Metro2.template = Engine;
  })(Metro, Dom);

  // ../metroui-lib/source/components/theme-switcher/theme-switcher.js
  ((Metro2, $7) => {
    "use strict";
    let ThemeSwitcherDefaultConfig = {
      state: Metro2.theme.LIGHT,
      target: "html",
      saveState: true,
      saveStateKey: "THEME:SWITCHER",
      clsDark: "",
      darkSymbol: "\u{1F319}",
      lightSymbol: "\u{1F31E}",
      mode: "switch",
      onThemeSwitcherCreate: Metro2.noop,
      onChangeTheme: Metro2.noop
    };
    Metro2.themeSwitcherSetup = (options) => {
      ThemeSwitcherDefaultConfig = $7.extend({}, ThemeSwitcherDefaultConfig, options);
    };
    if (typeof globalThis.metroThemeSwitcherSetup !== "undefined") {
      Metro2.themeSwitcherSetup(globalThis.metroThemeSwitcherSetup);
    }
    Metro2.Component("theme-switcher", {
      init: function(options, elem) {
        this._super(elem, options, ThemeSwitcherDefaultConfig, {
          container: null,
          state: null,
          target: null
        });
        this.state = this.options.state;
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("theme-switcher-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        let initState = "light";
        if (o2.saveState) {
          initState = Metro2.storage.getItem(o2.saveStateKey, false);
        }
        element2.attr("data-light-symbol", o2.lightSymbol);
        element2.attr("data-dark-symbol", o2.darkSymbol);
        Metro2.makePlugin(element2, "switch");
        this.container = element2.wrap($7("<label>").addClass("theme-switcher"));
        this.container.addClass(`mode-${o2.mode}`);
        this.target = $7(o2.target);
        if (this.target.length === 0) {
          this.target = $7("html");
        }
        this._setState(o2.saveState ? initState : o2.state === Metro2.theme.DARK);
        this._updateState();
      },
      _createEvents: function() {
        this.container.on("click", () => {
          this._updateState();
        });
        this._observeClass();
      },
      _observeClass: function() {
        const observer = new MutationObserver((mutations) => {
          for (const mutation of mutations) {
            if (mutation.type === "attributes") {
              if (mutation.attributeName === "class") {
                this.elem.checked = this.target[0].classList.contains("dark-side");
              }
            }
          }
        });
        observer.observe(this.target[0], {
          attributes: true,
          attributeFilter: ["class"]
        });
      },
      _setState: function(state2 = false) {
        this.elem.checked = state2;
      },
      _updateState: function() {
        const usingMeta = $7.meta("metro:theme").length > 0;
        const o2 = this.options;
        const elem = this.elem;
        const target = this.target;
        if (usingMeta) {
          return;
        }
        if (elem.checked) {
          target.addClass("dark-side").addClass(this.options.clsDark);
        } else {
          target.removeClass("dark-side").addClass(this.options.clsDark);
        }
        if (o2.saveState) {
          Metro2.storage.setItem(o2.saveStateKey, elem.checked);
        }
        this._fireEvent("change-theme", { state: elem.checked });
      },
      val: function(value) {
        if (typeof value === "undefined") {
          return this.elem.checked ? Metro2.theme.DARK : Metro2.theme.LIGHT;
        }
        this._setState(typeof value === "boolean" ? value : value === Metro2.theme.DARK);
        this._updateState();
      },
      changeAttribute: function(attr, newValue) {
        if (attr === "data-target") {
          this.target = $7(newValue);
          this._updateState();
        }
      },
      destroy: function() {
        this.container.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/tile/tile.js
  ((Metro2, $7) => {
    "use strict";
    const effects = ["slide-up", "slide-down", "slide-left", "slide-right", "fade", "zoom", "swirl", "switch"];
    let TileDefaultConfig = {
      tileDeferred: 0,
      size: "medium",
      cover: "",
      coverPosition: "center",
      effect: "",
      // slide-up, slide-down, slide-left, slide-right, fade, zoom, swirl, switch
      effectInterval: 3e3,
      effectDuration: 500,
      target: null,
      canTransform: true,
      onTileClick: Metro2.noop,
      onTileCreate: Metro2.noop
    };
    Metro2.tileSetup = (options) => {
      TileDefaultConfig = $7.extend({}, TileDefaultConfig, options);
    };
    if (typeof globalThis.metroTileSetup !== "undefined") {
      Metro2.tileSetup(globalThis.metroTileSetup);
    }
    Metro2.Component("tile", {
      init: function(options, elem) {
        this._super(elem, options, TileDefaultConfig, {
          effectInterval: false,
          images: [],
          slides: [],
          currentSlide: -1,
          unload: false
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this._createTile();
        this._createEvents();
        this._fireEvent("tile-create", {
          element: element2
        });
      },
      _createTile: function() {
        function switchImage(el, img_src, i3) {
          setTimeout(() => {
            el.fadeOut(500, () => {
              el.css("background-image", `url(${img_src})`);
              el.fadeIn();
            });
          }, i3 * 300);
        }
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        const slides = element2.find(".slide");
        const slides2 = element2.find(".slide-front, .slide-back");
        element2.addClass(`tile-${o2.size}`);
        if (o2.effect.indexOf("hover-") > -1) {
          element2.addClass(`effect-${o2.effect}`);
          $7.each(slides2, function() {
            const slide = $7(this);
            if (slide.data("cover") !== void 0) {
              that._setCover(slide, slide.data("cover"), slide.data("cover-position"));
            }
          });
        }
        if (effects.includes(o2.effect) && slides.length > 1) {
          $7.each(slides, function(i3) {
            const slide = $7(this);
            that.slides.push(this);
            if (slide.data("cover") !== void 0) {
              that._setCover(slide, slide.data("cover"), slide.data("cover-position"));
            }
            if (i3 > 0) {
              if (["slide-up", "slide-down"].indexOf(o2.effect) > -1) slide.css("top", "100%");
              if (["slide-left", "slide-right"].indexOf(o2.effect) > -1) slide.css("left", "100%");
              if (["fade", "zoom", "swirl", "switch"].indexOf(o2.effect) > -1) slide.css("opacity", 0);
            }
          });
          this.currentSlide = 0;
          this._runEffects();
        }
        if (o2.cover !== "") {
          this._setCover(element2, o2.cover);
        }
        if (o2.effect === "image-set") {
          element2.addClass("image-set");
          $7.each(element2.children("img"), function() {
            that.images.push(this);
            $7(this).remove();
          });
          const temp = this.images.slice();
          for (let i3 = 0; i3 < 5; i3++) {
            const rnd_index = $7.random(0, temp.length - 1);
            const div = $7("<div>").addClass(`img -js-img-${i3}`).css("background-image", `url(${temp[rnd_index].src})`);
            element2.prepend(div);
            temp.splice(rnd_index, 1);
          }
          let a2 = [0, 1, 4, 3, 2];
          setInterval(() => {
            const temp2 = that.images.slice();
            const bg = Farbe.Routines.randomColor();
            element2.css("background-color", bg);
            for (let i3 = 0; i3 < a2.length; i3++) {
              const rnd_index = $7.random(0, temp2.length - 1);
              const div = element2.find(`.-js-img-${a2[i3]}`);
              switchImage(div, temp2[rnd_index].src, i3);
              temp2.splice(rnd_index, 1);
            }
            a2 = a2.reverse();
          }, 5e3);
        }
      },
      _runEffects: function() {
        const o2 = this.options;
        if (this.effectInterval === false)
          this.effectInterval = setInterval(() => {
            let current;
            let next;
            current = $7(this.slides[this.currentSlide]);
            this.currentSlide++;
            if (this.currentSlide === this.slides.length) {
              this.currentSlide = 0;
            }
            next = this.slides[this.currentSlide];
            if (effects.includes(o2.effect)) {
              Metro2.Effects[Str.camelCase(o2.effect)]($7(current)[0], $7(next)[0], {
                duration: o2.effectDuration
              });
            }
          }, o2.effectInterval);
      },
      _stopEffects: function() {
        $7.clearInterval(this.effectInterval);
        this.effectInterval = false;
      },
      _setCover: function(to2, src, pos) {
        to2.css({
          backgroundImage: `url(${src})`,
          backgroundSize: "cover",
          backgroundRepeat: "no-repeat",
          backgroundPosition: pos || this.options.coverPosition
        });
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        element2.on(Metro2.events.startAll, function(e2) {
          const tile = $7(this);
          const dim = { w: element2.width(), h: element2.height() };
          const X5 = Metro2.utils.pageXY(e2).x - tile.offset().left;
          const Y4 = Metro2.utils.pageXY(e2).y - tile.offset().top;
          let side;
          if (Metro2.utils.isRightMouse(e2) === false) {
            if (X5 < dim.w * 1 / 3 && (Y4 < dim.h * 1 / 2 || Y4 > dim.h * 1 / 2)) {
              side = "left";
            } else if (X5 > dim.w * 2 / 3 && (Y4 < dim.h * 1 / 2 || Y4 > dim.h * 1 / 2)) {
              side = "right";
            } else if (X5 > dim.w * 1 / 3 && X5 < dim.w * 2 / 3 && Y4 > dim.h / 2) {
              side = "bottom";
            } else {
              side = "top";
            }
            if (o2.canTransform === true) tile.addClass(`transform-${side}`);
            if (o2.target !== null) {
              setTimeout(() => {
                document.location.href = o2.target;
              }, 100);
            }
            that._fireEvent("tile-click", {
              side
            });
          }
        });
        element2.on([Metro2.events.stopAll, Metro2.events.leave].join(" "), function() {
          $7(this).removeClass("transform-left").removeClass("transform-right").removeClass("transform-top").removeClass("transform-bottom");
        });
      },
      changeAttribute: () => {
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.startAll);
        element2.off([Metro2.events.stopAll, Metro2.events.leave].join(" "));
        element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/timepicker/timepicker.js
  ((Metro2, $7) => {
    "use strict";
    let TimePickerDefaultConfig = {
      label: "",
      timepickerDeferred: 0,
      hoursStep: 1,
      minutesStep: 1,
      secondsStep: 1,
      value: null,
      distance: 3,
      hours: true,
      minutes: true,
      seconds: true,
      showLabels: true,
      scrollSpeed: 4,
      copyInlineStyles: false,
      openMode: "auto",
      clsPicker: "",
      clsPart: "",
      clsHours: "",
      clsMinutes: "",
      clsSeconds: "",
      clsLabel: "",
      clsButton: "",
      clsOkButton: "",
      clsCancelButton: "",
      okButtonIcon: "\u2713",
      cancelButtonIcon: "\u{10102}",
      onSet: Metro2.noop,
      onOpen: Metro2.noop,
      onClose: Metro2.noop,
      onScroll: Metro2.noop,
      onTimePickerCreate: Metro2.noop
    };
    Metro2.timePickerSetup = (options) => {
      TimePickerDefaultConfig = $7.extend({}, TimePickerDefaultConfig, options);
    };
    if (typeof globalThis.metroTimePickerSetup !== "undefined") {
      Metro2.timePickerSetup(globalThis.metroTimePickerSetup);
    }
    Metro2.Component("time-picker", {
      init: function(options, elem) {
        this._super(elem, options, TimePickerDefaultConfig, {
          picker: null,
          isOpen: false,
          value: [],
          listTimer: {
            hours: null,
            minutes: null,
            seconds: null
          },
          id: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        let i3;
        this.id = element2.attr("id") || Hooks.useId(this.elem);
        if (o2.distance < 1) {
          o2.distance = 1;
        }
        if (o2.hoursStep < 1) {
          o2.hoursStep = 1;
        }
        if (o2.hoursStep > 23) {
          o2.hoursStep = 23;
        }
        if (o2.minutesStep < 1) {
          o2.minutesStep = 1;
        }
        if (o2.minutesStep > 59) {
          o2.minutesStep = 59;
        }
        if (o2.secondsStep < 1) {
          o2.secondsStep = 1;
        }
        if (o2.secondsStep > 59) {
          o2.secondsStep = 59;
        }
        if (element2.val() === "" && !Metro2.utils.isValue(o2.value)) {
          o2.value = datetime().format("HH:mm:ss");
        }
        this.value = (element2.val() !== "" ? element2.val() : `${o2.value}`).toArray(":");
        for (i3 = 0; i3 < 3; i3++) {
          if (this.value[i3] === void 0 || this.value[i3] === null) {
            this.value[i3] = 0;
          } else {
            this.value[i3] = Number.parseInt(this.value[i3]);
          }
        }
        this._normalizeValue();
        this._createStructure();
        this._createEvents();
        this._set();
        this._fireEvent("time-picker-create", {
          element: element2
        });
      },
      _normalizeValue: function() {
        const o2 = this.options;
        if (o2.hoursStep > 1) {
          this.value[0] = Metro2.utils.nearest(this.value[0], o2.hoursStep, true);
        }
        if (o2.minutesStep > 1) {
          this.value[1] = Metro2.utils.nearest(this.value[1], o2.minutesStep, true);
        }
        if (o2.minutesStep > 1) {
          this.value[2] = Metro2.utils.nearest(this.value[2], o2.secondsStep, true);
        }
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const strings = this.strings;
        let picker;
        let hours;
        let minutes;
        let seconds;
        let i3;
        let timeWrapper;
        let selectBlock;
        const id = Hooks.useId(element2[0]);
        picker = $7("<div>").addClass(`wheel-picker time-picker ${element2[0].className}`).addClass(o2.clsPicker);
        if (!picker.attr("id")) {
          picker.attr("id", id);
        }
        picker.insertBefore(element2);
        element2.attr("readonly", true).appendTo(picker);
        this._addLabel(o2.label, picker, {
          className: o2.clsLabel,
          id: picker.attr("id"),
          dir: element2.attr("dir")
        });
        timeWrapper = $7("<div>").addClass("time-wrapper").appendTo(picker);
        if (o2.hours) {
          hours = $7("<div>").attr("data-title", strings.label_hours).addClass("hours").addClass(o2.clsPart).addClass(o2.clsHours).appendTo(timeWrapper);
        }
        if (o2.minutes) {
          minutes = $7("<div>").attr("data-title", strings.label_minutes).addClass("minutes").addClass(o2.clsPart).addClass(o2.clsMinutes).appendTo(timeWrapper);
        }
        if (o2.seconds) {
          seconds = $7("<div>").attr("data-title", strings.label_seconds).addClass("seconds").addClass(o2.clsPart).addClass(o2.clsSeconds).appendTo(timeWrapper);
        }
        const selectWrapper = $7("<div>").addClass("select-wrapper").appendTo(picker);
        selectBlock = $7("<div>").addClass("select-block").appendTo(selectWrapper);
        if (o2.hours === true) {
          hours = $7("<ul>").addClass("sel-hours").appendTo(selectBlock);
          for (i3 = 0; i3 < o2.distance; i3++) $7("<li>").html("&nbsp;").data("value", -1).appendTo(hours);
          for (i3 = 0; i3 < 24; i3 = i3 + o2.hoursStep) {
            $7("<li>").addClass(`js-hours-${i3}`).html(Str.lpad(i3, "0", 2)).data("value", i3).appendTo(hours);
          }
          for (i3 = 0; i3 < o2.distance; i3++) $7("<li>").html("&nbsp;").data("value", -1).appendTo(hours);
        }
        if (o2.minutes === true) {
          minutes = $7("<ul>").addClass("sel-minutes").appendTo(selectBlock);
          for (i3 = 0; i3 < o2.distance; i3++) $7("<li>").html("&nbsp;").data("value", -1).appendTo(minutes);
          for (i3 = 0; i3 < 60; i3 = i3 + o2.minutesStep) {
            $7("<li>").addClass(`js-minutes-${i3}`).html(Str.lpad(i3, "0", 2)).data("value", i3).appendTo(minutes);
          }
          for (i3 = 0; i3 < o2.distance; i3++) $7("<li>").html("&nbsp;").data("value", -1).appendTo(minutes);
        }
        if (o2.seconds === true) {
          seconds = $7("<ul>").addClass("sel-seconds").appendTo(selectBlock);
          for (i3 = 0; i3 < o2.distance; i3++) $7("<li>").html("&nbsp;").data("value", -1).appendTo(seconds);
          for (i3 = 0; i3 < 60; i3 = i3 + o2.secondsStep) {
            $7("<li>").addClass(`js-seconds-${i3}`).html(Str.lpad(i3, "0", 2)).data("value", i3).appendTo(seconds);
          }
          for (i3 = 0; i3 < o2.distance; i3++) $7("<li>").html("&nbsp;").data("value", -1).appendTo(seconds);
        }
        selectBlock.height((o2.distance * 2 + 1) * 40);
        const actionBlock = $7("<div>").addClass("action-block").appendTo(selectWrapper);
        $7("<button>").attr("type", "button").addClass("button action-now").addClass(o2.clsButton).addClass(o2.clsTodayButton).html(`<span class="caption">${this.strings.label_now}</span>`).appendTo(actionBlock);
        $7("<button>").attr("type", "button").addClass("button action-ok").addClass(o2.clsButton).addClass(o2.clsOkButton).html(`<span class="icon">${o2.okButtonIcon}</span>`).appendTo(actionBlock);
        $7("<button>").attr("type", "button").addClass("button action-cancel").addClass(o2.clsButton).addClass(o2.clsCancelButton).html(`<span class="icon">${o2.cancelButtonIcon}</span>`).appendTo(actionBlock);
        element2[0].className = "";
        if (o2.copyInlineStyles === true) {
          for (i3 = 0; i3 < element2[0].style.length; i3++) {
            picker.css(element2[0].style[i3], element2.css(element2[0].style[i3]));
          }
        }
        if (o2.showLabels === true) {
          picker.addClass("show-labels");
        }
        if (element2.prop("disabled")) {
          picker.addClass("disabled");
        }
        this.picker = picker;
      },
      _createEvents: function() {
        const that = this;
        const o2 = this.options;
        const picker = this.picker;
        picker.on("touchstart", ".select-block ul", function(e2) {
          if (e2.changedTouches) {
            return;
          }
          let pageY = Metro2.utils.pageXY(e2).y;
          $7(document).on(
            "touchmove",
            (e3) => {
              this.scrollTop -= o2.scrollSpeed * (pageY > Metro2.utils.pageXY(e3).y ? -1 : 1);
              pageY = Metro2.utils.pageXY(e3).y;
            },
            { ns: that.id }
          );
          $7(document).on(
            "touchend",
            () => {
              $7(document).off(Metro2.events.move, { ns: that.id });
              $7(document).off(Metro2.events.stop, { ns: that.id });
            },
            { ns: that.id }
          );
        });
        picker.on(Metro2.events.click, (e2) => {
          if (that.isOpen === false) that.open();
          e2.stopPropagation();
        });
        picker.on(Metro2.events.click, ".action-ok", (e2) => {
          const sh = picker.find(".sel-hours li.active");
          const sm = picker.find(".sel-minutes li.active");
          const ss = picker.find(".sel-seconds li.active");
          const h3 = sh.length === 0 ? 0 : sh.data("value");
          const m5 = sm.length === 0 ? 0 : sm.data("value");
          const s2 = ss.length === 0 ? 0 : ss.data("value");
          that.value = [h3, m5, s2];
          that._normalizeValue();
          that._set();
          that.close();
          e2.stopPropagation();
        });
        picker.on(Metro2.events.click, ".action-cancel", (e2) => {
          that.close();
          e2.stopPropagation();
        });
        const scrollLatency = 150;
        $7.each(["hours", "minutes", "seconds"], function() {
          const list = picker.find(`.sel-${this}`);
          const scrollFn = Hooks.useDebounce((e2) => {
            let target;
            that.listTimer[this] = null;
            target = Math.round(Math.ceil(list.scrollTop()) / 40);
            if (this === "hours" && o2.hoursStep) {
              target *= Number.parseInt(o2.hoursStep);
            }
            if (this === "minutes" && o2.minutesStep) {
              target *= Number.parseInt(o2.minutesStep);
            }
            if (this === "seconds" && o2.secondsStep) {
              target *= Number.parseInt(o2.secondsStep);
            }
            const targetElement = list.find(`.js-${this}-${target}`);
            const scrollTop = targetElement.position().top - o2.distance * 40;
            list.find(".active").removeClass("active");
            list[0].scrollTop = scrollTop;
            targetElement.addClass("active");
            Metro2.utils.exec(o2.onScroll, [targetElement, list, picker], list[0]);
          }, scrollLatency);
          list.on("scroll", scrollFn);
        });
        picker.on(Metro2.events.click, "ul li", function(e2) {
          const target = $7(this);
          const list = target.closest("ul");
          const scrollTop = target.position().top - o2.distance * 40;
          list.find(".active").removeClass("active");
          $7.animate({
            el: list[0],
            draw: {
              scrollTop
            },
            dur: 300
          });
          list[0].scrollTop = scrollTop;
          target.addClass("active");
          Metro2.utils.exec(o2.onScroll, [target, list, picker], list[0]);
        });
        picker.on(Metro2.events.click, ".action-now", (e2) => {
          const now = datetime();
          const hour = now.hour();
          const minute = now.minute();
          const second = now.second();
          picker.find(`.sel-hours li.js-hours-${hour}`).click();
          picker.find(`.sel-minutes li.js-minutes-${minute}`).click();
          picker.find(`.sel-seconds li.js-seconds-${second}`).click();
          e2.preventDefault();
          e2.stopPropagation();
        });
      },
      _set: function() {
        const element2 = this.element;
        const o2 = this.options;
        const picker = this.picker;
        let h3 = "00";
        let m5 = "00";
        let s2 = "00";
        if (o2.hours === true) {
          h3 = Number.parseInt(this.value[0]);
          picker.find(".hours").html(Str.lpad(h3, "0", 2));
        }
        if (o2.minutes === true) {
          m5 = Number.parseInt(this.value[1]);
          picker.find(".minutes").html(Str.lpad(m5, "0", 2));
        }
        if (o2.seconds === true) {
          s2 = Number.parseInt(this.value[2]);
          picker.find(".seconds").html(Str.lpad(s2, "0", 2));
        }
        element2.val([h3, m5, s2].join(":")).trigger("change");
        this._fireEvent("set", {
          val: this.value,
          elementVal: element2.val()
        });
      },
      open: function() {
        const o2 = this.options;
        const picker = this.picker;
        let h3;
        let m5;
        let s2;
        let h_list;
        let m_list;
        let s_list;
        const items = picker.find("li");
        const select_wrapper = picker.find(".select-wrapper");
        let h_item;
        let m_item;
        let s_item;
        $7.each($7(".time-picker"), function() {
          $7(this).find("input").each(function() {
            Metro2.getPlugin(this, "timepicker").close();
          });
        });
        select_wrapper.show(0);
        items.removeClass("active");
        if (o2.openMode === "auto") {
          if (!Metro2.utils.inViewport(select_wrapper[0])) {
            select_wrapper.parent().addClass("drop-up-select");
          }
          if (!Metro2.utils.inViewport(select_wrapper[0])) {
            select_wrapper.parent().removeClass("drop-up-select");
            select_wrapper.parent().addClass("drop-as-dialog");
          }
        } else {
          if (o2.openMode === "dialog") {
            select_wrapper.parent().addClass("drop-as-dialog");
          } else if (o2.openMode === "up") {
            select_wrapper.parent().addClass("drop-up-select");
          }
        }
        const animateList = (list, item) => {
          list.scrollTop(0).animate({
            draw: {
              scrollTop: item.position().top - o2.distance * 40 + list.scrollTop()
            },
            dur: 100
          });
        };
        if (o2.hours === true) {
          h3 = Number.parseInt(this.value[0]);
          h_list = picker.find(".sel-hours");
          h_item = h_list.find(`li.js-hours-${h3}`).addClass("active");
          animateList(h_list, h_item);
        }
        if (o2.minutes === true) {
          m5 = Number.parseInt(this.value[1]);
          m_list = picker.find(".sel-minutes");
          m_item = m_list.find(`li.js-minutes-${m5}`).addClass("active");
          animateList(m_list, m_item);
        }
        if (o2.seconds === true) {
          s2 = Number.parseInt(this.value[2]);
          s_list = picker.find(".sel-seconds");
          s_item = s_list.find(`li.js-seconds-${s2}`).addClass("active");
          animateList(s_list, s_item);
        }
        this.isOpen = true;
        this._fireEvent("open", {
          val: this.value
        });
      },
      close: function() {
        const picker = this.picker;
        const o2 = this.options;
        picker.find(".select-wrapper").hide(0);
        if (o2.openMode === "auto") {
          picker.find(".select-wrapper").parent().removeClass("drop-up-select drop-as-dialog");
        }
        this.isOpen = false;
        this._fireEvent("close", {
          val: this.value
        });
      },
      _convert: (t) => {
        let result;
        if (Array.isArray(t)) {
          result = t;
        } else if (typeof t.getMonth === "function") {
          result = [t.getHours(), t.getMinutes(), t.getSeconds()];
        } else if (Metro2.utils.isObject(t)) {
          result = [t.h, t.m, t.s];
        } else {
          result = t.toArray(":");
        }
        return result;
      },
      val: function(t) {
        if (t === void 0) {
          return this.element.val();
        }
        this.value = this._convert(t);
        this._normalizeValue();
        this._set();
      },
      time: function(t) {
        if (t === void 0) {
          return {
            h: this.value[0],
            m: this.value[1],
            s: this.value[2]
          };
        }
        this.value = this._convert(t);
        this._normalizeValue();
        this._set();
      },
      date: function(t) {
        if (t === void 0 || typeof t.getMonth !== "function") {
          return datetime().hour(this.value[0]).minute(this.value[1]).second(this.value[2]).ms(0).val();
        }
        this.value = this._convert(t);
        this._normalizeValue();
        this._set();
      },
      disable: function() {
        this.element.data("disabled", true);
        this.element.parent().addClass("disabled");
      },
      enable: function() {
        this.element.data("disabled", false);
        this.element.parent().removeClass("disabled");
      },
      toggleState: function() {
        if (this.elem.disabled) {
          this.disable();
        } else {
          this.enable();
        }
      },
      changeAttribute: function(attr, newValue) {
        switch (attr) {
          case "data-value":
            this.val(newValue);
            break;
          case "disabled":
            this.toggleState();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const picker = this.picker;
        $7.each(["hours", "minutes", "seconds"], function() {
          picker.find(`.sel-${this}`).off("scroll");
        });
        picker.off(Metro2.events.start, ".select-block ul");
        picker.off(Metro2.events.click);
        picker.off(Metro2.events.click, ".action-ok");
        picker.off(Metro2.events.click, ".action-cancel");
        element2.remove();
      }
    });
    $7(document).on(Metro2.events.click, () => {
      $7.each($7(".time-picker"), function() {
        $7(this).find("input").each(function() {
          Metro2.getPlugin(this, "timepicker").close();
        });
      });
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/toast/toast.js
  ((Metro2, $7) => {
    "use strict";
    const TOAST_TIMEOUT = 3e3;
    const TOAST_DISTANCE = 20;
    const TOAST_DURATION = 200;
    Metro2.TOAST_POSITION = {
      TOP: "top",
      BOTTOM: "bottom",
      CENTER: "center"
    };
    let ToastDefaultConfig = {
      callback: Metro2.noop,
      timeout: TOAST_TIMEOUT,
      distance: TOAST_DISTANCE,
      position: Metro2.TOAST_POSITION.BOTTOM,
      // top, bottom, center
      clsToast: ""
    };
    Metro2.toastSetup = (options) => {
      ToastDefaultConfig = $7.extend({}, ToastDefaultConfig, options);
    };
    if (typeof globalThis.metroToastSetup !== "undefined") {
      Metro2.toastSetup(globalThis.metroToastSetup);
    }
    const Toast = {
      create: (message, opt2) => {
        let o2;
        let toast;
        if (typeof opt2 === "function") {
          opt2 = $7.extend({}, ToastDefaultConfig, { callback: opt2 });
        }
        o2 = $7.extend({}, ToastDefaultConfig, opt2);
        toast = $7("<div>").addClass("toast").html(message).appendTo($7("body"));
        const width = toast.outerWidth();
        if (o2.position === "top") {
          toast.addClass("show-top").css({
            top: o2.distance
          });
        } else if (o2.position === "center") {
          toast.addClass("show-center");
        } else {
          toast.css({
            bottom: o2.distance
          });
        }
        toast.css({
          left: "50%",
          "margin-left": -(width / 2)
        }).addClass(o2.clsToast).fadeIn(TOAST_DURATION, () => {
          setTimeout(() => {
            Toast.remove(toast, o2.callback);
          }, o2.timeout);
        });
      },
      remove: (toast, cb) => {
        if (!toast.length) return;
        toast.fadeOut(TOAST_DURATION, () => {
          toast.remove();
          Metro2.utils.exec(cb, null, toast[0]);
        });
      }
    };
    Metro2.toast = Toast;
    Metro2.createToast = Toast.create;
  })(Metro, Dom);

  // ../metroui-lib/source/components/toggle-button/toggle-button.js
  ((Metro2, $7) => {
    "use strict";
    let ToggleButtonDefaultConfig = {
      onChange: Metro2.noop,
      onButtonClick: Metro2.noop,
      onToggleButtonCreate: Metro2.noop
    };
    Metro2.toggleButtonSetup = (options) => {
      ToggleButtonDefaultConfig = $7.extend({}, ToggleButtonDefaultConfig, options);
    };
    if (typeof window.metroToggleButtonSetup !== "undefined") {
      Metro2.toggleButtonSetup(window.metroToggleButtonSetup);
    }
    Metro2.Component("toggle-button", {
      init: function(options, elem) {
        this._super(elem, options, ToggleButtonDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("toggle-buttons-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        element2.addClass("toggle-button");
        const buttons = element2.children("button.active");
        if (buttons.length === 0) {
          element2.children("button").first().addClass("active");
        }
        if (buttons.length > 1) {
          buttons.removeClass("active");
          buttons.first().addClass("active");
        }
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        element2.on("click", "button", function() {
          const toggleButton = $7(this);
          that._fireEvent("button-click", { button: toggleButton });
          if (toggleButton.hasClass("active")) {
            return;
          }
          element2.find("button").removeClass("active");
          toggleButton.addClass("active");
          that._fireEvent("change", { button: toggleButton });
        });
      },
      changeAttribute: (attr, newValue) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/tokenizer/tokenizer.js
  ((Metro2, $7) => {
    "use strict";
    let TokenizerDefaultConfig = {
      textToTokenize: "",
      spaceSymbol: "",
      spaceClass: "space",
      tokenClass: "",
      splitter: "",
      tokenElement: "span",
      useTokenSymbol: true,
      useTokenIndex: true,
      clsTokenizer: "",
      clsToken: "",
      clsTokenOdd: "",
      clsTokenEven: "",
      onTokenCreate: Metro2.noop,
      onTokenize: Metro2.noop,
      onTokenizerCreate: Metro2.noop
    };
    Metro2.tokenizerSetup = (options) => {
      TokenizerDefaultConfig = $7.extend({}, TokenizerDefaultConfig, options);
    };
    if (typeof globalThis.metroTokenizerSetup !== "undefined") {
      Metro2.tokenizerSetup(globalThis.metroTokenizerSetup);
    }
    Metro2.Component("tokenizer", {
      init: function(options, elem) {
        this._super(elem, options, TokenizerDefaultConfig, {
          // define instance vars here
          originalText: ""
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        this.originalText = o2.textToTokenize ? o2.textToTokenize.trim() : element2.text().trim().replace(/[\r\n\t]/gi, "").replace(/\s\s+/g, " ");
        this._createStructure();
        this._fireEvent("tokenizer-create");
      },
      _tokenize: function() {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        let index = 0;
        let append;
        let prepend;
        element2.clear().attr("aria-label", this.originalText);
        $7.each(this.originalText.split(o2.splitter), function(i3) {
          const isSpace = this === " ";
          let token;
          token = $7(`<${o2.tokenElement}>`).html(isSpace ? o2.spaceSymbol : this).attr("aria-hidden", true).addClass(isSpace ? o2.spaceClass : "").addClass(isSpace && o2.useTokenSymbol ? "" : `ts-${this.replace(" ", "_")}`).addClass(isSpace && o2.useTokenIndex ? "" : `ti-${i3 + 1}`).addClass(o2.tokenClass ? o2.tokenClass : "").addClass(!isSpace ? o2.clsToken : "");
          if (!isSpace) {
            index++;
            token.addClass(index % 2 === 0 ? "te-even" : "te-odd");
            token.addClass(index % 2 === 0 ? o2.clsTokenEven : o2.clsTokenOdd);
          }
          if (o2.prepend) {
            prepend = $7.isSelector(o2.prepend) ? $7(o2.prepend) : $7("<span>").html(o2.prepend);
            token.prepend(prepend);
          }
          if (o2.append) {
            append = $7.isSelector(o2.append) ? $7(o2.append) : $7("<span>").html(o2.append);
            token.append(append);
          }
          element2.append(token);
          that._fireEvent("token-create", {
            token: token[0]
          });
        });
        that._fireEvent("tokenize", {
          tokens: element2.children().items(),
          originalText: this.originalText
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass(o2.clsTokenizer);
        this._tokenize();
      },
      tokenize: function(v5) {
        this.originalText = v5;
        this._tokenize();
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/treeview/treeview.js
  ((Metro2, $7) => {
    "use strict";
    let TreeViewDefaultConfig = {
      treeviewDeferred: 0,
      showChildCount: false,
      duration: 100,
      hideActionsOnLeave: true,
      recheckTimeout: 100,
      leaves: [],
      onNodeClick: Metro2.noop,
      onNodeDblClick: Metro2.noop,
      onNodeDelete: Metro2.noop,
      onNodeInsert: Metro2.noop,
      onNodeClean: Metro2.noop,
      onCheckClick: Metro2.noop,
      onRadioClick: Metro2.noop,
      onExpandNode: Metro2.noop,
      onCollapseNode: Metro2.noop,
      onTreeViewCreate: Metro2.noop
    };
    Metro2.treeViewSetup = (options) => {
      TreeViewDefaultConfig = $7.extend({}, TreeViewDefaultConfig, options);
    };
    if (typeof globalThis.metroTreeViewSetup !== "undefined") {
      Metro2.treeViewSetup(globalThis.metroTreeViewSetup);
    }
    Metro2.Component("tree-view", {
      init: function(options, elem) {
        this._super(elem, options, TreeViewDefaultConfig);
        return this;
      },
      _create: function() {
        const that = this;
        const element2 = this.element;
        this._createTree();
        this._createEvents();
        $7.each(element2.find("input"), function() {
          if (!$7(this).is(":checked")) return;
          that._recheck(this);
        });
        this._fireEvent("tree-view-create", {
          element: element2
        });
      },
      _createIcon: (data) => {
        const src = Metro2.utils.isTag(data) ? $7(data) : $7("<img src='' alt=''>").attr("src", data);
        const icon = $7("<span>").addClass("icon");
        icon.html(src.outerHTML());
        return icon;
      },
      _createCaption: (data, style) => {
        const caption = $7("<span>").addClass("caption").html(data);
        if (style) {
          if (Metro2.utils.isObject(style)) {
            caption.css(style);
          } else if (typeof style === "string") {
            caption[0].style.cssText = style;
          }
        }
        return caption;
      },
      _createToggle: () => $7("<span>").addClass("node-toggle"),
      /*
       * data = {
       *   link: string,
       *   href: string,
       *   caption: string,
       *   icon: string,
       *   html: string,
       *   attributes: {},
       *   style: {} || string,
       *   badge: string,
       *   badges: [],
       *   secondary: string,
       *   actions: [],
       *   type: "" || "node",
       * }
       * */
      _createNode: function(data, target) {
        const o2 = this.options;
        const nodeContainer = target ? target : $7("<li>");
        const node = $7("<a>");
        nodeContainer.prepend(node);
        if (data.link || data.href) {
          node.attr("href", data.link || data.href);
        }
        if (data.caption) {
          node.prepend(this._createCaption(data.caption, data.style));
        }
        if (data.icon) {
          node.prepend(this._createIcon(data.icon));
        }
        if (data.html) {
          node.append(data.html);
        }
        if (data.attributes && $7.type(data.attributes) === "object") {
          for (const key in data.attributes) {
            node.attr(key, data.attributes[key]);
          }
        }
        if (data.style) {
          if (typeof data.style === "string") {
            node[0].style.cssText = data.style;
          } else if ($7.type(data.style) === "object") {
            node.css(data.style);
          }
        }
        if (data.badge) {
          const [badge, className] = data.badge.split(":");
          node.append($7("<span>").addClass("badge").addClass(className).html(badge));
        }
        if (data.badges) {
          $7.each(
            typeof data.badges === "string" ? data.badges.toArray(",") : Array.isArray(data.badges) ? data.badges : [],
            (_5, item) => {
              const [badge, className] = item.split(":");
              node.append($7("<span>").addClass("badge").addClass(className).html(badge));
            }
          );
        }
        if (data.secondary) {
          const [badge, className] = data.secondary.split(":");
          node.append($7("<span>").addClass("secondary-text").addClass(className).html(badge));
        }
        if (data.actions) {
          const actionsHolder = $7("<div class='dropdown-button'>").addClass("actions-holder");
          const actionsListTrigger = $7("<span class='actions-list-trigger'>").text("\u22EE").appendTo(actionsHolder);
          const actionsList = $7("<ul data-role='dropmenu' class='d-menu actions-list'>").appendTo(actionsHolder);
          nodeContainer.append(actionsHolder);
          for (const a2 of data.actions) {
            if (a2.type && a2.type === "divider") {
              $7("<li>").addClass("divider").appendTo(actionsList);
            } else {
              const icon = a2.icon ? $7(a2.icon).addClass("icon").outerHTML() : "";
              const caption = `<span class="caption">${a2.caption}</span>`;
              const li = $7(`<li><a href="#">${icon} ${caption}</a></li>`).appendTo(actionsList);
              if (a2.cls) {
                li.addClass(a2.cls);
              }
              li.find("a").on("click", function() {
                Metro2.utils.exec(a2.onclick, [li[0]], this);
              });
            }
          }
          actionsList.on(Metro2.events.leave, (e2) => {
            if (o2.hideActionsOnLeave) Metro2.getPlugin(actionsList, "dropmenu").close();
          });
        }
        if (data.current) {
          nodeContainer.addClass("current");
        }
        if (data.type === "node") {
          nodeContainer.addClass("tree-node");
          nodeContainer.append($7("<span>").addClass("node-toggle"));
          nodeContainer.append($7("<ul>"));
        }
        if (nodeContainer.children("ul").length) {
          nodeContainer.addClass("tree-node");
          nodeContainer.append($7("<span>").addClass("node-toggle"));
          if (Metro2.utils.bool(data.collapsed) !== true) {
            nodeContainer.addClass("expanded");
          } else {
            nodeContainer.children("ul").hide();
          }
        }
        return nodeContainer;
      },
      _createCheckNode: function(data, target) {
        const node = target ? target : $7("<li>");
        node.append(`
                <input data-role="${data.type}" type="${data.type ?? "checkbox"}" name="${data.name}" value="${data.value ?? ""}" ${data.checked ? "checked" : ""} data-append="${data.caption}"/>
            `);
        if (data.icon) {
          node.find("label").prepend(this._createIcon(data.icon));
        }
        if (data.attributes && $7.type(data.attributes) === "object") {
          for (const key in data.attributes) {
            node.attr(key, data.attributes[key]);
          }
        }
        if (data.secondary) {
          const [badge, className] = data.secondary.split(":");
          node.find("label").append($7("<span>").addClass("secondary-text").addClass(className).html(badge));
        }
        return node;
      },
      _createInputNode: (data, target) => {
        const node = target ? target : $7("<li>");
        node.append(`
                <input data-role="${data.type}" type="${data.type ?? "text"}" name="${data.name}" value="${data.value ?? ""}" data-prepend="${data.caption ?? ""}" placeholder="${data.placeholder ?? ""}"/>
            `);
        if (data.secondary) {
          const [badge, className] = data.secondary.split(":");
          node.find("label").append($7("<span>").addClass("secondary-text").addClass(className).html(badge));
        }
        return node;
      },
      _createTree: function() {
        const element2 = this.element;
        const o2 = this.options;
        const nodes = element2.find("li[data-caption]");
        element2.addClass("treeview");
        $7.each(nodes, (i3, _el) => {
          const el = $7(_el);
          if (el.data("type") === "checkbox" || el.data("type") === "radio") {
            this._createCheckNode(
              {
                caption: el.data("caption"),
                icon: el.data("icon"),
                type: el.data("type"),
                name: el.data("name"),
                attributes: el.data("attributes"),
                value: el.data("value"),
                checked: el.data("checked") === "true",
                secondary: el.data("secondary")
              },
              el
            );
          } else if (el.data("type") === "input") {
            this._createInputNode(
              {
                caption: el.data("caption"),
                type: el.data("type"),
                name: el.data("name"),
                attributes: el.data("attributes"),
                value: el.data("value"),
                secondary: el.data("secondary"),
                placeholder: el.data("placeholder")
              },
              el
            );
          } else {
            this._createNode(
              {
                caption: el.data("caption"),
                icon: el.data("icon"),
                html: el.data("html"),
                attributes: el.data("attributes"),
                badge: el.data("badge"),
                badges: el.data("badges"),
                actions: el.data("actions"),
                type: el.data("type"),
                collapsed: el.data("collapsed"),
                link: el.data("link"),
                href: el.data("href"),
                secondary: el.data("secondary"),
                style: el.data("style")
              },
              el
            );
          }
        });
        if (o2.leaves) {
          const leaves = Metro2.utils.isObject(o2.leaves);
          if (leaves) {
            this.fillTree(leaves);
          }
        }
        this._recheckTree();
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        element2.on(Metro2.events.click, ".node-toggle", function(e2) {
          const toggle = $7(this);
          const node = toggle.parent();
          that.toggleNode(node);
          e2.preventDefault();
        });
        element2.on(Metro2.events.click, "a", function(e2) {
          const node = $7(this).parent();
          that.current(node);
          that._fireEvent("node-click", {
            node: node[0]
          });
          e2.preventDefault();
        });
        element2.on(Metro2.events.dblclick, "a", function(e2) {
          const node = $7(this).closest("li");
          const toggle = node.children(".node-toggle");
          const subtree = node.children("ul");
          if (toggle.length > 0 || subtree.length > 0) {
            that.toggleNode(node);
          }
          that._fireEvent("node-dbl-click", {
            node: node[0]
          });
          e2.preventDefault();
        });
        element2.on(Metro2.events.click, "input[type=radio]", function() {
          const check = $7(this);
          const checked = check.is(":checked");
          const node = check.closest("li");
          that.current(node);
          that._fireEvent("radio-click", {
            checked,
            check: check[0],
            node: node[0]
          });
        });
        element2.on(Metro2.events.click, "input[type=checkbox]", function() {
          const check = $7(this);
          const checked = check.is(":checked");
          const node = check.closest("li");
          that._recheck(check);
          that._fireEvent("check-click", {
            checked,
            check: check[0],
            node: node[0]
          });
        });
      },
      _recheck: function(check_element) {
        const check = $7(check_element);
        const checked = check.is(":checked");
        const node = check.closest("li");
        this.current(node);
        const checks = check.closest("li").find("ul input[type=checkbox]");
        checks.attr("data-indeterminate", false);
        checks.prop("indeterminate", false);
        checks.prop("checked", checked);
        checks.trigger("change");
        this._recheckTree();
      },
      _recheckTree: function(timeout) {
        setTimeout(() => {
          const element2 = this.element;
          const all_checks = element2.find("input[type=checkbox]").reverse();
          $7.each(all_checks.reverse(), function() {
            const ch = $7(this);
            const children = ch.closest("li").children("ul").find("input[type=checkbox]").length;
            const children_checked = ch.closest("li").children("ul").find("input[type=checkbox]").filter((el) => el.checked).length;
            if (children > 0 && children_checked === 0) {
              ch.attr("data-indeterminate", false);
              ch.prop("indeterminate", false);
              ch.prop("checked", false);
              ch.trigger("change");
            }
            if (children_checked === 0) {
              ch.attr("data-indeterminate", false);
              ch.prop("indeterminate", false);
            } else {
              if (children_checked > 0 && children > children_checked) {
                ch.attr("data-indeterminate", true);
                ch.prop("indeterminate", true);
              } else if (children === children_checked) {
                ch.attr("data-indeterminate", false);
                ch.prop("indeterminate", false);
                ch.prop("checked", true);
                ch.trigger("change");
              }
            }
          });
        }, timeout ?? this.options.recheckTimeout);
      },
      current: function(node) {
        const element2 = this.element;
        if (!node) {
          return element2.find(".current");
        }
        element2.find(".current").removeClass("current");
        node.addClass("current");
      },
      toggleNode: function(n3) {
        const node = $7(n3);
        const o2 = this.options;
        const toBeExpanded = !node.data("collapsed");
        node.toggleClass("expanded");
        node.data("collapsed", toBeExpanded);
        const func = toBeExpanded === true ? "slideUp" : "slideDown";
        if (!toBeExpanded) {
          this._fireEvent("expand-node", {
            node: node[0]
          });
        } else {
          this._fireEvent("collapse-node", {
            node: node[0]
          });
        }
        node.children("ul")[func](o2.duration);
      },
      addTo: function(target_node, data) {
        const element2 = this.element;
        let target;
        let new_node;
        let toggle;
        let node;
        if (!target_node) {
          target = element2;
        } else {
          node = $7(target_node);
          target = node.children("ul");
          if (target.length === 0) {
            target = $7("<ul>").appendTo(node);
            toggle = this._createToggle();
            toggle.appendTo(node);
            node.addClass("expanded");
          }
          node?.addClass("tree-node");
        }
        if (data.type === "checkbox" || data.type === "radio") {
          new_node = this._createCheckNode(data);
        } else if (data.type === "input") {
          new_node = this._createInputNode(data);
        } else {
          new_node = this._createNode(data);
        }
        new_node.appendTo(target);
        this._fireEvent("node-insert", {
          node: new_node[0],
          parent: node ? node[0] : null
        });
        this._recheckTree();
        return new_node;
      },
      insertBefore: function(target_node, data) {
        const new_node = this._createNode(data);
        if (!target_node) {
          return this.addTo(void 0, data);
        }
        const node = $7(target_node);
        new_node.insertBefore(node);
        this._fireEvent("node-insert", {
          node: new_node[0],
          parent: node ? node[0] : null
        });
        return new_node;
      },
      insertAfter: function(target_node, data) {
        const new_node = this._createNode(data);
        if (!target_node) {
          return this.addTo(void 0, data);
        }
        const node = $7(target_node);
        new_node.insertAfter(node);
        this._fireEvent("node-insert", {
          node: new_node[0],
          parent: node[0]
        });
        return new_node;
      },
      del: function(target_node) {
        const element2 = this.element;
        const node = $7(target_node);
        const parent_list = node.closest("ul");
        const parent_node = parent_list.closest("li");
        this._fireEvent("node-delete", {
          node: node[0]
        });
        node.remove();
        if (parent_list.children().length === 0 && !parent_list.is(element2)) {
          parent_list.remove();
          parent_node.removeClass("expanded");
          parent_node.children(".node-toggle").remove();
        }
        this._recheckTree();
      },
      clean: function(target_node) {
        const node = $7(target_node);
        node.children("ul").remove();
        node.removeClass("expanded");
        node.children(".node-toggle").remove();
        this._fireEvent("node-clean", {
          node: node[0]
        });
      },
      collapseNode(target_node) {
        const o2 = this.options;
        const node = $7(target_node);
        node.removeClass("expanded");
        node.data("collapsed", true);
        node.children("ul").slideUp(o2.duration);
        this._fireEvent("collapse-node", {
          node: node[0]
        });
      },
      expandNode(target_node) {
        const o2 = this.options;
        const node = $7(target_node);
        if (!node.hasClass("tree-node")) {
          return;
        }
        node.addClass("expanded");
        node.data("collapsed", false);
        node.children("ul").slideDown(o2.duration);
        this._fireEvent("expand-node", {
          node: node[0]
        });
      },
      collapseAll() {
        const element2 = this.element;
        const o2 = this.options;
        element2.find(".expanded").each((_5, el) => {
          const node = $7(el);
          const toBeExpanded = !node.data("collapsed");
          node.toggleClass("expanded");
          node.data("collapsed", toBeExpanded);
          const func = toBeExpanded === true ? "slideUp" : "slideDown";
          if (!toBeExpanded) {
            this._fireEvent("expand-node", {
              node: node[0]
            });
          } else {
            this._fireEvent("collapse-node", {
              node: node[0]
            });
          }
          node.children("ul")[func](o2.duration);
        });
        this._fireEvent("collapse-all");
      },
      expandAll() {
        const element2 = this.element;
        const o2 = this.options;
        element2.find(".tree-node:not(.expanded)").each((_5, el) => {
          const node = $7(el);
          const toBeExpanded = !node.data("collapsed");
          node.toggleClass("expanded");
          node.data("collapsed", toBeExpanded);
          const func = toBeExpanded === true ? "slideUp" : "slideDown";
          if (!toBeExpanded) {
            this._fireEvent("expand-node", {
              node: node[0]
            });
          } else {
            this._fireEvent("collapse-node", {
              node: node[0]
            });
          }
          node.children("ul")[func](o2.duration);
        });
        this._fireEvent("expand-all");
      },
      fillTree: function(leaves, node) {
        for (const leaf of leaves) {
          const new_node = this.addTo(node, {
            ...leaf,
            type: leaf.items ? "node" : "item"
          });
          if (leaf.items) {
            this.fillTree(leaf.items, new_node);
          }
        }
      },
      changeAttribute: function(attr, value) {
        if (attr === "data-recheck-timeout") {
          this.options.recheckTimeout = value ?? 100;
        }
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, ".node-toggle");
        element2.off(Metro2.events.click, "li > .caption");
        element2.off(Metro2.events.dblclick, "li > .caption");
        element2.off(Metro2.events.click, "input[type=radio]");
        element2.off(Metro2.events.click, "input[type=checkbox]");
        element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/validator/validator.js
  ((Metro2, $7) => {
    "use strict";
    const ValidatorFuncs = {
      required: (val) => G.safeParse(G.required(), val).ok,
      length: (val, len) => G.safeParse(G.length(+len), val).ok,
      minlength: (val, len) => G.safeParse(G.minLength(+len), val).ok,
      maxlength: (val, len) => G.safeParse(G.maxLength(+len), val).ok,
      min: (val, min_value) => G.safeParse(G.min(+min_value), +val).ok,
      max: (val, max_value) => G.safeParse(G.max(+max_value), +val).ok,
      email: (val) => G.safeParse(G.email(), val).ok,
      domain: (val) => G.safeParse(G.domain(), val).ok,
      url: (val) => G.safeParse(G.url(), val).ok,
      date: (val, format, locale) => {
        try {
          const _d = !format ? datetime(val) : Datetime.from(val, format, locale);
          return !format ? true : _d.format(format, locale) === val;
        } catch {
          return false;
        }
      },
      number: (val) => G.safeParse(G.number(), +val).ok,
      integer: (val) => G.safeParse(G.integer(), +val).ok,
      safeInteger: (val) => G.safeParse(G.safeInteger(), +val).ok,
      float: (val) => G.safeParse(G.float(), +val).ok,
      digits: (val) => G.safeParse(G.digits(), val).ok,
      hexcolor: (val) => G.safeParse(G.hexColor(), val).ok,
      color: (val) => {
        if (!Metro2.utils.isValue(val)) return false;
        return Farbe.Palette.color(val, Farbe.StandardColors) || Farbe.Routines.isColor(val);
      },
      pattern: (val, pat) => G.safeParse(G.pattern(pat), val).ok,
      // biome-ignore lint/suspicious/noDoubleEquals: required for compare
      compare: (val, val2) => val == val2,
      // biome-ignore lint/suspicious/noDoubleEquals: required for compare
      not: (val, not_this) => val != not_this,
      notequals: (val, val2) => val !== val2,
      equals: (val, val2) => val === val2,
      custom: (val, func) => {
        if (Metro2.utils.isFunc(func) === false) {
          return false;
        }
        return Metro2.utils.exec(func, [val]);
      },
      is_control: (el) => el.attr("data-role"),
      reset_state: (el) => {
        const input = $7(el);
        const is_control = ValidatorFuncs.is_control(input);
        if (is_control) {
          input.parent().removeClass("invalid valid");
        } else {
          input.removeClass("invalid valid");
        }
      },
      set_valid_state: (el) => {
        const input = $7(el);
        const is_control = ValidatorFuncs.is_control(input);
        if (is_control) {
          input.parent().addClass("valid");
        } else {
          input.addClass("valid");
        }
      },
      set_invalid_state: (el) => {
        const input = $7(el);
        const is_control = ValidatorFuncs.is_control(input);
        if (is_control) {
          input.parent().addClass("invalid");
        } else {
          input.addClass("invalid");
        }
      },
      reset: function(form) {
        const that = this;
        $7.each($7(form).find("[data-validate]"), function() {
          that.reset_state(this);
        });
        return this;
      },
      validate: function(el, result, cb_ok, cb_error, required_mode) {
        let this_result = true;
        const input = $7(el);
        const funcs = input.data("validate") !== void 0 ? String(input.data("validate")).split(" ").map((s2) => s2.trim()) : [];
        const errors = [];
        const hasForm = input.closest("form").length > 0;
        let attr_name;
        let radio_checked;
        if (funcs.length === 0) {
          return true;
        }
        this.reset_state(input);
        if (input.attr("type") && input.attr("type").toLowerCase() === "checkbox") {
          if (funcs.indexOf("required") === -1) {
            this_result = true;
          } else {
            this_result = input.is(":checked");
          }
          if (this_result === false) {
            errors.push("required");
          }
          if (result !== void 0) {
            result.val += this_result ? 0 : 1;
          }
        } else if (input.attr("type") && input.attr("type").toLowerCase() === "radio") {
          attr_name = input.attr("name");
          if (typeof attr_name === "undefined") {
            this_result = true;
          } else {
            radio_checked = $7(`input[name=${attr_name.replace("[", "\\[").replace("]", "\\]")}]:checked`);
            this_result = radio_checked.length > 0;
          }
          if (result !== void 0) {
            result.val += this_result ? 0 : 1;
          }
        } else {
          $7.each(funcs, function() {
            if (this_result === false) return;
            const rule = this.split("=");
            let f5;
            let a2;
            let b5;
            f5 = rule[0];
            rule.shift();
            a2 = rule.join("=");
            if (["compare", "not", "equals", "notequals"].indexOf(f5) > -1) {
              a2 = hasForm ? input[0].form.elements[a2].value : $7(`[name=${a2}]`).val();
            }
            if (f5 === "date") {
              a2 = input.attr("data-value-format");
              b5 = input.attr("data-value-locale");
            }
            if (Metro2.utils.isFunc(ValidatorFuncs[f5]) === false) {
              this_result = true;
            } else {
              if (required_mode === true || f5 === "required") {
                this_result = ValidatorFuncs[f5](input.val(), a2, b5);
              } else {
                if (input.val().trim() !== "") {
                  this_result = ValidatorFuncs[f5](input.val(), a2, b5);
                } else {
                  this_result = true;
                }
              }
            }
            if (this_result === false) {
              errors.push(f5);
            }
            if (result !== void 0) {
              result.val += this_result ? 0 : 1;
            }
          });
        }
        if (this_result === false) {
          this.set_invalid_state(input);
          if (result !== void 0) {
            result.log.push({
              input: input[0],
              name: input.attr("name"),
              value: input.val(),
              funcs,
              errors
            });
          }
          if (cb_error !== void 0) Metro2.utils.exec(cb_error, [input, input.val()], input[0]);
        } else {
          this.set_valid_state(input);
          if (cb_ok !== void 0) Metro2.utils.exec(cb_ok, [input, input.val()], input[0]);
        }
        return this_result;
      }
    };
    Metro2.validator = ValidatorFuncs;
    let ValidatorDefaultConfig = {
      deferred: 500,
      validatorDeferred: 0,
      submitTimeout: 200,
      interactiveCheck: false,
      clearInvalid: 0,
      requiredMode: true,
      useRequiredClass: true,
      onBeforeSubmit: Metro2.noop_true,
      onSubmit: Metro2.noop,
      onError: Metro2.noop,
      onValidate: Metro2.noop,
      onErrorForm: Metro2.noop,
      onValidateForm: Metro2.noop,
      onValidatorCreate: Metro2.noop
    };
    Metro2.validatorSetup = (options) => {
      ValidatorDefaultConfig = $7.extend({}, ValidatorDefaultConfig, options);
    };
    if (typeof globalThis.metroValidatorSetup !== "undefined") {
      Metro2.validatorSetup(globalThis.metroValidatorSetup);
    }
    Metro2.Component("validator", {
      init: function(options, elem) {
        this._super(elem, options, ValidatorDefaultConfig, {
          _onsubmit: null,
          _onreset: null,
          result: []
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        const inputs = element2.find("[data-validate]");
        element2.attr("novalidate", "novalidate");
        setTimeout(() => {
          $7.each(inputs, function() {
            const input = $7(this);
            const funcs = input.data("validate");
            const required2 = funcs.includes("required");
            if (required2 && o2.useRequiredClass === true) {
              if (ValidatorFuncs.is_control(input)) {
                input.parent().addClass("required");
              } else {
                input.addClass("required");
              }
            }
            if (o2.interactiveCheck === true) {
              input.on(Metro2.events.inputchange, function() {
                ValidatorFuncs.validate(this, void 0, void 0, void 0, o2.requiredMode);
              });
            }
          });
          this._onsubmit = null;
          this._onreset = null;
          if (element2[0].onsubmit !== null) {
            this._onsubmit = element2[0].onsubmit;
            element2[0].onsubmit = null;
          }
          if (element2[0].onreset !== null) {
            this._onreset = element2[0].onreset;
            element2[0].onreset = null;
          }
          element2[0].onsubmit = () => this._submit();
          element2[0].onreset = () => this._reset();
          this._fireEvent("validator-create", {
            element: element2
          });
        }, o2.deferred);
      },
      _reset: function() {
        ValidatorFuncs.reset(this.element);
        if (this._onreset !== null) Metro2.utils.exec(this._onreset, null, this.element[0]);
      },
      _submit: function() {
        const element2 = this.element;
        const o2 = this.options;
        const form = this.elem;
        const inputs = element2.find("[data-validate]");
        const submit = element2.find("input[type=submit], button[type=submit]");
        const result = {
          val: 0,
          log: []
        };
        const formData = $7.serializeToArray(element2);
        if (submit.length > 0) {
          submit.attr("disabled", "disabled").addClass("disabled");
        }
        $7.each(inputs, function() {
          ValidatorFuncs.validate(this, result, o2.onValidate, o2.onError, o2.requiredMode);
        });
        submit.removeAttr("disabled").removeClass("disabled");
        result.val += Metro2.utils.exec(o2.onBeforeSubmit, [formData], this.elem) === false ? 1 : 0;
        if (result.val === 0) {
          this._fireEvent("validate-form", {
            data: formData
          });
          setTimeout(() => {
            Metro2.utils.exec(o2.onSubmit, [formData], form);
            element2.fire("formsubmit", {
              data: formData
            });
            if (this._onsubmit !== null) Metro2.utils.exec(this._onsubmit, null, form);
          }, o2.submitTimeout);
        } else {
          this._fireEvent("error-form", {
            log: result.log,
            data: formData
          });
          if (o2.clearInvalid > 0) {
            setTimeout(() => {
              $7.each(inputs, function() {
                const inp = $7(this);
                if (ValidatorFuncs.is_control(inp)) {
                  inp.parent().removeClass("invalid");
                } else {
                  inp.removeClass("invalid");
                }
              });
            }, o2.clearInvalid);
          }
        }
        return result.val === 0;
      },
      changeAttribute: () => {
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/vegas/vegas.js
  ((Metro2, $7) => {
    "use strict";
    let VegasDefaultConfig = {
      duration: 4e3,
      animationDuration: null,
      transitionDuration: null,
      transition: "fade",
      animation: null,
      slides: [],
      shuffle: false,
      align: "center",
      valign: "center",
      loop: true,
      autoplay: true,
      mute: true,
      cover: true,
      preload: true,
      timer: true,
      overlay: 2,
      color: null,
      volume: 1,
      onPlay: Metro2.noop,
      onPause: Metro2.noop,
      onEnd: Metro2.noop,
      onWalk: Metro2.noop,
      onNext: Metro2.noop,
      onPrev: Metro2.noop,
      onJump: Metro2.noop,
      onVegasCreate: Metro2.noop
    };
    Metro2.vegasSetup = (options) => {
      VegasDefaultConfig = $7.extend({}, VegasDefaultConfig, options);
    };
    if (typeof globalThis.metroVegasSetup !== "undefined") {
      Metro2.vegasSetup(globalThis.metroVegasSetup);
    }
    Metro2.Component("vegas", {
      videoCache: {},
      init: function(options, elem) {
        this.transitions = [
          "fade",
          "fade2",
          "slideLeft",
          "slideLeft2",
          "slideRight",
          "slideRight2",
          "slideUp",
          "slideUp2",
          "slideDown",
          "slideDown2",
          "zoomIn",
          "zoomIn2",
          "zoomOut",
          "zoomOut2",
          "swirlLeft",
          "swirlLeft2",
          "swirlRight",
          "swirlRight2"
        ];
        this.animations = [
          "kenburns",
          "kenburnsUp",
          "kenburnsDown",
          "kenburnsRight",
          "kenburnsLeft",
          "kenburnsUpLeft",
          "kenburnsUpRight",
          "kenburnsDownLeft",
          "kenburnsDownRight"
        ];
        this.support = {
          objectFit: "objectFit" in document.body.style,
          video: !/(Android|webOS|Phone|iPad|iPod|BlackBerry|Windows Phone)/i.test(navigator.userAgent)
        };
        this._super(elem, options, VegasDefaultConfig, {
          slide: 0,
          slides: null,
          total: 0,
          noshow: false,
          paused: false,
          ended: false,
          timer: null,
          overlay: null,
          first: true,
          timeout: false
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        this.slides = Metro2.utils.isObject(o2.slides) || [];
        this.total = this.slides.length;
        this.noshow = this.total < 2;
        this.paused = !o2.autoplay || this.noshow;
        if (o2.shuffle) {
          this.slides.shuffle();
        }
        if (o2.preload) {
          this._preload();
        }
        this._createStructure();
        this._createEvents();
        this._fireEvent("vegas-create", {
          element: element2
        });
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        const isBody = element2[0].tagName === "BODY";
        let wrapper;
        if (!isBody) {
          element2.css("height", element2.css("height"));
          wrapper = $7('<div class="vegas-wrapper">').css("overflow", element2.css("overflow")).css("padding", element2.css("padding"));
          if (!element2.css("padding")) {
            wrapper.css("padding-top", element2.css("padding-top")).css("padding-bottom", element2.css("padding-bottom")).css("padding-left", element2.css("padding-left")).css("padding-right", element2.css("padding-right"));
          }
          element2.children().appendTo(wrapper);
          element2.clear();
        }
        element2.addClass("vegas-container");
        if (!isBody) {
          element2.append(wrapper);
        }
        if (o2.timer) {
          this.timer = $7('<div class="vegas-timer"><div class="vegas-timer-progress">');
          element2.append(this.timer);
        }
        if (o2.overlay) {
          this.overlay = $7('<div class="vegas-overlay">').addClass(
            `overlay${typeof o2.overlay === "boolean" || isNaN(o2.overlay) ? 2 : +o2.overlay}`
          );
          element2.append(this.overlay);
        }
        setTimeout(() => {
          Metro2.utils.exec(o2.onPlay, null, element2[0]);
          this._goto(this.slide);
        }, 1);
      },
      _createEvents: () => {
      },
      _preload: function() {
        let img;
        let i3;
        for (i3 = 0; i3 < this.slides.length; i3++) {
          const obj = this.slides[i3];
          if (obj.src) {
            img = new Image();
            img.src = this.slides[i3].src;
          }
          if (obj.video) {
            if (Array.isArray(obj.video)) {
              this._video(obj.video);
            } else {
              this._video(obj.video.src);
            }
          }
        }
      },
      _slideShow: function() {
        const o2 = this.options;
        if (this.total > 1 && !this.ended && !this.paused && !this.noshow) {
          this.timeout = setTimeout(() => {
            this.next();
          }, o2.duration);
        }
      },
      _timer: function(state2) {
        const o2 = this.options;
        clearTimeout(this.timeout);
        if (!this.timer) {
          return;
        }
        this.timer.removeClass("vegas-timer-running").find("div").css("transition-duration", "0ms");
        if (this.ended || this.paused || this.noshow) {
          return;
        }
        if (state2) {
          setTimeout(() => {
            this.timer.addClass("vegas-timer-running").find("div").css("transition-duration", `${+o2.duration - 100}ms`);
          }, 100);
        }
      },
      _fadeSoundIn: function(video, duration) {
        const o2 = this.options;
        $7.animate({
          el: video,
          draw: {
            volume: +o2.volume
          },
          dur: duration
        });
      },
      _fadeSoundOut: (video, duration) => {
        $7.animate({
          el: video,
          draw: {
            volume: 0
          },
          dur: duration
        });
      },
      _video: function(sources) {
        let source;
        const cacheKey = sources.toString();
        const srcArray = Array.isArray(sources) ? sources : [sources];
        if (this.videoCache[cacheKey]) {
          return this.videoCache[cacheKey];
        }
        const video = document.createElement("video");
        video.preload = true;
        for (const src of srcArray) {
          source = document.createElement("source");
          source.src = src;
          video.appendChild(source);
        }
        this.videoCache[cacheKey] = video;
        return video;
      },
      _goto: function(n3) {
        const that = this;
        const element2 = this.element;
        const o2 = this.options;
        let _n = n3;
        if (typeof this.slides[_n] === "undefined") {
          _n = 0;
        }
        this.slide = _n;
        let $slide;
        let $inner;
        let video;
        let img;
        let $video;
        const slides = element2.children(".vegas-slide");
        const obj = this.slides[n3];
        let cover = o2.cover;
        let transition;
        let animation;
        let transitionDuration;
        let animationDuration;
        if (this.first) {
          this.first = false;
        }
        if (cover !== "repeat") {
          if (cover === true) {
            cover = "cover";
          } else if (cover === false) {
            cover = "contain";
          }
        }
        if (o2.transition === "random") {
          transition = $7.random(this.transitions);
        } else {
          transition = o2.transition ? o2.transition : this.transitions[0];
        }
        if (o2.animation === "random") {
          animation = $7.random(this.animations);
        } else {
          animation = o2.animation ? o2.animation : this.animations[0];
        }
        if (!o2.transitionDuration) {
          transitionDuration = +o2.duration;
        } else if (o2.transitionDuration === "auto" || +o2.transitionDuration > +o2.duration) {
          transitionDuration = +o2.duration;
        } else {
          transitionDuration = +o2.transitionDuration;
        }
        if (!o2.animationDuration) {
          animationDuration = +o2.duration;
        } else if (o2.animationDuration === "auto" || +o2.animationDuration > +o2.duration) {
          animationDuration = +o2.duration;
        } else {
          animationDuration = +o2.animationDuration;
        }
        $slide = $7("<div>").addClass("vegas-slide").addClass(`vegas-transition-${transition}`);
        if (this.support.video && obj.video) {
          video = Array.isArray(obj.video) ? this._video(obj.video) : this._video(obj.video.src);
          video.loop = obj.video.loop ? obj.video.loop : o2.loop;
          video.muted = obj.video.mute ? obj.video.mute : o2.mute;
          if (!video.muted) {
            this._fadeSoundIn(video, transitionDuration);
          } else {
            video.pause();
          }
          $video = $7(video).addClass("vegas-video").css("background-color", o2.color || "#000000");
          if (this.support.objectFit) {
            $video.css("object-position", `${o2.align} ${o2.valign}`).css("object-fit", cover).css("width", "100%").css("height", "100%");
          } else if (cover === "contain") {
            $video.css("width", "100%").css("height", "100%");
          }
          $slide.append($video);
        } else {
          img = new Image();
          $inner = $7("<div>").addClass("vegas-slide-inner").css({
            backgroundImage: `url("${obj.src}")`,
            backgroundColor: o2.color || "#000000",
            backgroundPosition: `${o2.align} ${o2.valign}`
          });
          if (cover === "repeat") {
            $inner.css("background-repeat", "repeat");
          } else {
            $inner.css("background-size", cover);
          }
          if (animation) {
            $inner.addClass(`vegas-animation-${animation}`).css("animation-duration", `${animationDuration}ms`);
          }
          $slide.append($inner);
        }
        if (slides.length) {
          slides.eq(slides.length - 1).after($slide);
        } else {
          element2.prepend($slide);
        }
        slides.css("transition", "all 0ms").each(function() {
          this.className = "vegas-slide";
          if (this.tagName === "VIDEO") {
            this.className += " vegas-video";
          }
          if (transition) {
            this.className += ` vegas-transition-${transition}`;
            this.className += ` vegas-transition-${transition}-in`;
          }
        });
        this._timer(false);
        function go2() {
          that._timer(true);
          setTimeout(() => {
            slides.css("transition", `all ${transitionDuration}ms`).addClass(`vegas-transition-${transition}-out`);
            slides.each(() => {
              const video2 = slides.find("video").get(0);
              if (video2) {
                video2.volume = 1;
                that._fadeSoundOut(video2, transitionDuration);
              }
            });
            $slide.css("transition", `all ${transitionDuration}ms`).addClass(`vegas-transition-${transition}-in`);
            for (let i3 = 0; i3 < slides.length - 1; i3++) {
              slides.eq(i3).remove();
            }
            that._fireEvent("walk", {
              slide: that.current(true)
            });
            that._slideShow();
          }, 100);
        }
        if (video) {
          if (video.readyState === 4) {
            video.currentTime = 0;
          }
          video.play();
          go2();
        } else {
          img.src = obj.src;
          if (img.complete) {
            go2();
          } else {
            img.onload = go2;
          }
        }
      },
      _end: function() {
        this.ended = this.options.autoplay;
        this._timer(false);
        this._fireEvent("end", {
          slide: this.current(true)
        });
      },
      play: function() {
        if (!this.paused) {
          return;
        }
        this._fireEvent("play", {
          slide: this.current(true)
        });
        this.paused = false;
        this.next();
      },
      pause: function() {
        this._timer(false);
        this.paused = true;
        this._fireEvent("pause", {
          slide: this.current(true)
        });
      },
      toggle: function() {
        this.paused ? this.play() : this.pause();
      },
      playing: function() {
        return !this.paused && !this.noshow;
      },
      current: function(advanced) {
        if (advanced) {
          return {
            slide: this.slide,
            data: this.slides[this.slide]
          };
        }
        return this.slide;
      },
      jump: function(n3) {
        if (n3 <= 0 || n3 > this.slides.length || n3 === this.slide + 1) {
          return this;
        }
        this.slide = n3 - 1;
        this._fireEvent("jump", {
          slide: this.current(true)
        });
        this._goto(this.slide);
      },
      next: function() {
        const o2 = this.options;
        this.slide++;
        if (this.slide >= this.slides.length) {
          if (!o2.loop) {
            return this._end();
          }
          this.slide = 0;
        }
        this._fireEvent("next", {
          slide: this.current(true)
        });
        this._goto(this.slide);
      },
      prev: function() {
        const o2 = this.options;
        this.slide--;
        if (this.slide < 0) {
          if (!o2.loop) {
            this.slide++;
            return this._end();
          }
          this.slide = this.slides.length - 1;
        }
        this._fireEvent("prev", {
          slide: this.current(true)
        });
        this._goto(this.slide);
      },
      changeAttribute: function(attr) {
        const element2 = this.element;
        const o2 = this.options;
        const propName = Str.camelCase(attr.replace("data-", ""));
        if (propName === "slides") {
          o2.slides = element2.attr("data-slides");
          this.slides = Metro2.utils.isObject(o2.slides) || [];
          this.total = this.slides.length;
          this.noshow = this.total < 2;
          this.paused = !this.options.autoplay || this.noshow;
        } else {
          if (typeof VegasDefaultConfig[propName] !== "undefined") o2[propName] = JSON.parse(element2.attr(attr));
        }
      },
      destroy: function() {
        const element2 = this.element;
        const o2 = this.options;
        clearTimeout(this.timeout);
        element2.removeClass("vegas-container");
        element2.find("> .vegas-slide").remove();
        element2.find("> .vegas-wrapper").children().appendTo(element2);
        element2.find("> .vegas-wrapper").remove();
        if (o2.timer) {
          this.timer.remove();
        }
        if (o2.overlay) {
          this.overlay.remove();
        }
        element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/video-player/video-player.js
  ((Metro2, $7) => {
    "use strict";
    let VideoPlayerDefaultConfig = {
      videoDeferred: 0,
      src: null,
      poster: "",
      logo: "",
      logoHeight: 32,
      logoWidth: "auto",
      logoTarget: "",
      volume: 0.5,
      loop: false,
      autoplay: false,
      fullScreenMode: Metro2.fullScreenMode.DESKTOP,
      aspectRatio: Metro2.aspectRatio.HD,
      controlsHide: 3e3,
      showLoop: true,
      showPlay: true,
      showStop: true,
      showMute: true,
      showFull: true,
      showStream: true,
      showVolume: true,
      showInfo: true,
      loopIcon: "\u2B94",
      stopIcon: "\u23F9",
      playIcon: "\u25B6",
      pauseIcon: "\u23F8",
      muteIcon: "\u{1F507}",
      volumeLowIcon: "\u{1F508}",
      volumeMediumIcon: "\u{1F509}",
      volumeHighIcon: "\u{1F50A}",
      screenMoreIcon: "\u2B1C",
      screenLessIcon: "\u25AB\uFE0F",
      onPlay: Metro2.noop,
      onPause: Metro2.noop,
      onStop: Metro2.noop,
      onEnd: Metro2.noop,
      onMetadata: Metro2.noop,
      onTime: Metro2.noop,
      onVideoPlayerCreate: Metro2.noop
    };
    Metro2.videoPlayerSetup = (options) => {
      VideoPlayerDefaultConfig = $7.extend({}, VideoPlayerDefaultConfig, options);
    };
    if (typeof globalThis.metroVideoPlayerSetup !== "undefined") {
      Metro2.videoPlayerSetup(globalThis.metroVideoPlayerSetup);
    }
    Metro2.Component("video-player", {
      init: function(options, elem) {
        this._super(elem, options, VideoPlayerDefaultConfig, {
          fullscreen: false,
          preloader: null,
          player: null,
          video: elem,
          stream: null,
          volume: null,
          volumeBackup: 0,
          muted: false,
          fullScreenInterval: false,
          isPlaying: false,
          id: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        this.id = element2.attr("id") || Hooks.useId(this.elem);
        if (Metro2.fullScreenEnabled === false) {
          o2.fullScreenMode = Metro2.fullScreenMode.WINDOW;
        }
        this._createPlayer();
        this._createControls();
        this._createEvents();
        this._setAspectRatio();
        if (o2.autoplay === true) {
          this.play();
        }
        this._fireEvent("video-player-create", {
          element: element2,
          player: this.player
        });
      },
      _createPlayer: function() {
        const element2 = this.element;
        const o2 = this.options;
        const video = this.video;
        const player = element2.wrap("<div>").addClass(`media-player video-player ${element2[0].className}`);
        const preloader = $7("<div>").addClass("preloader").appendTo(player);
        const logo = $7("<a>").attr("href", o2.logoTarget).addClass("logo").appendTo(player);
        element2.wrap("<div>").addClass("video-wrapper");
        $7.each(["muted", "autoplay", "controls", "height", "width", "loop", "poster", "preload"], function() {
          element2.removeAttr(this);
        });
        element2.attr("preload", "auto");
        if (o2.poster !== "") {
          element2.attr("poster", o2.poster);
        }
        video.volume = o2.volume;
        preloader.activity({
          type: "cycle",
          style: "color"
        });
        preloader.hide();
        this.preloader = preloader;
        if (o2.logo !== "") {
          $7("<img>").css({
            height: o2.logoHeight,
            width: o2.logoWidth
          }).attr("src", o2.logo).appendTo(logo);
        }
        if (o2.src !== null) {
          this._setSource(o2.src);
        }
        element2[0].className = "";
        this.player = player;
      },
      _setSource: function(src) {
        const element2 = this.element;
        element2.find("source").remove();
        element2.removeAttr("src");
        if (Array.isArray(src)) {
          $7.each(src, function() {
            if (this.src === void 0) return;
            $7("<source>").attr("src", this.src).attr("type", this.type !== void 0 ? this.type : "").appendTo(element2);
          });
        } else {
          element2.attr("src", src);
        }
      },
      _createControls: function() {
        const element2 = this.element;
        const o2 = this.options;
        const video = this.elem;
        const controls = $7("<div>").addClass("controls").addClass(o2.clsControls).appendTo(this.player);
        const stream = $7("<div>").addClass("stream").appendTo(controls);
        const streamSlider = $7("<input>").addClass("stream-slider ultra-thin cycle-marker").appendTo(stream);
        const volume = $7("<div>").addClass("volume").appendTo(controls);
        const volumeSlider = $7("<input>").addClass("volume-slider ultra-thin cycle-marker").appendTo(volume);
        const infoBox = $7("<div>").addClass("info-box").appendTo(controls);
        if (o2.showInfo !== true) {
          infoBox.hide();
        }
        Metro2.makePlugin(streamSlider, "slider", {
          clsMarker: "bg-red",
          clsHint: "bg-cyan fg-white",
          clsComplete: "bg-cyan",
          hint: true,
          onStart: () => {
            if (!video.paused) video.pause();
          },
          onStop: (val) => {
            if (video.seekable.length > 0) {
              video.currentTime = (this.duration * val / 100).toFixed(0);
            }
            if (video.paused && video.currentTime > 0) {
              video.play();
            }
          }
        });
        this.stream = streamSlider;
        if (o2.showStream !== true) {
          stream.hide();
        }
        Metro2.makePlugin(volumeSlider, "slider", {
          clsMarker: "bg-red",
          clsHint: "bg-cyan fg-white",
          hint: true,
          value: o2.volume * 100,
          onChangeValue: (val) => {
            video.volume = val / 100;
          }
        });
        this.volume = volumeSlider;
        if (o2.showVolume !== true) {
          volume.hide();
        }
        let loop;
        if (o2.showLoop === true)
          loop = $7("<button>").attr("type", "button").addClass("button square loop").attr("title", this.strings.label_loop).html(o2.loopIcon).appendTo(controls);
        if (o2.showPlay === true)
          $7("<button>").attr("type", "button").addClass("button square play").attr("title", this.strings.label_play).html(o2.playIcon).appendTo(controls);
        if (o2.showStop === true)
          $7("<button>").attr("type", "button").addClass("button square stop").attr("title", this.strings.label_stop).html(o2.stopIcon).appendTo(controls);
        if (o2.showMute === true)
          $7("<button>").attr("type", "button").addClass("button square mute").attr("title", this.strings.label_mute).html(o2.muteIcon).appendTo(controls);
        if (o2.showFull === true)
          $7("<button>").attr("type", "button").addClass("button square full").html(o2.screenMoreIcon).appendTo(controls);
        if (o2.loop === true) {
          loop.addClass("active");
          element2.attr("loop", "loop");
        }
        this._setVolume();
        if (o2.muted) {
          this.volumeBackup = video.volume;
          Metro2.getPlugin(this.volume, "slider").val(0);
          video.volume = 0;
        }
        infoBox.html("00:00 / 00:00");
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        const video = this.elem;
        const player = this.player;
        element2.on("loadstart", () => {
          this.preloader.show();
        });
        element2.on("loadedmetadata", () => {
          this.duration = video.duration.toFixed(0);
          this._setInfo(0, this.duration);
          Metro2.utils.exec(o2.onMetadata, [video, player], element2[0]);
        });
        element2.on("canplay", () => {
          this._setBuffer();
          this.preloader.hide();
        });
        element2.on("progress", () => {
          this._setBuffer();
        });
        element2.on("timeupdate", () => {
          const position = Math.round(video.currentTime * 100 / this.duration);
          this._setInfo(video.currentTime, this.duration);
          Metro2.getPlugin(this.stream, "slider").val(position);
          Metro2.utils.exec(o2.onTime, [video.currentTime, this.duration, video, player], element2[0]);
        });
        element2.on("waiting", () => {
          this.preloader.show();
        });
        element2.on("loadeddata", () => {
        });
        element2.on("play", () => {
          player.find(".play").html(o2.pauseIcon);
          Metro2.utils.exec(o2.onPlay, [video, player], element2[0]);
        });
        element2.on("pause", () => {
          player.find(".play").html(o2.playIcon);
          Metro2.utils.exec(o2.onPause, [video, player], element2[0]);
        });
        element2.on("stop", () => {
          Metro2.getPlugin(this.stream, "slider").val(0);
          Metro2.utils.exec(o2.onStop, [video, player], element2[0]);
        });
        element2.on("ended", () => {
          Metro2.getPlugin(this.stream, "slider").val(0);
          Metro2.utils.exec(o2.onEnd, [video, player], element2[0]);
        });
        element2.on("volumechange", () => {
          this._setVolume();
        });
        player.on(Metro2.events.click, ".play", () => {
          if (video.paused) {
            this.play();
          } else {
            this.pause();
          }
        });
        player.on(Metro2.events.click, ".stop", () => {
          this.stop();
        });
        player.on(Metro2.events.click, ".mute", () => {
          this._toggleMute();
        });
        player.on(Metro2.events.click, ".loop", () => {
          this._toggleLoop();
        });
        player.on(Metro2.events.click, ".full", () => {
          this.fullscreen = !this.fullscreen;
          player.find(".full").html(this.fullscreen === true ? o2.screenLessIcon : o2.screenMoreIcon);
          if (o2.fullScreenMode === Metro2.fullScreenMode.WINDOW) {
            if (this.fullscreen === true) {
              player.addClass("full-screen");
            } else {
              player.removeClass("full-screen");
            }
          } else {
            if (this.fullscreen === true) {
              Metro2.requestFullScreen(video);
              if (this.fullScreenInterval === false)
                this.fullScreenInterval = setInterval(() => {
                  if (Metro2.inFullScreen() === false) {
                    this.fullscreen = false;
                    clearInterval(this.fullScreenInterval);
                    this.fullScreenInterval = false;
                    player.find(".full").html(o2.screenMoreIcon);
                  }
                }, 1e3);
            } else {
              Metro2.exitFullScreen();
            }
          }
        });
        $7(globalThis).on(
          Metro2.events.keyup,
          (e2) => {
            if (this.fullscreen && e2.keyCode === 27) {
              player.find(".full").click();
            }
          },
          { ns: this.id }
        );
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            this._setAspectRatio();
          },
          { ns: this.id }
        );
      },
      _toggleLoop: function() {
        const loop = this.player.find(".loop");
        if (loop.length === 0) return;
        loop.toggleClass("active");
        if (loop.hasClass("active")) {
          this.element.attr("loop", "loop");
        } else {
          this.element.removeAttr("loop");
        }
      },
      _toggleMute: function() {
        this.muted = !this.muted;
        if (this.muted === false) {
          this.video.volume = this.volumeBackup;
        } else {
          this.volumeBackup = this.video.volume;
          this.video.volume = 0;
        }
        Metro2.getPlugin(this.volume, "slider").val(this.muted === false ? this.volumeBackup * 100 : 0);
      },
      _setInfo: function(a2, b5) {
        this.player.find(".info-box").html(
          `${Metro2.utils.secondsToFormattedString(Math.round(a2))} / ${Metro2.utils.secondsToFormattedString(Math.round(b5))}`
        );
      },
      _setBuffer: function() {
        const buffer = this.video.buffered.length ? Math.round(Math.floor(this.video.buffered.end(0)) / Math.floor(this.video.duration) * 100) : 0;
        Metro2.getPlugin(this.stream, "slider").buff(buffer);
      },
      _setVolume: function() {
        const video = this.video;
        const player = this.player;
        const o2 = this.options;
        const volumeButton = player.find(".mute");
        const volume = video.volume * 100;
        if (volume > 1 && volume < 30) {
          volumeButton.html(o2.volumeLowIcon);
        } else if (volume >= 30 && volume < 60) {
          volumeButton.html(o2.volumeMediumIcon);
        } else if (volume >= 60 && volume <= 100) {
          volumeButton.html(o2.volumeHighIcon);
        } else {
          volumeButton.html(o2.muteIcon);
        }
      },
      _setAspectRatio: function() {
        const player = this.player;
        const o2 = this.options;
        const width = player.outerWidth();
        let height;
        switch (o2.aspectRatio) {
          case Metro2.aspectRatio.SD:
            height = Metro2.utils.aspectRatioH(width, "4/3");
            break;
          case Metro2.aspectRatio.CINEMA:
            height = Metro2.utils.aspectRatioH(width, "21/9");
            break;
          default:
            height = Metro2.utils.aspectRatioH(width, "16/9");
        }
        player.outerHeight(height);
      },
      aspectRatio: function(ratio) {
        this.options.aspectRatio = ratio;
        this._setAspectRatio();
      },
      play: function(src) {
        if (src) {
          this._setSource(src);
        }
        if (this.element.attr("src") === void 0 && this.element.find("source").length === 0) {
          return;
        }
        this.isPlaying = true;
        this.video.play();
      },
      pause: function() {
        this.isPlaying = false;
        this.video.pause();
      },
      resume: function() {
        if (this.video.paused) {
          this.play();
        }
      },
      stop: function() {
        this.isPlaying = false;
        this.video.pause();
        this.video.currentTime = 0;
        Metro2.getPlugin(this.stream, "slider").val(0);
        this._offMouse();
      },
      setVolume: function(v5) {
        if (typeof v5 === "undefined") {
          return this.video.volume;
        }
        let new_volume = Number.parseFloat(v5);
        if (new_volume > 1) {
          new_volume /= 100;
        }
        this.video.volume = new_volume;
        Metro2.getPlugin(this.volume[0], "slider").val(v5 * 100);
      },
      loop: function() {
        this._toggleLoop();
      },
      mute: function() {
        this._toggleMute();
      },
      changeAspectRatio: function() {
        this.options.aspectRatio = this.element.attr("data-aspect-ratio");
        this._setAspectRatio();
      },
      changeSource: function() {
        const src = JSON.parse(this.element.attr("data-src"));
        this.play(src);
      },
      changeVolume: function() {
        const volume = this.element.attr("data-volume");
        this.setVolume(volume);
      },
      changeAttribute: function(attributeName) {
        switch (attributeName) {
          case "data-aspect-ratio":
            this.changeAspectRatio();
            break;
          case "data-src":
            this.changeSource();
            break;
          case "data-volume":
            this.changeVolume();
            break;
        }
      },
      destroy: function() {
        const element2 = this.element;
        const player = this.player;
        Metro2.getPlugin(this.stream, "slider").destroy();
        Metro2.getPlugin(this.volume, "slider").destroy();
        element2.off("loadstart");
        element2.off("loadedmetadata");
        element2.off("canplay");
        element2.off("progress");
        element2.off("timeupdate");
        element2.off("waiting");
        element2.off("loadeddata");
        element2.off("play");
        element2.off("pause");
        element2.off("stop");
        element2.off("ended");
        element2.off("volumechange");
        player.off(Metro2.events.click, ".play");
        player.off(Metro2.events.click, ".stop");
        player.off(Metro2.events.click, ".mute");
        player.off(Metro2.events.click, ".loop");
        player.off(Metro2.events.click, ".full");
        $7(globalThis).off(Metro2.events.keyup, { ns: this.id });
        $7(globalThis).off(Metro2.events.resize, { ns: this.id });
        return element2;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/viewport-check/viewport-check.js
  ((Metro2, $7) => {
    "use strict";
    let ViewportCheckDefaultConfig = {
      onViewport: Metro2.noop,
      onViewportEnter: Metro2.noop,
      onViewportLeave: Metro2.noop,
      onViewportCheckCreate: Metro2.noop
    };
    Metro2.viewportCheckSetup = (options) => {
      ViewportCheckDefaultConfig = $7.extend({}, ViewportCheckDefaultConfig, options);
    };
    if (typeof globalThis.metroViewportCheckSetup !== "undefined") {
      Metro2.viewportCheckSetup(globalThis.metroViewportCheckSetup);
    }
    Metro2.Component("viewport-check", {
      init: function(options, elem) {
        this._super(elem, options, ViewportCheckDefaultConfig, {
          // define instance vars here
          inViewport: false,
          id: null
        });
        return this;
      },
      _create: function() {
        this.id = this.element.attr("id") || Hooks.useId(this.elem);
        this.inViewport = Metro2.utils.inViewport(this.elem);
        this._createEvents();
        this._fireEvent("viewport-check-create");
      },
      _createEvents: function() {
        const elem = this.elem;
        $7(globalThis).on(
          Metro2.events.scroll,
          () => {
            const oldState = this.inViewport;
            this.inViewport = Metro2.utils.inViewport(elem);
            if (oldState !== this.inViewport) {
              if (this.inViewport) {
                this._fireEvent("viewport-enter");
              } else {
                this._fireEvent("viewport-leave");
              }
            }
            this._fireEvent("viewport", {
              state: this.inViewport
            });
          },
          { ns: this.id }
        );
      },
      state: function() {
        return this.inViewport;
      },
      destroy: function() {
        $7(globalThis).off(Metro2.events.scroll, { ns: this.id });
        return this.element;
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/window/window.js
  ((Metro2, $7) => {
    "use strict";
    let WindowDefaultConfig = {
      _runtime: false,
      windowDeferred: 0,
      hidden: false,
      width: "auto",
      height: "auto",
      btnClose: true,
      btnMin: true,
      btnMax: true,
      draggable: true,
      dragElement: ".window-caption .title",
      dragArea: "parent",
      shadow: false,
      icon: "",
      title: "Window",
      content: null,
      resizable: true,
      overlay: false,
      overlayColor: "transparent",
      overlayAlpha: 0.5,
      modal: false,
      position: "absolute",
      checkEmbed: true,
      top: "auto",
      left: "auto",
      place: "auto",
      closeAction: Metro2.actions.HIDE,
      customButtons: null,
      status: "",
      canClose: true,
      canMaximize: true,
      canMinimize: true,
      clsCustomButton: "",
      clsCaption: "",
      clsContent: "",
      clsWindow: "",
      minWidth: 0,
      minHeight: 0,
      maxWidth: 0,
      maxHeight: 0,
      zIndex: null,
      onDragStart: Metro2.noop,
      onDragStop: Metro2.noop,
      onDragMove: Metro2.noop,
      onWindowClick: Metro2.noop,
      onCaptionClick: Metro2.noop,
      onCaptionDblClick: Metro2.noop,
      onCloseClick: Metro2.noop,
      onMaxClick: Metro2.noop,
      onMinClick: Metro2.noop,
      onResizeStart: Metro2.noop,
      onResizeStop: Metro2.noop,
      onResize: Metro2.noop,
      onWindowCreate: Metro2.noop,
      onShow: Metro2.noop,
      onWindowDestroy: Metro2.noop,
      onCanClose: Metro2.noop_true,
      onMinimize: Metro2.noop,
      onMaximize: Metro2.noop,
      onClose: Metro2.noop
    };
    Metro2.windowSetup = (options) => {
      WindowDefaultConfig = $7.extend({}, WindowDefaultConfig, options);
    };
    if (typeof globalThis.metroWindowSetup !== "undefined") {
      Metro2.windowSetup(globalThis.metroWindowSetup);
    }
    Metro2.Component("window", {
      init: function(options, elem) {
        this._super(elem, options, WindowDefaultConfig, {
          win: null,
          overlay: null,
          position: {
            top: 0,
            left: 0
          },
          hidden: false,
          content: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        let win;
        let overlay;
        const parent2 = o2.dragArea === "parent" ? element2.parent() : $7(o2.dragArea);
        let _content;
        if (o2.modal === true) {
          o2.btnMax = false;
          o2.btnMin = false;
          o2.resizable = false;
        }
        if (Metro2.utils.isNull(o2.content)) {
          o2.content = element2;
        } else {
          if (Metro2.utils.isUrl(o2.content) && Metro2.utils.isVideoUrl(o2.content)) {
            o2.content = Metro2.utils.embedUrl(o2.content);
            element2.css({
              height: "100%"
            });
          } else if (!Metro2.utils.isQ(o2.content) && Metro2.utils.isFunc(o2.content)) {
            o2.content = Metro2.utils.exec(o2.content);
          }
          _content = $7(o2.content);
          if (_content.length === 0) {
            element2.appendText(o2.content);
          } else {
            element2.append(_content);
          }
          o2.content = element2;
        }
        if (o2._runtime === true) {
          this._runtime(element2, "window");
        }
        win = this._window(o2);
        win.addClass("no-visible");
        parent2.append(win);
        if (o2.overlay === true) {
          overlay = this._overlay();
          overlay.appendTo(win.parent());
          this.overlay = overlay;
        }
        this.win = win;
        this._fireEvent("window-create", {
          win: this.win[0],
          element: element2
        });
        setTimeout(() => {
          this._setPosition();
          if (o2.hidden !== true) {
            this.win.removeClass("no-visible");
          }
          this._fireEvent("show", {
            win: this.win[0],
            element: element2
          });
        }, 100);
      },
      _setPosition: function() {
        const o2 = this.options;
        const win = this.win;
        const parent2 = o2.dragArea === "parent" ? win.parent() : $7(o2.dragArea);
        const top_center = parent2.height() / 2 - win[0].offsetHeight / 2;
        const left_center = parent2.width() / 2 - win[0].offsetWidth / 2;
        let top;
        let left;
        let right;
        let bottom;
        if (o2.place !== "auto") {
          switch (o2.place.toLowerCase()) {
            case "top-left":
              top = 0;
              left = 0;
              right = "auto";
              bottom = "auto";
              break;
            case "top-center":
              top = 0;
              left = left_center;
              right = "auto";
              bottom = "auto";
              break;
            case "top-right":
              top = 0;
              right = 0;
              left = "auto";
              bottom = "auto";
              break;
            case "right-center":
              top = top_center;
              right = 0;
              left = "auto";
              bottom = "auto";
              break;
            case "bottom-right":
              bottom = 0;
              right = 0;
              left = "auto";
              top = "auto";
              break;
            case "bottom-center":
              bottom = 0;
              left = left_center;
              right = "auto";
              top = "auto";
              break;
            case "bottom-left":
              bottom = 0;
              left = 0;
              right = "auto";
              top = "auto";
              break;
            case "left-center":
              top = top_center;
              left = 0;
              right = "auto";
              bottom = "auto";
              break;
            default:
              top = top_center;
              left = left_center;
              bottom = "auto";
              right = "auto";
          }
          win.css({
            top,
            left,
            bottom,
            right
          });
        }
      },
      _window: function(o2) {
        const that = this;
        let win;
        let caption;
        let content;
        let icon;
        let buttons;
        let btnClose;
        let btnMin;
        let btnMax;
        let resizer;
        let status;
        let width = o2.width;
        let height = o2.height;
        win = $7("<div>").addClass("window");
        if (o2.zIndex !== null) {
          win.css("z-index", o2.zIndex);
        }
        if (o2.modal === true) {
          win.addClass("modal");
        }
        caption = $7("<div>").addClass("window-caption");
        content = $7("<div>").addClass("window-content");
        win.append(caption);
        win.append(content);
        if (o2.status || o2.resizable) {
          status = $7("<div>").addClass("window-status").html(o2.status);
          win.append(status);
        }
        if (o2.shadow === true) {
          win.addClass("shadowed");
        }
        if (Metro2.utils.isValue(o2.icon)) {
          icon = $7("<span>").addClass("icon").html(o2.icon);
          icon.appendTo(caption);
        }
        const title = $7("<span>").addClass("title").html(Metro2.utils.isValue(o2.title) ? o2.title : "&nbsp;");
        title.appendTo(caption);
        if (!Metro2.utils.isNull(o2.content)) {
          if (Metro2.utils.isQ(o2.content)) {
            o2.content.appendTo(content);
          } else {
            content.html(o2.content);
          }
        }
        buttons = $7("<div>").addClass("buttons");
        buttons.appendTo(caption);
        if (o2.btnMax === true) {
          btnMax = $7("<span>").addClass("button small square btn-max sys-button");
          btnMax.appendTo(buttons);
        }
        if (o2.btnMin === true) {
          btnMin = $7("<span>").addClass("button small square btn-min sys-button");
          btnMin.appendTo(buttons);
        }
        if (o2.btnClose === true) {
          btnClose = $7("<span>").addClass("button small square btn-close sys-button");
          btnClose.appendTo(buttons);
        }
        if (o2.customButtons) {
          const customButtons = Metro2.utils.isObject(o2.customButtons);
          if (customButtons) {
            $7.each(customButtons, function() {
              const btn = $7("<span>");
              btn.addClass("button btn-custom").addClass(o2.clsCustomButton).addClass(this.cls).attr("tabindex", -1).html(this.text || this.html || "");
              that._setAttributes(btn, this.attr);
              if (this.onclick) {
                btn.on(Metro2.events.click, (e2) => {
                  if (Metro2.utils.isRightMouse(e2)) return;
                  Metro2.utils.exec(this.onclick, [btn[0], win[0]]);
                });
              }
              btn.appendTo(buttons);
            });
          }
        }
        win.attr("id", o2.id === void 0 ? Hooks.useId(win[0]) : o2.id);
        win.on(Metro2.events.startAll, ".window-caption", (e2) => {
          this._fireEvent("caption-click", {
            win: win[0],
            e: e2
          });
        });
        win.on(Metro2.events.dblclick, ".window-caption", (e2) => {
          this.maximize(e2);
        });
        caption.on(Metro2.events.click, ".btn-max, .btn-min, .btn-close", (e2) => {
          if (Metro2.utils.isRightMouse(e2)) return;
          const target = $7(e2.target);
          if (target.hasClass("btn-max") && o2.canMaximize) this.maximize(e2);
          if (target.hasClass("btn-min") && o2.canMinimize) this.minimize(e2);
          if (target.hasClass("btn-close") && o2.canClose) this.close(e2);
        });
        win.on(Metro2.events.click, (e2) => {
          this._fireEvent("window-click", {
            win: win[0],
            e: e2
          });
        });
        if (o2.draggable === true) {
          Metro2.makePlugin(win, "draggable", {
            dragContext: win[0],
            dragElement: caption,
            dragArea: o2.dragArea,
            onDragStart: o2.onDragStart,
            onDragStop: o2.onDragStop,
            onDragMove: o2.onDragMove
          });
        }
        win.addClass(o2.clsWindow);
        caption.addClass(o2.clsCaption);
        content.addClass(o2.clsContent);
        if (o2.minWidth === 0) {
          o2.minWidth = 34;
          $7.each(buttons.children(".btn-custom"), function() {
            o2.minWidth += Metro2.utils.hiddenElementSize(this).width;
          });
          if (o2.btnMax) o2.minWidth += 34;
          if (o2.btnMin) o2.minWidth += 34;
          if (o2.btnClose) o2.minWidth += 34;
        }
        if (o2.minWidth > 0 && !isNaN(o2.width) && o2.width < o2.minWidth) {
          width = o2.minWidth;
        }
        if (o2.minHeight > 0 && !isNaN(o2.height) && o2.height > o2.minHeight) {
          height = o2.minHeight;
        }
        if (o2.resizable) {
          resizer = $7("<span>").addClass("resize-element");
          resizer.appendTo(win);
          win.addClass("resizable");
          Metro2.makePlugin(win, "resizable", {
            minWidth: o2.minWidth,
            minHeight: o2.minHeight,
            maxWidth: o2.maxWidth,
            maxHeight: o2.maxHeight,
            resizeElement: ".resize-element",
            onResizeStart: o2.onResizeStart,
            onResizeStop: o2.onResizeStop,
            onResize: o2.onResize
          });
        }
        win.css({
          width,
          height,
          position: o2.position,
          top: o2.top,
          left: o2.left
        });
        return win;
      },
      _overlay: function() {
        const o2 = this.options;
        const overlay = $7("<div>");
        overlay.addClass("overlay");
        if (o2.overlayColor === "transparent") {
          overlay.addClass("transparent");
        } else {
          overlay.css({
            background: Farbe.Routines.toRGBA(Farbe.Routines.parse(o2.overlayColor), o2.overlayAlpha)
          });
        }
        return overlay;
      },
      width: function(v5) {
        const win = this.win;
        if (!Metro2.utils.isValue(v5)) {
          return win.width();
        }
        win.css("width", Number.parseInt(v5));
        return this;
      },
      height: function(v5) {
        const win = this.win;
        if (!Metro2.utils.isValue(v5)) {
          return win.height();
        }
        win.css("height", Number.parseInt(v5));
        return this;
      },
      maximize: function(e2) {
        const win = this.win;
        const o2 = this.options;
        const target = $7(e2.target);
        if (o2.btnMax) {
          win.removeClass("minimized");
          win.toggleClass("maximized");
        }
        if (target.hasClass?.("title")) {
          this._fireEvent("caption-dbl-click", {
            win: win[0]
          });
        } else {
          this._fireEvent("max-click", {
            win: win[0]
          });
        }
        this._fireEvent("maximize", {
          win: win[0]
        });
      },
      minimize: function() {
        const win = this.win;
        const o2 = this.options;
        if (o2.btnMin) {
          win.removeClass("maximized");
          win.toggleClass("minimized");
        }
        this._fireEvent("min-click", {
          win: win[0]
        });
        this._fireEvent("minimize", {
          win: win[0]
        });
      },
      close: function() {
        const win = this.win;
        const o2 = this.options;
        if (Metro2.utils.exec(o2.onCanClose, [win]) === false) {
          return false;
        }
        let timeout = 0;
        if (o2.onClose !== Metro2.noop) {
          timeout = 500;
        }
        this._fireEvent("close", {
          win: win[0]
        });
        setTimeout(() => {
          if (o2.modal === true) {
            win.siblings(".overlay").remove();
          }
          this._fireEvent("close-click", {
            win: win[0]
          });
          if (o2.closeAction === Metro2.actions.REMOVE) {
            this._fireEvent("window-destroy", {
              win: win[0]
            });
            win.remove();
          } else {
            this.hide();
          }
        }, timeout);
      },
      hide: function() {
        const win = this.win;
        win.css({
          display: "none"
        });
        this._fireEvent("hide", {
          win: win[0]
        });
      },
      show: function() {
        const win = this.win;
        win.removeClass("no-visible").css({
          display: "flex"
        });
        this._fireEvent("show", {
          win: win[0]
        });
      },
      toggle: function() {
        if (this.win.css("display") === "none" || this.win.hasClass("no-visible")) {
          this.show();
        } else {
          this.hide();
        }
      },
      isOpen: function() {
        return this.win.hasClass("no-visible");
      },
      min: function(a2) {
        a2 ? this.win.addClass("minimized") : this.win.removeClass("minimized");
      },
      max: function(a2) {
        a2 ? this.win.addClass("maximized") : this.win.removeClass("maximized");
      },
      changeClass: function(a2) {
        const element2 = this.element;
        const win = this.win;
        const o2 = this.options;
        if (a2 === "data-cls-window") {
          win[0].className = `window ${o2.resizable ? " resizable " : " "}${element2.attr("data-cls-window")}`;
        }
        if (a2 === "data-cls-caption") {
          win.find(".window-caption")[0].className = `window-caption ${element2.attr("data-cls-caption")}`;
        }
        if (a2 === "data-cls-content") {
          win.find(".window-content")[0].className = `window-content ${element2.attr("data-cls-content")}`;
        }
      },
      toggleShadow: function() {
        const element2 = this.element;
        const win = this.win;
        const flag = JSON.parse(element2.attr("data-shadow"));
        if (flag === true) {
          win.addClass("win-shadow");
        } else {
          win.removeClass("win-shadow");
        }
      },
      setContent: function(c5) {
        const element2 = this.element;
        const win = this.win;
        const content = Metro2.utils.isValue(c5) ? c5 : element2.attr("data-content");
        let result;
        if (!Metro2.utils.isQ(content) && Metro2.utils.isFunc(content)) {
          result = Metro2.utils.exec(content);
        } else if (Metro2.utils.isQ(content)) {
          result = content.html();
        } else {
          result = content;
        }
        win.find(".window-content").html(result);
      },
      setTitle: function(t) {
        const element2 = this.element;
        const win = this.win;
        const title = Metro2.utils.isValue(t) ? t : element2.attr("data-title");
        win.find(".window-caption .title").html(title);
      },
      setIcon: function(i3) {
        const element2 = this.element;
        const win = this.win;
        const icon = Metro2.utils.isValue(i3) ? i3 : element2.attr("data-icon");
        win.find(".window-caption .icon").html(icon);
      },
      getIcon: function() {
        return this.win.find(".window-caption .icon").html();
      },
      getTitle: function() {
        return this.win.find(".window-caption .title").html();
      },
      toggleDraggable: function(f5) {
        const win = this.win;
        const flag = Metro2.utils.bool(f5);
        const drag = Metro2.getPlugin(win, "draggable");
        if (flag === true) {
          drag.on();
        } else {
          drag.off();
        }
      },
      toggleResizable: function(f5) {
        const win = this.win;
        const flag = Metro2.utils.bool(f5);
        const resize = Metro2.getPlugin(win, "resizable");
        if (flag === true) {
          resize.on();
          win.find(".resize-element").removeClass("resize-element-disabled");
        } else {
          resize.off();
          win.find(".resize-element").addClass("resize-element-disabled");
        }
      },
      changePlace: function(p5) {
        const element2 = this.element;
        const win = this.win;
        const place = Metro2.utils.isValue(p5) ? p5 : element2.attr("data-place");
        win.addClass(place);
      },
      pos: function(top, left) {
        const win = this.win;
        win.css({
          top,
          left
        });
        return this;
      },
      top: function(v5) {
        this.win.css({
          top: v5
        });
        return this;
      },
      left: function(v5) {
        this.win.css({
          left: v5
        });
        return this;
      },
      zIndex: function(v5) {
        if (Metro2.utils.isNull(v5) === false) {
          this.win.css({
            zIndex: +v5
          });
        }
        return this.win.style("zIndex");
      },
      changeAttribute: function(attr, value) {
        const changePos = function(a2, v5) {
          const win = this.win;
          let pos;
          if (a2 === "data-top") {
            pos = Number.parseInt(v5);
            if (!isNaN(pos)) {
              return;
            }
            win.css("top", pos);
          }
          if (a2 === "data-left") {
            pos = Number.parseInt(v5);
            if (!isNaN(pos)) {
              return;
            }
            win.css("left", pos);
          }
        };
        const toggleButtons = function(a2, v5) {
          const win = this.win;
          const btnClose = win.find(".btn-close");
          const btnMin = win.find(".btn-min");
          const btnMax = win.find(".btn-max");
          const _v = Metro2.utils.bool(v5);
          const func = _v ? "show" : "hide";
          switch (a2) {
            case "data-btn-close":
              btnClose[func]();
              break;
            case "data-btn-min":
              btnMin[func]();
              break;
            case "data-btn-max":
              btnMax[func]();
              break;
          }
        };
        const changeSize = function(a2, v5) {
          const win = this.win;
          if (a2 === "data-width") {
            win.css("width", +v5);
          }
          if (a2 === "data-height") {
            win.css("height", +v5);
          }
        };
        switch (attr) {
          case "data-btn-close":
          case "data-btn-min":
          case "data-btn-max":
            toggleButtons(attr, value);
            break;
          case "data-width":
          case "data-height":
            changeSize(attr, value);
            break;
          case "data-cls-window":
          case "data-cls-caption":
          case "data-cls-content":
            this.changeClass(attr);
            break;
          case "data-shadow":
            this.toggleShadow();
            break;
          case "data-icon":
            this.setIcon();
            break;
          case "data-title":
            this.setTitle();
            break;
          case "data-content":
            this.setContent();
            break;
          case "data-draggable":
            this.toggleDraggable(value);
            break;
          case "data-resizable":
            this.toggleResizable(value);
            break;
          case "data-top":
          case "data-left":
            changePos(attr, value);
            break;
          case "data-place":
            this.changePlace();
            break;
        }
      },
      destroy: function() {
        return this.element;
      }
    });
    Metro2.window = {
      isWindow: (el) => Metro2.utils.isMetroObject(el, "window"),
      min: function(el, a2) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").min(a2);
      },
      max: function(el, a2) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").max(a2);
      },
      show: function(el) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").show();
      },
      hide: function(el) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").hide();
      },
      toggle: function(el) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").toggle();
      },
      isOpen: function(el) {
        if (!this.isWindow(el)) {
          return false;
        }
        const win = Metro2.getPlugin(el, "window");
        return win.isOpen();
      },
      close: function(el) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").close();
      },
      pos: function(el, top, left) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").pos(top, left);
      },
      top: function(el, top) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").top(top);
      },
      left: function(el, left) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").left(left);
      },
      width: function(el, width) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").width(width);
      },
      height: function(el, height) {
        if (!this.isWindow(el)) {
          return false;
        }
        Metro2.getPlugin(el, "window").height(height);
      },
      create: (options, parent2) => {
        const w6 = $7("<div>").appendTo(parent2 ? $7(parent2) : $7("body"));
        const w_options = $7.extend(
          {
            _runtime: true
          },
          options ? options : {}
        );
        Metro2.makePlugin(w6, "window", w_options);
        return Metro2.getPlugin(w6, "window").win;
      }
    };
  })(Metro, Dom);

  // ../metroui-lib/source/components/wizard/wizard.js
  ((Metro2, $7) => {
    "use strict";
    let WizardDefaultConfig = {
      wizardDeferred: 0,
      start: 1,
      finish: 0,
      iconHelp: "\u{1F4A1}",
      iconPrev: "\u2190",
      iconNext: "\u2192",
      iconFinish: "\u2714",
      buttonMode: "cycle",
      // default, cycle, square
      buttonOutline: true,
      duration: 300,
      clsWizard: "",
      clsActions: "",
      clsHelp: "",
      clsPrev: "",
      clsNext: "",
      clsFinish: "",
      onPage: Metro2.noop,
      onNextPage: Metro2.noop,
      onPrevPage: Metro2.noop,
      onFirstPage: Metro2.noop,
      onLastPage: Metro2.noop,
      onFinishPage: Metro2.noop,
      onHelpClick: Metro2.noop,
      onPrevClick: Metro2.noop,
      onNextClick: Metro2.noop,
      onFinishClick: Metro2.noop,
      onBeforePrev: Metro2.noop_true,
      onBeforeNext: Metro2.noop_true,
      onWizardCreate: Metro2.noop
    };
    Metro2.wizardSetup = (options) => {
      WizardDefaultConfig = $7.extend({}, WizardDefaultConfig, options);
    };
    if (typeof globalThis.metroWizardSetup !== "undefined") {
      Metro2.wizardSetup(globalThis.metroWizardSetup);
    }
    Metro2.Component("wizard", {
      init: function(options, elem) {
        this._super(elem, options, WizardDefaultConfig, {
          id: null
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        this.id = Hooks.useId(this.elem);
        this._createWizard();
        this._createEvents();
        this._fireEvent("wizard-create", {
          element: element2
        });
      },
      _createWizard: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass("wizard").addClass(o2.view).addClass(o2.clsWizard);
        const bar = $7("<div>").addClass("action-bar").addClass(o2.clsActions).appendTo(element2);
        let buttonMode = o2.buttonMode === "button" ? "" : o2.buttonMode;
        if (o2.buttonOutline === true) {
          buttonMode += " outline";
        }
        if (o2.iconHelp !== false)
          $7("<button>").attr("type", "button").addClass("button wizard-btn-help").addClass(buttonMode).addClass(o2.clsHelp).html(o2.iconHelp).appendTo(bar);
        if (o2.iconPrev !== false)
          $7("<button>").attr("type", "button").addClass("button wizard-btn-prev").addClass(buttonMode).addClass(o2.clsPrev).html(o2.iconPrev).appendTo(bar);
        if (o2.iconNext !== false)
          $7("<button>").attr("type", "button").addClass("button wizard-btn-next").addClass(buttonMode).addClass(o2.clsNext).html(o2.iconNext).appendTo(bar);
        if (o2.iconFinish !== false)
          $7("<button>").attr("type", "button").addClass("button wizard-btn-finish").addClass(buttonMode).addClass(o2.clsFinish).html(o2.iconFinish).appendTo(bar);
        this.toPage(o2.start);
        this._setHeight();
      },
      _setHeight: function() {
        const element2 = this.element;
        const pages = element2.children("section");
        let max_height = 0;
        pages.children(".page-content").css("max-height", "none");
        $7.each(pages, function() {
          const h3 = $7(this).height();
          if (max_height < Number.parseInt(h3)) {
            max_height = h3;
          }
        });
        element2.height(max_height);
      },
      _createEvents: function() {
        const that = this;
        const element2 = this.element;
        element2.on(Metro2.events.click, ".wizard-btn-help", () => {
          const pages = element2.children("section");
          const page = pages.get(that.current - 1);
          that._fireEvent("help-click", {
            index: that.current,
            page
          });
        });
        element2.on(Metro2.events.click, ".wizard-btn-prev", () => {
          that.prev();
          const pages = element2.children("section");
          const page = pages.get(that.current - 1);
          that._fireEvent("prev-click", {
            index: that.current,
            page
          });
        });
        element2.on(Metro2.events.click, ".wizard-btn-next", () => {
          that.next();
          const pages = element2.children("section");
          const page = pages.get(that.current - 1);
          that._fireEvent("next-click", {
            index: that.current,
            page
          });
        });
        element2.on(Metro2.events.click, ".wizard-btn-finish", () => {
          const pages = element2.children("section");
          const page = pages.get(that.current - 1);
          that._fireEvent("finish-click", {
            index: that.current,
            page
          });
        });
        element2.on(Metro2.events.click, ".complete", function() {
          const index = $7(this).index() + 1;
          that.toPage(index);
        });
        $7(globalThis).on(
          Metro2.events.resize,
          () => {
            that._setHeight();
          },
          { ns: this.id }
        );
      },
      next: function() {
        const element2 = this.element;
        const o2 = this.options;
        const pages = element2.children("section");
        let page = $7(element2.children("section").get(this.current - 1));
        if (this.current + 1 > pages.length || Metro2.utils.exec(o2.onBeforeNext, [this.current, page, element2]) === false) {
          return;
        }
        this.current++;
        this.toPage(this.current);
        page = $7(element2.children("section").get(this.current - 1));
        this._fireEvent("next-page", {
          index: this.current,
          page: page[0]
        });
      },
      prev: function() {
        const element2 = this.element;
        const o2 = this.options;
        let page = $7(element2.children("section").get(this.current - 1));
        if (this.current - 1 === 0 || Metro2.utils.exec(o2.onBeforePrev, [this.current, page, element2]) === false) {
          return;
        }
        this.current--;
        this.toPage(this.current);
        page = $7(element2.children("section").get(this.current - 1));
        this._fireEvent("prev-page", {
          index: this.current,
          page: page[0]
        });
      },
      last: function() {
        const element2 = this.element;
        this.toPage(element2.children("section").length);
        const page = $7(element2.children("section").get(this.current - 1));
        this._fireEvent("last-page", {
          index: this.current,
          page: page[0]
        });
      },
      first: function() {
        const element2 = this.element;
        this.toPage(1);
        const page = $7(element2.children("section").get(0));
        this._fireEvent("first-page", {
          index: this.current,
          page: page[0]
        });
      },
      toPage: function(page) {
        const element2 = this.element;
        const o2 = this.options;
        const target = $7(element2.children("section").get(page - 1));
        const sections = element2.children("section");
        const actions = element2.find(".action-bar");
        if (target.length === 0) {
          return;
        }
        const finish = element2.find(".wizard-btn-finish").addClass("disabled");
        const next = element2.find(".wizard-btn-next").addClass("disabled");
        const prev = element2.find(".wizard-btn-prev").addClass("disabled");
        this.current = page;
        element2.children("section").removeClass("complete current").removeClass(o2.clsCurrent).removeClass(o2.clsComplete);
        target.addClass("current").addClass(o2.clsCurrent);
        target.prevAll().addClass("complete").addClass(o2.clsComplete);
        const border_size = element2.children("section.complete").length === 0 ? 0 : Number.parseInt(
          Metro2.utils.getStyleOne(element2.children("section.complete")[0], "border-left-width")
        );
        actions.animate({
          draw: {
            left: element2.children("section.complete").length * border_size + 41
          },
          dur: o2.duration
        });
        if (this.current === sections.length || o2.finish > 0 && this.current >= o2.finish) {
          finish.removeClass("disabled");
        }
        if (Number.parseInt(o2.finish) > 0 && this.current === Number.parseInt(o2.finish)) {
          this._fireEvent("finish-page", {
            index: this.current,
            page: target[0]
          });
        }
        if (this.current < sections.length) {
          next.removeClass("disabled");
        }
        if (this.current > 1) {
          prev.removeClass("disabled");
        }
        this._fireEvent("page", {
          index: this.current,
          page: target[0]
        });
      },
      changeAttribute: () => {
      },
      destroy: function() {
        const element2 = this.element;
        element2.off(Metro2.events.click, ".wizard-btn-help");
        element2.off(Metro2.events.click, ".wizard-btn-prev");
        element2.off(Metro2.events.click, ".wizard-btn-next");
        element2.off(Metro2.events.click, ".wizard-btn-finish");
        element2.off(Metro2.events.click, ".complete");
        $7(globalThis).off(Metro2.events.resize, { ns: this.id });
        element2.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/wizard-classic/wizard-classic.js
  ((Metro2, $7) => {
    "use strict";
    let WizardClassicDefaultConfig = {
      buttons: "next, prev, finish, cancel, help",
      startPage: 1,
      height: 300,
      labelNext: "",
      labelPrev: "",
      labelHelp: "",
      labelFinish: "",
      labelCancel: "",
      iconNext: "",
      iconPrev: "",
      iconHelp: "",
      iconFinish: "",
      iconCancel: "",
      clsWizard: "",
      clsPage: "",
      clsActions: "",
      clsActionHelp: "",
      clsActionPrev: "",
      clsActionNext: "",
      clsActionFinish: "",
      clsActionCancel: "",
      onBeforePage: Metro2.noop_true,
      onPage: Metro2.noop,
      onNext: Metro2.noop,
      onPrev: Metro2.noop,
      onFinish: Metro2.noop,
      onCancel: Metro2.noop,
      onHelp: Metro2.noop,
      onMyObjectCreate: Metro2.noop
    };
    Metro2.wizardClassicSetup = (options) => {
      WizardClassicDefaultConfig = $7.extend({}, WizardClassicDefaultConfig, options);
    };
    if (typeof window.metroWizardClassicSetup !== "undefined") {
      Metro2.wizardClassicSetup(window.metroWizardClassicSetup);
    }
    Metro2.Component("wizard-classic", {
      init: function(options, elem) {
        this._super(elem, options, WizardClassicDefaultConfig, {
          // define instance vars here
          currentPage: 0
        });
        return this;
      },
      _create: function() {
        const element2 = this.element;
        const o2 = this.options;
        this._createStructure();
        this._createEvents();
        this._fireEvent("wizard-create");
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.addClass(`wizard-classic ${o2.clsWizard}`).css({
          height: o2.height
        });
        const wizard_pages = $7("<div>").addClass("wizard-pages").appendTo(element2);
        const actions = $7("<div>").addClass("wizard-actions").appendTo(element2);
        for (const btn of o2.buttons.toArray(",")) {
          const button = $7("<button>").addClass("wizard-action").attr("data-wizard-action", btn).html(
            `${o2[`icon${str(btn).capitalize()}`] ? o2[`icon${str(btn).capitalize()}`] : ""} ${o2[`label${str(btn).capitalize()}`] || this.strings[`label_${btn}`]}`
          ).appendTo(actions);
          if (btn === "next") {
            button.addClass(`wizard-next ${o2.clsActionNext}`);
          } else if (btn === "prev") {
            button.addClass(`wizard-prev ${o2.clsActionPrev}`);
          } else if (btn === "finish") {
            button.addClass(`wizard-finish ${o2.clsActionFinish}`);
          } else if (btn === "cancel") {
            button.addClass(`wizard-cancel ${o2.clsActionCancel}`);
          } else if (btn === "help") {
            button.addClass(`wizard-help ${o2.clsActionHelp}`);
          }
        }
        this.pages = element2.find(".page").addClass(o2.clsPage);
        this.pages.appendTo(wizard_pages);
        if (this.pages[o2.startPage - 1] === void 0) {
          o2.startPage = 0;
        }
        this.currentPage = o2.startPage - 1;
        this.pages[this.currentPage]?.classList.add("active");
        this._refreshButtons();
      },
      _createEvents: function() {
        const element2 = this.element;
        const o2 = this.options;
        element2.on("click", ".wizard-action", (e2) => {
          const action = $7(e2.target).closest("button").attr("data-wizard-action");
          if (action === "next") {
            if (Metro2.utils.exec(o2.onBeforePage, [this.currentPage, this.pages[this.currentPage]]) === false) {
              return false;
            }
            this.next();
            this._fireEvent("next");
          } else if (action === "prev") {
            if (Metro2.utils.exec(o2.onBeforePage, [this.currentPage, this.pages[this.currentPage]]) === false) {
              return false;
            }
            this.prev();
            this._fireEvent("prev");
          } else if (action === "finish") {
            this._fireEvent("finish");
          } else if (action === "cancel") {
            this._fireEvent("cancel");
          } else if (action === "help") {
            this._fireEvent("help");
          }
        });
      },
      _refreshButtons: function() {
        const element2 = this.element;
        const o2 = this.options;
        const pages = this.pages;
        const actions = element2.find(".wizard-action");
        actions.each((i3, btn) => {
          $7(btn).removeClass("disabled");
        });
        if (this.currentPage === 0) {
          actions.filter(".wizard-prev").addClass("disabled");
        }
        if (this.currentPage === pages.length - 1) {
          actions.filter(".wizard-next").addClass("disabled");
          actions.filter(".wizard-finish").removeClass("disabled");
        }
        if (this.currentPage >= 0 && this.currentPage < pages.length - 1) {
          actions.filter(".wizard-finish").addClass("disabled");
        }
        if (this.currentPage > 0) {
          actions.filter(".wizard-prev").removeClass("disabled");
        }
      },
      next: function() {
        const element2 = this.element;
        const o2 = this.options;
        const pages = element2.find(".page");
        if (this.currentPage < pages.length - 1) {
          $7(pages[this.currentPage]).addClass("out");
          setTimeout(
            (i3) => {
              $7(pages[i3]).removeClass("active");
            },
            300,
            this.currentPage
          );
          this.currentPage++;
          $7(pages[this.currentPage]).addClass("active");
        }
        this._refreshButtons();
      },
      prev: function() {
        const element2 = this.element;
        const o2 = this.options;
        const pages = element2.find(".page");
        if (this.currentPage > 0) {
          $7(pages[this.currentPage]).removeClass("active");
          this.currentPage--;
          $7(pages[this.currentPage]).removeClass("out").addClass("active");
        }
        this._refreshButtons();
      },
      changeAttribute: (attr, newValue) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/working-tree/working-tree.js
  ((Metro2, $7) => {
    "use strict";
    let WorkingTreeDefaultConfig = {
      onStateChange: Metro2.noop,
      onWorkingTreeCreate: Metro2.noop
    };
    Metro2.workingTreeSetup = (options) => {
      WorkingTreeDefaultConfig = $7.extend({}, WorkingTreeDefaultConfig, options);
    };
    if (typeof globalThis.metroWorkingTreeSetup !== "undefined") {
      Metro2.workingTreeSetup(globalThis.metroWorkingTreeSetup);
    }
    Metro2.Component("working-tree", {
      init(options, elem) {
        this._super(elem, options, WorkingTreeDefaultConfig, {
          // define instance vars here
        });
        return this;
      },
      _create() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("tree-create");
      },
      addNode({ id, title = "", value = "", items = [] } = {}) {
        const element2 = this.element;
        const nodeId = (id || Hooks.useId(`working-tree-node-${element2.children().length}`)).replace(/:/gi, "");
        const node = `
                <li id="${nodeId}">
                    <div class="bull"></div>
                    <div class="node">
                        <div class="title">${title}</div>
                        <div class="value">${value}</div>
                    </div>
                    <ul class="leaves">
                        ${items.map((i3) => `<li><div class="title">${i3.title}</div><div class="value">${i3.value}</div> </li>`).join("\n")}                    
                    </ul>
                </li>
            `;
        this.element.append(node);
        return nodeId;
      },
      setState(id, state2 = "pending") {
        const element2 = this.element;
        const node = element2.find(`#${id}`).clearClasses().addClass(`work-${state2}`);
        node.find(".bull").html(`<span data-role="bull" data-type="${state2}"></span>`);
        this._fireEvent("state-change", { id, state: state2, node });
        return this;
      },
      _createStructure() {
        const element2 = this.element;
        element2.addClass("working-tree");
      },
      _createEvents() {
      },
      changeAttribute(attr, newValue) {
      },
      destroy() {
        this.element.remove();
      }
    });
  })(Metro, Dom);

  // ../metroui-lib/source/components/drop-menu/drop-menu.js
  ((Metro2, $7) => {
    "use strict";
    const participants = "[data-role-dropmenu], [data-role-dropdown]";
    const toggleImage = `<svg aria-hidden="true" width="16" height="16" viewBox="0 0 24 24"><path d="m14.83 11.29-4.24-4.24a1 1 0 1 0-1.42 1.41L12.71 12l-3.54 3.54a1 1 0 0 0 0 1.41 1 1 0 0 0 .71.29 1 1 0 0 0 .71-.29l4.24-4.24a1.002 1.002 0 0 0 0-1.42Z"></path></svg>`;
    let DropMenuDefaultConfig = {
      height: "auto",
      align: "left",
      // left, right
      onMenuCreate: Metro2.noop
    };
    Metro2.dropMenuSetup = (options) => {
      DropMenuDefaultConfig = $7.extend({}, DropMenuDefaultConfig, options);
    };
    if (typeof globalThis.metroDropMenuSetup !== "undefined") {
      Metro2.dropMenuSetup(globalThis.metroDropMenuSetup);
    }
    Metro2.Component("dropmenu", {
      init: function(options, elem) {
        this._super(elem, options, DropMenuDefaultConfig, {
          toggle: null,
          displayOrigin: null,
          isOpen: false,
          level: 0
        });
        return this;
      },
      _create: function() {
        this._createStructure();
        this._createEvents();
        this._fireEvent("menu-create");
      },
      _toggle: function() {
        const element2 = this.element;
        let toggle = element2.siblings(".menu-toggle, .dropdown-toggle, a");
        if (toggle.length === 0) {
          toggle = element2.prev();
          if (toggle.length === 0) {
            throw new Error("Menu toggle not found");
          }
        }
        return $7(toggle[0]);
      },
      _createStructure: function() {
        const element2 = this.element;
        const o2 = this.options;
        this.level = element2.parents("[data-role-dropmenu]").length;
        this.toggle = this._toggle();
        this.toggle.append(toggleImage);
        this.displayOrigin = element2.css("display");
        this.element.addClass("drop-menu").css("z-index", `calc(var(--z-index-fixed) + ${this.level})!important`).hide();
        if (o2.height !== "auto") {
          element2.css("max-height", o2.height);
        }
      },
      _createEvents: function() {
        const element2 = this.element;
        this.toggle.on("click", (e2) => {
          $7(participants).each((i3, el) => {
            const $el = $7(el);
            const isSubMenu = element2.parents("[data-role-dropmenu]").is(el);
            if (el === element2[0] || isSubMenu || $el.hasClass("keep-open") || $el.hasClass("stay-open") || $el.hasClass("ignore-document-click"))
              return;
            const dd = Metro2.getPlugin(el, "dropdown");
            const dm = Metro2.getPlugin(el, "dropmenu");
            if (dd) {
              dd.close();
            }
            if (dm) {
              dm.close();
            }
          });
          if (this.isOpen === false) {
            this.open();
          } else {
            this.close();
          }
          e2.preventDefault();
          e2.stopPropagation();
        });
      },
      close: function() {
        if (this.isOpen === false) {
          return;
        }
        this.toggle.removeClass("active-toggle");
        this.element.hide();
        this.isOpen = false;
      },
      open: function() {
        const element2 = this.element;
        const o2 = this.options;
        const toggleRect = Metro2.utils.rect(this.toggle[0]);
        const level = element2.parents("[data-role-dropmenu]").length;
        element2.show().visible(false);
        if (level === 0) {
          element2.css({
            top: toggleRect.bottom,
            left: toggleRect.left
          });
          const wOut = Metro2.utils.viewportOutByWidth(element2[0]);
          const hOut = Metro2.utils.viewportOutByHeight(element2[0]);
          if (o2.align === "right" || wOut) {
            element2.css({
              left: toggleRect.right - element2.width()
            });
            if (o2.align !== "right" && Metro2.utils.viewportOutByWidth(element2[0])) {
              element2.css({
                left: toggleRect.left
              });
            }
          }
          if (hOut) {
            element2.css({
              top: toggleRect.top - element2.height()
            });
            if (Metro2.utils.viewportOutByHeight(element2[0])) {
              element2.css({
                top: toggleRect.bottom
              });
            }
          }
        } else {
          element2.css({
            top: toggleRect.top,
            left: toggleRect.right
          });
          const wOut = Metro2.utils.viewportOutByWidth(element2[0]);
          if (o2.align === "right" || wOut) {
            element2.css({
              left: toggleRect.left - element2.width()
            });
            if (o2.align !== "right" && Metro2.utils.viewportOutByWidth(element2[0])) {
              element2.css({
                left: toggleRect.right
              });
            }
          }
        }
        this.toggle.addClass("active-toggle");
        this.isOpen = true;
        element2.visible(true);
      },
      changeAttribute: (attr, val) => {
      },
      destroy: function() {
        this.element.remove();
      }
    });
    $7(document).on("click", () => {
      $7(participants).each((i3, el) => {
        const $el = $7(el);
        if ($el.hasClass("keep-open") || $el.hasClass("stay-open") || $el.hasClass("ignore-document-click")) return;
        const dd = Metro2.getPlugin(el, "dropdown");
        const dm = Metro2.getPlugin(el, "dropmenu");
        if (dd) {
          dd.close();
        }
        if (dm) {
          dm.close();
        }
      });
    });
  })(Metro, Dom);
})();
//!node.hasClass("expanded");
/*! Bundled license information:

@olton/datetime/dist/datetime.js:
  (*!
   * Datetime v3.2.5.
   * Build time: 18.05.2025, 14:46:05
   * Copyright 2025 by Serhii Pimenov
   * Licensed under MIT
   *
   * Build time: 18.05.2025 14:46:05
   *)

@olton/string/dist/string.js:
  (*!
   * String v0.10.2 (@olton/string)
   * Copyright 2025 by Serhii Pimenov
   * Built: 18.05.2025, 14:39:06
   * Licensed under MIT
   *)

@olton/dom/dist/dom.js:
  (*!
   * DOM - Work with HTML elements (@olton/dom, https://metroui.org.ua)
   * Version: 1.5.1
   * Build date: 18.05.2025, 14:45:23
   * Copyright 2012-2025 by Serhii Pimenov
   * Licensed under MIT
   *)

@olton/hooks/dist/hooks.js:
  (*!
   * Hooks v0.13.0 (@olton/hooks)
   * Copyright 2025 by Serhii Pimenov <serhii@pimenov.com.ua>
   * Built: 07.03.2025, 23:32:05
   * Licensed under MIT
   *)

@olton/farbe/dist/farbe.js:
  (*!
   * Farbe v1.0.11. Color Routines for JavaScript.
   * Build: 06.08.2025, 11:05:32
   * Copyright 2025 by Serhii Pimenov
   * Licensed under MIT
   *)

@olton/html/dist/html.js:
  (*!
   * Html.js v0.15.1
   * Description: Creating HTML Elements with JavaScript
   * Build: 18.05.2025, 14:41:46
   * Copyright 2025 by Serhii Pimenov
   * Licensed under MIT
   *)

@olton/guardian/dist/guardian.js:
  (*!
   * Guardian v0.7.3. Data guard and validation library.
   * Copyright 2025 Serhii Pimenov
   * Licensed under MIT
   * Build time: 18.05.2025 14:43:24
   *)

@olton/router/dist/router.js:
  (*!
   * Router v0.4.1 (Router ror SPA)
   * Build: 18.05.2025, 14:39:57
   * Copyright 2025 by Serhii Pimenov
   * Licensed under MIT
   *)

@olton/model/dist/model.js:
  (*!
   * Model v0.18.1
   * Build: 18.05.2025, 14:40:40
   * Copyright 2012-2025 by Serhii Pimenov
   * Licensed under MIT
   *)
*/
